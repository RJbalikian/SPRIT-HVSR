<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sprit.sprit_jupyter_UI API documentation</title>
<meta name="description" content="Functions to create jupyter notebook widget UI" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sprit.sprit_jupyter_UI</code></h1>
</header>
<section id="section-intro">
<p>Functions to create jupyter notebook widget UI</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Functions to create jupyter notebook widget UI
&#34;&#34;&#34;

import datetime
import inspect
import os
import pathlib
import tkinter as tk
from tkinter import filedialog
import webbrowser

from zoneinfo import available_timezones

import ipywidgets as widgets
from IPython.display import display, clear_output
import numpy as np
import pandas as pd
import plotly.express as px
import plotly.graph_objs as go
import plotly.subplots as subplots
from scipy import signal

try: #For distribution
    from sprit import sprit_utils
    from sprit import sprit_hvsr
except: #For local testing
    import sprit_hvsr 
    import sprit_utils

global hvsr_data
    

OBSPY_FORMATS =  [&#39;AH&#39;, &#39;ALSEP_PSE&#39;, &#39;ALSEP_WTH&#39;, &#39;ALSEP_WTN&#39;, &#39;CSS&#39;, &#39;DMX&#39;, &#39;GCF&#39;, &#39;GSE1&#39;, &#39;GSE2&#39;, &#39;KINEMETRICS_EVT&#39;, &#39;KNET&#39;, &#39;MSEED&#39;, &#39;NNSA_KB_CORE&#39;, &#39;PDAS&#39;, &#39;PICKLE&#39;, &#39;Q&#39;, &#39;REFTEK130&#39;, &#39;RG16&#39;, &#39;SAC&#39;, &#39;SACXY&#39;, &#39;SEG2&#39;, &#39;SEGY&#39;, &#39;SEISAN&#39;, &#39;SH_ASC&#39;, &#39;SLIST&#39;, &#39;SU&#39;, &#39;TSPAIR&#39;, &#39;WAV&#39;, &#39;WIN&#39;, &#39;Y&#39;]

def get_default(func, param):
    return inspect.signature(func).parameters[param].default

def create_jupyter_ui():
    global hvsr_data

    ui_width = 20
    ui_height= 12
    global results_fig
    global log_textArea
    log_textArea = widgets.Textarea(value=&#34;SESSION LOG&#34;, disabled=True, layout={&#39;height&#39;: &#39;300px&#39;,&#39;width&#39;: &#39;99%&#39;, &#39;overflow&#39;: &#39;scroll&#39;})

    # INPUT TAB
    # Create a VBox for the accordions
    input_HBox = widgets.HBox()
    input_accordion_label_box = widgets.VBox()
    input_accordion_box = widgets.VBox()
    input_accordion = widgets.Accordion()

    # Metadata accordion
    metadata_grid = widgets.GridspecLayout(7, 10)
    network_textbox = widgets.Text(description=&#39;Network:&#39;,
                                    placeholder=get_default(sprit_hvsr.input_params, &#39;network&#39;),
                                    value=get_default(sprit_hvsr.input_params, &#39;network&#39;),
                                    tooltip=&#34;input_params(network)&#34;)

    station_textbox = widgets.Text(description=&#39;Station:&#39;,
                                    placeholder=get_default(sprit_hvsr.input_params, &#39;station&#39;),
                                    value=get_default(sprit_hvsr.input_params, &#39;station&#39;))

    location_textbox = widgets.Text(description=&#39;Location:&#39;,
                                    placeholder=get_default(sprit_hvsr.input_params, &#39;loc&#39;),
                                    value=get_default(sprit_hvsr.input_params, &#39;loc&#39;))

    z_channel_textbox = widgets.Text(description=&#39;Z Channel:&#39;,
                                    placeholder=get_default(sprit_hvsr.input_params, &#39;channels&#39;)[0],
                                    value=get_default(sprit_hvsr.input_params, &#39;channels&#39;)[0])

    e_channel_textbox = widgets.Text(description=&#39;E Channel:&#39;,
                                    placeholder=get_default(sprit_hvsr.input_params, &#39;channels&#39;)[2],
                                    value=get_default(sprit_hvsr.input_params, &#39;channels&#39;)[2])

    n_channel_textbox = widgets.Text(description=&#39;N Channel:&#39;,
                                    placeholder=get_default(sprit_hvsr.input_params, &#39;channels&#39;)[1],
                                    value=get_default(sprit_hvsr.input_params, &#39;channels&#39;)[1])


    # Instrument Settings
    inst_settings_text = widgets.Text(placeholder=&#39;Instrument Settings Filepath&#39;, layout=widgets.Layout(width=&#39;55%&#39;))
    instrument_read_button = widgets.Button(icon=&#39;fa-file-import&#39;,button_style=&#39;success&#39;,
                                            layout=widgets.Layout(width=&#39;4%&#39;))
    instrument_settings_button = widgets.Button(description=&#39;Select .inst file&#39;,
                                            layout=widgets.Layout(width=&#39;10%&#39;))
    inst_settings_hbox = widgets.HBox([inst_settings_text,instrument_read_button, instrument_settings_button])
    
    def select_inst(event):
        try:
            if event.description == &#39;Select .inst file&#39;:
                root = tk.Tk()
                root.wm_attributes(&#39;-topmost&#39;, True)
                root.withdraw()
                inst_files = filedialog.askopenfilenames(defaultextension=&#39;.inst&#39;, filetypes=[(&#39;Inst&#39;, &#39;.inst&#39;)],
                                                                    title=&#34;Select Instrument Settings File&#34;)
                if isinstance(inst_files, tuple):
                    pass
                else:
                    inst_files = tuple(inst_files)
                root.destroy()
            else:
                inst_files = tuple([inst_settings_text.value])

            for i, inst_f in enumerate(inst_files):
                inst_settings_text.value = pathlib.Path(inst_f).as_posix()
                inst_settings = sprit_hvsr.import_settings(settings_import_path=pathlib.Path(inst_f).as_posix(), settings_import_type=&#39;instrument&#39;)
                
                # Go through all items and add them
                if &#39;instrument&#39; in inst_settings.keys():
                    if inst_settings[&#39;instrument&#39;] not in instrument_dropdown.options:
                        instrument_dropdown.options.append(inst_settings[&#39;instrument&#39;])
                    instrument_dropdown.value = inst_settings[&#39;instrument&#39;]
                
                if &#39;net&#39; in inst_settings.keys():
                    network_textbox.value = inst_settings[&#39;net&#39;]

                if &#39;sta&#39; in inst_settings.keys():
                    station_textbox.value = inst_settings[&#39;sta&#39;]

                if &#39;loc&#39; in inst_settings.keys():
                    location_textbox.value = inst_settings[&#39;loc&#39;]

                if &#39;cha&#39; in inst_settings.keys():
                    for c in inst_settings[&#39;cha&#39;]:
                        if c.lower()[2]==&#39;z&#39;:
                            z_channel_textbox.value = c
                        if c.lower()[2]==&#39;e&#39;:
                            e_channel_textbox.value = c
                        if c.lower()[2] ==&#39;n&#39;:
                            n_channel_textbox.value = c
                
                if &#39;metapath&#39; in inst_settings.keys():
                    metadata_filepath.value = inst_settings[&#39;metapath&#39;]

                if &#39;hvsr_band&#39; in inst_settings.keys():
                    hvsr_band_min_box.value = inst_settings[&#39;hvsr_band&#39;][0]
                    hvsr_band_max_box.value = inst_settings[&#39;hvsr_band&#39;][1]

        except Exception as e:
            print(e)
            instrument_settings_button.disabled=True
            instrument_settings_button.description=&#39;Use Text Field&#39;
    
    instrument_settings_button.on_click(select_inst)
    instrument_read_button.on_click(select_inst)

    metadata_grid[0,:] = inst_settings_hbox
    metadata_grid[1,0] = network_textbox
    metadata_grid[2,0] = station_textbox
    metadata_grid[3,0] = location_textbox
    metadata_grid[4,0] = z_channel_textbox
    metadata_grid[5,0] = e_channel_textbox
    metadata_grid[6,0] = n_channel_textbox

    # Acquisition Accordion
    instrument_grid = widgets.GridspecLayout(5, 10)
    # Date Picker labelled &#34;Acquisition Date&#34;
    acquisition_date_picker = widgets.DatePicker(description=&#39;Acq.Date:&#39;,
                                            placeholder=datetime.datetime.today().date(),
                                            value=datetime.datetime.today().date())

    # Label that shows the Date currently selected in the Date Picker
    acquisition_doy = widgets.IntText(description=&#39;DOY&#39;,
                                                placeholder=f&#34;{acquisition_date_picker.value.timetuple().tm_yday}&#34;,
                                                value=f&#34;{acquisition_date_picker.value.timetuple().tm_yday}&#34;,
                                                layout=widgets.Layout(width=&#39;auto&#39;))

    def on_acq_date_change(change):
        acquisition_doy.value = acquisition_date_picker.value.timetuple().tm_yday
    acquisition_date_picker.observe(on_acq_date_change)

    def on_doy_change(change):
        curr_year = datetime.datetime.today().year
        if acquisition_doy.value &gt; datetime.datetime.today().timetuple().tm_yday:
            curr_year -= 1
        acquisition_date_picker.value = (datetime.datetime(curr_year, 1, 1) + datetime.timedelta(days = acquisition_doy.value-1)).date()
    acquisition_doy.observe(on_doy_change)

    # Time selector (hour and minute) labelled &#34;Start Time&#34;.
    try:
        start_time_picker = widgets.TimePicker(description=&#39;Start Time:&#39;,
                                            placeholder=datetime.time(0,0,0),
                                            value=datetime.time(0,0,0),
                                            layout=widgets.Layout(width=&#39;auto&#39;))
    except Exception as e:
        start_time_picker = widgets.Text(description=&#39;Start Time:&#39;,
                                        placeholder=&#39;00:00&#39;,
                                        value=&#39;00:00&#39;,
                                        layout=widgets.Layout(width=&#39;auto&#39;))

    # Time selector (hour and minute) labelled &#34;End Time&#34;. Same as Start Time otherwise.
    try:
        end_time_picker = widgets.TimePicker(description=&#39;End Time:&#39;,
                                        placeholder=datetime.time(23,59),
                                        value=datetime.time(23,59),
                                        layout=widgets.Layout(width=&#39;auto&#39;))
    except Exception as e:
        end_time_picker = widgets.Text(description=&#39;End Time:&#39;,
                                        placeholder=&#39;23:59:59.999999&#39;,
                                        value=&#39;23:59:59.999999&#39;,
                                        layout=widgets.Layout(width=&#39;auto&#39;))

    tzlist = list(available_timezones())
    tzlist.sort()
    tzlist.remove(&#39;UTC&#39;)
    tzlist.remove(&#39;US/Central&#39;)
    tzlist.insert(0, &#39;US/Central&#39;)
    tzlist.insert(0, &#39;UTC&#39;)
    # A dropdown list with all the items from zoneinfo.available_timezones(), default &#39;UTC&#39;
    time_zone_dropdown = widgets.Dropdown(options=tzlist,value=get_default(sprit_hvsr.input_params, &#39;tzone&#39;),
                                            description=&#39;Time Zone:&#39;,layout=widgets.Layout(width=&#39;fill&#39;))

    instrument_grid[0,0] = acquisition_date_picker
    instrument_grid[0,1] = acquisition_doy
    instrument_grid[1,0] = start_time_picker
    instrument_grid[2,0] = end_time_picker
    instrument_grid[3,0] = time_zone_dropdown

    # LOCATION ACCORDION
    location_grid = widgets.GridspecLayout(4, 10)
    # X coordinate input
    xcoord_textbox = widgets.FloatText(description=&#39;X Coordinate:&#39;, tooltip=&#39;xcoord&#39;,
                                        value=get_default(sprit_hvsr.input_params, &#39;xcoord&#39;), 
                                        placeholder=get_default(sprit_hvsr.input_params, &#39;xcoord&#39;),
                                        layout=widgets.Layout(width=&#39;auto&#39;))
    location_grid[0, 0] = xcoord_textbox

    # Y coordinate input
    ycoord_textbox = widgets.FloatText(description=&#39;Y Coordinate&#39;, tooltip=&#39;ycoord:&#39;,
                                        value=get_default(sprit_hvsr.input_params, &#39;ycoord&#39;), 
                                        placeholder=get_default(sprit_hvsr.input_params, &#39;ycoord&#39;),
                                        layout=widgets.Layout(width=&#39;auto&#39;))
    location_grid[1, 0] = ycoord_textbox

    # Z coordinate input
    zcoord_textbox = widgets.FloatText(description=&#39;Z Coordinate&#39;, tooltip=&#39;elevation:&#39;,
                                        value=get_default(sprit_hvsr.input_params, &#39;elevation&#39;),
                                        placeholder=get_default(sprit_hvsr.input_params, &#39;elevation&#39;),                                     
                                        layout=widgets.Layout(width=&#39;auto&#39;))
    location_grid[2, 0] = zcoord_textbox

    # Z coordinate unit input
    elevation_unit_textbox = widgets.Dropdown(options=[(&#39;Feet&#39;, &#39;feet&#39;), (&#39;Meters&#39;, &#39;meters&#39;)],
                                                value=get_default(sprit_hvsr.input_params, &#39;elev_unit&#39;),
                                                description=&#39;Z Unit:&#39;, tooltip=&#39;elev_unit&#39;,
                                                layout=widgets.Layout(width=&#39;auto&#39;))
    location_grid[2, 1] = elevation_unit_textbox

    # Input CRS input
    input_crs_textbox = widgets.Text(description=&#39;Input CRS:&#39;,
                                        layout=widgets.Layout(width=&#39;auto&#39;),
                                        placholder=get_default(sprit_hvsr.input_params, &#39;input_crs&#39;),
                                        value=get_default(sprit_hvsr.input_params, &#39;input_crs&#39;))
    location_grid[3, 0] = input_crs_textbox

    # Output CRS input
    output_crs_textbox = widgets.Text(description=&#39;Output CRS:&#39;,
                                        layout=widgets.Layout(width=&#39;auto&#39;),
                                        placholder=get_default(sprit_hvsr.input_params, &#39;output_crs&#39;),
                                        value=get_default(sprit_hvsr.input_params, &#39;output_crs&#39;))
    location_grid[3, 1] = output_crs_textbox

    # IO PARAMS ACCORDION
    ioparam_grid = widgets.GridspecLayout(6, 10)

    # Data format (for obspy format to use to read in)
    data_format_dropdown = widgets.Dropdown(
            options=OBSPY_FORMATS,
            value=&#39;MSEED&#39;,
            description=&#39;Data Formats:&#39;, layout=widgets.Layout(width=&#39;auto&#39;))

    hvsr_band_min_box = widgets.FloatText(description=&#39;HVSR Band [Hz]&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                          placeholder=get_default(sprit_hvsr.input_params, &#39;hvsr_band&#39;)[0],
                                          value=get_default(sprit_hvsr.input_params, &#39;hvsr_band&#39;)[0])
    hvsr_band_max_box = widgets.FloatText(placeholder=get_default(sprit_hvsr.input_params, &#39;hvsr_band&#39;)[1],
                                          value=get_default(sprit_hvsr.input_params, &#39;hvsr_band&#39;)[1])
    hvsr_band_hbox = widgets.HBox([hvsr_band_min_box, hvsr_band_max_box],layout=widgets.Layout(width=&#39;auto&#39;))


    peak_freq_range_min_box = widgets.FloatText(description=&#39;Peak Range [Hz]&#39;,placeholder=get_default(sprit_hvsr.input_params, &#39;peak_freq_range&#39;)[0], 
                                                value=get_default(sprit_hvsr.input_params, &#39;peak_freq_range&#39;)[0],
                                                style={&#39;description_width&#39;: &#39;initial&#39;}, layout=widgets.Layout(width=&#39;auto&#39;))
    peak_freq_range_max_box = widgets.FloatText(placeholder=get_default(sprit_hvsr.input_params, &#39;peak_freq_range&#39;)[1], 
                                                value=get_default(sprit_hvsr.input_params, &#39;peak_freq_range&#39;)[1],layout=widgets.Layout(width=&#39;auto&#39;))
    peak_freq_range_hbox = widgets.HBox([peak_freq_range_min_box, peak_freq_range_max_box],layout=widgets.Layout(width=&#39;auto&#39;))


    # A dropdown labeled &#34;Detrend type&#34; with &#34;Spline&#34;, &#34;Polynomial&#34;, or &#34;None&#34;
    detrend_type_dropdown = widgets.Dropdown(options=[(&#39;Spline&#39;, &#39;spline&#39;), (&#39;Polynomial&#39;, &#39;polynomial&#39;), (&#39;None&#39;, &#39;none&#39;)],
                            description=&#39;Detrend Type:&#39;,  layout=widgets.Layout(width=&#39;auto&#39;))
    detrend_order = widgets.FloatText(description=&#39;Order:&#39;, tooltip=&#39;detrend_order&#39;, placeholder=get_default(sprit_hvsr.fetch_data, &#39;detrend_order&#39;), 
                                      value=get_default(sprit_hvsr.fetch_data, &#39;detrend_order&#39;),layout=widgets.Layout(width=&#39;auto&#39;))

    # A text to specify the trim directory
    trim_directory = widgets.Text(description=&#39;Trim Dir.:&#39;, value=&#34;None&#34;,#pathlib.Path().home().as_posix(),
                                    layout=widgets.Layout(width=&#39;auto&#39;))
    trim_export_dropdown = widgets.Dropdown(
                options=OBSPY_FORMATS,
                value=&#39;MSEED&#39;,
                description=&#39;Trim Format:&#39;, layout=widgets.Layout(width=&#39;auto&#39;))
    trim_directory_upload = widgets.FileUpload(
                            accept=&#39;&#39;, 
                            multiple=False, layout=widgets.Layout(width=&#39;auto&#39;))

    # Processing Settings
    proc_settings_text = widgets.Text(placeholder=&#39;Instrument Settings Filepath&#39;, layout=widgets.Layout(width=&#39;55%&#39;))
    proc_settings_read_button = widgets.Button(icon=&#39;fa-file-import&#39;,button_style=&#39;success&#39;,
                                            layout=widgets.Layout(width=&#39;4%&#39;))
    proc_settings_browse_button = widgets.Button(description=&#39;Select .proc file&#39;,
                                            layout=widgets.Layout(width=&#39;10%&#39;))
    proc_settings_hbox = widgets.HBox([proc_settings_text, proc_settings_read_button, proc_settings_browse_button])
    
    excluded_params = [&#39;hvsr_data&#39;, &#39;params&#39;, &#39;hvsr_results&#39;]
    funcList = [sprit_hvsr.fetch_data, sprit_hvsr.remove_noise,
                sprit_hvsr.generate_ppsds, sprit_hvsr.process_hvsr,
                sprit_hvsr.remove_outlier_curves, sprit_hvsr.check_peaks,
                sprit_hvsr.get_report]

    def select_proc(event):
        try:
            if event.description == &#39;Select .proc file&#39;:
                root = tk.Tk()
                root.wm_attributes(&#39;-topmost&#39;, True)
                root.withdraw()
                proc_files = filedialog.askopenfilenames(defaultextension=&#39;.proc&#39;, filetypes=[(&#39;PROC&#39;, &#39;.proc&#39;)],
                                                                    title=&#34;Select Processing Settings File&#34;)
                if isinstance(proc_files, tuple):
                    pass
                else:
                    proc_files = tuple(proc_files)
                root.destroy()
            else:
                proc_files = tuple([proc_settings_text.value])

            for i, proc_f in enumerate(proc_files):
                proc_settings_text.value = pathlib.Path(proc_f).as_posix()
                proc_settings = sprit_hvsr.import_settings(settings_import_path=pathlib.Path(proc_f).as_posix(), settings_import_type=&#39;processing&#39;)
                
                for func, params in proc_settings.items():
                    if func in widget_param_dict.keys():
                        for prm, val in params.items():
                            if prm in widget_param_dict[func].keys():
                                print(prm, &#39;:&#39;, widget_param_dict[func][prm],&#39; |  &#39;, val)
                                if val is None or val==&#39;None&#39;:
                                    val=&#39;none&#39;
                                if prm == &#39;export_format&#39;:
                                    val = val.upper()
                                if prm == &#39;smooth&#39;:
                                    if val is True:
                                        val = 51
                                if prm == &#39;resample&#39;:
                                    if val is True:
                                        val = 1000
                                if isinstance(widget_param_dict[func][prm], list):
                                    for i, item in enumerate(widget_param_dict[func][prm]):
                                        item.value = val[i]
                                else:
                                    widget_param_dict[func][prm].value = val
        except Exception as e:
            print(e)
            proc_settings_browse_button.disabled=True
            proc_settings_browse_button.description=&#39;Use Text Field&#39;
    
    proc_settings_read_button.on_click(select_proc)
    proc_settings_browse_button.on_click(select_proc)

    ioparam_grid[0,:] = proc_settings_hbox
    ioparam_grid[1,0] = data_format_dropdown
    ioparam_grid[2,:5] = hvsr_band_hbox
    ioparam_grid[3,:5] = peak_freq_range_hbox
    ioparam_grid[4,:1] = detrend_type_dropdown
    ioparam_grid[4,1] = detrend_order
    ioparam_grid[5,:6] = trim_directory
    ioparam_grid[5, 6:8] = trim_export_dropdown
    ioparam_grid[5, 8] = trim_directory_upload

    # PYTHON API ACCORDION
    inputAPI_grid = widgets.GridspecLayout(2, 10)
    # A text label with &#34;input_params()&#34;
    input_params_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;input_params&#39; + &#39;&lt;/p&gt;&#39;, 
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    input_params_call = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;()&#39; + &#39;&lt;/p&gt;&#39;,
                                     layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-start&#39;,align_content=&#39;flex-start&#39;),)
    #input_params_call =  widgets.Label(value=&#39;input_params()&#39;, layout=widgets.Layout(width=&#39;auto&#39;))
    inputAPI_grid[0, 0] = input_params_prefix
    inputAPI_grid[0, 1:] = input_params_call

    # A text label with &#34;fetch_data()&#34;
    fetch_data_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;fetch_data&#39; + &#39;&lt;/p&gt;&#39;, 
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    fetch_data_call = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;()&#39; + &#39;&lt;/p&gt;&#39;,
                                     layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-start&#39;,align_content=&#39;flex-start&#39;),)
    inputAPI_grid[1, 0] = fetch_data_prefix
    inputAPI_grid[1, 1:] = fetch_data_call

    # Set it all in place
    metaLabel = widgets.Label(&#39;Instrument&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    instLabel = widgets.Label(&#39;Acquisition&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    locLabel = widgets.Label(&#39;Location&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    ioparmLabel = widgets.Label(&#39;IO/Params&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    apiLabel = widgets.Label(&#39;API Call&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    input_accordion_label_box.children = [metaLabel, instLabel, locLabel, ioparmLabel, apiLabel]
    input_accordion_label_box.layout = widgets.Layout(align_content=&#39;space-between&#39;, width=&#39;5%&#39;)

    input_accordion.children = [metadata_grid, instrument_grid, location_grid, ioparam_grid, inputAPI_grid]
    input_accordion.titles = [&#34;Instrument Metadata&#34;, &#34;Acquisition Information&#34;, &#34;Location Information&#34;, &#34;I/O and Parameters&#34;, &#34;See Python API Call&#34;]
    input_accordion_box.layout = widgets.Layout(align_content=&#39;space-between&#39;, width=&#39;99%&#39;)
    
    input_accordion.layout = widgets.Layout(width=&#39;99%&#39;)

    # ADD THE REST OF THE WIDGETS AROUND THE ACCORDIONS
    # A text box for the site name
    site_name = widgets.Text(description=&#39;Site Name:&#39;,
                            value=&#39;HVSR_Site&#39;,
                            placeholder=&#39;HVSR_Site&#39;,
                            style={&#39;description_width&#39;: &#39;initial&#39;}, layout=widgets.Layout(width=&#39;30%&#39;))

    tenpct_spacer = widgets.Button(description=&#39;&#39;, layout=widgets.Layout(width=&#39;20%&#39;, visibility=&#39;hidden&#39;))

    # Dropdown with different source types 
    data_source_type = widgets.Dropdown(options=[(&#39;File&#39;, &#39;file&#39;), (&#39;Raw&#39;, &#39;raw&#39;), (&#39;Batch&#39;, &#39;batch&#39;), (&#39;Directory&#39;, &#39;dir&#39;)],
                                            description=&#39;Data Source type:&#39;,
                                            value=&#39;file&#39;,orientation=&#39;horizontal&#39;, 
                                            style={&#39;description_width&#39;: &#39;initial&#39;},
                                            layout=widgets.Layout(width=&#39;20%&#39;))
    def on_ds_change(event):
        if data_source_type.value == &#39;file&#39; or data_source_type.value== &#39;batch&#39;:
            browse_data_button.description = &#39;Select Files&#39;
        else:
            browse_data_button.description = &#39;Select Folders&#39;
    data_source_type.observe(on_ds_change)
    # Dropdown labeled &#34;Instrument&#34; with options &#34;Raspberry Shake&#34;, &#34;Tromino&#34;, &#34;Other&#34;
    instrument_dropdown = widgets.Dropdown(options=[&#39;Raspberry Shake&#39;, &#39;Tromino&#39;, &#39;Other&#39;],
                                        style={&#39;description_width&#39;: &#39;initial&#39;},
                                        description=&#39;Instrument:&#39;,layout=widgets.Layout(width=&#39;20%&#39;))

    # Processing Settings
    processing_settings_button = widgets.FileUpload(accept=&#39;.proc&#39;, description=&#39;Processing Settings&#39;,
                                            multiple=False,layout=widgets.Layout(width=&#39;10%&#39;))

    # Whether to show plots outside of widget
    show_plot_check =  widgets.Checkbox(description=&#39;Print Plots&#39;, value=False, disabled=False, indent=False,
                                    layout=widgets.Layout(width=&#39;10%&#39;, justify_content=&#39;flex-end&#39;))


    # Whether to print to terminal
    verbose_check = widgets.Checkbox(description=&#39;Verbose&#39;, value=False, disabled=False, indent=False,
                                    layout=widgets.Layout(width=&#39;10%&#39;, justify_content=&#39;flex-end&#39;))

    # A text box labeled Data Filepath
    data_filepath = widgets.Text(description=&#39;Data Filepath:&#39;,
                                    placeholder=&#39;sample&#39;, value=&#39;sample&#39;,
                                    style={&#39;description_width&#39;: &#39;initial&#39;},layout=widgets.Layout(width=&#39;70%&#39;))

    # A button next to it labeled &#34;Browse&#34;
    browse_data_button = widgets.Button(description=&#39;Select Files&#39;, layout=widgets.Layout(width=&#39;10%&#39;))
    def select_datapath(event):
        try:
            root = tk.Tk()
            root.wm_attributes(&#39;-topmost&#39;, True)
            root.withdraw()
            if data_source_type.value==&#39;file&#39; or data_source_type.value==&#39;batch&#39;:
                data_filepath.value = str(filedialog.askopenfilenames(defaultextension=&#39;.MSEED&#39;, title=&#39;Select Data File&#39;))
            else:
                data_filepath.value = str(filedialog.askdirectory(mustexist=True, title=&#34;Select Data Directory&#34;))
            root.destroy()
        except Exception as e:
            print(e)
            browse_data_button.disabled=True
            browse_data_button.description=&#39;Use Text Field&#39;
    browse_data_button.on_click(select_datapath)

    # A text box labeled Metadata Filepath
    metadata_filepath = widgets.Text(description=&#39;Metadata Filepath:&#39;,
                                        style={&#39;description_width&#39;: &#39;initial&#39;},layout=widgets.Layout(width=&#39;70%&#39;))

    # A button next to it labeled &#34;Browse&#34;
    browse_metadata_button = widgets.Button(description=&#39;Select File(s)&#39;, layout=widgets.Layout(width=&#39;10%&#39;))
    def select_metapath(event):
        try:
            root = tk.Tk()
            root.wm_attributes(&#39;-topmost&#39;, True)
            root.withdraw()
            metadata_filepath.value = str(filedialog.askopenfilenames(title=&#39;Select Metadata File(s)&#39;))
            root.destroy()
        except Exception as e:
            print(e)
            browse_metadata_button.disabled=True
            browse_metadata_button.description=&#39;Use Text Field&#39;
    browse_metadata_button.on_click(select_metapath)

    # A progress bar
    progress_bar = widgets.FloatProgress(value=0.0,min=0.0,max=1.0,
                                    bar_style=&#39;info&#39;,
                                    orientation=&#39;horizontal&#39;,layout=widgets.Layout(width=&#39;85%&#39;))

    # A dark yellow button labeled &#34;Read Data&#34;
    read_data_button = widgets.Button(description=&#39;Read Data&#39;,
                                    button_style=&#39;warning&#39;,layout=widgets.Layout(width=&#39;10%&#39;))


    # A forest green button labeled &#34;Process HVSR&#34;
    process_hvsr_button = widgets.Button(description=&#39;Run&#39;,
                                            button_style=&#39;success&#39;,layout=widgets.Layout(width=&#39;5%&#39;))

    # Update input_param call
    def update_input_param_call():
        input_param_text = f&#34;&#34;&#34;(datapath=&#39;{data_filepath.value}&#39;, metapath=&#39;{metadata_filepath.value}&#39;, site=&#39;{site_name.value}&#39;, network=&#39;{network_textbox.value}&#39;,
                    station=&#39;{station_textbox.value}&#39;, loc=&#39;{location_textbox.value}&#39;, channels={[z_channel_textbox.value, e_channel_textbox.value, n_channel_textbox.value]},
                    acq_date=&#39;{acquisition_date_picker.value}&#39;, starttime=&#39;{start_time_picker.value}&#39;, endtime=&#39;{end_time_picker.value}&#39;, tzone=&#39;{time_zone_dropdown.value}&#39;,
                    xcoord={xcoord_textbox.value}, ycoord={ycoord_textbox.value}, elevation={zcoord_textbox.value}, depth=0
                    input_crs=&#39;{input_crs_textbox.value}&#39;, output_crs=&#39;{output_crs_textbox.value}&#39;, elev_unit=&#39;{elevation_unit_textbox.value}&#39;,
                    instrument=&#39;{instrument_dropdown.value}&#39;, hvsr_band={[hvsr_band_min_box.value, hvsr_band_max_box.value]}, 
                    peak_freq_range={[peak_freq_range_min_box.value, peak_freq_range_max_box.value]}, verbose={verbose_check.value})&#34;&#34;&#34;
        input_params_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + input_param_text + &#39;&lt;/p&gt;&#39;
    update_input_param_call()
    
    # Update fetch_data call
    def update_fetch_data_call():
        fetch_data_text = f&#34;&#34;&#34;(params=hvsr_data, source={data_source_type.value}, trim_dir={trim_directory.value},
                            export_format={trim_export_dropdown.value}, detrend={detrend_type_dropdown.value}, detrend_order={detrend_order.value}, verbose={verbose_check.value})&#34;&#34;&#34;
        fetch_data_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + fetch_data_text + &#39;&lt;/p&gt;&#39;
    update_fetch_data_call()

    site_hbox = widgets.HBox()
    site_hbox.children = [site_name, tenpct_spacer, tenpct_spacer, tenpct_spacer, tenpct_spacer, tenpct_spacer, show_plot_check, verbose_check]
    datapath_hbox = widgets.HBox()
    datapath_hbox.children = [data_filepath, browse_data_button, data_source_type]
    metadata_hbox = widgets.HBox()
    metadata_hbox.children = [metadata_filepath, browse_metadata_button, instrument_dropdown]
    progress_hbox = widgets.HBox()
    progress_hbox.children = [progress_bar, read_data_button, process_hvsr_button]

    input_params_vbox = widgets.VBox()
    input_params_vbox.children = [site_hbox,datapath_hbox,metadata_hbox,progress_hbox]

    input_accordion_box.children = [input_accordion]
    #input_HBox.children = [input_accordion_label_box, input_accordion_box]
    #input_HBox.layout= widgets.Layout(align_content=&#39;space-between&#39;)

    # Create a GridBox with 12 rows and 20 columns
    input_tab = widgets.GridBox(layout=widgets.Layout(grid_template_columns=&#39;repeat(10, 1)&#39;,
                                                grid_template_rows=&#39;repeat(12, 1)&#39;))

    # Add the VBox to the GridBox
    input_tab.children = [site_hbox,
                            datapath_hbox,
                            metadata_hbox,
                            input_accordion_box,
                            progress_hbox]

    def get_input_params():
        input_params_kwargs={
            &#39;datapath&#39;:data_filepath.value,
            &#39;metapath&#39;:metadata_filepath.value,
            &#39;site&#39;:site_name.value,
            &#39;instrument&#39;:instrument_dropdown.value,
            &#39;network&#39;:network_textbox.value, &#39;station&#39;:station_textbox.value, &#39;loc&#39;:location_textbox.value, 
            &#39;channels&#39;:[z_channel_textbox.value, e_channel_textbox.value, n_channel_textbox.value],
            &#39;starttime&#39;:start_time_picker.value,
            &#39;endtime&#39;:end_time_picker.value,
            &#39;tzone&#39;:time_zone_dropdown.value,
            &#39;xcoord&#39;:xcoord_textbox.value,
            &#39;ycoord&#39;:ycoord_textbox.value,
            &#39;elevation&#39;:zcoord_textbox.value, &#39;elev_unit&#39;:elevation_unit_textbox.value,&#39;depth&#39;:0,
            &#39;input_crs&#39;:input_crs_textbox.value,&#39;output_crs&#39;:output_crs_textbox.value,
            &#39;hvsr_band&#39;:[hvsr_band_min_box.value, hvsr_band_max_box.value],
            &#39;peak_freq_range&#39;:[peak_freq_range_min_box.value, peak_freq_range_max_box.value]}
        return input_params_kwargs

    def get_fetch_data_params():
        fetch_data_kwargs = {
            &#39;source&#39;:data_source_type.value, 
            &#39;trim_dir&#39;:trim_directory.value,
            &#39;export_format&#39;:data_format_dropdown.value,
            &#39;detrend&#39;:detrend_type_dropdown.value,
            &#39;detrend_order&#39;:detrend_order.value}
        if str(fetch_data_kwargs[&#39;detrend&#39;]).lower() == &#39;none&#39;:
            fetch_data_kwargs[&#39;detrend&#39;] = None
        
        if str(fetch_data_kwargs[&#39;trim_dir&#39;]).lower() == &#39;none&#39;:
            fetch_data_kwargs[&#39;trim_dir&#39;] = None
        return fetch_data_kwargs

    def read_data(button):
        progress_bar.value = 0
        log_textArea.value += f&#34;\n\nREADING DATA [{datetime.datetime.now()}]&#34;

        ip_kwargs = get_input_params()
        hvsr_data = sprit_hvsr.input_params(**ip_kwargs, verbose=verbose_check.value)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\ninput_params():\n&#39;{ip_kwargs}&#34;
        if button.description==&#39;Read Data&#39;:
            progress_bar.value=0.333
        else:
            progress_bar.value=0.1
        fd_kwargs = get_fetch_data_params()
        hvsr_data = sprit_hvsr.fetch_data(hvsr_data, **fd_kwargs, verbose=verbose_check.value)
        log_textArea.value += &#39;\n\n&#39;+str(datetime.datetime.now())+&#39;\nfetch_data():\n\t&#39;+str(fd_kwargs)
        if button.description==&#39;Read Data&#39;:
            progress_bar.value=0.666
        else:
            progress_bar.value=0.2
        
        use_hv_curve_rmse.value=False
        use_hv_curve_rmse.disabled=True

        update_preview_fig(hvsr_data, preview_fig)

        if button.description==&#39;Read Data&#39;:
            sprit_tabs.selected_index = 1
            progress_bar.value=0
        return hvsr_data
    
    read_data_button.on_click(read_data)

    def get_remove_noise_kwargs():
        def get_remove_method():
            remove_method_list=[]
            do_stalta = stalta_check.value
            do_sat_pct = max_saturation_check.value
            do_noiseWin=noisy_windows_check.value
            do_warmcool=warmcool_check.value
            
            if auto_remove_check.value:
                remove_method_list=[&#39;stalta&#39;, &#39;saturation&#39;, &#39;noise&#39;, &#39;warmcool&#39;]
            else:
                if do_stalta:
                    remove_method_list.append(&#39;stalta&#39;)
                if do_sat_pct:
                    remove_method_list.append(&#39;saturation&#39;)
                if do_noiseWin:
                    remove_method_list.append(&#39;noise&#39;)
                if do_warmcool:
                    remove_method_list.append(&#39;warmcool&#39;)
            
            if not remove_method_list:
                remove_method_list = None
            return remove_method_list
        
        remove_noise_kwargs = {&#39;remove_method&#39;:get_remove_method(),
                                &#39;sat_percent&#39;:max_saturation_pct.value, 
                                &#39;noise_percent&#39;:max_window_pct.value,
                                &#39;sta&#39;:sta.value,
                                &#39;lta&#39;:lta.value, 
                                &#39;stalta_thresh&#39;:[stalta_thresh_low.value, stalta_thresh_hi.value], 
                                &#39;warmup_time&#39;:warmup_time.value,
                                &#39;cooldown_time&#39;:cooldown_time.value,
                                &#39;min_win_size&#39;:noisy_window_length.value,
                                &#39;remove_raw_noise&#39;:raw_data_remove_check.value,
                                &#39;verbose&#39;:verbose_check.value}
        return remove_noise_kwargs

    def get_generate_ppsd_kwargs():
        ppsd_kwargs = {
            &#39;skip_on_gaps&#39;:skip_on_gaps.value,
            &#39;db_bins&#39;:[db_bins_min.value, db_bins_max.value, db_bins_step.value],
            &#39;ppsd_length&#39;:ppsd_length.value,
            &#39;overlap&#39;:overlap_pct.value,
            &#39;special_handling&#39;:special_handling_dropdown.value,
            &#39;period_smoothing_width_octaves&#39;:period_smoothing_width.value,
            &#39;period_step_octaves&#39;:period_step_octave.value,
            &#39;period_limits&#39;:[period_limits_min.value, period_limits_max.value],
            &#39;verbose&#39;:verbose_check.value
            }

        if str(ppsd_kwargs[&#39;special_handling&#39;]).lower() == &#39;none&#39;:
            ppsd_kwargs[&#39;special_handling&#39;] = None        
        return ppsd_kwargs

    def get_remove_outlier_curve_kwargs():
        roc_kwargs = {
                &#39;use_percentile&#39;:rmse_pctile_check.value,
                &#39;rmse_thresh&#39;:rmse_thresh.value,
                &#39;use_hv_curve&#39;:False,
                &#39;verbose&#39;:verbose_check.value
            }
        return roc_kwargs

    def get_process_hvsr_kwargs():
        if smooth_hv_curve_bool.value:
            smooth_value = smooth_hv_curve.value
        else:
            smooth_value = smooth_hv_curve_bool.value

        if resample_hv_curve_bool.value:
            resample_value = resample_hv_curve.value
        else:
            resample_value = resample_hv_curve_bool.value

        ph_kwargs={&#39;method&#39;:h_combine_meth.value,
                    &#39;smooth&#39;:smooth_value,
                    &#39;freq_smooth&#39;:freq_smoothing.value,
                    &#39;f_smooth_width&#39;:freq_smooth_width.value,
                    &#39;resample&#39;:resample_value,
                    &#39;outlier_curve_rmse_percentile&#39;:use_hv_curve_rmse.value,
                    &#39;verbose&#39;:verbose_check.value}
        return ph_kwargs

    def get_check_peaks_kwargs():
        cp_kwargs = {&#39;hvsr_band&#39;:[hvsr_band_min_box.value, hvsr_band_max_box.value],
                    &#39;peak_freq_range&#39;:[peak_freq_range_min_box.value, peak_freq_range_max_box.value],
                    &#39;peak_selection&#39;:peak_selection_type.value,
                    &#39;verbose&#39;:verbose_check.value}
        return cp_kwargs

    def get_get_report_kwargs():
        def get_formatted_plot_str():
            # Initialize plot string
            hvsr_plot_str = &#39;&#39;
            comp_plot_str = &#39;&#39;
            spec_plot_str = &#39;&#39;

            # Whether to use each plot
            if use_plot_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34;HVSR&#34;
            if use_plot_comp.value:
                comp_plot_str=comp_plot_str + &#34;C&#34;
            if use_plot_spec.value:
                spec_plot_str=spec_plot_str + &#34;SPEC&#34;

            # Whether components be on the same plot as HV curve?
            if not combine_hv_comp.value:
                comp_plot_str=comp_plot_str + &#34;+&#34;
            else:
                comp_plot_str=comp_plot_str.replace(&#39;+&#39;,&#39;&#39;)

            # Whether to show (log) standard deviations
            if not show_std_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; -s&#34;
            if not show_std_comp.value:
                comp_plot_str=comp_plot_str + &#34; -s&#34;                

            # Whether to show all peaks
            if show_all_peaks_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; all&#34;

            # Whether curves from each time window are shown
            if show_all_curves_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; t&#34;
            if show_all_curves_comp.value:
                comp_plot_str=comp_plot_str + &#34; t&#34;

            # Whether the best peak is displayed
            if show_best_peak_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; p&#34;
            if show_best_peak_comp.value:
                comp_plot_str=comp_plot_str + &#34; p&#34;
            if show_best_peak_spec.value:
                spec_plot_str=spec_plot_str + &#34; p&#34;

            # Whether best peak value is annotated
            if ann_best_peak_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; ann&#34;
            if ann_best_peak_comp.value:
                comp_plot_str=comp_plot_str + &#34; ann&#34;
            if ann_best_peak_spec.value:
                spec_plot_str=spec_plot_str + &#34; ann&#34;

            # Whether peaks from individual time windows are shown
            if show_ind_peaks_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; tp&#34;
            if show_ind_peaks_spec.value:
                spec_plot_str=spec_plot_str + &#39; tp&#39;
            
            # Whether to show legend
            if show_legend_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; leg&#34;
            if ann_best_peak_comp.value:
                comp_plot_str=comp_plot_str + &#34; leg&#34;
            if show_legend_spec.value:
                spec_plot_str=spec_plot_str + &#34; leg&#34;            

            # Combine string into one
            plot_str = hvsr_plot_str + &#39; &#39; + comp_plot_str+ &#39; &#39; + spec_plot_str
            return plot_str

        gr_kwargs = {&#39;report_format&#39;:[&#39;print&#39;,&#39;csv&#39;],
                     &#39;plot_type&#39;:get_formatted_plot_str(),
                     &#39;export_path&#39;:None,
                     &#39;csv_overwrite_opt&#39;:&#39;overwrite&#39;,
                     &#39;no_output&#39;:False,
                    &#39;verbose&#39;:verbose_check.value
                     }
        return gr_kwargs

    def process_data(button):
        startProc=datetime.datetime.now()
        progress_bar.value = 0
        log_textArea.value += f&#34;\n\nPROCESSING DATA [{startProc}]&#34;
        global hvsr_data
        # Read data again only if internal hvsr_data datapath variable is different from what is in the gui
        if not &#39;hvsr_data&#39; in globals() or not hasattr(hvsr_data, &#39;datapath&#39;) or \
                (pathlib.Path(hvsr_data.datapath).as_posix() != pathlib.Path(data_filepath.value).as_posix()):
            hvsr_data = read_data(button)

        remove_noise_kwargs = get_remove_noise_kwargs()
        hvsr_data = sprit_hvsr.remove_noise(hvsr_data, **remove_noise_kwargs)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nremove_noise()\n\t{remove_noise_kwargs}&#34;
        progress_bar.value = 0.3

        generate_ppsd_kwargs = get_generate_ppsd_kwargs()
        hvsr_data = sprit_hvsr.generate_ppsds(hvsr_data, **generate_ppsd_kwargs)
        progress_bar.value = 0.5
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\ngenerate_ppsds()\n\t{generate_ppsd_kwargs}&#34;
        
       
        # If this was started by clicking &#34;Generate PPSDs&#34;, stop here
        if button.description == &#39;Generate PPSDs&#39;:
            return

        ph_kwargs = get_process_hvsr_kwargs()
        hvsr_data = sprit_hvsr.process_hvsr(hvsr_data, **ph_kwargs)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nprocess_hvsr()\n\t{ph_kwargs}&#34;
        progress_bar.value = 0.75
        update_outlier_fig()

        roc_kwargs = get_remove_outlier_curve_kwargs()
        hvsr_data = sprit_hvsr.remove_outlier_curves(hvsr_data, **roc_kwargs)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nremove_outlier_curves()\n\t{roc_kwargs}&#34;
        progress_bar.value = 0.85
        outlier_fig, hvsr_data = update_outlier_fig()

        use_hv_curve_rmse.value=False
        use_hv_curve_rmse.disabled=False

        def get_rmse_range():
            minRMSE = 10000
            maxRMSE = -1
            if roc_kwargs[&#39;use_hv_curve&#39;]:
                colnames = [&#39;HV_Curves&#39;]
            else:
                colnames = [&#39;psd_values_Z&#39;,
                            &#39;psd_values_E&#39;,
                            &#39;psd_values_N&#39;]
            dataList = []
            for col in colnames:
                dataArr = np.stack(hvsr_data.hvsr_df[col])
                medCurveArr = np.nanmedian(dataArr, axis=0)
                rmse = np.sqrt(((np.subtract(dataArr, medCurveArr)**2).sum(axis=1))/dataArr.shape[1])
                if rmse.min() &lt; minRMSE:
                    minRMSE = rmse.min()
                if rmse.max() &gt; maxRMSE:
                    maxRMSE = rmse.max()
            rmse_thresh_slider.min = minRMSE
            rmse_thresh_slider.max = maxRMSE
            rmse_thresh_slider.step = round((maxRMSE-minRMSE)/100, 2)
            rmse_thresh_slider.value = maxRMSE
        get_rmse_range()

        cp_kwargs = get_check_peaks_kwargs()
        hvsr_data = sprit_hvsr.check_peaks(hvsr_data, **cp_kwargs)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\ncheck_peaks()\n\t{cp_kwargs}&#34;
        progress_bar.value = 0.9

        gr_kwargs = get_get_report_kwargs()
        hvsr_data = sprit_hvsr.get_report(hvsr_data, **gr_kwargs)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nget_report()\n\t{gr_kwargs}\n\n&#34;
        hvsr_data.get_report(report_format=&#39;print&#39;) # Just in case print wasn&#39;t included
        log_textArea.value += hvsr_data[&#39;Print_Report&#39;]
        printed_results_textArea.value = hvsr_data[&#39;Print_Report&#39;]
        hvsr_data.get_report(report_format=&#39;csv&#39;) 
        results_table.value = hvsr_data[&#39;CSV_Report&#39;].to_html()
        
        log_textArea.value += f&#39;Processing time: {datetime.datetime.now() - startProc}&#39;
        progress_bar.value = 0.95

        update_results_fig(hvsr_data, gr_kwargs[&#39;plot_type&#39;])
        
        progress_bar.value = 1
        global hvsr_results
        hvsr_results = hvsr_data

    def parse_plot_string(plot_string):
        plot_list = plot_string.split()

        hvsrList = [&#39;hvsr&#39;, &#39;hv&#39;, &#39;h&#39;]
        compList = [&#39;component&#39;, &#39;comp&#39;, &#39;c&#39;]
        compPlus = [item + &#39;+&#39; for item in compList]
        specList = [&#39;spectrogram&#39;, &#39;specgram&#39;, &#39;spec&#39;,&#39;sg&#39;, &#39;s&#39;]

        hvInd = np.nan
        compInd = np.nan
        specInd = np.nan

        hvIndFound = False
        compIndFound = False
        specIndFound = False

        for i, item in enumerate(plot_list):
            if item.lower() in hvsrList and not hvIndFound:
                # assign the index
                hvInd = i
                hvIndFound = True
            if (item.lower() in compList or item.lower() in compPlus) and not compIndFound:
                # assign the index
                compInd = i
                compIndFound = True
            if item.lower() in specList and not specIndFound:
                # assign the index
                specInd = i
                specIndFound = True

        # Get individual plot lists (should already be correctly ordered)
        if hvInd is np.nan:
            hvsr_plot_list = [&#39;HVSR&#39;]

        if compInd is np.nan:
            comp_plot_list = []
            if specInd is np.nan:
                if hvInd is not np.nan:
                    hvsr_plot_list = plot_list
                spec_plot_list = []
            else:
                if hvInd is not np.nan:
                    hvsr_plot_list = plot_list[hvInd:specInd]
                spec_plot_list = plot_list[specInd:]
        else:
            if hvInd is not np.nan:
                hvsr_plot_list = plot_list[hvInd:compInd]
            
            if specInd is np.nan:
                comp_plot_list = plot_list[compInd:]
                spec_plot_list = []
            else:
                comp_plot_list = plot_list[compInd:specInd]
                spec_plot_list = plot_list[specInd:]

        # Figure out how many subplots there will be
        plot_list_list = [hvsr_plot_list, comp_plot_list, spec_plot_list]

        return plot_list_list

    def parse_hv_plot_list(hv_data, hvsr_plot_list):
        hvsr_data = hv_data
        x_data = hvsr_data.x_freqs[&#39;Z&#39;]
        hvsrDF = hvsr_data.hvsr_df

        if &#39;tp&#39; in hvsr_plot_list:
            allpeaks = []
            for row in hvsrDF[hvsrDF[&#39;Use&#39;]][&#39;CurvesPeakFreqs&#39;].values:
                for peak in row:
                    allpeaks.append(peak)
            allInd = []
            for row, peakList in enumerate(hvsrDF[hvsrDF[&#39;Use&#39;]][&#39;CurvesPeakIndices&#39;].values):
                for ind in peakList:
                    allInd.append((row, ind))
            x_vals = []
            y_vals = []
            y_max = np.nanmax(hvsr_data.hvsrp)
            hvCurveInd = list(hvsrDF.columns).index(&#39;HV_Curves&#39;)
            for i, tp in enumerate(allpeaks):
                x_vals.extend([tp, tp, None]) # add two x values and a None
                y_vals.extend([0, hvsrDF.iloc[allInd[i][0], hvCurveInd][allInd[i][1]], None]) # add the first and last y values and a None            

            results_fig.add_trace(go.Scatter(x=x_vals, y=y_vals, mode=&#39;lines&#39;,
                                            line=dict(width=4, dash=&#34;solid&#34;, 
                                            color=&#34;rgba(128,0,0,0.1)&#34;), 
                                            name=&#39;Best Peaks Over Time&#39;),
                                            row=1, col=1)

        if &#39;t&#39; in hvsr_plot_list:
            alltimecurves = np.stack(hvsrDF[hvsrDF[&#39;Use&#39;]][&#39;HV_Curves&#39;])
            for i, row in enumerate(alltimecurves):
                if i==0:
                    showLeg = True
                else:
                    showLeg= False
                results_fig.add_trace(go.Scatter(x=x_data[:-1], y=row, mode=&#39;lines&#39;,
                                            line=dict(width=0.5, dash=&#34;solid&#34;, 
                                            color=&#34;rgba(100, 110, 100, 0.8)&#34;), 
                                            showlegend=showLeg, 
                                            name=&#39;Ind. time win. curve&#39;, 
                                            hoverinfo=&#39;none&#39;),
                                            row=1, col=1)

        if &#39;all&#39; in hvsr_plot_list:
            for i, p in enumerate(hvsr_data[&#39;hvsr_peak_freqs&#39;]):
                if i==0:
                    showLeg = True
                else:
                    showLeg= False

                results_fig.add_trace(go.Scatter(
                    x=[p, p, None], # set x to None
                    y=[0, np.nanmax(np.stack(hvsrDF[&#39;HV_Curves&#39;])),None], # set y to None
                    mode=&#34;lines&#34;, # set mode to lines
                    line=dict(width=1, dash=&#34;dot&#34;, color=&#34;gray&#34;), # set line properties
                    name=&#34;All checked peaks&#34;, # set legend name
                    showlegend=showLeg),
                    row=1, col=1)

        if &#39;-s&#39; not in hvsr_plot_list:
            # Show standard deviation
            results_fig.add_trace(go.Scatter(x=x_data, y=hvsr_data.hvsrp2,
                                    line={&#39;color&#39;:&#39;black&#39;, &#39;width&#39;:0.1},marker=None, 
                                    showlegend=False, name=&#39;Log. St.Dev. Upper&#39;,
                                    hoverinfo=&#39;none&#39;),
                                    row=1, col=1)
            
            results_fig.add_trace(go.Scatter(x=x_data, y=hvsr_data.hvsrm2,
                                    line={&#39;color&#39;:&#39;black&#39;, &#39;width&#39;:0.1},marker=None,
                                    fill=&#39;tonexty&#39;, fillcolor=&#34;rgba(128, 128, 128, 0.6)&#34;,
                                    name=&#39;Log. St.Dev.&#39;, hoverinfo=&#39;none&#39;),
                                    row=1, col=1)
                
        if &#39;p&#39; in hvsr_plot_list:
            results_fig.add_trace(go.Scatter(
                x=[hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;], hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;], None], # set x to None
                y=[0,np.nanmax(np.stack(hvsrDF[&#39;HV_Curves&#39;])),None], # set y to None
                mode=&#34;lines&#34;, # set mode to lines
                line=dict(width=1, dash=&#34;dash&#34;, color=&#34;black&#34;), # set line properties
                name=&#34;Best Peak&#34;),
                row=1, col=1)

        if &#39;ann&#39; in hvsr_plot_list:
            # Annotate best peak
            results_fig.add_annotation(x=np.log10(hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;]),
                                    y=0, yanchor=&#39;bottom&#39;, xanchor=&#39;center&#39;,
                                    text=f&#34;{hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;]:.3f} Hz&#34;,
                                    bgcolor=&#39;rgba(255, 255, 255, 0.7)&#39;,
                                    showarrow=False,
                                    row=1, col=1)
        return results_fig

    def parse_comp_plot_list(hv_data, comp_plot_list):
        
        hvsr_data = hv_data
        # Initial setup
        x_data = hvsr_data.x_freqs[&#39;Z&#39;]
        hvsrDF = hvsr_data.hvsr_df
        same_plot = ((comp_plot_list != []) and (&#39;+&#39; not in comp_plot_list[0]))

        if same_plot:
            yaxis_to_use = &#39;y2&#39;
            use_secondary = True
            transparency_modifier = 0.5
        else:
            yaxis_to_use = &#39;y&#39;
            use_secondary=False
            transparency_modifier = 1

        alpha = 0.4 * transparency_modifier
        components = [&#39;Z&#39;, &#39;E&#39;, &#39;N&#39;]
        compColor_semi_light = {&#39;Z&#39;:f&#39;rgba(128,128,128,{alpha})&#39;,
                    &#39;E&#39;:f&#39;rgba(0,0,128,{alpha})&#39;,
                    &#39;N&#39;:f&#39;rgba(128,0,0,{alpha})&#39;}

        alpha = 0.7 * transparency_modifier
        compColor_semi = {&#39;Z&#39;:f&#39;rgba(128,128,128,{alpha})&#39;, 
                        &#39;E&#39;:f&#39;rgba(100,100,128,{alpha})&#39;, 
                        &#39;N&#39;:f&#39;rgba(128,100,100,{alpha})&#39;}

        compColor = {&#39;Z&#39;:f&#39;rgba(128,128,128,{alpha})&#39;, 
                    &#39;E&#39;:f&#39;rgba(100,100,250,{alpha})&#39;, 
                    &#39;N&#39;:f&#39;rgba(250,100,100,{alpha})&#39;}

        # Whether to plot in new subplot or not
        if  comp_plot_list != [] and &#39;+&#39; in comp_plot_list[0]:
            compRow=2
        else:
            compRow=1

        # Whether to plot individual time curves
        if &#39;t&#39; in comp_plot_list:
            for comp in components:
                alltimecurves = np.stack(hvsrDF[hvsrDF[&#39;Use&#39;]][&#39;psd_values_&#39;+comp])
                for i, row in enumerate(alltimecurves):
                    if i==0:
                        showLeg = True
                    else:
                        showLeg= False
                    
                    results_fig.add_trace(go.Scatter(x=x_data[:-1], y=row, mode=&#39;lines&#39;,
                                    line=dict(width=0.5, dash=&#34;solid&#34;, 
                                    color=compColor_semi[comp]),
                                    name=&#39;Ind. time win. curve&#39;,
                                    showlegend=False,
                                    hoverinfo=&#39;none&#39;,
                                    yaxis=yaxis_to_use),
                                    secondary_y=use_secondary,
                                    row=compRow, col=1)

        # Code to plot standard deviation windows, if not removed
        if &#39;-s&#39; not in comp_plot_list:
            for comp in components:
                # Show standard deviation
                results_fig.add_trace(go.Scatter(x=x_data, y=hvsr_data.ppsd_std_vals_p[comp],
                                        line={&#39;color&#39;:compColor_semi_light[comp], &#39;width&#39;:0.1},marker=None, 
                                        showlegend=False, name=&#39;Log. St.Dev. Upper&#39;,
                                        hoverinfo=&#39;none&#39;,    
                                        yaxis=yaxis_to_use),
                                        secondary_y=use_secondary,
                                        row=compRow, col=1)
                
                results_fig.add_trace(go.Scatter(x=x_data, y=hvsr_data.ppsd_std_vals_m[comp],
                                        line={&#39;color&#39;:compColor_semi_light[comp], &#39;width&#39;:0.1},marker=None,
                                        fill=&#39;tonexty&#39;, fillcolor=compColor_semi_light[comp],
                                        name=f&#39;St.Dev. [{comp}]&#39;, hoverinfo=&#39;none&#39;, showlegend=False, 
                                        yaxis=yaxis_to_use),
                                        secondary_y=use_secondary,
                                        row=compRow, col=1)
                
        # Code to plot location of best peak
        if &#39;p&#39; in comp_plot_list:
            minVal = 10000
            maxVal = -10000
            for comp in components:
                currPPSDCurve = hvsr_data[&#39;psd_values_tavg&#39;][comp]
                if np.nanmin(currPPSDCurve) &lt; minVal:
                    minVal = np.nanmin(currPPSDCurve)
                if np.nanmax(currPPSDCurve) &gt; maxVal:
                    maxVal = np.nanmax(currPPSDCurve)

            results_fig.add_trace(go.Scatter(
                x=[hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;], hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;], None], # set x to None
                y=[minVal,maxVal,None], # set y to None
                mode=&#34;lines&#34;, # set mode to lines
                line=dict(width=1, dash=&#34;dash&#34;, color=&#34;black&#34;), # set line properties
                name=&#34;Best Peak&#34;,
                yaxis=yaxis_to_use),
                secondary_y=use_secondary,
                row=compRow, col=1)
            
        # Code to annotate value of best peak
        if &#39;ann&#39; in comp_plot_list:
            minVal = 10000
            for comp in components:
                currPPSDCurve = hvsr_data[&#39;psd_values_tavg&#39;][comp]
                if np.nanmin(currPPSDCurve) &lt; minVal:
                    minVal = np.nanmin(currPPSDCurve)
            results_fig.add_annotation(x=np.log10(hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;]),
                            y=minVal,
                            text=f&#34;{hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;]:.3f} Hz&#34;,
                            bgcolor=&#39;rgba(255, 255, 255, 0.7)&#39;,
                            showarrow=False,
                            yref=yaxis_to_use,
                            secondary_y=use_secondary,
                            row=compRow, col=1)

        # Plot the main averaged component PPSDs
        for comp in components:
            results_fig.add_trace(go.Scatter(x=hvsr_data.x_freqs[comp],
                                            y=hvsr_data[&#39;psd_values_tavg&#39;][comp],
                                            line=dict(width=2, dash=&#34;solid&#34;, 
                                            color=compColor[comp]),marker=None, 
                                            name=&#39;PPSD Curve &#39;+comp,    
                                            yaxis=yaxis_to_use), 
                                            secondary_y=use_secondary,
                                            row=compRow, col=&#39;all&#39;)

        # If new subplot, update accordingly
        if compRow==2:
            results_fig.update_xaxes(type=&#39;log&#39;,
                            range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])],
                            row=compRow, col=1)
        return results_fig

    def parse_spec_plot_list(hv_data, spec_plot_list, subplot_num):
        hvsr_data = hv_data
        # Initial setup
        hvsrDF = hvsr_data.hvsr_df
        specAxisTimes = np.array([dt.isoformat() for dt in hvsrDF.index.to_pydatetime()])
        y_data = hvsr_data.x_freqs[&#39;Z&#39;][1:]
        image_data = np.stack(hvsrDF[&#39;HV_Curves&#39;]).T

        maxZ = np.percentile(image_data, 100)
        minZ = np.percentile(image_data, 0)

        use_mask = hvsr_data.hvsr_df.Use.values
        use_mask = np.tile(use_mask, (image_data.shape[0],1))
        use_mask = np.where(use_mask is False, np.nan, use_mask)

        hmap = go.Heatmap(z=image_data,
                    x=specAxisTimes,
                    y=y_data,
                    colorscale=&#39;Turbo&#39;,
                    showlegend=False,
                    #opacity=0.7,
                    hovertemplate=&#39;Time [UTC]: %{x}&lt;br&gt;Frequency [Hz]: %{y:.2f}&lt;br&gt;H/V Amplitude: %{z:.2f}&lt;extra&gt;&lt;/extra&gt;&#39;,
                    zmin=minZ,zmax=maxZ, showscale=False, name=&#39;HV Curve Amp. over Time&#39;)
        results_fig.add_trace(hmap, row=subplot_num, col=1)

        data_used = go.Heatmap(
            x=specAxisTimes,
            y=y_data,
            z=use_mask,
            showlegend=False,
            colorscale=[[0, &#39;rgba(0,0,0,0.66)&#39;], [0.25, &#39;rgba(0,0,0,0.66)&#39;], [1, &#39;rgba(250,250,250,0)&#39;]],
            showscale=False, name=&#39;Used&#39;)
        results_fig.add_trace(data_used, row=subplot_num, col=1)


        # tp currently is not being added to spec_plot_list
        if &#39;tp&#39; in spec_plot_list:
            yvals = []
            for row in hvsrDF[&#39;HV_Curves&#39;].values:
                maxInd = np.argmax(row)
                yvals.append(y_data[maxInd])
            tp_trace = go.Scatter(x=specAxisTimes, y=yvals, mode=&#39;markers&#39;,
                                    line=None, marker=dict(color=&#39;white&#39;, size=2, line=dict(color=&#39;black&#39;, width=0.1)), name=&#39;Individual H/V Peaks&#39;)
            results_fig.add_trace(tp_trace, row=subplot_num, col=&#39;all&#39;)

        if &#39;p&#39; in spec_plot_list:
            results_fig.add_hline(y=hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;], line_width=1, line_dash=&#39;dash&#39;, line_color=&#39;black&#39;, row=subplot_num, col=&#39;all&#39;)

        if &#39;ann&#39; in spec_plot_list:
            results_fig.add_annotation(x=specAxisTimes[-1],
                                    y=hvsr_data[&#39;hvsr_band&#39;][1],
                                    text=f&#34;Peak: {hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;]:.3f} Hz&#34;,
                                    bgcolor=&#39;rgba(255, 255, 255, 0.7)&#39;,
                                    showarrow=False, xanchor=&#39;right&#39;, yanchor=&#39;top&#39;,
                                    row=subplot_num, col=&#39;all&#39;)

        if &#39;leg&#39; in spec_plot_list:
            pass

        results_fig.update_yaxes(type=&#39;log&#39;,
                        range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])],
                        row=subplot_num, col=1)

        results_fig.add_annotation(
            text=f&#34;{hvsrDF[&#39;Use&#39;].sum()}/{hvsrDF.shape[0]} windows used&#34;,
            x=max(specAxisTimes),
            y=np.log10(min(y_data))+(np.log10(max(y_data))-np.log10(min(y_data)))*0.01,
            xanchor=&#34;right&#34;, yanchor=&#34;bottom&#34;,bgcolor=&#39;rgba(256,256,256,0.7)&#39;,
            showarrow=False,row=subplot_num, col=1)

        return results_fig

    def update_results_fig(hv_data, plot_string):
        global results_fig
        hvsr_data = hv_data

        if isinstance(hvsr_data, sprit_hvsr.HVSRBatch):
            hvsr_data=hvsr_data[0]

        hvsrDF = hvsr_data.hvsr_df

        plot_list = parse_plot_string(plot_string)

        combinedComp=False
        noSubplots = 3 - plot_list.count([])
        if plot_list[1] != [] and &#39;+&#39; not in plot_list[1][0]:
            combinedComp = True
            noSubplots -= 1
        
        # Get all data for each plotted item
        # COMP Plot
        # Figure out which subplot is which
        if combinedComp:
            comp_plot_row = 1
            spec_plot_row = 2
        else:
            comp_plot_row = 2
            spec_plot_row = 3

        # Re-initialize results_fig
        results_fig.data = []
        results_fig.update_layout(grid=None)  # Clear the existing grid layout
        if not combinedComp: 
            subp = subplots.make_subplots(rows=3, cols=1, horizontal_spacing=0.01, vertical_spacing=0.07,
                                                row_heights=[2, 1.5, 1])
        else:
            subp = subplots.make_subplots(rows=2, cols=1, horizontal_spacing=0.01, vertical_spacing=0.07,
                                    specs =[[{&#39;secondary_y&#39;: True}],
                                            [{&#39;secondary_y&#39;: False}]],
                                            row_heights=[1, 1])
        results_fig.update_layout(grid={&#39;rows&#39;: noSubplots})
        #del results_fig
        results_fig = go.FigureWidget(subp)

        results_fig = parse_comp_plot_list(hvsr_data, comp_plot_list=plot_list[1])

        # HVSR Plot (plot this after COMP so it is on top COMP and to prevent deletion with no C+)
        results_fig = parse_hv_plot_list(hvsr_data, hvsr_plot_list=plot_list[0])
        # Will always plot the HV Curve
        results_fig.add_trace(go.Scatter(x=hvsr_data.x_freqs[&#39;Z&#39;],y=hvsr_data.hvsr_curve,
                            line={&#39;color&#39;:&#39;black&#39;, &#39;width&#39;:1.5},marker=None, name=&#39;HVSR Curve&#39;),
                            row=1, col=&#39;all&#39;)

        # SPEC plot
        results_fig = parse_spec_plot_list(hvsr_data, spec_plot_list=plot_list[2], subplot_num=spec_plot_row)

        # Final figure updating
        showtickLabels = (plot_list[1]==[] or &#39;+&#39; not in plot_list[1][0])
        if showtickLabels:
            side=&#39;bottom&#39;
        else:
            side=&#39;top&#39;
        results_fig.update_xaxes(type=&#39;log&#39;,
                        range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])],
                        side=&#39;top&#39;,
                        row=1, col=1)
        
        results_fig.update_xaxes(type=&#39;log&#39;,overlaying=&#39;x&#39;,
                        range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])],
                        side=&#39;bottom&#39;,
                        row=1, col=1)
        if comp_plot_row!=1:
            results_fig.update_xaxes(showticklabels=showtickLabels, row=comp_plot_row, col=1)
        
        if preview_fig.layout.width is None:
            if outlier_fig.layout.widgth is None:
                chartwidth = 800
            else:
                chartwidth = outlier_fig.layout.width

        else:
            chartwidth = preview_fig.layout.width

        results_fig.update_layout(margin={&#34;l&#34;:10, &#34;r&#34;:10, &#34;t&#34;:35, &#39;b&#39;:0},
                                showlegend=False, autosize=True, height = 1.2 * float(chartwidth),
                                title=f&#34;{hvsr_data[&#39;site&#39;]} Results&#34;)
        results_fig.update_yaxes(title_text=&#39;H/V Ratio&#39;, row=1, col=1)
        results_fig.update_yaxes(title_text=&#39;H/V Over Time&#39;, row=noSubplots, col=1)
        if comp_plot_row==1:
            results_fig.update_yaxes(title_text=&#34;PPSD Amp\n[m2/s4/Hz][dB]&#34;, secondary_y=True, row=comp_plot_row, col=1)
        else:
            results_fig.update_yaxes(title_text=&#34;PPSD Amp\n[m2/s4/Hz][dB]&#34;, row=comp_plot_row, col=1)
        
        # Reset results_graph_widget and display 
        with results_graph_widget:
            clear_output(wait=True)
            display(results_fig)

        if show_plot_check.value:
            results_fig.show()

        sprit_tabs.selected_index = 4
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nResults Figure Updated: {plot_string}&#34;

    process_hvsr_button.on_click(process_data)

    # PREVIEW TAB
    #Initialize plot
    subp = subplots.make_subplots(rows=4, cols=1, shared_xaxes=True, horizontal_spacing=0.01, vertical_spacing=0.01, row_heights=[3,1,1,1])
    preview_fig = go.FigureWidget(subp)

    def update_preview_fig(hv_data, preview_fig):
        preview_fig.data = []
        
        hvsr_data = hv_data
        if isinstance(hvsr_data, sprit_hvsr.HVSRBatch):
            hvsr_data=hvsr_data[0]

        stream_z = hvsr_data[&#39;stream&#39;].select(component=&#39;Z&#39;) #may be np.ma.masked_array
        stream_e = hvsr_data[&#39;stream&#39;].select(component=&#39;E&#39;) #may be np.ma.masked_array
        stream_n = hvsr_data[&#39;stream&#39;].select(component=&#39;N&#39;) #may be np.ma.masked_array

        # Get iso_times and datetime.datetime
        utcdt = stream_z[0].times(type=&#39;utcdatetime&#39;)
        iso_times=[]
        dt_times = []
        for t in utcdt:
            if t is not np.ma.masked:
                iso_times.append(t.isoformat())
                dt_times.append(datetime.datetime.fromisoformat(t.isoformat()))
            else:
                iso_times.append(np.nan)
        iso_times=np.array(iso_times)
        dt_times = np.array (dt_times)

        # Generate spectrogram
        f, t, Sxx = signal.spectrogram(x=stream_z[0].data, fs=stream_z[0].stats.sampling_rate, mode=&#39;magnitude&#39;)
        
        # Get times for the axis (one time per window)
        axisTimes = []
        for tpass in t:
            axisTimes.append((dt_times[0]+datetime.timedelta(seconds=tpass)).isoformat())

        # Add data to preview_fig
        # Add spectrogram of Z component
        minz = np.percentile(Sxx, 1)
        maxz = np.percentile(Sxx, 99)
        hmap = go.Heatmap(z=Sxx,
                    x=axisTimes,
                    y=f,
                    colorscale=&#39;Turbo&#39;,
                    showlegend=False,
                    hovertemplate=&#39;Time [UTC]: %{x}&lt;br&gt;Frequency [Hz]: %{y:.2f}&lt;br&gt;Spectrogram Magnitude: %{z:.2f}&lt;extra&gt;&lt;/extra&gt;&#39;,
                    zmin=minz, zmax=maxz, showscale=False, name=&#39;Z Component Spectrogram&#39;)
        preview_fig.add_trace(hmap, row=1, col=1)
        preview_fig.update_yaxes(type=&#39;log&#39;, range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])], row=1, col=1)
        preview_fig.update_yaxes(title={&#39;text&#39;:&#39;Spectrogram (Z)&#39;}, row=1, col=1)

        # Add raw traces
        dec_factor=5 #This just makes the plotting go faster, by &#34;decimating&#34; the data
        preview_fig.add_trace(go.Scatter(x=iso_times[::dec_factor], y=stream_z[0].data[::dec_factor],
                                        line={&#39;color&#39;:&#39;black&#39;, &#39;width&#39;:0.5},marker=None, name=&#39;Z component data&#39;), row=2, col=&#39;all&#39;)
        preview_fig.update_yaxes(title={&#39;text&#39;:&#39;Z&#39;}, row=2, col=1)
        preview_fig.add_trace(go.Scatter(x=iso_times[::dec_factor], y=stream_e[0].data[::dec_factor],
                                        line={&#39;color&#39;:&#39;blue&#39;, &#39;width&#39;:0.5},marker=None, name=&#39;E component data&#39;),row=3, col=&#39;all&#39;)
        preview_fig.update_yaxes(title={&#39;text&#39;:&#39;E&#39;}, row=3, col=1)
        preview_fig.add_trace(go.Scatter(x=iso_times[::dec_factor], y=stream_n[0].data[::dec_factor],
                                        line={&#39;color&#39;:&#39;red&#39;, &#39;width&#39;:0.5},marker=None, name=&#39;N component data&#39;), row=4, col=&#39;all&#39;)
        preview_fig.update_yaxes(title={&#39;text&#39;:&#39;N&#39;}, row=4, col=1)
        
        #preview_fig.add_trace(p)
        preview_fig.update_layout(margin={&#34;l&#34;:10, &#34;r&#34;:10, &#34;t&#34;:30, &#39;b&#39;:0}, showlegend=False,
                                  title=f&#34;{hvsr_data[&#39;site&#39;]} Data Preview&#34;)

        if show_plot_check.value:
            preview_fig.show()

    # REMOVE NOISE SUBTAB
    # STA/LTA Antitrigger
    stalta_check = widgets.Checkbox(value=False, disabled=False, indent=False, description=&#39;STA/LTA Antitrigger&#39;)
    sta = widgets.FloatText(description=&#39;STA [s]&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=5, value=5,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    lta = widgets.FloatText(description=&#39;LTA [s]&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=30, value=30,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    stalta_thresh_low = widgets.FloatText(description=&#39;STA/LTA Thresholds (low, high)&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0.5, value=0.5,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    stalta_thresh_hi = widgets.FloatText(style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=5, value=5,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))

    #% Saturation Threshold
    max_saturation_check = widgets.Checkbox(description=&#39;Percentage Threshold (Instantaneous)&#39;, value=False, disabled=False, indent=False)
    max_saturation_pct = widgets.FloatText(description=&#39;Max Saturation %:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0.995, value=0.995,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))

    #Noise Windows
    noisy_windows_check = widgets.Checkbox(description=&#39;Noisy Windows&#39;, value=False, disabled=False, indent=False)
    max_window_pct = widgets.FloatText(description=&#39;Max Window %:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0.8, value=0.8,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    noisy_window_length = widgets.FloatText(description=&#39;Window Length [s]:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=30, value=30,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))

    #Warmup/cooldown
    warmcool_check = widgets.Checkbox(description=&#39;Warmup &amp; Cooldown Time&#39;, value=False, disabled=False, indent=False)
    warmup_time = widgets.FloatText(description=&#39;Warmup time [s]:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0, value=0,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    cooldown_time = widgets.FloatText(description=&#39;Cooldown time [s]:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0, value=0,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))

    #STD Ratio
    std_ratio_check = widgets.Checkbox(description=&#39;Standard Deviation Antitrigger (not yet implemented)&#39;, value=False, disabled=True, indent=False)
    std_ratio_text = widgets.FloatText(description=&#39;StdDev Ratio:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0, value=0,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=True)
    std_window_length_text = widgets.FloatText(description=&#39;Moving window Length [s]:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0, value=0,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;),disabled=True)

    #Autoremove
    auto_remove_check = widgets.Checkbox(description=&#39;Use Auto Remove&#39;, value=False, disabled=False, indent=False)

    #Remove from raw data
    raw_data_remove_check = widgets.Checkbox(description=&#39;Remove Noise From Raw Data&#39;, value=False, disabled=False, indent=False)

    #remove_noise call
    remove_noise_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;remove_noise&#39; + &#39;&lt;/p&gt;&#39;, 
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    remove_noise_call = widgets.HTML(value=&#39;()&#39;)
    remove_noise_call_hbox = widgets.HBox([remove_noise_prefix, remove_noise_call])

    # Update remove_outlier call
    def update_remove_noise_call():
        rnkwargs = get_remove_noise_kwargs()
        rn_text = f&#34;&#34;&#34;(hvsr_data=hvsr_data, remove_method={rnkwargs[&#39;remove_method&#39;]}, 
                    sat_percent={rnkwargs[&#39;sat_percent&#39;]}, 
                    noise_percent={rnkwargs[&#39;noise_percent&#39;]}, 
                    sta={rnkwargs[&#39;sta&#39;]}, 
                    lta={rnkwargs[&#39;lta&#39;]}, 
                    stalta_thresh={rnkwargs[&#39;stalta_thresh&#39;]}, 
                    warmup_time={rnkwargs[&#39;warmup_time&#39;]}, 
                    cooldown_time={rnkwargs[&#39;cooldown_time&#39;]}, 
                    min_win_size={rnkwargs[&#39;min_win_size&#39;]}, 
                    remove_raw_noise={rnkwargs[&#39;remove_raw_noise&#39;]}, 
                    verbose={verbose_check.value})&#34;&#34;&#34;
        remove_noise_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + rn_text + &#39;&lt;/p&gt;&#39;
    update_remove_noise_call()

    #Update noise windows
    update_noise_windows_button = widgets.Button(description=&#39;Update Noise Windows&#39;,button_style=&#39;info&#39;,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=True)

    preview_graph_widget = widgets.Output()
    #progress bar (same as above)
    preview_progress_hbox = widgets.HBox(children=[progress_bar, update_noise_windows_button, process_hvsr_button])

    # Add it all in to the tab
    stalta_hbox = widgets.HBox([stalta_check, sta, lta, stalta_thresh_low, stalta_thresh_hi])
    sat_hbox = widgets.HBox([max_saturation_check, max_saturation_pct])
    noise_win_hbox = widgets.HBox([noisy_windows_check, max_window_pct, noisy_window_length])
    warmcool_hbox = widgets.HBox([warmcool_check, warmup_time, cooldown_time])
    std_ratio_hbox = widgets.HBox([std_ratio_check, std_ratio_text, std_window_length_text])
    spacer_hbox = widgets.HBox([tenpct_spacer])

    preview_noise_tab = widgets.VBox([stalta_hbox,
                                      sat_hbox,
                                      noise_win_hbox,
                                      warmcool_hbox,
                                      std_ratio_hbox,
                                      auto_remove_check,
                                      raw_data_remove_check,
                                      spacer_hbox,
                                      remove_noise_call_hbox])

    preview_graph_tab = widgets.VBox(children=[preview_graph_widget])
    preview_subtabs = widgets.Tab([preview_graph_tab, preview_noise_tab])
    preview_tab = widgets.VBox()

    preview_subtabs.set_title(0, &#34;Data Preview&#34;)
    preview_subtabs.set_title(1, &#34;Noise Removal&#34;)

    preview_tab.children = [preview_subtabs, preview_progress_hbox]
    # Initialize tab
    with preview_graph_widget:
        display(preview_fig)

    # SETTINGS TAB
    plot_settings_tab = widgets.GridspecLayout(18, ui_width)
    settings_progress_hbox = widgets.HBox(children=[progress_bar, tenpct_spacer, process_hvsr_button])

    # PPSD SETTINGS SUBTAB
    ppsd_length_label = widgets.Label(value=&#39;Window Length for PPSDs:&#39;)
    ppsd_length = widgets.FloatText(style={&#39;description_width&#39;: &#39;initial&#39;}, 
                                    placeholder=20, value=20,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    
    overlap_pct_label = widgets.Label(value=&#39;Overlap %:&#39;)
    overlap_pct = widgets.FloatText(style={&#39;description_width&#39;: &#39;initial&#39;}, 
                                    placeholder=0.5, value=0.5, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    period_step_label = widgets.Label(value=&#39;Period Step Octaves:&#39;)
    period_step_octave = widgets.FloatText(style={&#39;description_width&#39;: &#39;initial&#39;}, 
                                           placeholder=0.0625, value=0.0625, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    skip_on_gaps_label = widgets.Label(value=&#39;Skip on gaps:&#39;)
    skip_on_gaps = widgets.Checkbox(value=False, disabled=False, indent=False)

    db_step_label = widgets.Label(value=&#39;dB bins:&#39;)
    db_bins_min = widgets.FloatText(description=&#39;Min. dB&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=-200, value=-200, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    db_bins_max = widgets.FloatText(description=&#39;Max. dB&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=-50, value=-50, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    db_bins_step = widgets.FloatText(description=&#39;dB Step&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=1, value=1, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    
    period_limit_label = widgets.Label(value=&#39;Period Limits:&#39;)
    minPLim = round(1/(hvsr_band_max_box.value), 3)
    maxPLim = round(1/(hvsr_band_min_box.value), 3)
    period_limits_min = widgets.FloatText(description=&#39;Min. Period Limit&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=minPLim, value=minPLim, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    period_limits_max = widgets.FloatText(description=&#39;Max. Period Limit&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=maxPLim, value=maxPLim, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    period_smoothing_width = widgets.FloatText(description=&#39;Period Smoothing Width&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=1, value=1, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    special_handling_dropdown = widgets.Dropdown(description=&#39;Special Handling&#39;, value=&#39;none&#39;,
                                                options=[(&#39;None&#39;, &#39;none&#39;), (&#39;Ringlaser&#39;, &#39;ringlaser&#39;), (&#39;Hydrophone&#39;, &#39;hydrophone&#39;)],
                                            style={&#39;description_width&#39;: &#39;initial&#39;},  layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    #remove_noise call
    generate_ppsd_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;generate_ppsds&#39; + &#39;&lt;/p&gt;&#39;, 
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    generate_ppsd_call = widgets.HTML(value=&#39;()&#39;)
    generate_ppsd_call_hbox = widgets.HBox([generate_ppsd_prefix, generate_ppsd_call])

    # Update generate_ppsds() call
    def update_generate_ppsd_call():
        gppsdkwargs = get_generate_ppsd_kwargs()
        gppsd_text = f&#34;&#34;&#34;(hvsr_data=hvsr_data, 
                        stats=hvsr_data[&#39;stream&#39;].select(component=&#39;*&#39;).traces[0].stats, 
                        metadata=hvsr_data[&#39;paz&#39;][&#39;*&#39;], 
                        skip_on_gaps={gppsdkwargs[&#39;skip_on_gaps&#39;]}, 
                        db_bins={gppsdkwargs[&#39;db_bins&#39;]}, 
                        ppsd_length={gppsdkwargs[&#39;ppsd_length&#39;]}, 
                        overlap={gppsdkwargs[&#39;overlap&#39;]}, 
                        special_handling={gppsdkwargs[&#39;special_handling&#39;]}, 
                        period_smoothing_width_octaves={gppsdkwargs[&#39;period_smoothing_width_octaves&#39;]}, 
                        period_step_octaves={gppsdkwargs[&#39;period_step_octaves&#39;]}, 
                        period_limits={gppsdkwargs[&#39;period_limits&#39;]}, 
                        verbose={verbose_check.value})&#34;&#34;&#34;
        generate_ppsd_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + gppsd_text + &#39;&lt;/p&gt;&#39;
    update_generate_ppsd_call()

    ppsd_length_hbox = widgets.HBox([ppsd_length_label, ppsd_length])
    overlap_pct_hbox = widgets.HBox([overlap_pct_label, overlap_pct])
    pstep_hbox = widgets.HBox([period_step_label, period_step_octave])
    skipgaps_hbox = widgets.HBox([skip_on_gaps_label, skip_on_gaps])
    db_bins_hbox = widgets.HBox([db_step_label, db_bins_min, db_bins_max, db_bins_step])
    plim_hbox = widgets.HBox([period_limit_label, period_limits_min, period_limits_max, period_smoothing_width])

    ppsd_settings_tab = widgets.VBox([ppsd_length_hbox,
                                      overlap_pct_hbox,
                                      pstep_hbox,
                                      skipgaps_hbox,
                                      db_bins_hbox,
                                      plim_hbox,
                                      special_handling_dropdown,
                                      generate_ppsd_call_hbox])

    # OUTLIER SETTINGS SUBTAB
    rmse_pctile_check = widgets.Checkbox(description=&#39;Using percentile&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), style={&#39;description_width&#39;: &#39;initial&#39;}, value=True)
    rmse_thresh = widgets.FloatText(description=&#39;RMSE Threshold&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=98, value=98, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    use_hv_curve_rmse = widgets.Checkbox(description=&#39;Use HV Curve Outliers (may only be used after they have been calculated during the process_hvsr() step))&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), style={&#39;description_width&#39;: &#39;initial&#39;}, value=False, disabled=True)

    outlier_threshbox_hbox = widgets.HBox(children=[rmse_thresh, rmse_pctile_check])
    outlier_params_vbox = widgets.VBox(children=[outlier_threshbox_hbox, use_hv_curve_rmse])

    global outlier_fig
    outlier_fig = go.FigureWidget()
    outlier_graph_widget = widgets.Output()

    outlier_thresh_slider_label = widgets.Label(value=&#39;RMSE Thresholds:&#39;)
    rmse_thresh_slider = widgets.FloatSlider(value=0, min=0, max=100, step=0.1,description=&#39;RMSE Value&#39;,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;),disabled=True)
    rmse_pctile_slider = widgets.FloatSlider(value=get_default(sprit_hvsr.remove_outlier_curves, &#39;rmse_thresh&#39;), min=0, max=100, step=0.1, description=&#34;Percentile&#34;,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;),)
    
    def calc_rmse(array_2d):
        medArray = np.nanmedian(array_2d, axis=0)
        rmse = np.sqrt(((np.subtract(array_2d, medArray)**2).sum(axis=1))/array_2d.shape[1])
        return rmse
    
    def on_update_rmse_thresh_slider(change):
        if use_hv_curve_rmse.value:
            rmse = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;HV_Curves&#39;]))
        else:
            rmsez = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;psd_values_Z&#39;]))
            rmsee = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;psd_values_E&#39;]))
            rmsen = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;psd_values_N&#39;]))

            rmse = np.stack([rmsez, rmsee, rmsen]).flatten()

        if rmse_pctile_check.value:
            rmse_thresh.value = rmse_pctile_slider.value
        else:
            rmse_thresh.value = rmse_thresh_slider.value
            rmse_pctile_slider.value = ((rmse &lt; rmse_thresh_slider.value).sum() / len(rmse)) * 100

    def on_update_rmse_pctile_slider(change):
        if use_hv_curve_rmse.value:
            rmse = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;HV_Curves&#39;]))
        else:
            rmsez = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;psd_values_Z&#39;]))
            rmsee = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;psd_values_E&#39;]))
            rmsen = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;psd_values_N&#39;]))

            rmse = np.stack([rmsez, rmsee, rmsen])

        if rmse_pctile_check.value:
            rmse_thresh_slider.value = np.percentile(rmse, rmse_pctile_slider.value)
            rmse_thresh.value = rmse_pctile_slider.value
        else:
            rmse_thresh.value = rmse_thresh_slider.value

    def on_update_rmse_pctile_check(change):
        if rmse_pctile_check.value:
            rmse_pctile_slider.disabled = False
            rmse_thresh_slider.disabled = True
        else:
            rmse_pctile_slider.disabled = True
            rmse_thresh_slider.disabled = False
    
    def on_update_rmse_thresh(change):
        if rmse_pctile_check.value:
            rmse_pctile_slider.value = rmse_thresh.value
        else:
            rmse_thresh_slider.value = rmse_thresh.value

    rmse_pctile_check.observe(on_update_rmse_pctile_check)
    rmse_thresh_slider.observe(on_update_rmse_thresh_slider)
    rmse_pctile_slider.observe(on_update_rmse_pctile_slider)
    rmse_thresh.observe(on_update_rmse_thresh)

    use_hv_curve_label = widgets.Label(value=&#39;NOTE: Outlier curves may only be identified after PPSDs have been calculated (during the generate_ppsds() step)&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;80%&#39;))
    generate_ppsd_button = widgets.Button(description=&#39;Generate PPSDs&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;20%&#39;, justify_content=&#39;flex-end&#39;), disabled=False)
    update_outlier_plot_button = widgets.Button(description=&#39;Remove Outliers&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;20%&#39;, justify_content=&#39;flex-end&#39;), disabled=False)
    outlier_ppsd_hbox = widgets.HBox([use_hv_curve_label, generate_ppsd_button, update_outlier_plot_button])
    remove_outlier_curve_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;remove_outlier_curves&#39; + &#39;&lt;/p&gt;&#39;, 
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    remove_outlier_curve_call = widgets.HTML(value=&#39;()&#39;)
    remove_outlier_hbox = widgets.HBox([remove_outlier_curve_prefix, remove_outlier_curve_call])

    # Update remove_outlier call
    def update_remove_outlier_curve_call():
        roc_text = f&#34;&#34;&#34;(hvsr_data=hvsr_data, rmse_thresh={rmse_thresh.value}, use_percentile={rmse_pctile_check.value},
                            use_hv_curve={use_hv_curve_rmse.value}...verbose={verbose_check.value})&#34;&#34;&#34;
        remove_outlier_curve_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + roc_text + &#39;&lt;/p&gt;&#39;
    update_remove_outlier_curve_call()

    def update_outlier_fig_button(button):
        outlier_fig, hvsr_data = update_outlier_fig(button)

    generate_ppsd_button.on_click(process_data)

    update_outlier_plot_button.on_click(update_outlier_fig_button)

    outlier_settings_tab = widgets.VBox(children=[outlier_params_vbox,
                                                  outlier_graph_widget,
                                                  outlier_thresh_slider_label,
                                                  rmse_thresh_slider,
                                                  rmse_pctile_slider,
                                                  outlier_ppsd_hbox,
                                                  remove_outlier_hbox])

    with outlier_graph_widget:
        display(outlier_fig)

    def update_outlier_fig(input=None, _rmse_thresh=rmse_pctile_slider.value, _use_percentile=True, _use_hv_curve=use_hv_curve_rmse.value, _verbose=verbose_check.value):
        global outlier_fig
        global hvsr_data
        hv_data = hvsr_data

        roc_kwargs = {&#39;rmse_thresh&#39;:rmse_pctile_slider.value,
                        &#39;use_percentile&#39;:True,
                        &#39;use_hv_curve&#39;:use_hv_curve_rmse.value,
                        &#39;show_plot&#39;:False,
                        &#39;verbose&#39;:verbose_check.value
                      }
        if &#39;PPSDStatus&#39; in hvsr_data.ProcessingStatus.keys() and hvsr_data.ProcessingStatus[&#39;PPSDStatus&#39;]:
            log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nremove_outlier_curves():\n&#39;{roc_kwargs}&#34;    
            hvsr_data = sprit_hvsr.remove_outlier_curves(hvsr_data, **roc_kwargs)
        else:
            log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nremove_outlier_curves() attempted, but not completed. hvsr_data.ProcessingStatus[&#39;PPSDStatus&#39;]=False\n&#39;{roc_kwargs}&#34;
            return outlier_fig, hvsr_data

        if roc_kwargs[&#39;use_hv_curve&#39;]:
            no_subplots = 1
            if hasattr(hvsr_data, &#39;hvsr_df&#39;) and &#39;HV_Curves&#39; in hvsr_data.hvsr_df.columns:
                outlier_fig.data = []
                outlier_fig.update_layout(grid=None)  # Clear the existing grid layout
                subp = subplots.make_subplots(rows=no_subplots, cols=1, horizontal_spacing=0.01, vertical_spacing=0.1)
                outlier_fig.update_layout(grid={&#39;rows&#39;: 1})
                outlier_fig = go.FigureWidget(subp)

                x_data = hvsr_data[&#39;x_freqs&#39;]
                curve_traces = []
                for hv in hvsr_data.hvsr_df[&#39;HV_Curves&#39;].iterrows():
                    curve_traces.append(go.Scatter(x=x_data, y=hv[1]))
                outlier_fig.add_traces(curve_traces)
                
                # Calculate a median curve, and reshape so same size as original
                medCurve = np.nanmedian(np.stack(hvsr_data.hvsr_df[&#39;HV_Curves&#39;]), axis=0)
                outlier_fig.add_trace(go.Scatter(x=x_data, y=medCurve, line=dict(color=&#39;rgba(0,0,0,1)&#39;, width=1.5),showlegend=False))
                
                minY = np.nanmin(np.stack(hvsr_data.hvsr_df[&#39;HV_Curves&#39;]))
                maxY = np.nanmax(np.stack(hvsr_data.hvsr_df[&#39;HV_Curves&#39;]))
                totalWindows = hvsr_data.hvsr_df.shape[0]
                #medCurveArr = np.tile(medCurve, (curr_data.shape[0], 1))

        else:
            no_subplots = 3
            outlier_fig.data = []
            outlier_fig.update_layout(grid=None)  # Clear the existing grid layout
            subp = subplots.make_subplots(rows=no_subplots, cols=1, horizontal_spacing=0.01, vertical_spacing=0.02,
                                                    row_heights=[1, 1, 1])
            outlier_fig.update_layout(grid={&#39;rows&#39;: 3})
            outlier_fig = go.FigureWidget(subp)

            if hasattr(hvsr_data, &#39;hvsr_df&#39;):
                rowDict = {&#39;Z&#39;:1, &#39;E&#39;:2, &#39;N&#39;:3}
                showTLabelsDict={&#39;Z&#39;:False, &#39;E&#39;:False, &#39;N&#39;:True}
                def comp_rgba(comp, a):
                    compstr = &#39;&#39;
                    if comp==&#39;Z&#39;:
                        compstr = f&#39;rgba(0, 0, 0, {a})&#39;
                    if comp==&#39;E&#39;:
                        compstr = f&#39;rgba(50, 50, 250, {a})&#39;
                    if comp==&#39;N&#39;:
                        compstr = f&#39;rgba(250, 50, 50, {a})&#39;
                    return compstr                         
                compNames = [&#39;Z&#39;, &#39;E&#39;, &#39;N&#39;]
                rmse_to_plot=[]
                med_traces=[]

                noRemoved = 0
                indRemoved = []
                for i, comp in enumerate(compNames):
                    if hasattr(hvsr_data, &#39;x_freqs&#39;):
                        x_data = hvsr_data[&#39;x_freqs&#39;][comp]
                    else:
                        x_data = [1/p for p in hvsr_data[&#39;ppsds&#39;][comp][&#39;period_xedges&#39;][1:]]                    
                    column = &#39;psd_values_&#39;+comp
                    # Retrieve data from dataframe (use all windows, just in case)
                    curr_data = np.stack(hvsr_data[&#39;hvsr_df&#39;][column])
                    
                    # Calculate a median curve, and reshape so same size as original
                    medCurve = np.nanmedian(curr_data, axis=0)
                    medCurveArr = np.tile(medCurve, (curr_data.shape[0], 1))
                    medTrace = go.Scatter(x=x_data, y=medCurve, line=dict(color=comp_rgba(comp, 1), width=1.5), 
                                                 name=f&#39;{comp} Component&#39;, showlegend=True)
                    # Calculate RMSE
                    rmse = np.sqrt(((np.subtract(curr_data, medCurveArr)**2).sum(axis=1))/curr_data.shape[1])

                    rmse_threshold = np.percentile(rmse, roc_kwargs[&#39;rmse_thresh&#39;])
                    
                    # Retrieve index of those RMSE values that lie outside the threshold
                    timeIndex = hvsr_data[&#39;hvsr_df&#39;].index
                    for j, curve in enumerate(curr_data):
                        if rmse[j] &gt; rmse_threshold:
                            badTrace = go.Scatter(x=x_data, y=curve,
                                                line=dict(color=comp_rgba(comp, 1), width=1.5, dash=&#39;dash&#39;),
                                                #marker=dict(color=comp_rgba(comp, 1), size=3),
                                                name=str(hvsr_data.hvsr_df.index[j]), showlegend=False)
                            outlier_fig.add_trace(badTrace, row=rowDict[comp], col=1)
                            if j not in indRemoved:
                                indRemoved.append(j)
                            noRemoved += 1
                        else:
                            goodTrace = go.Scatter(x=x_data, y=curve,
                                                  line=dict(color=comp_rgba(comp, 0.01)), name=str(hvsr_data.hvsr_df.index[j]), showlegend=False)
                            outlier_fig.add_trace(goodTrace, row=rowDict[comp], col=1)

                    timeIndRemoved = pd.DatetimeIndex([timeIndex[ind] for ind in indRemoved])
                    hvsr_data[&#39;hvsr_df&#39;].loc[timeIndRemoved, &#39;Use&#39;] = False

                    outlier_fig.add_trace(medTrace, row=rowDict[comp], col=1)
                    
                    outlier_fig.update_xaxes(showticklabels=False, row=1, col=1)
                    outlier_fig.update_yaxes(title={&#39;text&#39;:&#39;Z&#39;}, row=1, col=1)
                    outlier_fig.update_xaxes(showticklabels=False, row=2, col=1)
                    outlier_fig.update_yaxes(title={&#39;text&#39;:&#39;E&#39;}, row=2, col=1)
                    outlier_fig.update_xaxes(showticklabels=True, row=3, col=1)
                    outlier_fig.update_yaxes(title={&#39;text&#39;:&#39;N&#39;}, row=3, col=1)

                    outlier_fig.update_layout(margin={&#34;l&#34;:10, &#34;r&#34;:10, &#34;t&#34;:30, &#39;b&#39;:0}, showlegend=True,
                                  title=f&#34;{hvsr_data[&#39;site&#39;]} Outliers&#34;)
                    if comp == &#39;N&#39;:
                        minY = np.nanmin(curr_data)
                        maxY = np.nanmax(curr_data)
                    totalWindows = curr_data.shape[0]
                
                outlier_fig.add_annotation(
                    text=f&#34;{len(indRemoved)}/{totalWindows} outlier windows removed&#34;,
                    x=np.log10(max(x_data)) - (np.log10(max(x_data))-np.log10(min(x_data))) * 0.01,
                    y=minY+(maxY-minY)*0.01,
                    xanchor=&#34;right&#34;, yanchor=&#34;bottom&#34;,#bgcolor=&#39;rgba(256,256,256,0.7)&#39;,
                    showarrow=False,row=no_subplots, col=1)


        outlier_fig.update_xaxes(type=&#39;log&#39;)
        with outlier_graph_widget:
            clear_output(wait=True)
            display(outlier_fig)
        
        if show_plot_check.value:
            outlier_fig.show()

        return outlier_fig, hvsr_data

    # HVSR SETTINGS SUBTAB
    h_combine_meth = widgets.Dropdown(description=&#39;Horizontal Combination Method&#39;, value=3,
                                    options=[(&#39;1. Differential Field Assumption (not implemented)&#39;, 1), 
                                             (&#39;2. Arithmetic Mean |  H = (N + E)/2&#39;, 2), 
                                             (&#39;3. Geometric Mean | H = (N * E) (SESAME recommended)&#39;, 3),
                                             (&#39;4. Vector Summation | H = (N^2 + E^2)&#39;, 4),
                                             (&#39;5. Quadratic Mean | H = (N^2 + E^2)/2&#39;, 5),
                                             (&#39;6. Maximum Horizontal Value | H = max(N, E)&#39;, 6)],
                                    style={&#39;description_width&#39;: &#39;initial&#39;},  layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    freq_smoothing = widgets.Dropdown(description=&#39;Frequency Smoothing Operations&#39;, value=&#39;konno ohmachi&#39;,
                                    options=[(&#39;Konno-Ohmachi&#39;, &#39;konno ohmachi&#39;),
                                             (&#39;Constant&#39;,&#39;constant&#39;),
                                             (&#39;Proportional&#39;, &#39;proportional&#39;),
                                             (&#39;None&#39;, None)],
                                    style={&#39;description_width&#39;: &#39;initial&#39;},  layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    freq_smooth_width = widgets.FloatText(description=&#39;Freq. Smoothing Width&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=40, value=40, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    resample_hv_curve_bool = widgets.Checkbox(layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), style={&#39;description_width&#39;: &#39;initial&#39;}, value=True)
    resample_hv_curve = widgets.IntText(description=&#39;Resample H/V Curve&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=500, value=500, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    smooth_hv_curve_bool = widgets.Checkbox(layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), style={&#39;description_width&#39;: &#39;initial&#39;}, value=True)
    smooth_hv_curve = widgets.IntText(description=&#39;Smooth H/V Curve&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=51, value=51, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    hvsr_band_hbox_hvsrSet = widgets.HBox([hvsr_band_min_box, hvsr_band_max_box],layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))

    peak_freq_range_hbox_hvsrSet = widgets.HBox([peak_freq_range_min_box, peak_freq_range_max_box],layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))

    peak_selection_type = widgets.Dropdown(description=&#39;Peak Selection Method&#39;, value=&#39;max&#39;,
                                    options=[(&#39;Highest Peak&#39;, &#39;max&#39;),
                                             (&#39;Best Scored&#39;,&#39;scored&#39;)],
                                    style={&#39;description_width&#39;: &#39;initial&#39;},  layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    process_hvsr_call_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;process_hvsr&#39; + &#39;&lt;/p&gt;&#39;, 
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;, align_content=&#39;flex-start&#39;))
    process_hvsr_call = widgets.HTML(value=&#39;()&#39;)
    process_hvsr_call_hbox = widgets.HBox([process_hvsr_call_prefix, process_hvsr_call])

    # Update process_hvsr call
    def update_process_hvsr_call():
        ph_kwargs = get_process_hvsr_kwargs()
        ph_text = f&#34;&#34;&#34;(hvsr_data=hvsr_data, 
                        method={ph_kwargs[&#39;method&#39;]}, 
                        smooth={ph_kwargs[&#39;smooth&#39;]}, 
                        freq_smooth={ph_kwargs[&#39;freq_smooth&#39;]}, 
                        f_smooth_width={ph_kwargs[&#39;f_smooth_width&#39;]}, 
                        resample={ph_kwargs[&#39;resample&#39;]}, 
                        outlier_curve_rmse_percentile={ph_kwargs[&#39;outlier_curve_rmse_percentile&#39;]}, 
                        verbose={verbose_check.value})&#34;&#34;&#34;
        process_hvsr_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + ph_text + &#39;&lt;/p&gt;&#39;
    update_process_hvsr_call()

    check_peaks_call_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39;+&#39;check_peaks&#39; + &#39;&lt;/p&gt;&#39;,
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    check_peaks_call = widgets.HTML(value=&#39;()&#39;)
    check_peaks_call_hbox = widgets.HBox([check_peaks_call_prefix, check_peaks_call])

    # Update process_hvsr call
    def update_check_peaks_call():
        cp_kwargs = get_check_peaks_kwargs()
        cp_text = f&#34;&#34;&#34;(hvsr_data=hvsr_data, 
                        hvsr_band={cp_kwargs[&#39;hvsr_band&#39;]}, 
                        peak_selection={cp_kwargs[&#39;peak_selection&#39;]}, 
                        peak_freq_range={cp_kwargs[&#39;peak_freq_range&#39;]}, 
                        verbose={verbose_check.value})&#34;&#34;&#34;
        check_peaks_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + cp_text + &#39;&lt;/p&gt;&#39;
    update_check_peaks_call()

    freq_smooth_hbox = widgets.HBox([freq_smoothing, freq_smooth_width])
    resample_hbox = widgets.HBox([resample_hv_curve_bool, resample_hv_curve])
    smooth_hbox = widgets.HBox([smooth_hv_curve_bool, smooth_hv_curve])
    
    # Set up vbox for hvsr_settings subtab
    hvsr_settings_tab = widgets.VBox([h_combine_meth,
                                    freq_smooth_hbox,
                                    resample_hbox,
                                    smooth_hbox,
                                    hvsr_band_hbox_hvsrSet,
                                    peak_freq_range_hbox_hvsrSet,
                                    peak_selection_type,
                                    process_hvsr_call_hbox,
                                    check_peaks_call_hbox])

    # PLOT SETTINGS SUBTAB
    hv_plot_label = widgets.Label(value=&#39;HVSR Plot&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;))
    component_plot_label = widgets.Label(value=&#39;Component Plot&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;))
    spec_plot_label = widgets.Label(value=&#39;Spectrogram Plot&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;))

    use_plot_label = widgets.Label(value=&#39;Use Plot&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    use_plot_hv = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    use_plot_comp = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    use_plot_spec = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    comibne_plot_label = widgets.Label(value=&#39;Combine HV and Comp. Plot&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    combine_hv_comp = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    show_peak_label = widgets.Label(value=&#39;Show Best Peak&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_best_peak_hv = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_best_peak_comp = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_best_peak_spec = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    annotate_peak_label = widgets.Label(value=&#39;Annotate Best Peak&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    ann_best_peak_hv = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    ann_best_peak_comp = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    ann_best_peak_spec = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    show_all_peaks_label = widgets.Label(value=&#39;Show All Peaks&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_all_peaks_hv = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    show_all_curves_label = widgets.Label(value=&#39;Show All Curves&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_all_curves_hv = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_all_curves_comp = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    show_ind_peaks_label = widgets.Label(value=&#39;Show Individual Peaks&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_ind_peaks_hv = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_ind_peaks_spec = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                       style={&#39;description_width&#39;: &#39;initial&#39;})

    show_std_label = widgets.Label(value=&#39;Show Standard Deviation&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_std_hv = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_std_comp = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    show_legend_label = widgets.Label(value=&#39;Show Legend&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_legend_hv = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_legend_comp = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_legend_spec = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    x_type_label = widgets.Label(value=&#39;X Type&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    x_type = widgets.Dropdown(options=[(&#39;Frequency&#39;, &#39;freq&#39;), (&#39;Period&#39;, &#39;period&#39;)],
                              layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), style={&#39;description_width&#39;: &#39;initial&#39;})

    plotly_kwargs_label = widgets.Label(value=&#39;Plotly Kwargs&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    plotly_kwargs = widgets.Text(style={&#39;description_width&#39;: &#39;initial&#39;},
                                layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    mpl_kwargs_label = widgets.Label(value=&#39;Matplotlib Kwargs&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    mpl_kwargs = widgets.Text(style={&#39;description_width&#39;: &#39;initial&#39;},
                                layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    plot_hvsr_call = widgets.Label(value=f&#34;Plot String: &#39;{get_default(sprit_hvsr.get_report, &#39;plot_type&#39;)}&#39;&#34;)
    def update_plot_string():
        plot_hvsr_text = f&#34;&#34;&#34;Plot String: {get_get_report_kwargs()[&#39;plot_type&#39;]}&#34;&#34;&#34;
        plot_hvsr_call.value = plot_hvsr_text
    update_plot_string()

    update_plot_button = widgets.Button(description=&#39;Update Plot&#39;,button_style=&#39;info&#39;,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    def manually_update_results_fig(change):
        plot_string = get_get_report_kwargs()[&#39;plot_type&#39;]
        update_results_fig(hvsr_results, plot_string)
        sprit_tabs.selected_index = 4

    # Set up grid for ppsd_settings subtab
    plot_settings_tab[0, 5:10]   = hv_plot_label
    plot_settings_tab[0, 10:15]  = component_plot_label
    plot_settings_tab[0, 15:] = spec_plot_label

    plot_settings_tab[1, :] = widgets.HTML(&#39;&lt;hr&gt;&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;))

    plot_settings_tab[2, :5] = use_plot_label
    plot_settings_tab[2, 5:10] = use_plot_hv
    plot_settings_tab[2, 10:15] = use_plot_comp
    plot_settings_tab[2, 15:] = use_plot_spec

    plot_settings_tab[3, :] = widgets.HTML(&#39;&lt;hr&gt;&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;))

    plot_settings_tab[4, :5] = comibne_plot_label
    plot_settings_tab[4, 10:15] = combine_hv_comp

    plot_settings_tab[5, :5] = show_peak_label
    plot_settings_tab[5, 5:10] = show_best_peak_hv
    plot_settings_tab[5, 10:15] = show_best_peak_comp
    plot_settings_tab[5, 15:] = show_best_peak_spec

    plot_settings_tab[6, :5] = annotate_peak_label
    plot_settings_tab[6, 5:10] = ann_best_peak_hv
    plot_settings_tab[6, 10:15] = ann_best_peak_comp
    plot_settings_tab[6, 15:] = ann_best_peak_spec

    plot_settings_tab[7, :5] = show_all_peaks_label
    plot_settings_tab[7, 5:10] = show_all_peaks_hv

    plot_settings_tab[8, :5] = show_all_curves_label
    plot_settings_tab[8, 5:10] = show_all_curves_hv
    plot_settings_tab[8, 10:15] = show_all_curves_comp

    plot_settings_tab[9, :5] = show_ind_peaks_label
    plot_settings_tab[9, 5:10] = show_ind_peaks_hv
    plot_settings_tab[9, 15:] = show_ind_peaks_spec
   
    plot_settings_tab[10, :5] = show_std_label
    plot_settings_tab[10, 5:10] = show_std_hv
    plot_settings_tab[10, 10:15] = show_std_comp

    plot_settings_tab[11, :5] = show_legend_label
    plot_settings_tab[11, 5:10] = show_legend_hv
    plot_settings_tab[11, 10:15] = show_legend_comp
    plot_settings_tab[11, 15:] = show_legend_spec

    plot_settings_tab[12, :] = widgets.HTML(&#39;&lt;hr&gt;&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;))

    plot_settings_tab[13, :5] = x_type_label
    plot_settings_tab[13, 6:] = x_type

    plot_settings_tab[14, :5] = plotly_kwargs_label
    plot_settings_tab[14, 6:] = plotly_kwargs

    plot_settings_tab[15, :5] = mpl_kwargs_label
    plot_settings_tab[15, 6:] = mpl_kwargs

    plot_settings_tab[16, :] = widgets.HTML(&#39;&lt;hr&gt;&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;))

    plot_settings_tab[17, :18] = plot_hvsr_call
    plot_settings_tab[17, 18:] = update_plot_button
    update_plot_button.on_click(manually_update_results_fig)

    # Place everything in Settings Tab
    settings_subtabs = widgets.Tab([ppsd_settings_tab, hvsr_settings_tab, outlier_settings_tab, plot_settings_tab])
    settings_tab = widgets.VBox(children=[settings_subtabs, settings_progress_hbox])
    settings_subtabs.set_title(0, &#34;PPSD Settings&#34;)
    settings_subtabs.set_title(1, &#34;HVSR Settings&#34;)
    settings_subtabs.set_title(2, &#34;Outlier Settings&#34;)
    settings_subtabs.set_title(3, &#34;Plot Settings&#34;)

    # LOG TAB - not currently using
    log_tab = widgets.VBox(children=[log_textArea])
    #log_textArea = widgets.Textarea(value=&#34;SESSION LOG&#34;, disabled=True, layout={&#39;height&#39;: &#39;99%&#39;,&#39;width&#39;: &#39;99%&#39;, &#39;overflow&#39;: &#39;scroll&#39;})

    # RESULTS TAB
    # PLOT SUBTAB
    subp = subplots.make_subplots(rows=3, cols=1, horizontal_spacing=0.01, vertical_spacing=0.01, row_heights=[2,1,1])
    results_fig = go.FigureWidget(subp)
    global results_graph_widget
    results_graph_widget = widgets.Output()   

    with results_graph_widget:
        display(results_fig)

    global printed_results_textArea
    printed_results_textArea = widgets.Textarea(value=&#34;RESULTS&#34;, disabled=True, layout={&#39;height&#39;: &#39;500px&#39;,&#39;width&#39;: &#39;99%&#39;, &#39;overflow&#39;: &#39;scroll&#39;})

    global results_table
    initialTableCols=[&#39;SiteName&#39;, &#39;Acq_Date&#39;, &#39;Longitude&#39;, &#39;Latitude&#39;, &#39;Elevation&#39;,
                      &#39;PeakFrequency&#39;, &#39;WindowLengthFreq.&#39;, &#39;SignificantCycles&#39;, &#39;LowCurveStDevOverTime&#39;, 
                      &#39;PeakProminenceBelow&#39;, &#39;PeakProminenceAbove&#39;, &#39;PeakAmpClarity&#39;, 
                      &#39;FreqStability&#39;, &#39;PeakStability_FreqStD&#39;, &#39;PeakStability_AmpStD&#39;, &#39;PeakPasses&#39;]
    results_table = widgets.HTML(value=pd.DataFrame(columns=initialTableCols).to_html())

    # A text box labeled Data Filepath
    export_results_table_filepath = widgets.Text(description=&#39;Export Filepath:&#39;,
                                    placeholder=&#39;&#39;, value=&#39;&#39;,
                                    style={&#39;description_width&#39;: &#39;initial&#39;},layout=widgets.Layout(width=&#39;90%&#39;))

    export_results_table_read_button = widgets.Button(description=&#39;&#39;, icon=&#39;fa-file-import&#39;,button_style=&#39;success&#39;,
                                            layout=widgets.Layout(width=&#39;10%&#39;))
    export_results_table_browse_button = widgets.Button(description=&#39;Export Table&#39;,
                                            layout=widgets.Layout(width=&#39;10%&#39;))
    def export_results_table(button):
        try:
            if button.value == &#39;Export Table&#39;:
                root = tk.Tk()
                root.wm_attributes(&#39;-topmost&#39;, True)
                root.withdraw()
                export_results_table_filepath.value = str(filedialog.asksaveasfilename(defaultextension=&#39;.csv&#39;, title=&#39;Save CSV Report&#39;))
                root.destroy()
        except Exception as e:
            print(e)
            export_results_table_browse_button.disabled=True
            export_results_table_browse_button.description=&#39;Use Text Field&#39;

        out_path = export_results_table_filepath.value
        sprit_hvsr.get_report(hvsr_results, report_format=&#39;csv&#39;, export_path=out_path,
                              csv_overwrite_opt=&#39;overwrite&#39;)

    export_results_table_browse_button.on_click(export_results_table)
    export_results_table_read_button.on_click(export_results_table)

    results_table_export_hbox = widgets.HBox([export_results_table_filepath, export_results_table_read_button, export_results_table_browse_button])
    results_table_vbox = widgets.VBox([results_table, results_table_export_hbox])
    global results_tab
    results_subtabs = widgets.Tab([results_graph_widget, printed_results_textArea, results_table_vbox])
    results_tab = widgets.VBox(children=[results_subtabs])
    results_subtabs.set_title(0, &#34;Plot&#34;)
    results_subtabs.set_title(1, &#34;Peak Tests&#34;)
    results_subtabs.set_title(2, &#34;Peak Table&#34;)

    widget_param_dict = {
        &#39;fetch_data&#39;: 
            {&#39;source&#39;: data_source_type,
            &#39;trim_dir&#39;: trim_directory,
            &#39;export_format&#39;: trim_export_dropdown,
            &#39;detrend&#39;: detrend_type_dropdown,
            &#39;detrend_order&#39;: detrend_order,
            &#39;verbose&#39;: verbose_check},
        &#39;remove_noise&#39;: 
            {
            &#39;sat_percent&#39;: max_saturation_pct,
            &#39;noise_percent&#39;: max_window_pct,
            &#39;sta&#39;: sta,
            &#39;lta&#39;: lta,
            &#39;stalta_thresh&#39;: [stalta_thresh_low, stalta_thresh_hi],
            &#39;warmup_time&#39;: warmup_time,
            &#39;cooldown_time&#39;: cooldown_time,
            &#39;min_win_size&#39;: noisy_window_length,
            &#39;remove_raw_noise&#39;: raw_data_remove_check,
            &#39;verbose&#39;: verbose_check},
        &#39;generate_ppsds&#39;: 
            {&#39;verbose&#39;: verbose_check,
             &#39;skip_on_gaps&#39;:skip_on_gaps, 
             &#39;db_bins&#39;:[db_bins_min, db_bins_max, db_bins_step],
             &#39;ppsd_length&#39;:ppsd_length, 
             &#39;overlap&#39;:overlap_pct, 
             &#39;special_handling&#39;:special_handling_dropdown, 
             &#39;period_smoothing_width_octaves&#39;:period_smoothing_width, 
             &#39;period_step_octaves&#39;:period_step_octave, 
             &#39;period_limits&#39;:[hvsr_band_min_box, hvsr_band_max_box]},
        &#39;process_hvsr&#39;: 
            {&#39;method&#39;: h_combine_meth,
            &#39;smooth&#39;: smooth_hv_curve,
            &#39;freq_smooth&#39;: freq_smoothing,
            &#39;f_smooth_width&#39;: freq_smooth_width,
            &#39;resample&#39;: resample_hv_curve,
            &#39;verbose&#39;: verbose_check},
        &#39;remove_outlier_curves&#39;: 
            {&#39;rmse_thresh&#39;: rmse_thresh,
            &#39;use_percentile&#39;: rmse_pctile_check,
            &#39;use_hv_curve&#39;: use_hv_curve_rmse,
            &#39;verbose&#39;: verbose_check},
        &#39;check_peaks&#39;: 
            {&#39;hvsr_band&#39;: [hvsr_band_min_box, hvsr_band_max_box],
            &#39;peak_freq_range&#39;: [peak_freq_range_min_box, peak_freq_range_max_box],
            &#39;verbose&#39;: verbose_check},
        &#39;get_report&#39;: 
            {
            &#39;export_path&#39;: export_results_table_filepath,
            &#39;verbose&#39;: verbose_check}}

    # SPRIT WIDGET
    # Add all  a tab and add the grid to it
    global sprit_tabs
    sprit_tabs = widgets.Tab([input_tab, preview_tab, settings_tab, log_tab, results_tab])
    sprit_tabs.set_title(0, &#34;Input&#34;)
    sprit_tabs.set_title(1, &#34;Preview&#34;)
    sprit_tabs.set_title(2, &#34;Settings&#34;)
    sprit_tabs.set_title(3, &#34;Log&#34;)
    sprit_tabs.set_title(4, &#34;Results&#34;)

    sprit_title = widgets.Label(value=&#39;SPRIT&#39;, layout=widgets.Layout(width=&#39;150px&#39;))
    sprit_subtitle = widgets.Label(value=&#39;Tools for ambient siesmic noise analysis using HVSR&#39;,
                                   layout=widgets.Layout(flex=&#39;1&#39;, justify_content=&#39;flex-start&#39;, align_content=&#39;flex-end&#39;))

    # Function to open a link
    def open_dist(button):
        link = &#39;https://pypi.org/project/sprit/&#39;
        webbrowser.open_new_tab(link)

    def open_repo(button):
        link = &#39;https://github.com/RJbalikian/SPRIT-HVSR&#39;
        webbrowser.open_new_tab(link)

    def open_docs(button):
        link = &#39;https://rjbalikian.github.io/SPRIT-HVSR/main.html&#39;
        webbrowser.open_new_tab(link)


    sourcebutton = widgets.Button(description=&#34;PyPI&#34;,
                                layout=widgets.Layout(width=&#39;4%&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-end&#39;))
    repobutton = widgets.Button(description=&#34;Repo&#34;,
                                layout=widgets.Layout(width=&#39;4%&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-end&#39;))
    docsbutton = widgets.Button(description=&#34;Docs&#34;,
                                layout=widgets.Layout(width=&#39;8%&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-end&#39;))

    # Attach the open_link function to the button&#39;s on_click event
    sourcebutton.on_click(open_dist)
    repobutton.on_click(open_repo)
    docsbutton.on_click(open_docs)

    titlehbox = widgets.HBox([sprit_title, sprit_subtitle, repobutton, sourcebutton, docsbutton],
                            layout = widgets.Layout(align_content=&#39;space-between&#39;))
    
    title_style = {
        &#39;font_family&#39;: &#39;Arial, sans-serif&#39;,
        &#39;font_size&#39;: &#39;36px&#39;,
        &#39;font_weight&#39;: &#39;bold&#39;,
        &#39;color&#39;: &#39;black&#39;
    }

    # Apply the style to the label
    sprit_title.style = title_style

    sprit_widget = widgets.VBox([titlehbox, sprit_tabs])

    def observe_children(widget, callback):
        if hasattr(widget, &#39;children&#39;):
            for child in widget.children:
                child.observe(callback)
                observe_children(child, callback)

    def any_update(change):
        update_input_param_call()
        update_fetch_data_call()
        update_remove_noise_call()
        update_generate_ppsd_call()
        update_process_hvsr_call()
        update_remove_outlier_curve_call()
        update_check_peaks_call()
        update_plot_string()

    observe_children(sprit_tabs, any_update)

    # Display the tab
    display(sprit_widget)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sprit.sprit_jupyter_UI.create_jupyter_ui"><code class="name flex">
<span>def <span class="ident">create_jupyter_ui</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_jupyter_ui():
    global hvsr_data

    ui_width = 20
    ui_height= 12
    global results_fig
    global log_textArea
    log_textArea = widgets.Textarea(value=&#34;SESSION LOG&#34;, disabled=True, layout={&#39;height&#39;: &#39;300px&#39;,&#39;width&#39;: &#39;99%&#39;, &#39;overflow&#39;: &#39;scroll&#39;})

    # INPUT TAB
    # Create a VBox for the accordions
    input_HBox = widgets.HBox()
    input_accordion_label_box = widgets.VBox()
    input_accordion_box = widgets.VBox()
    input_accordion = widgets.Accordion()

    # Metadata accordion
    metadata_grid = widgets.GridspecLayout(7, 10)
    network_textbox = widgets.Text(description=&#39;Network:&#39;,
                                    placeholder=get_default(sprit_hvsr.input_params, &#39;network&#39;),
                                    value=get_default(sprit_hvsr.input_params, &#39;network&#39;),
                                    tooltip=&#34;input_params(network)&#34;)

    station_textbox = widgets.Text(description=&#39;Station:&#39;,
                                    placeholder=get_default(sprit_hvsr.input_params, &#39;station&#39;),
                                    value=get_default(sprit_hvsr.input_params, &#39;station&#39;))

    location_textbox = widgets.Text(description=&#39;Location:&#39;,
                                    placeholder=get_default(sprit_hvsr.input_params, &#39;loc&#39;),
                                    value=get_default(sprit_hvsr.input_params, &#39;loc&#39;))

    z_channel_textbox = widgets.Text(description=&#39;Z Channel:&#39;,
                                    placeholder=get_default(sprit_hvsr.input_params, &#39;channels&#39;)[0],
                                    value=get_default(sprit_hvsr.input_params, &#39;channels&#39;)[0])

    e_channel_textbox = widgets.Text(description=&#39;E Channel:&#39;,
                                    placeholder=get_default(sprit_hvsr.input_params, &#39;channels&#39;)[2],
                                    value=get_default(sprit_hvsr.input_params, &#39;channels&#39;)[2])

    n_channel_textbox = widgets.Text(description=&#39;N Channel:&#39;,
                                    placeholder=get_default(sprit_hvsr.input_params, &#39;channels&#39;)[1],
                                    value=get_default(sprit_hvsr.input_params, &#39;channels&#39;)[1])


    # Instrument Settings
    inst_settings_text = widgets.Text(placeholder=&#39;Instrument Settings Filepath&#39;, layout=widgets.Layout(width=&#39;55%&#39;))
    instrument_read_button = widgets.Button(icon=&#39;fa-file-import&#39;,button_style=&#39;success&#39;,
                                            layout=widgets.Layout(width=&#39;4%&#39;))
    instrument_settings_button = widgets.Button(description=&#39;Select .inst file&#39;,
                                            layout=widgets.Layout(width=&#39;10%&#39;))
    inst_settings_hbox = widgets.HBox([inst_settings_text,instrument_read_button, instrument_settings_button])
    
    def select_inst(event):
        try:
            if event.description == &#39;Select .inst file&#39;:
                root = tk.Tk()
                root.wm_attributes(&#39;-topmost&#39;, True)
                root.withdraw()
                inst_files = filedialog.askopenfilenames(defaultextension=&#39;.inst&#39;, filetypes=[(&#39;Inst&#39;, &#39;.inst&#39;)],
                                                                    title=&#34;Select Instrument Settings File&#34;)
                if isinstance(inst_files, tuple):
                    pass
                else:
                    inst_files = tuple(inst_files)
                root.destroy()
            else:
                inst_files = tuple([inst_settings_text.value])

            for i, inst_f in enumerate(inst_files):
                inst_settings_text.value = pathlib.Path(inst_f).as_posix()
                inst_settings = sprit_hvsr.import_settings(settings_import_path=pathlib.Path(inst_f).as_posix(), settings_import_type=&#39;instrument&#39;)
                
                # Go through all items and add them
                if &#39;instrument&#39; in inst_settings.keys():
                    if inst_settings[&#39;instrument&#39;] not in instrument_dropdown.options:
                        instrument_dropdown.options.append(inst_settings[&#39;instrument&#39;])
                    instrument_dropdown.value = inst_settings[&#39;instrument&#39;]
                
                if &#39;net&#39; in inst_settings.keys():
                    network_textbox.value = inst_settings[&#39;net&#39;]

                if &#39;sta&#39; in inst_settings.keys():
                    station_textbox.value = inst_settings[&#39;sta&#39;]

                if &#39;loc&#39; in inst_settings.keys():
                    location_textbox.value = inst_settings[&#39;loc&#39;]

                if &#39;cha&#39; in inst_settings.keys():
                    for c in inst_settings[&#39;cha&#39;]:
                        if c.lower()[2]==&#39;z&#39;:
                            z_channel_textbox.value = c
                        if c.lower()[2]==&#39;e&#39;:
                            e_channel_textbox.value = c
                        if c.lower()[2] ==&#39;n&#39;:
                            n_channel_textbox.value = c
                
                if &#39;metapath&#39; in inst_settings.keys():
                    metadata_filepath.value = inst_settings[&#39;metapath&#39;]

                if &#39;hvsr_band&#39; in inst_settings.keys():
                    hvsr_band_min_box.value = inst_settings[&#39;hvsr_band&#39;][0]
                    hvsr_band_max_box.value = inst_settings[&#39;hvsr_band&#39;][1]

        except Exception as e:
            print(e)
            instrument_settings_button.disabled=True
            instrument_settings_button.description=&#39;Use Text Field&#39;
    
    instrument_settings_button.on_click(select_inst)
    instrument_read_button.on_click(select_inst)

    metadata_grid[0,:] = inst_settings_hbox
    metadata_grid[1,0] = network_textbox
    metadata_grid[2,0] = station_textbox
    metadata_grid[3,0] = location_textbox
    metadata_grid[4,0] = z_channel_textbox
    metadata_grid[5,0] = e_channel_textbox
    metadata_grid[6,0] = n_channel_textbox

    # Acquisition Accordion
    instrument_grid = widgets.GridspecLayout(5, 10)
    # Date Picker labelled &#34;Acquisition Date&#34;
    acquisition_date_picker = widgets.DatePicker(description=&#39;Acq.Date:&#39;,
                                            placeholder=datetime.datetime.today().date(),
                                            value=datetime.datetime.today().date())

    # Label that shows the Date currently selected in the Date Picker
    acquisition_doy = widgets.IntText(description=&#39;DOY&#39;,
                                                placeholder=f&#34;{acquisition_date_picker.value.timetuple().tm_yday}&#34;,
                                                value=f&#34;{acquisition_date_picker.value.timetuple().tm_yday}&#34;,
                                                layout=widgets.Layout(width=&#39;auto&#39;))

    def on_acq_date_change(change):
        acquisition_doy.value = acquisition_date_picker.value.timetuple().tm_yday
    acquisition_date_picker.observe(on_acq_date_change)

    def on_doy_change(change):
        curr_year = datetime.datetime.today().year
        if acquisition_doy.value &gt; datetime.datetime.today().timetuple().tm_yday:
            curr_year -= 1
        acquisition_date_picker.value = (datetime.datetime(curr_year, 1, 1) + datetime.timedelta(days = acquisition_doy.value-1)).date()
    acquisition_doy.observe(on_doy_change)

    # Time selector (hour and minute) labelled &#34;Start Time&#34;.
    try:
        start_time_picker = widgets.TimePicker(description=&#39;Start Time:&#39;,
                                            placeholder=datetime.time(0,0,0),
                                            value=datetime.time(0,0,0),
                                            layout=widgets.Layout(width=&#39;auto&#39;))
    except Exception as e:
        start_time_picker = widgets.Text(description=&#39;Start Time:&#39;,
                                        placeholder=&#39;00:00&#39;,
                                        value=&#39;00:00&#39;,
                                        layout=widgets.Layout(width=&#39;auto&#39;))

    # Time selector (hour and minute) labelled &#34;End Time&#34;. Same as Start Time otherwise.
    try:
        end_time_picker = widgets.TimePicker(description=&#39;End Time:&#39;,
                                        placeholder=datetime.time(23,59),
                                        value=datetime.time(23,59),
                                        layout=widgets.Layout(width=&#39;auto&#39;))
    except Exception as e:
        end_time_picker = widgets.Text(description=&#39;End Time:&#39;,
                                        placeholder=&#39;23:59:59.999999&#39;,
                                        value=&#39;23:59:59.999999&#39;,
                                        layout=widgets.Layout(width=&#39;auto&#39;))

    tzlist = list(available_timezones())
    tzlist.sort()
    tzlist.remove(&#39;UTC&#39;)
    tzlist.remove(&#39;US/Central&#39;)
    tzlist.insert(0, &#39;US/Central&#39;)
    tzlist.insert(0, &#39;UTC&#39;)
    # A dropdown list with all the items from zoneinfo.available_timezones(), default &#39;UTC&#39;
    time_zone_dropdown = widgets.Dropdown(options=tzlist,value=get_default(sprit_hvsr.input_params, &#39;tzone&#39;),
                                            description=&#39;Time Zone:&#39;,layout=widgets.Layout(width=&#39;fill&#39;))

    instrument_grid[0,0] = acquisition_date_picker
    instrument_grid[0,1] = acquisition_doy
    instrument_grid[1,0] = start_time_picker
    instrument_grid[2,0] = end_time_picker
    instrument_grid[3,0] = time_zone_dropdown

    # LOCATION ACCORDION
    location_grid = widgets.GridspecLayout(4, 10)
    # X coordinate input
    xcoord_textbox = widgets.FloatText(description=&#39;X Coordinate:&#39;, tooltip=&#39;xcoord&#39;,
                                        value=get_default(sprit_hvsr.input_params, &#39;xcoord&#39;), 
                                        placeholder=get_default(sprit_hvsr.input_params, &#39;xcoord&#39;),
                                        layout=widgets.Layout(width=&#39;auto&#39;))
    location_grid[0, 0] = xcoord_textbox

    # Y coordinate input
    ycoord_textbox = widgets.FloatText(description=&#39;Y Coordinate&#39;, tooltip=&#39;ycoord:&#39;,
                                        value=get_default(sprit_hvsr.input_params, &#39;ycoord&#39;), 
                                        placeholder=get_default(sprit_hvsr.input_params, &#39;ycoord&#39;),
                                        layout=widgets.Layout(width=&#39;auto&#39;))
    location_grid[1, 0] = ycoord_textbox

    # Z coordinate input
    zcoord_textbox = widgets.FloatText(description=&#39;Z Coordinate&#39;, tooltip=&#39;elevation:&#39;,
                                        value=get_default(sprit_hvsr.input_params, &#39;elevation&#39;),
                                        placeholder=get_default(sprit_hvsr.input_params, &#39;elevation&#39;),                                     
                                        layout=widgets.Layout(width=&#39;auto&#39;))
    location_grid[2, 0] = zcoord_textbox

    # Z coordinate unit input
    elevation_unit_textbox = widgets.Dropdown(options=[(&#39;Feet&#39;, &#39;feet&#39;), (&#39;Meters&#39;, &#39;meters&#39;)],
                                                value=get_default(sprit_hvsr.input_params, &#39;elev_unit&#39;),
                                                description=&#39;Z Unit:&#39;, tooltip=&#39;elev_unit&#39;,
                                                layout=widgets.Layout(width=&#39;auto&#39;))
    location_grid[2, 1] = elevation_unit_textbox

    # Input CRS input
    input_crs_textbox = widgets.Text(description=&#39;Input CRS:&#39;,
                                        layout=widgets.Layout(width=&#39;auto&#39;),
                                        placholder=get_default(sprit_hvsr.input_params, &#39;input_crs&#39;),
                                        value=get_default(sprit_hvsr.input_params, &#39;input_crs&#39;))
    location_grid[3, 0] = input_crs_textbox

    # Output CRS input
    output_crs_textbox = widgets.Text(description=&#39;Output CRS:&#39;,
                                        layout=widgets.Layout(width=&#39;auto&#39;),
                                        placholder=get_default(sprit_hvsr.input_params, &#39;output_crs&#39;),
                                        value=get_default(sprit_hvsr.input_params, &#39;output_crs&#39;))
    location_grid[3, 1] = output_crs_textbox

    # IO PARAMS ACCORDION
    ioparam_grid = widgets.GridspecLayout(6, 10)

    # Data format (for obspy format to use to read in)
    data_format_dropdown = widgets.Dropdown(
            options=OBSPY_FORMATS,
            value=&#39;MSEED&#39;,
            description=&#39;Data Formats:&#39;, layout=widgets.Layout(width=&#39;auto&#39;))

    hvsr_band_min_box = widgets.FloatText(description=&#39;HVSR Band [Hz]&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                          placeholder=get_default(sprit_hvsr.input_params, &#39;hvsr_band&#39;)[0],
                                          value=get_default(sprit_hvsr.input_params, &#39;hvsr_band&#39;)[0])
    hvsr_band_max_box = widgets.FloatText(placeholder=get_default(sprit_hvsr.input_params, &#39;hvsr_band&#39;)[1],
                                          value=get_default(sprit_hvsr.input_params, &#39;hvsr_band&#39;)[1])
    hvsr_band_hbox = widgets.HBox([hvsr_band_min_box, hvsr_band_max_box],layout=widgets.Layout(width=&#39;auto&#39;))


    peak_freq_range_min_box = widgets.FloatText(description=&#39;Peak Range [Hz]&#39;,placeholder=get_default(sprit_hvsr.input_params, &#39;peak_freq_range&#39;)[0], 
                                                value=get_default(sprit_hvsr.input_params, &#39;peak_freq_range&#39;)[0],
                                                style={&#39;description_width&#39;: &#39;initial&#39;}, layout=widgets.Layout(width=&#39;auto&#39;))
    peak_freq_range_max_box = widgets.FloatText(placeholder=get_default(sprit_hvsr.input_params, &#39;peak_freq_range&#39;)[1], 
                                                value=get_default(sprit_hvsr.input_params, &#39;peak_freq_range&#39;)[1],layout=widgets.Layout(width=&#39;auto&#39;))
    peak_freq_range_hbox = widgets.HBox([peak_freq_range_min_box, peak_freq_range_max_box],layout=widgets.Layout(width=&#39;auto&#39;))


    # A dropdown labeled &#34;Detrend type&#34; with &#34;Spline&#34;, &#34;Polynomial&#34;, or &#34;None&#34;
    detrend_type_dropdown = widgets.Dropdown(options=[(&#39;Spline&#39;, &#39;spline&#39;), (&#39;Polynomial&#39;, &#39;polynomial&#39;), (&#39;None&#39;, &#39;none&#39;)],
                            description=&#39;Detrend Type:&#39;,  layout=widgets.Layout(width=&#39;auto&#39;))
    detrend_order = widgets.FloatText(description=&#39;Order:&#39;, tooltip=&#39;detrend_order&#39;, placeholder=get_default(sprit_hvsr.fetch_data, &#39;detrend_order&#39;), 
                                      value=get_default(sprit_hvsr.fetch_data, &#39;detrend_order&#39;),layout=widgets.Layout(width=&#39;auto&#39;))

    # A text to specify the trim directory
    trim_directory = widgets.Text(description=&#39;Trim Dir.:&#39;, value=&#34;None&#34;,#pathlib.Path().home().as_posix(),
                                    layout=widgets.Layout(width=&#39;auto&#39;))
    trim_export_dropdown = widgets.Dropdown(
                options=OBSPY_FORMATS,
                value=&#39;MSEED&#39;,
                description=&#39;Trim Format:&#39;, layout=widgets.Layout(width=&#39;auto&#39;))
    trim_directory_upload = widgets.FileUpload(
                            accept=&#39;&#39;, 
                            multiple=False, layout=widgets.Layout(width=&#39;auto&#39;))

    # Processing Settings
    proc_settings_text = widgets.Text(placeholder=&#39;Instrument Settings Filepath&#39;, layout=widgets.Layout(width=&#39;55%&#39;))
    proc_settings_read_button = widgets.Button(icon=&#39;fa-file-import&#39;,button_style=&#39;success&#39;,
                                            layout=widgets.Layout(width=&#39;4%&#39;))
    proc_settings_browse_button = widgets.Button(description=&#39;Select .proc file&#39;,
                                            layout=widgets.Layout(width=&#39;10%&#39;))
    proc_settings_hbox = widgets.HBox([proc_settings_text, proc_settings_read_button, proc_settings_browse_button])
    
    excluded_params = [&#39;hvsr_data&#39;, &#39;params&#39;, &#39;hvsr_results&#39;]
    funcList = [sprit_hvsr.fetch_data, sprit_hvsr.remove_noise,
                sprit_hvsr.generate_ppsds, sprit_hvsr.process_hvsr,
                sprit_hvsr.remove_outlier_curves, sprit_hvsr.check_peaks,
                sprit_hvsr.get_report]

    def select_proc(event):
        try:
            if event.description == &#39;Select .proc file&#39;:
                root = tk.Tk()
                root.wm_attributes(&#39;-topmost&#39;, True)
                root.withdraw()
                proc_files = filedialog.askopenfilenames(defaultextension=&#39;.proc&#39;, filetypes=[(&#39;PROC&#39;, &#39;.proc&#39;)],
                                                                    title=&#34;Select Processing Settings File&#34;)
                if isinstance(proc_files, tuple):
                    pass
                else:
                    proc_files = tuple(proc_files)
                root.destroy()
            else:
                proc_files = tuple([proc_settings_text.value])

            for i, proc_f in enumerate(proc_files):
                proc_settings_text.value = pathlib.Path(proc_f).as_posix()
                proc_settings = sprit_hvsr.import_settings(settings_import_path=pathlib.Path(proc_f).as_posix(), settings_import_type=&#39;processing&#39;)
                
                for func, params in proc_settings.items():
                    if func in widget_param_dict.keys():
                        for prm, val in params.items():
                            if prm in widget_param_dict[func].keys():
                                print(prm, &#39;:&#39;, widget_param_dict[func][prm],&#39; |  &#39;, val)
                                if val is None or val==&#39;None&#39;:
                                    val=&#39;none&#39;
                                if prm == &#39;export_format&#39;:
                                    val = val.upper()
                                if prm == &#39;smooth&#39;:
                                    if val is True:
                                        val = 51
                                if prm == &#39;resample&#39;:
                                    if val is True:
                                        val = 1000
                                if isinstance(widget_param_dict[func][prm], list):
                                    for i, item in enumerate(widget_param_dict[func][prm]):
                                        item.value = val[i]
                                else:
                                    widget_param_dict[func][prm].value = val
        except Exception as e:
            print(e)
            proc_settings_browse_button.disabled=True
            proc_settings_browse_button.description=&#39;Use Text Field&#39;
    
    proc_settings_read_button.on_click(select_proc)
    proc_settings_browse_button.on_click(select_proc)

    ioparam_grid[0,:] = proc_settings_hbox
    ioparam_grid[1,0] = data_format_dropdown
    ioparam_grid[2,:5] = hvsr_band_hbox
    ioparam_grid[3,:5] = peak_freq_range_hbox
    ioparam_grid[4,:1] = detrend_type_dropdown
    ioparam_grid[4,1] = detrend_order
    ioparam_grid[5,:6] = trim_directory
    ioparam_grid[5, 6:8] = trim_export_dropdown
    ioparam_grid[5, 8] = trim_directory_upload

    # PYTHON API ACCORDION
    inputAPI_grid = widgets.GridspecLayout(2, 10)
    # A text label with &#34;input_params()&#34;
    input_params_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;input_params&#39; + &#39;&lt;/p&gt;&#39;, 
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    input_params_call = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;()&#39; + &#39;&lt;/p&gt;&#39;,
                                     layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-start&#39;,align_content=&#39;flex-start&#39;),)
    #input_params_call =  widgets.Label(value=&#39;input_params()&#39;, layout=widgets.Layout(width=&#39;auto&#39;))
    inputAPI_grid[0, 0] = input_params_prefix
    inputAPI_grid[0, 1:] = input_params_call

    # A text label with &#34;fetch_data()&#34;
    fetch_data_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;fetch_data&#39; + &#39;&lt;/p&gt;&#39;, 
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    fetch_data_call = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;()&#39; + &#39;&lt;/p&gt;&#39;,
                                     layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-start&#39;,align_content=&#39;flex-start&#39;),)
    inputAPI_grid[1, 0] = fetch_data_prefix
    inputAPI_grid[1, 1:] = fetch_data_call

    # Set it all in place
    metaLabel = widgets.Label(&#39;Instrument&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    instLabel = widgets.Label(&#39;Acquisition&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    locLabel = widgets.Label(&#39;Location&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    ioparmLabel = widgets.Label(&#39;IO/Params&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    apiLabel = widgets.Label(&#39;API Call&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    input_accordion_label_box.children = [metaLabel, instLabel, locLabel, ioparmLabel, apiLabel]
    input_accordion_label_box.layout = widgets.Layout(align_content=&#39;space-between&#39;, width=&#39;5%&#39;)

    input_accordion.children = [metadata_grid, instrument_grid, location_grid, ioparam_grid, inputAPI_grid]
    input_accordion.titles = [&#34;Instrument Metadata&#34;, &#34;Acquisition Information&#34;, &#34;Location Information&#34;, &#34;I/O and Parameters&#34;, &#34;See Python API Call&#34;]
    input_accordion_box.layout = widgets.Layout(align_content=&#39;space-between&#39;, width=&#39;99%&#39;)
    
    input_accordion.layout = widgets.Layout(width=&#39;99%&#39;)

    # ADD THE REST OF THE WIDGETS AROUND THE ACCORDIONS
    # A text box for the site name
    site_name = widgets.Text(description=&#39;Site Name:&#39;,
                            value=&#39;HVSR_Site&#39;,
                            placeholder=&#39;HVSR_Site&#39;,
                            style={&#39;description_width&#39;: &#39;initial&#39;}, layout=widgets.Layout(width=&#39;30%&#39;))

    tenpct_spacer = widgets.Button(description=&#39;&#39;, layout=widgets.Layout(width=&#39;20%&#39;, visibility=&#39;hidden&#39;))

    # Dropdown with different source types 
    data_source_type = widgets.Dropdown(options=[(&#39;File&#39;, &#39;file&#39;), (&#39;Raw&#39;, &#39;raw&#39;), (&#39;Batch&#39;, &#39;batch&#39;), (&#39;Directory&#39;, &#39;dir&#39;)],
                                            description=&#39;Data Source type:&#39;,
                                            value=&#39;file&#39;,orientation=&#39;horizontal&#39;, 
                                            style={&#39;description_width&#39;: &#39;initial&#39;},
                                            layout=widgets.Layout(width=&#39;20%&#39;))
    def on_ds_change(event):
        if data_source_type.value == &#39;file&#39; or data_source_type.value== &#39;batch&#39;:
            browse_data_button.description = &#39;Select Files&#39;
        else:
            browse_data_button.description = &#39;Select Folders&#39;
    data_source_type.observe(on_ds_change)
    # Dropdown labeled &#34;Instrument&#34; with options &#34;Raspberry Shake&#34;, &#34;Tromino&#34;, &#34;Other&#34;
    instrument_dropdown = widgets.Dropdown(options=[&#39;Raspberry Shake&#39;, &#39;Tromino&#39;, &#39;Other&#39;],
                                        style={&#39;description_width&#39;: &#39;initial&#39;},
                                        description=&#39;Instrument:&#39;,layout=widgets.Layout(width=&#39;20%&#39;))

    # Processing Settings
    processing_settings_button = widgets.FileUpload(accept=&#39;.proc&#39;, description=&#39;Processing Settings&#39;,
                                            multiple=False,layout=widgets.Layout(width=&#39;10%&#39;))

    # Whether to show plots outside of widget
    show_plot_check =  widgets.Checkbox(description=&#39;Print Plots&#39;, value=False, disabled=False, indent=False,
                                    layout=widgets.Layout(width=&#39;10%&#39;, justify_content=&#39;flex-end&#39;))


    # Whether to print to terminal
    verbose_check = widgets.Checkbox(description=&#39;Verbose&#39;, value=False, disabled=False, indent=False,
                                    layout=widgets.Layout(width=&#39;10%&#39;, justify_content=&#39;flex-end&#39;))

    # A text box labeled Data Filepath
    data_filepath = widgets.Text(description=&#39;Data Filepath:&#39;,
                                    placeholder=&#39;sample&#39;, value=&#39;sample&#39;,
                                    style={&#39;description_width&#39;: &#39;initial&#39;},layout=widgets.Layout(width=&#39;70%&#39;))

    # A button next to it labeled &#34;Browse&#34;
    browse_data_button = widgets.Button(description=&#39;Select Files&#39;, layout=widgets.Layout(width=&#39;10%&#39;))
    def select_datapath(event):
        try:
            root = tk.Tk()
            root.wm_attributes(&#39;-topmost&#39;, True)
            root.withdraw()
            if data_source_type.value==&#39;file&#39; or data_source_type.value==&#39;batch&#39;:
                data_filepath.value = str(filedialog.askopenfilenames(defaultextension=&#39;.MSEED&#39;, title=&#39;Select Data File&#39;))
            else:
                data_filepath.value = str(filedialog.askdirectory(mustexist=True, title=&#34;Select Data Directory&#34;))
            root.destroy()
        except Exception as e:
            print(e)
            browse_data_button.disabled=True
            browse_data_button.description=&#39;Use Text Field&#39;
    browse_data_button.on_click(select_datapath)

    # A text box labeled Metadata Filepath
    metadata_filepath = widgets.Text(description=&#39;Metadata Filepath:&#39;,
                                        style={&#39;description_width&#39;: &#39;initial&#39;},layout=widgets.Layout(width=&#39;70%&#39;))

    # A button next to it labeled &#34;Browse&#34;
    browse_metadata_button = widgets.Button(description=&#39;Select File(s)&#39;, layout=widgets.Layout(width=&#39;10%&#39;))
    def select_metapath(event):
        try:
            root = tk.Tk()
            root.wm_attributes(&#39;-topmost&#39;, True)
            root.withdraw()
            metadata_filepath.value = str(filedialog.askopenfilenames(title=&#39;Select Metadata File(s)&#39;))
            root.destroy()
        except Exception as e:
            print(e)
            browse_metadata_button.disabled=True
            browse_metadata_button.description=&#39;Use Text Field&#39;
    browse_metadata_button.on_click(select_metapath)

    # A progress bar
    progress_bar = widgets.FloatProgress(value=0.0,min=0.0,max=1.0,
                                    bar_style=&#39;info&#39;,
                                    orientation=&#39;horizontal&#39;,layout=widgets.Layout(width=&#39;85%&#39;))

    # A dark yellow button labeled &#34;Read Data&#34;
    read_data_button = widgets.Button(description=&#39;Read Data&#39;,
                                    button_style=&#39;warning&#39;,layout=widgets.Layout(width=&#39;10%&#39;))


    # A forest green button labeled &#34;Process HVSR&#34;
    process_hvsr_button = widgets.Button(description=&#39;Run&#39;,
                                            button_style=&#39;success&#39;,layout=widgets.Layout(width=&#39;5%&#39;))

    # Update input_param call
    def update_input_param_call():
        input_param_text = f&#34;&#34;&#34;(datapath=&#39;{data_filepath.value}&#39;, metapath=&#39;{metadata_filepath.value}&#39;, site=&#39;{site_name.value}&#39;, network=&#39;{network_textbox.value}&#39;,
                    station=&#39;{station_textbox.value}&#39;, loc=&#39;{location_textbox.value}&#39;, channels={[z_channel_textbox.value, e_channel_textbox.value, n_channel_textbox.value]},
                    acq_date=&#39;{acquisition_date_picker.value}&#39;, starttime=&#39;{start_time_picker.value}&#39;, endtime=&#39;{end_time_picker.value}&#39;, tzone=&#39;{time_zone_dropdown.value}&#39;,
                    xcoord={xcoord_textbox.value}, ycoord={ycoord_textbox.value}, elevation={zcoord_textbox.value}, depth=0
                    input_crs=&#39;{input_crs_textbox.value}&#39;, output_crs=&#39;{output_crs_textbox.value}&#39;, elev_unit=&#39;{elevation_unit_textbox.value}&#39;,
                    instrument=&#39;{instrument_dropdown.value}&#39;, hvsr_band={[hvsr_band_min_box.value, hvsr_band_max_box.value]}, 
                    peak_freq_range={[peak_freq_range_min_box.value, peak_freq_range_max_box.value]}, verbose={verbose_check.value})&#34;&#34;&#34;
        input_params_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + input_param_text + &#39;&lt;/p&gt;&#39;
    update_input_param_call()
    
    # Update fetch_data call
    def update_fetch_data_call():
        fetch_data_text = f&#34;&#34;&#34;(params=hvsr_data, source={data_source_type.value}, trim_dir={trim_directory.value},
                            export_format={trim_export_dropdown.value}, detrend={detrend_type_dropdown.value}, detrend_order={detrend_order.value}, verbose={verbose_check.value})&#34;&#34;&#34;
        fetch_data_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + fetch_data_text + &#39;&lt;/p&gt;&#39;
    update_fetch_data_call()

    site_hbox = widgets.HBox()
    site_hbox.children = [site_name, tenpct_spacer, tenpct_spacer, tenpct_spacer, tenpct_spacer, tenpct_spacer, show_plot_check, verbose_check]
    datapath_hbox = widgets.HBox()
    datapath_hbox.children = [data_filepath, browse_data_button, data_source_type]
    metadata_hbox = widgets.HBox()
    metadata_hbox.children = [metadata_filepath, browse_metadata_button, instrument_dropdown]
    progress_hbox = widgets.HBox()
    progress_hbox.children = [progress_bar, read_data_button, process_hvsr_button]

    input_params_vbox = widgets.VBox()
    input_params_vbox.children = [site_hbox,datapath_hbox,metadata_hbox,progress_hbox]

    input_accordion_box.children = [input_accordion]
    #input_HBox.children = [input_accordion_label_box, input_accordion_box]
    #input_HBox.layout= widgets.Layout(align_content=&#39;space-between&#39;)

    # Create a GridBox with 12 rows and 20 columns
    input_tab = widgets.GridBox(layout=widgets.Layout(grid_template_columns=&#39;repeat(10, 1)&#39;,
                                                grid_template_rows=&#39;repeat(12, 1)&#39;))

    # Add the VBox to the GridBox
    input_tab.children = [site_hbox,
                            datapath_hbox,
                            metadata_hbox,
                            input_accordion_box,
                            progress_hbox]

    def get_input_params():
        input_params_kwargs={
            &#39;datapath&#39;:data_filepath.value,
            &#39;metapath&#39;:metadata_filepath.value,
            &#39;site&#39;:site_name.value,
            &#39;instrument&#39;:instrument_dropdown.value,
            &#39;network&#39;:network_textbox.value, &#39;station&#39;:station_textbox.value, &#39;loc&#39;:location_textbox.value, 
            &#39;channels&#39;:[z_channel_textbox.value, e_channel_textbox.value, n_channel_textbox.value],
            &#39;starttime&#39;:start_time_picker.value,
            &#39;endtime&#39;:end_time_picker.value,
            &#39;tzone&#39;:time_zone_dropdown.value,
            &#39;xcoord&#39;:xcoord_textbox.value,
            &#39;ycoord&#39;:ycoord_textbox.value,
            &#39;elevation&#39;:zcoord_textbox.value, &#39;elev_unit&#39;:elevation_unit_textbox.value,&#39;depth&#39;:0,
            &#39;input_crs&#39;:input_crs_textbox.value,&#39;output_crs&#39;:output_crs_textbox.value,
            &#39;hvsr_band&#39;:[hvsr_band_min_box.value, hvsr_band_max_box.value],
            &#39;peak_freq_range&#39;:[peak_freq_range_min_box.value, peak_freq_range_max_box.value]}
        return input_params_kwargs

    def get_fetch_data_params():
        fetch_data_kwargs = {
            &#39;source&#39;:data_source_type.value, 
            &#39;trim_dir&#39;:trim_directory.value,
            &#39;export_format&#39;:data_format_dropdown.value,
            &#39;detrend&#39;:detrend_type_dropdown.value,
            &#39;detrend_order&#39;:detrend_order.value}
        if str(fetch_data_kwargs[&#39;detrend&#39;]).lower() == &#39;none&#39;:
            fetch_data_kwargs[&#39;detrend&#39;] = None
        
        if str(fetch_data_kwargs[&#39;trim_dir&#39;]).lower() == &#39;none&#39;:
            fetch_data_kwargs[&#39;trim_dir&#39;] = None
        return fetch_data_kwargs

    def read_data(button):
        progress_bar.value = 0
        log_textArea.value += f&#34;\n\nREADING DATA [{datetime.datetime.now()}]&#34;

        ip_kwargs = get_input_params()
        hvsr_data = sprit_hvsr.input_params(**ip_kwargs, verbose=verbose_check.value)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\ninput_params():\n&#39;{ip_kwargs}&#34;
        if button.description==&#39;Read Data&#39;:
            progress_bar.value=0.333
        else:
            progress_bar.value=0.1
        fd_kwargs = get_fetch_data_params()
        hvsr_data = sprit_hvsr.fetch_data(hvsr_data, **fd_kwargs, verbose=verbose_check.value)
        log_textArea.value += &#39;\n\n&#39;+str(datetime.datetime.now())+&#39;\nfetch_data():\n\t&#39;+str(fd_kwargs)
        if button.description==&#39;Read Data&#39;:
            progress_bar.value=0.666
        else:
            progress_bar.value=0.2
        
        use_hv_curve_rmse.value=False
        use_hv_curve_rmse.disabled=True

        update_preview_fig(hvsr_data, preview_fig)

        if button.description==&#39;Read Data&#39;:
            sprit_tabs.selected_index = 1
            progress_bar.value=0
        return hvsr_data
    
    read_data_button.on_click(read_data)

    def get_remove_noise_kwargs():
        def get_remove_method():
            remove_method_list=[]
            do_stalta = stalta_check.value
            do_sat_pct = max_saturation_check.value
            do_noiseWin=noisy_windows_check.value
            do_warmcool=warmcool_check.value
            
            if auto_remove_check.value:
                remove_method_list=[&#39;stalta&#39;, &#39;saturation&#39;, &#39;noise&#39;, &#39;warmcool&#39;]
            else:
                if do_stalta:
                    remove_method_list.append(&#39;stalta&#39;)
                if do_sat_pct:
                    remove_method_list.append(&#39;saturation&#39;)
                if do_noiseWin:
                    remove_method_list.append(&#39;noise&#39;)
                if do_warmcool:
                    remove_method_list.append(&#39;warmcool&#39;)
            
            if not remove_method_list:
                remove_method_list = None
            return remove_method_list
        
        remove_noise_kwargs = {&#39;remove_method&#39;:get_remove_method(),
                                &#39;sat_percent&#39;:max_saturation_pct.value, 
                                &#39;noise_percent&#39;:max_window_pct.value,
                                &#39;sta&#39;:sta.value,
                                &#39;lta&#39;:lta.value, 
                                &#39;stalta_thresh&#39;:[stalta_thresh_low.value, stalta_thresh_hi.value], 
                                &#39;warmup_time&#39;:warmup_time.value,
                                &#39;cooldown_time&#39;:cooldown_time.value,
                                &#39;min_win_size&#39;:noisy_window_length.value,
                                &#39;remove_raw_noise&#39;:raw_data_remove_check.value,
                                &#39;verbose&#39;:verbose_check.value}
        return remove_noise_kwargs

    def get_generate_ppsd_kwargs():
        ppsd_kwargs = {
            &#39;skip_on_gaps&#39;:skip_on_gaps.value,
            &#39;db_bins&#39;:[db_bins_min.value, db_bins_max.value, db_bins_step.value],
            &#39;ppsd_length&#39;:ppsd_length.value,
            &#39;overlap&#39;:overlap_pct.value,
            &#39;special_handling&#39;:special_handling_dropdown.value,
            &#39;period_smoothing_width_octaves&#39;:period_smoothing_width.value,
            &#39;period_step_octaves&#39;:period_step_octave.value,
            &#39;period_limits&#39;:[period_limits_min.value, period_limits_max.value],
            &#39;verbose&#39;:verbose_check.value
            }

        if str(ppsd_kwargs[&#39;special_handling&#39;]).lower() == &#39;none&#39;:
            ppsd_kwargs[&#39;special_handling&#39;] = None        
        return ppsd_kwargs

    def get_remove_outlier_curve_kwargs():
        roc_kwargs = {
                &#39;use_percentile&#39;:rmse_pctile_check.value,
                &#39;rmse_thresh&#39;:rmse_thresh.value,
                &#39;use_hv_curve&#39;:False,
                &#39;verbose&#39;:verbose_check.value
            }
        return roc_kwargs

    def get_process_hvsr_kwargs():
        if smooth_hv_curve_bool.value:
            smooth_value = smooth_hv_curve.value
        else:
            smooth_value = smooth_hv_curve_bool.value

        if resample_hv_curve_bool.value:
            resample_value = resample_hv_curve.value
        else:
            resample_value = resample_hv_curve_bool.value

        ph_kwargs={&#39;method&#39;:h_combine_meth.value,
                    &#39;smooth&#39;:smooth_value,
                    &#39;freq_smooth&#39;:freq_smoothing.value,
                    &#39;f_smooth_width&#39;:freq_smooth_width.value,
                    &#39;resample&#39;:resample_value,
                    &#39;outlier_curve_rmse_percentile&#39;:use_hv_curve_rmse.value,
                    &#39;verbose&#39;:verbose_check.value}
        return ph_kwargs

    def get_check_peaks_kwargs():
        cp_kwargs = {&#39;hvsr_band&#39;:[hvsr_band_min_box.value, hvsr_band_max_box.value],
                    &#39;peak_freq_range&#39;:[peak_freq_range_min_box.value, peak_freq_range_max_box.value],
                    &#39;peak_selection&#39;:peak_selection_type.value,
                    &#39;verbose&#39;:verbose_check.value}
        return cp_kwargs

    def get_get_report_kwargs():
        def get_formatted_plot_str():
            # Initialize plot string
            hvsr_plot_str = &#39;&#39;
            comp_plot_str = &#39;&#39;
            spec_plot_str = &#39;&#39;

            # Whether to use each plot
            if use_plot_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34;HVSR&#34;
            if use_plot_comp.value:
                comp_plot_str=comp_plot_str + &#34;C&#34;
            if use_plot_spec.value:
                spec_plot_str=spec_plot_str + &#34;SPEC&#34;

            # Whether components be on the same plot as HV curve?
            if not combine_hv_comp.value:
                comp_plot_str=comp_plot_str + &#34;+&#34;
            else:
                comp_plot_str=comp_plot_str.replace(&#39;+&#39;,&#39;&#39;)

            # Whether to show (log) standard deviations
            if not show_std_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; -s&#34;
            if not show_std_comp.value:
                comp_plot_str=comp_plot_str + &#34; -s&#34;                

            # Whether to show all peaks
            if show_all_peaks_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; all&#34;

            # Whether curves from each time window are shown
            if show_all_curves_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; t&#34;
            if show_all_curves_comp.value:
                comp_plot_str=comp_plot_str + &#34; t&#34;

            # Whether the best peak is displayed
            if show_best_peak_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; p&#34;
            if show_best_peak_comp.value:
                comp_plot_str=comp_plot_str + &#34; p&#34;
            if show_best_peak_spec.value:
                spec_plot_str=spec_plot_str + &#34; p&#34;

            # Whether best peak value is annotated
            if ann_best_peak_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; ann&#34;
            if ann_best_peak_comp.value:
                comp_plot_str=comp_plot_str + &#34; ann&#34;
            if ann_best_peak_spec.value:
                spec_plot_str=spec_plot_str + &#34; ann&#34;

            # Whether peaks from individual time windows are shown
            if show_ind_peaks_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; tp&#34;
            if show_ind_peaks_spec.value:
                spec_plot_str=spec_plot_str + &#39; tp&#39;
            
            # Whether to show legend
            if show_legend_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; leg&#34;
            if ann_best_peak_comp.value:
                comp_plot_str=comp_plot_str + &#34; leg&#34;
            if show_legend_spec.value:
                spec_plot_str=spec_plot_str + &#34; leg&#34;            

            # Combine string into one
            plot_str = hvsr_plot_str + &#39; &#39; + comp_plot_str+ &#39; &#39; + spec_plot_str
            return plot_str

        gr_kwargs = {&#39;report_format&#39;:[&#39;print&#39;,&#39;csv&#39;],
                     &#39;plot_type&#39;:get_formatted_plot_str(),
                     &#39;export_path&#39;:None,
                     &#39;csv_overwrite_opt&#39;:&#39;overwrite&#39;,
                     &#39;no_output&#39;:False,
                    &#39;verbose&#39;:verbose_check.value
                     }
        return gr_kwargs

    def process_data(button):
        startProc=datetime.datetime.now()
        progress_bar.value = 0
        log_textArea.value += f&#34;\n\nPROCESSING DATA [{startProc}]&#34;
        global hvsr_data
        # Read data again only if internal hvsr_data datapath variable is different from what is in the gui
        if not &#39;hvsr_data&#39; in globals() or not hasattr(hvsr_data, &#39;datapath&#39;) or \
                (pathlib.Path(hvsr_data.datapath).as_posix() != pathlib.Path(data_filepath.value).as_posix()):
            hvsr_data = read_data(button)

        remove_noise_kwargs = get_remove_noise_kwargs()
        hvsr_data = sprit_hvsr.remove_noise(hvsr_data, **remove_noise_kwargs)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nremove_noise()\n\t{remove_noise_kwargs}&#34;
        progress_bar.value = 0.3

        generate_ppsd_kwargs = get_generate_ppsd_kwargs()
        hvsr_data = sprit_hvsr.generate_ppsds(hvsr_data, **generate_ppsd_kwargs)
        progress_bar.value = 0.5
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\ngenerate_ppsds()\n\t{generate_ppsd_kwargs}&#34;
        
       
        # If this was started by clicking &#34;Generate PPSDs&#34;, stop here
        if button.description == &#39;Generate PPSDs&#39;:
            return

        ph_kwargs = get_process_hvsr_kwargs()
        hvsr_data = sprit_hvsr.process_hvsr(hvsr_data, **ph_kwargs)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nprocess_hvsr()\n\t{ph_kwargs}&#34;
        progress_bar.value = 0.75
        update_outlier_fig()

        roc_kwargs = get_remove_outlier_curve_kwargs()
        hvsr_data = sprit_hvsr.remove_outlier_curves(hvsr_data, **roc_kwargs)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nremove_outlier_curves()\n\t{roc_kwargs}&#34;
        progress_bar.value = 0.85
        outlier_fig, hvsr_data = update_outlier_fig()

        use_hv_curve_rmse.value=False
        use_hv_curve_rmse.disabled=False

        def get_rmse_range():
            minRMSE = 10000
            maxRMSE = -1
            if roc_kwargs[&#39;use_hv_curve&#39;]:
                colnames = [&#39;HV_Curves&#39;]
            else:
                colnames = [&#39;psd_values_Z&#39;,
                            &#39;psd_values_E&#39;,
                            &#39;psd_values_N&#39;]
            dataList = []
            for col in colnames:
                dataArr = np.stack(hvsr_data.hvsr_df[col])
                medCurveArr = np.nanmedian(dataArr, axis=0)
                rmse = np.sqrt(((np.subtract(dataArr, medCurveArr)**2).sum(axis=1))/dataArr.shape[1])
                if rmse.min() &lt; minRMSE:
                    minRMSE = rmse.min()
                if rmse.max() &gt; maxRMSE:
                    maxRMSE = rmse.max()
            rmse_thresh_slider.min = minRMSE
            rmse_thresh_slider.max = maxRMSE
            rmse_thresh_slider.step = round((maxRMSE-minRMSE)/100, 2)
            rmse_thresh_slider.value = maxRMSE
        get_rmse_range()

        cp_kwargs = get_check_peaks_kwargs()
        hvsr_data = sprit_hvsr.check_peaks(hvsr_data, **cp_kwargs)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\ncheck_peaks()\n\t{cp_kwargs}&#34;
        progress_bar.value = 0.9

        gr_kwargs = get_get_report_kwargs()
        hvsr_data = sprit_hvsr.get_report(hvsr_data, **gr_kwargs)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nget_report()\n\t{gr_kwargs}\n\n&#34;
        hvsr_data.get_report(report_format=&#39;print&#39;) # Just in case print wasn&#39;t included
        log_textArea.value += hvsr_data[&#39;Print_Report&#39;]
        printed_results_textArea.value = hvsr_data[&#39;Print_Report&#39;]
        hvsr_data.get_report(report_format=&#39;csv&#39;) 
        results_table.value = hvsr_data[&#39;CSV_Report&#39;].to_html()
        
        log_textArea.value += f&#39;Processing time: {datetime.datetime.now() - startProc}&#39;
        progress_bar.value = 0.95

        update_results_fig(hvsr_data, gr_kwargs[&#39;plot_type&#39;])
        
        progress_bar.value = 1
        global hvsr_results
        hvsr_results = hvsr_data

    def parse_plot_string(plot_string):
        plot_list = plot_string.split()

        hvsrList = [&#39;hvsr&#39;, &#39;hv&#39;, &#39;h&#39;]
        compList = [&#39;component&#39;, &#39;comp&#39;, &#39;c&#39;]
        compPlus = [item + &#39;+&#39; for item in compList]
        specList = [&#39;spectrogram&#39;, &#39;specgram&#39;, &#39;spec&#39;,&#39;sg&#39;, &#39;s&#39;]

        hvInd = np.nan
        compInd = np.nan
        specInd = np.nan

        hvIndFound = False
        compIndFound = False
        specIndFound = False

        for i, item in enumerate(plot_list):
            if item.lower() in hvsrList and not hvIndFound:
                # assign the index
                hvInd = i
                hvIndFound = True
            if (item.lower() in compList or item.lower() in compPlus) and not compIndFound:
                # assign the index
                compInd = i
                compIndFound = True
            if item.lower() in specList and not specIndFound:
                # assign the index
                specInd = i
                specIndFound = True

        # Get individual plot lists (should already be correctly ordered)
        if hvInd is np.nan:
            hvsr_plot_list = [&#39;HVSR&#39;]

        if compInd is np.nan:
            comp_plot_list = []
            if specInd is np.nan:
                if hvInd is not np.nan:
                    hvsr_plot_list = plot_list
                spec_plot_list = []
            else:
                if hvInd is not np.nan:
                    hvsr_plot_list = plot_list[hvInd:specInd]
                spec_plot_list = plot_list[specInd:]
        else:
            if hvInd is not np.nan:
                hvsr_plot_list = plot_list[hvInd:compInd]
            
            if specInd is np.nan:
                comp_plot_list = plot_list[compInd:]
                spec_plot_list = []
            else:
                comp_plot_list = plot_list[compInd:specInd]
                spec_plot_list = plot_list[specInd:]

        # Figure out how many subplots there will be
        plot_list_list = [hvsr_plot_list, comp_plot_list, spec_plot_list]

        return plot_list_list

    def parse_hv_plot_list(hv_data, hvsr_plot_list):
        hvsr_data = hv_data
        x_data = hvsr_data.x_freqs[&#39;Z&#39;]
        hvsrDF = hvsr_data.hvsr_df

        if &#39;tp&#39; in hvsr_plot_list:
            allpeaks = []
            for row in hvsrDF[hvsrDF[&#39;Use&#39;]][&#39;CurvesPeakFreqs&#39;].values:
                for peak in row:
                    allpeaks.append(peak)
            allInd = []
            for row, peakList in enumerate(hvsrDF[hvsrDF[&#39;Use&#39;]][&#39;CurvesPeakIndices&#39;].values):
                for ind in peakList:
                    allInd.append((row, ind))
            x_vals = []
            y_vals = []
            y_max = np.nanmax(hvsr_data.hvsrp)
            hvCurveInd = list(hvsrDF.columns).index(&#39;HV_Curves&#39;)
            for i, tp in enumerate(allpeaks):
                x_vals.extend([tp, tp, None]) # add two x values and a None
                y_vals.extend([0, hvsrDF.iloc[allInd[i][0], hvCurveInd][allInd[i][1]], None]) # add the first and last y values and a None            

            results_fig.add_trace(go.Scatter(x=x_vals, y=y_vals, mode=&#39;lines&#39;,
                                            line=dict(width=4, dash=&#34;solid&#34;, 
                                            color=&#34;rgba(128,0,0,0.1)&#34;), 
                                            name=&#39;Best Peaks Over Time&#39;),
                                            row=1, col=1)

        if &#39;t&#39; in hvsr_plot_list:
            alltimecurves = np.stack(hvsrDF[hvsrDF[&#39;Use&#39;]][&#39;HV_Curves&#39;])
            for i, row in enumerate(alltimecurves):
                if i==0:
                    showLeg = True
                else:
                    showLeg= False
                results_fig.add_trace(go.Scatter(x=x_data[:-1], y=row, mode=&#39;lines&#39;,
                                            line=dict(width=0.5, dash=&#34;solid&#34;, 
                                            color=&#34;rgba(100, 110, 100, 0.8)&#34;), 
                                            showlegend=showLeg, 
                                            name=&#39;Ind. time win. curve&#39;, 
                                            hoverinfo=&#39;none&#39;),
                                            row=1, col=1)

        if &#39;all&#39; in hvsr_plot_list:
            for i, p in enumerate(hvsr_data[&#39;hvsr_peak_freqs&#39;]):
                if i==0:
                    showLeg = True
                else:
                    showLeg= False

                results_fig.add_trace(go.Scatter(
                    x=[p, p, None], # set x to None
                    y=[0, np.nanmax(np.stack(hvsrDF[&#39;HV_Curves&#39;])),None], # set y to None
                    mode=&#34;lines&#34;, # set mode to lines
                    line=dict(width=1, dash=&#34;dot&#34;, color=&#34;gray&#34;), # set line properties
                    name=&#34;All checked peaks&#34;, # set legend name
                    showlegend=showLeg),
                    row=1, col=1)

        if &#39;-s&#39; not in hvsr_plot_list:
            # Show standard deviation
            results_fig.add_trace(go.Scatter(x=x_data, y=hvsr_data.hvsrp2,
                                    line={&#39;color&#39;:&#39;black&#39;, &#39;width&#39;:0.1},marker=None, 
                                    showlegend=False, name=&#39;Log. St.Dev. Upper&#39;,
                                    hoverinfo=&#39;none&#39;),
                                    row=1, col=1)
            
            results_fig.add_trace(go.Scatter(x=x_data, y=hvsr_data.hvsrm2,
                                    line={&#39;color&#39;:&#39;black&#39;, &#39;width&#39;:0.1},marker=None,
                                    fill=&#39;tonexty&#39;, fillcolor=&#34;rgba(128, 128, 128, 0.6)&#34;,
                                    name=&#39;Log. St.Dev.&#39;, hoverinfo=&#39;none&#39;),
                                    row=1, col=1)
                
        if &#39;p&#39; in hvsr_plot_list:
            results_fig.add_trace(go.Scatter(
                x=[hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;], hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;], None], # set x to None
                y=[0,np.nanmax(np.stack(hvsrDF[&#39;HV_Curves&#39;])),None], # set y to None
                mode=&#34;lines&#34;, # set mode to lines
                line=dict(width=1, dash=&#34;dash&#34;, color=&#34;black&#34;), # set line properties
                name=&#34;Best Peak&#34;),
                row=1, col=1)

        if &#39;ann&#39; in hvsr_plot_list:
            # Annotate best peak
            results_fig.add_annotation(x=np.log10(hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;]),
                                    y=0, yanchor=&#39;bottom&#39;, xanchor=&#39;center&#39;,
                                    text=f&#34;{hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;]:.3f} Hz&#34;,
                                    bgcolor=&#39;rgba(255, 255, 255, 0.7)&#39;,
                                    showarrow=False,
                                    row=1, col=1)
        return results_fig

    def parse_comp_plot_list(hv_data, comp_plot_list):
        
        hvsr_data = hv_data
        # Initial setup
        x_data = hvsr_data.x_freqs[&#39;Z&#39;]
        hvsrDF = hvsr_data.hvsr_df
        same_plot = ((comp_plot_list != []) and (&#39;+&#39; not in comp_plot_list[0]))

        if same_plot:
            yaxis_to_use = &#39;y2&#39;
            use_secondary = True
            transparency_modifier = 0.5
        else:
            yaxis_to_use = &#39;y&#39;
            use_secondary=False
            transparency_modifier = 1

        alpha = 0.4 * transparency_modifier
        components = [&#39;Z&#39;, &#39;E&#39;, &#39;N&#39;]
        compColor_semi_light = {&#39;Z&#39;:f&#39;rgba(128,128,128,{alpha})&#39;,
                    &#39;E&#39;:f&#39;rgba(0,0,128,{alpha})&#39;,
                    &#39;N&#39;:f&#39;rgba(128,0,0,{alpha})&#39;}

        alpha = 0.7 * transparency_modifier
        compColor_semi = {&#39;Z&#39;:f&#39;rgba(128,128,128,{alpha})&#39;, 
                        &#39;E&#39;:f&#39;rgba(100,100,128,{alpha})&#39;, 
                        &#39;N&#39;:f&#39;rgba(128,100,100,{alpha})&#39;}

        compColor = {&#39;Z&#39;:f&#39;rgba(128,128,128,{alpha})&#39;, 
                    &#39;E&#39;:f&#39;rgba(100,100,250,{alpha})&#39;, 
                    &#39;N&#39;:f&#39;rgba(250,100,100,{alpha})&#39;}

        # Whether to plot in new subplot or not
        if  comp_plot_list != [] and &#39;+&#39; in comp_plot_list[0]:
            compRow=2
        else:
            compRow=1

        # Whether to plot individual time curves
        if &#39;t&#39; in comp_plot_list:
            for comp in components:
                alltimecurves = np.stack(hvsrDF[hvsrDF[&#39;Use&#39;]][&#39;psd_values_&#39;+comp])
                for i, row in enumerate(alltimecurves):
                    if i==0:
                        showLeg = True
                    else:
                        showLeg= False
                    
                    results_fig.add_trace(go.Scatter(x=x_data[:-1], y=row, mode=&#39;lines&#39;,
                                    line=dict(width=0.5, dash=&#34;solid&#34;, 
                                    color=compColor_semi[comp]),
                                    name=&#39;Ind. time win. curve&#39;,
                                    showlegend=False,
                                    hoverinfo=&#39;none&#39;,
                                    yaxis=yaxis_to_use),
                                    secondary_y=use_secondary,
                                    row=compRow, col=1)

        # Code to plot standard deviation windows, if not removed
        if &#39;-s&#39; not in comp_plot_list:
            for comp in components:
                # Show standard deviation
                results_fig.add_trace(go.Scatter(x=x_data, y=hvsr_data.ppsd_std_vals_p[comp],
                                        line={&#39;color&#39;:compColor_semi_light[comp], &#39;width&#39;:0.1},marker=None, 
                                        showlegend=False, name=&#39;Log. St.Dev. Upper&#39;,
                                        hoverinfo=&#39;none&#39;,    
                                        yaxis=yaxis_to_use),
                                        secondary_y=use_secondary,
                                        row=compRow, col=1)
                
                results_fig.add_trace(go.Scatter(x=x_data, y=hvsr_data.ppsd_std_vals_m[comp],
                                        line={&#39;color&#39;:compColor_semi_light[comp], &#39;width&#39;:0.1},marker=None,
                                        fill=&#39;tonexty&#39;, fillcolor=compColor_semi_light[comp],
                                        name=f&#39;St.Dev. [{comp}]&#39;, hoverinfo=&#39;none&#39;, showlegend=False, 
                                        yaxis=yaxis_to_use),
                                        secondary_y=use_secondary,
                                        row=compRow, col=1)
                
        # Code to plot location of best peak
        if &#39;p&#39; in comp_plot_list:
            minVal = 10000
            maxVal = -10000
            for comp in components:
                currPPSDCurve = hvsr_data[&#39;psd_values_tavg&#39;][comp]
                if np.nanmin(currPPSDCurve) &lt; minVal:
                    minVal = np.nanmin(currPPSDCurve)
                if np.nanmax(currPPSDCurve) &gt; maxVal:
                    maxVal = np.nanmax(currPPSDCurve)

            results_fig.add_trace(go.Scatter(
                x=[hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;], hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;], None], # set x to None
                y=[minVal,maxVal,None], # set y to None
                mode=&#34;lines&#34;, # set mode to lines
                line=dict(width=1, dash=&#34;dash&#34;, color=&#34;black&#34;), # set line properties
                name=&#34;Best Peak&#34;,
                yaxis=yaxis_to_use),
                secondary_y=use_secondary,
                row=compRow, col=1)
            
        # Code to annotate value of best peak
        if &#39;ann&#39; in comp_plot_list:
            minVal = 10000
            for comp in components:
                currPPSDCurve = hvsr_data[&#39;psd_values_tavg&#39;][comp]
                if np.nanmin(currPPSDCurve) &lt; minVal:
                    minVal = np.nanmin(currPPSDCurve)
            results_fig.add_annotation(x=np.log10(hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;]),
                            y=minVal,
                            text=f&#34;{hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;]:.3f} Hz&#34;,
                            bgcolor=&#39;rgba(255, 255, 255, 0.7)&#39;,
                            showarrow=False,
                            yref=yaxis_to_use,
                            secondary_y=use_secondary,
                            row=compRow, col=1)

        # Plot the main averaged component PPSDs
        for comp in components:
            results_fig.add_trace(go.Scatter(x=hvsr_data.x_freqs[comp],
                                            y=hvsr_data[&#39;psd_values_tavg&#39;][comp],
                                            line=dict(width=2, dash=&#34;solid&#34;, 
                                            color=compColor[comp]),marker=None, 
                                            name=&#39;PPSD Curve &#39;+comp,    
                                            yaxis=yaxis_to_use), 
                                            secondary_y=use_secondary,
                                            row=compRow, col=&#39;all&#39;)

        # If new subplot, update accordingly
        if compRow==2:
            results_fig.update_xaxes(type=&#39;log&#39;,
                            range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])],
                            row=compRow, col=1)
        return results_fig

    def parse_spec_plot_list(hv_data, spec_plot_list, subplot_num):
        hvsr_data = hv_data
        # Initial setup
        hvsrDF = hvsr_data.hvsr_df
        specAxisTimes = np.array([dt.isoformat() for dt in hvsrDF.index.to_pydatetime()])
        y_data = hvsr_data.x_freqs[&#39;Z&#39;][1:]
        image_data = np.stack(hvsrDF[&#39;HV_Curves&#39;]).T

        maxZ = np.percentile(image_data, 100)
        minZ = np.percentile(image_data, 0)

        use_mask = hvsr_data.hvsr_df.Use.values
        use_mask = np.tile(use_mask, (image_data.shape[0],1))
        use_mask = np.where(use_mask is False, np.nan, use_mask)

        hmap = go.Heatmap(z=image_data,
                    x=specAxisTimes,
                    y=y_data,
                    colorscale=&#39;Turbo&#39;,
                    showlegend=False,
                    #opacity=0.7,
                    hovertemplate=&#39;Time [UTC]: %{x}&lt;br&gt;Frequency [Hz]: %{y:.2f}&lt;br&gt;H/V Amplitude: %{z:.2f}&lt;extra&gt;&lt;/extra&gt;&#39;,
                    zmin=minZ,zmax=maxZ, showscale=False, name=&#39;HV Curve Amp. over Time&#39;)
        results_fig.add_trace(hmap, row=subplot_num, col=1)

        data_used = go.Heatmap(
            x=specAxisTimes,
            y=y_data,
            z=use_mask,
            showlegend=False,
            colorscale=[[0, &#39;rgba(0,0,0,0.66)&#39;], [0.25, &#39;rgba(0,0,0,0.66)&#39;], [1, &#39;rgba(250,250,250,0)&#39;]],
            showscale=False, name=&#39;Used&#39;)
        results_fig.add_trace(data_used, row=subplot_num, col=1)


        # tp currently is not being added to spec_plot_list
        if &#39;tp&#39; in spec_plot_list:
            yvals = []
            for row in hvsrDF[&#39;HV_Curves&#39;].values:
                maxInd = np.argmax(row)
                yvals.append(y_data[maxInd])
            tp_trace = go.Scatter(x=specAxisTimes, y=yvals, mode=&#39;markers&#39;,
                                    line=None, marker=dict(color=&#39;white&#39;, size=2, line=dict(color=&#39;black&#39;, width=0.1)), name=&#39;Individual H/V Peaks&#39;)
            results_fig.add_trace(tp_trace, row=subplot_num, col=&#39;all&#39;)

        if &#39;p&#39; in spec_plot_list:
            results_fig.add_hline(y=hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;], line_width=1, line_dash=&#39;dash&#39;, line_color=&#39;black&#39;, row=subplot_num, col=&#39;all&#39;)

        if &#39;ann&#39; in spec_plot_list:
            results_fig.add_annotation(x=specAxisTimes[-1],
                                    y=hvsr_data[&#39;hvsr_band&#39;][1],
                                    text=f&#34;Peak: {hvsr_data[&#39;BestPeak&#39;][&#39;f0&#39;]:.3f} Hz&#34;,
                                    bgcolor=&#39;rgba(255, 255, 255, 0.7)&#39;,
                                    showarrow=False, xanchor=&#39;right&#39;, yanchor=&#39;top&#39;,
                                    row=subplot_num, col=&#39;all&#39;)

        if &#39;leg&#39; in spec_plot_list:
            pass

        results_fig.update_yaxes(type=&#39;log&#39;,
                        range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])],
                        row=subplot_num, col=1)

        results_fig.add_annotation(
            text=f&#34;{hvsrDF[&#39;Use&#39;].sum()}/{hvsrDF.shape[0]} windows used&#34;,
            x=max(specAxisTimes),
            y=np.log10(min(y_data))+(np.log10(max(y_data))-np.log10(min(y_data)))*0.01,
            xanchor=&#34;right&#34;, yanchor=&#34;bottom&#34;,bgcolor=&#39;rgba(256,256,256,0.7)&#39;,
            showarrow=False,row=subplot_num, col=1)

        return results_fig

    def update_results_fig(hv_data, plot_string):
        global results_fig
        hvsr_data = hv_data

        if isinstance(hvsr_data, sprit_hvsr.HVSRBatch):
            hvsr_data=hvsr_data[0]

        hvsrDF = hvsr_data.hvsr_df

        plot_list = parse_plot_string(plot_string)

        combinedComp=False
        noSubplots = 3 - plot_list.count([])
        if plot_list[1] != [] and &#39;+&#39; not in plot_list[1][0]:
            combinedComp = True
            noSubplots -= 1
        
        # Get all data for each plotted item
        # COMP Plot
        # Figure out which subplot is which
        if combinedComp:
            comp_plot_row = 1
            spec_plot_row = 2
        else:
            comp_plot_row = 2
            spec_plot_row = 3

        # Re-initialize results_fig
        results_fig.data = []
        results_fig.update_layout(grid=None)  # Clear the existing grid layout
        if not combinedComp: 
            subp = subplots.make_subplots(rows=3, cols=1, horizontal_spacing=0.01, vertical_spacing=0.07,
                                                row_heights=[2, 1.5, 1])
        else:
            subp = subplots.make_subplots(rows=2, cols=1, horizontal_spacing=0.01, vertical_spacing=0.07,
                                    specs =[[{&#39;secondary_y&#39;: True}],
                                            [{&#39;secondary_y&#39;: False}]],
                                            row_heights=[1, 1])
        results_fig.update_layout(grid={&#39;rows&#39;: noSubplots})
        #del results_fig
        results_fig = go.FigureWidget(subp)

        results_fig = parse_comp_plot_list(hvsr_data, comp_plot_list=plot_list[1])

        # HVSR Plot (plot this after COMP so it is on top COMP and to prevent deletion with no C+)
        results_fig = parse_hv_plot_list(hvsr_data, hvsr_plot_list=plot_list[0])
        # Will always plot the HV Curve
        results_fig.add_trace(go.Scatter(x=hvsr_data.x_freqs[&#39;Z&#39;],y=hvsr_data.hvsr_curve,
                            line={&#39;color&#39;:&#39;black&#39;, &#39;width&#39;:1.5},marker=None, name=&#39;HVSR Curve&#39;),
                            row=1, col=&#39;all&#39;)

        # SPEC plot
        results_fig = parse_spec_plot_list(hvsr_data, spec_plot_list=plot_list[2], subplot_num=spec_plot_row)

        # Final figure updating
        showtickLabels = (plot_list[1]==[] or &#39;+&#39; not in plot_list[1][0])
        if showtickLabels:
            side=&#39;bottom&#39;
        else:
            side=&#39;top&#39;
        results_fig.update_xaxes(type=&#39;log&#39;,
                        range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])],
                        side=&#39;top&#39;,
                        row=1, col=1)
        
        results_fig.update_xaxes(type=&#39;log&#39;,overlaying=&#39;x&#39;,
                        range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])],
                        side=&#39;bottom&#39;,
                        row=1, col=1)
        if comp_plot_row!=1:
            results_fig.update_xaxes(showticklabels=showtickLabels, row=comp_plot_row, col=1)
        
        if preview_fig.layout.width is None:
            if outlier_fig.layout.widgth is None:
                chartwidth = 800
            else:
                chartwidth = outlier_fig.layout.width

        else:
            chartwidth = preview_fig.layout.width

        results_fig.update_layout(margin={&#34;l&#34;:10, &#34;r&#34;:10, &#34;t&#34;:35, &#39;b&#39;:0},
                                showlegend=False, autosize=True, height = 1.2 * float(chartwidth),
                                title=f&#34;{hvsr_data[&#39;site&#39;]} Results&#34;)
        results_fig.update_yaxes(title_text=&#39;H/V Ratio&#39;, row=1, col=1)
        results_fig.update_yaxes(title_text=&#39;H/V Over Time&#39;, row=noSubplots, col=1)
        if comp_plot_row==1:
            results_fig.update_yaxes(title_text=&#34;PPSD Amp\n[m2/s4/Hz][dB]&#34;, secondary_y=True, row=comp_plot_row, col=1)
        else:
            results_fig.update_yaxes(title_text=&#34;PPSD Amp\n[m2/s4/Hz][dB]&#34;, row=comp_plot_row, col=1)
        
        # Reset results_graph_widget and display 
        with results_graph_widget:
            clear_output(wait=True)
            display(results_fig)

        if show_plot_check.value:
            results_fig.show()

        sprit_tabs.selected_index = 4
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nResults Figure Updated: {plot_string}&#34;

    process_hvsr_button.on_click(process_data)

    # PREVIEW TAB
    #Initialize plot
    subp = subplots.make_subplots(rows=4, cols=1, shared_xaxes=True, horizontal_spacing=0.01, vertical_spacing=0.01, row_heights=[3,1,1,1])
    preview_fig = go.FigureWidget(subp)

    def update_preview_fig(hv_data, preview_fig):
        preview_fig.data = []
        
        hvsr_data = hv_data
        if isinstance(hvsr_data, sprit_hvsr.HVSRBatch):
            hvsr_data=hvsr_data[0]

        stream_z = hvsr_data[&#39;stream&#39;].select(component=&#39;Z&#39;) #may be np.ma.masked_array
        stream_e = hvsr_data[&#39;stream&#39;].select(component=&#39;E&#39;) #may be np.ma.masked_array
        stream_n = hvsr_data[&#39;stream&#39;].select(component=&#39;N&#39;) #may be np.ma.masked_array

        # Get iso_times and datetime.datetime
        utcdt = stream_z[0].times(type=&#39;utcdatetime&#39;)
        iso_times=[]
        dt_times = []
        for t in utcdt:
            if t is not np.ma.masked:
                iso_times.append(t.isoformat())
                dt_times.append(datetime.datetime.fromisoformat(t.isoformat()))
            else:
                iso_times.append(np.nan)
        iso_times=np.array(iso_times)
        dt_times = np.array (dt_times)

        # Generate spectrogram
        f, t, Sxx = signal.spectrogram(x=stream_z[0].data, fs=stream_z[0].stats.sampling_rate, mode=&#39;magnitude&#39;)
        
        # Get times for the axis (one time per window)
        axisTimes = []
        for tpass in t:
            axisTimes.append((dt_times[0]+datetime.timedelta(seconds=tpass)).isoformat())

        # Add data to preview_fig
        # Add spectrogram of Z component
        minz = np.percentile(Sxx, 1)
        maxz = np.percentile(Sxx, 99)
        hmap = go.Heatmap(z=Sxx,
                    x=axisTimes,
                    y=f,
                    colorscale=&#39;Turbo&#39;,
                    showlegend=False,
                    hovertemplate=&#39;Time [UTC]: %{x}&lt;br&gt;Frequency [Hz]: %{y:.2f}&lt;br&gt;Spectrogram Magnitude: %{z:.2f}&lt;extra&gt;&lt;/extra&gt;&#39;,
                    zmin=minz, zmax=maxz, showscale=False, name=&#39;Z Component Spectrogram&#39;)
        preview_fig.add_trace(hmap, row=1, col=1)
        preview_fig.update_yaxes(type=&#39;log&#39;, range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])], row=1, col=1)
        preview_fig.update_yaxes(title={&#39;text&#39;:&#39;Spectrogram (Z)&#39;}, row=1, col=1)

        # Add raw traces
        dec_factor=5 #This just makes the plotting go faster, by &#34;decimating&#34; the data
        preview_fig.add_trace(go.Scatter(x=iso_times[::dec_factor], y=stream_z[0].data[::dec_factor],
                                        line={&#39;color&#39;:&#39;black&#39;, &#39;width&#39;:0.5},marker=None, name=&#39;Z component data&#39;), row=2, col=&#39;all&#39;)
        preview_fig.update_yaxes(title={&#39;text&#39;:&#39;Z&#39;}, row=2, col=1)
        preview_fig.add_trace(go.Scatter(x=iso_times[::dec_factor], y=stream_e[0].data[::dec_factor],
                                        line={&#39;color&#39;:&#39;blue&#39;, &#39;width&#39;:0.5},marker=None, name=&#39;E component data&#39;),row=3, col=&#39;all&#39;)
        preview_fig.update_yaxes(title={&#39;text&#39;:&#39;E&#39;}, row=3, col=1)
        preview_fig.add_trace(go.Scatter(x=iso_times[::dec_factor], y=stream_n[0].data[::dec_factor],
                                        line={&#39;color&#39;:&#39;red&#39;, &#39;width&#39;:0.5},marker=None, name=&#39;N component data&#39;), row=4, col=&#39;all&#39;)
        preview_fig.update_yaxes(title={&#39;text&#39;:&#39;N&#39;}, row=4, col=1)
        
        #preview_fig.add_trace(p)
        preview_fig.update_layout(margin={&#34;l&#34;:10, &#34;r&#34;:10, &#34;t&#34;:30, &#39;b&#39;:0}, showlegend=False,
                                  title=f&#34;{hvsr_data[&#39;site&#39;]} Data Preview&#34;)

        if show_plot_check.value:
            preview_fig.show()

    # REMOVE NOISE SUBTAB
    # STA/LTA Antitrigger
    stalta_check = widgets.Checkbox(value=False, disabled=False, indent=False, description=&#39;STA/LTA Antitrigger&#39;)
    sta = widgets.FloatText(description=&#39;STA [s]&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=5, value=5,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    lta = widgets.FloatText(description=&#39;LTA [s]&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=30, value=30,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    stalta_thresh_low = widgets.FloatText(description=&#39;STA/LTA Thresholds (low, high)&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0.5, value=0.5,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    stalta_thresh_hi = widgets.FloatText(style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=5, value=5,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))

    #% Saturation Threshold
    max_saturation_check = widgets.Checkbox(description=&#39;Percentage Threshold (Instantaneous)&#39;, value=False, disabled=False, indent=False)
    max_saturation_pct = widgets.FloatText(description=&#39;Max Saturation %:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0.995, value=0.995,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))

    #Noise Windows
    noisy_windows_check = widgets.Checkbox(description=&#39;Noisy Windows&#39;, value=False, disabled=False, indent=False)
    max_window_pct = widgets.FloatText(description=&#39;Max Window %:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0.8, value=0.8,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    noisy_window_length = widgets.FloatText(description=&#39;Window Length [s]:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=30, value=30,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))

    #Warmup/cooldown
    warmcool_check = widgets.Checkbox(description=&#39;Warmup &amp; Cooldown Time&#39;, value=False, disabled=False, indent=False)
    warmup_time = widgets.FloatText(description=&#39;Warmup time [s]:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0, value=0,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    cooldown_time = widgets.FloatText(description=&#39;Cooldown time [s]:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0, value=0,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))

    #STD Ratio
    std_ratio_check = widgets.Checkbox(description=&#39;Standard Deviation Antitrigger (not yet implemented)&#39;, value=False, disabled=True, indent=False)
    std_ratio_text = widgets.FloatText(description=&#39;StdDev Ratio:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0, value=0,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=True)
    std_window_length_text = widgets.FloatText(description=&#39;Moving window Length [s]:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0, value=0,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;),disabled=True)

    #Autoremove
    auto_remove_check = widgets.Checkbox(description=&#39;Use Auto Remove&#39;, value=False, disabled=False, indent=False)

    #Remove from raw data
    raw_data_remove_check = widgets.Checkbox(description=&#39;Remove Noise From Raw Data&#39;, value=False, disabled=False, indent=False)

    #remove_noise call
    remove_noise_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;remove_noise&#39; + &#39;&lt;/p&gt;&#39;, 
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    remove_noise_call = widgets.HTML(value=&#39;()&#39;)
    remove_noise_call_hbox = widgets.HBox([remove_noise_prefix, remove_noise_call])

    # Update remove_outlier call
    def update_remove_noise_call():
        rnkwargs = get_remove_noise_kwargs()
        rn_text = f&#34;&#34;&#34;(hvsr_data=hvsr_data, remove_method={rnkwargs[&#39;remove_method&#39;]}, 
                    sat_percent={rnkwargs[&#39;sat_percent&#39;]}, 
                    noise_percent={rnkwargs[&#39;noise_percent&#39;]}, 
                    sta={rnkwargs[&#39;sta&#39;]}, 
                    lta={rnkwargs[&#39;lta&#39;]}, 
                    stalta_thresh={rnkwargs[&#39;stalta_thresh&#39;]}, 
                    warmup_time={rnkwargs[&#39;warmup_time&#39;]}, 
                    cooldown_time={rnkwargs[&#39;cooldown_time&#39;]}, 
                    min_win_size={rnkwargs[&#39;min_win_size&#39;]}, 
                    remove_raw_noise={rnkwargs[&#39;remove_raw_noise&#39;]}, 
                    verbose={verbose_check.value})&#34;&#34;&#34;
        remove_noise_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + rn_text + &#39;&lt;/p&gt;&#39;
    update_remove_noise_call()

    #Update noise windows
    update_noise_windows_button = widgets.Button(description=&#39;Update Noise Windows&#39;,button_style=&#39;info&#39;,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=True)

    preview_graph_widget = widgets.Output()
    #progress bar (same as above)
    preview_progress_hbox = widgets.HBox(children=[progress_bar, update_noise_windows_button, process_hvsr_button])

    # Add it all in to the tab
    stalta_hbox = widgets.HBox([stalta_check, sta, lta, stalta_thresh_low, stalta_thresh_hi])
    sat_hbox = widgets.HBox([max_saturation_check, max_saturation_pct])
    noise_win_hbox = widgets.HBox([noisy_windows_check, max_window_pct, noisy_window_length])
    warmcool_hbox = widgets.HBox([warmcool_check, warmup_time, cooldown_time])
    std_ratio_hbox = widgets.HBox([std_ratio_check, std_ratio_text, std_window_length_text])
    spacer_hbox = widgets.HBox([tenpct_spacer])

    preview_noise_tab = widgets.VBox([stalta_hbox,
                                      sat_hbox,
                                      noise_win_hbox,
                                      warmcool_hbox,
                                      std_ratio_hbox,
                                      auto_remove_check,
                                      raw_data_remove_check,
                                      spacer_hbox,
                                      remove_noise_call_hbox])

    preview_graph_tab = widgets.VBox(children=[preview_graph_widget])
    preview_subtabs = widgets.Tab([preview_graph_tab, preview_noise_tab])
    preview_tab = widgets.VBox()

    preview_subtabs.set_title(0, &#34;Data Preview&#34;)
    preview_subtabs.set_title(1, &#34;Noise Removal&#34;)

    preview_tab.children = [preview_subtabs, preview_progress_hbox]
    # Initialize tab
    with preview_graph_widget:
        display(preview_fig)

    # SETTINGS TAB
    plot_settings_tab = widgets.GridspecLayout(18, ui_width)
    settings_progress_hbox = widgets.HBox(children=[progress_bar, tenpct_spacer, process_hvsr_button])

    # PPSD SETTINGS SUBTAB
    ppsd_length_label = widgets.Label(value=&#39;Window Length for PPSDs:&#39;)
    ppsd_length = widgets.FloatText(style={&#39;description_width&#39;: &#39;initial&#39;}, 
                                    placeholder=20, value=20,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    
    overlap_pct_label = widgets.Label(value=&#39;Overlap %:&#39;)
    overlap_pct = widgets.FloatText(style={&#39;description_width&#39;: &#39;initial&#39;}, 
                                    placeholder=0.5, value=0.5, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    period_step_label = widgets.Label(value=&#39;Period Step Octaves:&#39;)
    period_step_octave = widgets.FloatText(style={&#39;description_width&#39;: &#39;initial&#39;}, 
                                           placeholder=0.0625, value=0.0625, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    skip_on_gaps_label = widgets.Label(value=&#39;Skip on gaps:&#39;)
    skip_on_gaps = widgets.Checkbox(value=False, disabled=False, indent=False)

    db_step_label = widgets.Label(value=&#39;dB bins:&#39;)
    db_bins_min = widgets.FloatText(description=&#39;Min. dB&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=-200, value=-200, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    db_bins_max = widgets.FloatText(description=&#39;Max. dB&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=-50, value=-50, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    db_bins_step = widgets.FloatText(description=&#39;dB Step&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=1, value=1, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    
    period_limit_label = widgets.Label(value=&#39;Period Limits:&#39;)
    minPLim = round(1/(hvsr_band_max_box.value), 3)
    maxPLim = round(1/(hvsr_band_min_box.value), 3)
    period_limits_min = widgets.FloatText(description=&#39;Min. Period Limit&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=minPLim, value=minPLim, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    period_limits_max = widgets.FloatText(description=&#39;Max. Period Limit&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=maxPLim, value=maxPLim, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    period_smoothing_width = widgets.FloatText(description=&#39;Period Smoothing Width&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=1, value=1, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    special_handling_dropdown = widgets.Dropdown(description=&#39;Special Handling&#39;, value=&#39;none&#39;,
                                                options=[(&#39;None&#39;, &#39;none&#39;), (&#39;Ringlaser&#39;, &#39;ringlaser&#39;), (&#39;Hydrophone&#39;, &#39;hydrophone&#39;)],
                                            style={&#39;description_width&#39;: &#39;initial&#39;},  layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    #remove_noise call
    generate_ppsd_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;generate_ppsds&#39; + &#39;&lt;/p&gt;&#39;, 
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    generate_ppsd_call = widgets.HTML(value=&#39;()&#39;)
    generate_ppsd_call_hbox = widgets.HBox([generate_ppsd_prefix, generate_ppsd_call])

    # Update generate_ppsds() call
    def update_generate_ppsd_call():
        gppsdkwargs = get_generate_ppsd_kwargs()
        gppsd_text = f&#34;&#34;&#34;(hvsr_data=hvsr_data, 
                        stats=hvsr_data[&#39;stream&#39;].select(component=&#39;*&#39;).traces[0].stats, 
                        metadata=hvsr_data[&#39;paz&#39;][&#39;*&#39;], 
                        skip_on_gaps={gppsdkwargs[&#39;skip_on_gaps&#39;]}, 
                        db_bins={gppsdkwargs[&#39;db_bins&#39;]}, 
                        ppsd_length={gppsdkwargs[&#39;ppsd_length&#39;]}, 
                        overlap={gppsdkwargs[&#39;overlap&#39;]}, 
                        special_handling={gppsdkwargs[&#39;special_handling&#39;]}, 
                        period_smoothing_width_octaves={gppsdkwargs[&#39;period_smoothing_width_octaves&#39;]}, 
                        period_step_octaves={gppsdkwargs[&#39;period_step_octaves&#39;]}, 
                        period_limits={gppsdkwargs[&#39;period_limits&#39;]}, 
                        verbose={verbose_check.value})&#34;&#34;&#34;
        generate_ppsd_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + gppsd_text + &#39;&lt;/p&gt;&#39;
    update_generate_ppsd_call()

    ppsd_length_hbox = widgets.HBox([ppsd_length_label, ppsd_length])
    overlap_pct_hbox = widgets.HBox([overlap_pct_label, overlap_pct])
    pstep_hbox = widgets.HBox([period_step_label, period_step_octave])
    skipgaps_hbox = widgets.HBox([skip_on_gaps_label, skip_on_gaps])
    db_bins_hbox = widgets.HBox([db_step_label, db_bins_min, db_bins_max, db_bins_step])
    plim_hbox = widgets.HBox([period_limit_label, period_limits_min, period_limits_max, period_smoothing_width])

    ppsd_settings_tab = widgets.VBox([ppsd_length_hbox,
                                      overlap_pct_hbox,
                                      pstep_hbox,
                                      skipgaps_hbox,
                                      db_bins_hbox,
                                      plim_hbox,
                                      special_handling_dropdown,
                                      generate_ppsd_call_hbox])

    # OUTLIER SETTINGS SUBTAB
    rmse_pctile_check = widgets.Checkbox(description=&#39;Using percentile&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), style={&#39;description_width&#39;: &#39;initial&#39;}, value=True)
    rmse_thresh = widgets.FloatText(description=&#39;RMSE Threshold&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=98, value=98, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    use_hv_curve_rmse = widgets.Checkbox(description=&#39;Use HV Curve Outliers (may only be used after they have been calculated during the process_hvsr() step))&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), style={&#39;description_width&#39;: &#39;initial&#39;}, value=False, disabled=True)

    outlier_threshbox_hbox = widgets.HBox(children=[rmse_thresh, rmse_pctile_check])
    outlier_params_vbox = widgets.VBox(children=[outlier_threshbox_hbox, use_hv_curve_rmse])

    global outlier_fig
    outlier_fig = go.FigureWidget()
    outlier_graph_widget = widgets.Output()

    outlier_thresh_slider_label = widgets.Label(value=&#39;RMSE Thresholds:&#39;)
    rmse_thresh_slider = widgets.FloatSlider(value=0, min=0, max=100, step=0.1,description=&#39;RMSE Value&#39;,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;),disabled=True)
    rmse_pctile_slider = widgets.FloatSlider(value=get_default(sprit_hvsr.remove_outlier_curves, &#39;rmse_thresh&#39;), min=0, max=100, step=0.1, description=&#34;Percentile&#34;,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;),)
    
    def calc_rmse(array_2d):
        medArray = np.nanmedian(array_2d, axis=0)
        rmse = np.sqrt(((np.subtract(array_2d, medArray)**2).sum(axis=1))/array_2d.shape[1])
        return rmse
    
    def on_update_rmse_thresh_slider(change):
        if use_hv_curve_rmse.value:
            rmse = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;HV_Curves&#39;]))
        else:
            rmsez = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;psd_values_Z&#39;]))
            rmsee = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;psd_values_E&#39;]))
            rmsen = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;psd_values_N&#39;]))

            rmse = np.stack([rmsez, rmsee, rmsen]).flatten()

        if rmse_pctile_check.value:
            rmse_thresh.value = rmse_pctile_slider.value
        else:
            rmse_thresh.value = rmse_thresh_slider.value
            rmse_pctile_slider.value = ((rmse &lt; rmse_thresh_slider.value).sum() / len(rmse)) * 100

    def on_update_rmse_pctile_slider(change):
        if use_hv_curve_rmse.value:
            rmse = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;HV_Curves&#39;]))
        else:
            rmsez = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;psd_values_Z&#39;]))
            rmsee = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;psd_values_E&#39;]))
            rmsen = calc_rmse(np.stack(hvsr_data.hvsr_df[&#39;psd_values_N&#39;]))

            rmse = np.stack([rmsez, rmsee, rmsen])

        if rmse_pctile_check.value:
            rmse_thresh_slider.value = np.percentile(rmse, rmse_pctile_slider.value)
            rmse_thresh.value = rmse_pctile_slider.value
        else:
            rmse_thresh.value = rmse_thresh_slider.value

    def on_update_rmse_pctile_check(change):
        if rmse_pctile_check.value:
            rmse_pctile_slider.disabled = False
            rmse_thresh_slider.disabled = True
        else:
            rmse_pctile_slider.disabled = True
            rmse_thresh_slider.disabled = False
    
    def on_update_rmse_thresh(change):
        if rmse_pctile_check.value:
            rmse_pctile_slider.value = rmse_thresh.value
        else:
            rmse_thresh_slider.value = rmse_thresh.value

    rmse_pctile_check.observe(on_update_rmse_pctile_check)
    rmse_thresh_slider.observe(on_update_rmse_thresh_slider)
    rmse_pctile_slider.observe(on_update_rmse_pctile_slider)
    rmse_thresh.observe(on_update_rmse_thresh)

    use_hv_curve_label = widgets.Label(value=&#39;NOTE: Outlier curves may only be identified after PPSDs have been calculated (during the generate_ppsds() step)&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;80%&#39;))
    generate_ppsd_button = widgets.Button(description=&#39;Generate PPSDs&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;20%&#39;, justify_content=&#39;flex-end&#39;), disabled=False)
    update_outlier_plot_button = widgets.Button(description=&#39;Remove Outliers&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;20%&#39;, justify_content=&#39;flex-end&#39;), disabled=False)
    outlier_ppsd_hbox = widgets.HBox([use_hv_curve_label, generate_ppsd_button, update_outlier_plot_button])
    remove_outlier_curve_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;remove_outlier_curves&#39; + &#39;&lt;/p&gt;&#39;, 
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    remove_outlier_curve_call = widgets.HTML(value=&#39;()&#39;)
    remove_outlier_hbox = widgets.HBox([remove_outlier_curve_prefix, remove_outlier_curve_call])

    # Update remove_outlier call
    def update_remove_outlier_curve_call():
        roc_text = f&#34;&#34;&#34;(hvsr_data=hvsr_data, rmse_thresh={rmse_thresh.value}, use_percentile={rmse_pctile_check.value},
                            use_hv_curve={use_hv_curve_rmse.value}...verbose={verbose_check.value})&#34;&#34;&#34;
        remove_outlier_curve_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + roc_text + &#39;&lt;/p&gt;&#39;
    update_remove_outlier_curve_call()

    def update_outlier_fig_button(button):
        outlier_fig, hvsr_data = update_outlier_fig(button)

    generate_ppsd_button.on_click(process_data)

    update_outlier_plot_button.on_click(update_outlier_fig_button)

    outlier_settings_tab = widgets.VBox(children=[outlier_params_vbox,
                                                  outlier_graph_widget,
                                                  outlier_thresh_slider_label,
                                                  rmse_thresh_slider,
                                                  rmse_pctile_slider,
                                                  outlier_ppsd_hbox,
                                                  remove_outlier_hbox])

    with outlier_graph_widget:
        display(outlier_fig)

    def update_outlier_fig(input=None, _rmse_thresh=rmse_pctile_slider.value, _use_percentile=True, _use_hv_curve=use_hv_curve_rmse.value, _verbose=verbose_check.value):
        global outlier_fig
        global hvsr_data
        hv_data = hvsr_data

        roc_kwargs = {&#39;rmse_thresh&#39;:rmse_pctile_slider.value,
                        &#39;use_percentile&#39;:True,
                        &#39;use_hv_curve&#39;:use_hv_curve_rmse.value,
                        &#39;show_plot&#39;:False,
                        &#39;verbose&#39;:verbose_check.value
                      }
        if &#39;PPSDStatus&#39; in hvsr_data.ProcessingStatus.keys() and hvsr_data.ProcessingStatus[&#39;PPSDStatus&#39;]:
            log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nremove_outlier_curves():\n&#39;{roc_kwargs}&#34;    
            hvsr_data = sprit_hvsr.remove_outlier_curves(hvsr_data, **roc_kwargs)
        else:
            log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nremove_outlier_curves() attempted, but not completed. hvsr_data.ProcessingStatus[&#39;PPSDStatus&#39;]=False\n&#39;{roc_kwargs}&#34;
            return outlier_fig, hvsr_data

        if roc_kwargs[&#39;use_hv_curve&#39;]:
            no_subplots = 1
            if hasattr(hvsr_data, &#39;hvsr_df&#39;) and &#39;HV_Curves&#39; in hvsr_data.hvsr_df.columns:
                outlier_fig.data = []
                outlier_fig.update_layout(grid=None)  # Clear the existing grid layout
                subp = subplots.make_subplots(rows=no_subplots, cols=1, horizontal_spacing=0.01, vertical_spacing=0.1)
                outlier_fig.update_layout(grid={&#39;rows&#39;: 1})
                outlier_fig = go.FigureWidget(subp)

                x_data = hvsr_data[&#39;x_freqs&#39;]
                curve_traces = []
                for hv in hvsr_data.hvsr_df[&#39;HV_Curves&#39;].iterrows():
                    curve_traces.append(go.Scatter(x=x_data, y=hv[1]))
                outlier_fig.add_traces(curve_traces)
                
                # Calculate a median curve, and reshape so same size as original
                medCurve = np.nanmedian(np.stack(hvsr_data.hvsr_df[&#39;HV_Curves&#39;]), axis=0)
                outlier_fig.add_trace(go.Scatter(x=x_data, y=medCurve, line=dict(color=&#39;rgba(0,0,0,1)&#39;, width=1.5),showlegend=False))
                
                minY = np.nanmin(np.stack(hvsr_data.hvsr_df[&#39;HV_Curves&#39;]))
                maxY = np.nanmax(np.stack(hvsr_data.hvsr_df[&#39;HV_Curves&#39;]))
                totalWindows = hvsr_data.hvsr_df.shape[0]
                #medCurveArr = np.tile(medCurve, (curr_data.shape[0], 1))

        else:
            no_subplots = 3
            outlier_fig.data = []
            outlier_fig.update_layout(grid=None)  # Clear the existing grid layout
            subp = subplots.make_subplots(rows=no_subplots, cols=1, horizontal_spacing=0.01, vertical_spacing=0.02,
                                                    row_heights=[1, 1, 1])
            outlier_fig.update_layout(grid={&#39;rows&#39;: 3})
            outlier_fig = go.FigureWidget(subp)

            if hasattr(hvsr_data, &#39;hvsr_df&#39;):
                rowDict = {&#39;Z&#39;:1, &#39;E&#39;:2, &#39;N&#39;:3}
                showTLabelsDict={&#39;Z&#39;:False, &#39;E&#39;:False, &#39;N&#39;:True}
                def comp_rgba(comp, a):
                    compstr = &#39;&#39;
                    if comp==&#39;Z&#39;:
                        compstr = f&#39;rgba(0, 0, 0, {a})&#39;
                    if comp==&#39;E&#39;:
                        compstr = f&#39;rgba(50, 50, 250, {a})&#39;
                    if comp==&#39;N&#39;:
                        compstr = f&#39;rgba(250, 50, 50, {a})&#39;
                    return compstr                         
                compNames = [&#39;Z&#39;, &#39;E&#39;, &#39;N&#39;]
                rmse_to_plot=[]
                med_traces=[]

                noRemoved = 0
                indRemoved = []
                for i, comp in enumerate(compNames):
                    if hasattr(hvsr_data, &#39;x_freqs&#39;):
                        x_data = hvsr_data[&#39;x_freqs&#39;][comp]
                    else:
                        x_data = [1/p for p in hvsr_data[&#39;ppsds&#39;][comp][&#39;period_xedges&#39;][1:]]                    
                    column = &#39;psd_values_&#39;+comp
                    # Retrieve data from dataframe (use all windows, just in case)
                    curr_data = np.stack(hvsr_data[&#39;hvsr_df&#39;][column])
                    
                    # Calculate a median curve, and reshape so same size as original
                    medCurve = np.nanmedian(curr_data, axis=0)
                    medCurveArr = np.tile(medCurve, (curr_data.shape[0], 1))
                    medTrace = go.Scatter(x=x_data, y=medCurve, line=dict(color=comp_rgba(comp, 1), width=1.5), 
                                                 name=f&#39;{comp} Component&#39;, showlegend=True)
                    # Calculate RMSE
                    rmse = np.sqrt(((np.subtract(curr_data, medCurveArr)**2).sum(axis=1))/curr_data.shape[1])

                    rmse_threshold = np.percentile(rmse, roc_kwargs[&#39;rmse_thresh&#39;])
                    
                    # Retrieve index of those RMSE values that lie outside the threshold
                    timeIndex = hvsr_data[&#39;hvsr_df&#39;].index
                    for j, curve in enumerate(curr_data):
                        if rmse[j] &gt; rmse_threshold:
                            badTrace = go.Scatter(x=x_data, y=curve,
                                                line=dict(color=comp_rgba(comp, 1), width=1.5, dash=&#39;dash&#39;),
                                                #marker=dict(color=comp_rgba(comp, 1), size=3),
                                                name=str(hvsr_data.hvsr_df.index[j]), showlegend=False)
                            outlier_fig.add_trace(badTrace, row=rowDict[comp], col=1)
                            if j not in indRemoved:
                                indRemoved.append(j)
                            noRemoved += 1
                        else:
                            goodTrace = go.Scatter(x=x_data, y=curve,
                                                  line=dict(color=comp_rgba(comp, 0.01)), name=str(hvsr_data.hvsr_df.index[j]), showlegend=False)
                            outlier_fig.add_trace(goodTrace, row=rowDict[comp], col=1)

                    timeIndRemoved = pd.DatetimeIndex([timeIndex[ind] for ind in indRemoved])
                    hvsr_data[&#39;hvsr_df&#39;].loc[timeIndRemoved, &#39;Use&#39;] = False

                    outlier_fig.add_trace(medTrace, row=rowDict[comp], col=1)
                    
                    outlier_fig.update_xaxes(showticklabels=False, row=1, col=1)
                    outlier_fig.update_yaxes(title={&#39;text&#39;:&#39;Z&#39;}, row=1, col=1)
                    outlier_fig.update_xaxes(showticklabels=False, row=2, col=1)
                    outlier_fig.update_yaxes(title={&#39;text&#39;:&#39;E&#39;}, row=2, col=1)
                    outlier_fig.update_xaxes(showticklabels=True, row=3, col=1)
                    outlier_fig.update_yaxes(title={&#39;text&#39;:&#39;N&#39;}, row=3, col=1)

                    outlier_fig.update_layout(margin={&#34;l&#34;:10, &#34;r&#34;:10, &#34;t&#34;:30, &#39;b&#39;:0}, showlegend=True,
                                  title=f&#34;{hvsr_data[&#39;site&#39;]} Outliers&#34;)
                    if comp == &#39;N&#39;:
                        minY = np.nanmin(curr_data)
                        maxY = np.nanmax(curr_data)
                    totalWindows = curr_data.shape[0]
                
                outlier_fig.add_annotation(
                    text=f&#34;{len(indRemoved)}/{totalWindows} outlier windows removed&#34;,
                    x=np.log10(max(x_data)) - (np.log10(max(x_data))-np.log10(min(x_data))) * 0.01,
                    y=minY+(maxY-minY)*0.01,
                    xanchor=&#34;right&#34;, yanchor=&#34;bottom&#34;,#bgcolor=&#39;rgba(256,256,256,0.7)&#39;,
                    showarrow=False,row=no_subplots, col=1)


        outlier_fig.update_xaxes(type=&#39;log&#39;)
        with outlier_graph_widget:
            clear_output(wait=True)
            display(outlier_fig)
        
        if show_plot_check.value:
            outlier_fig.show()

        return outlier_fig, hvsr_data

    # HVSR SETTINGS SUBTAB
    h_combine_meth = widgets.Dropdown(description=&#39;Horizontal Combination Method&#39;, value=3,
                                    options=[(&#39;1. Differential Field Assumption (not implemented)&#39;, 1), 
                                             (&#39;2. Arithmetic Mean |  H = (N + E)/2&#39;, 2), 
                                             (&#39;3. Geometric Mean | H = (N * E) (SESAME recommended)&#39;, 3),
                                             (&#39;4. Vector Summation | H = (N^2 + E^2)&#39;, 4),
                                             (&#39;5. Quadratic Mean | H = (N^2 + E^2)/2&#39;, 5),
                                             (&#39;6. Maximum Horizontal Value | H = max(N, E)&#39;, 6)],
                                    style={&#39;description_width&#39;: &#39;initial&#39;},  layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    freq_smoothing = widgets.Dropdown(description=&#39;Frequency Smoothing Operations&#39;, value=&#39;konno ohmachi&#39;,
                                    options=[(&#39;Konno-Ohmachi&#39;, &#39;konno ohmachi&#39;),
                                             (&#39;Constant&#39;,&#39;constant&#39;),
                                             (&#39;Proportional&#39;, &#39;proportional&#39;),
                                             (&#39;None&#39;, None)],
                                    style={&#39;description_width&#39;: &#39;initial&#39;},  layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    freq_smooth_width = widgets.FloatText(description=&#39;Freq. Smoothing Width&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=40, value=40, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    resample_hv_curve_bool = widgets.Checkbox(layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), style={&#39;description_width&#39;: &#39;initial&#39;}, value=True)
    resample_hv_curve = widgets.IntText(description=&#39;Resample H/V Curve&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=500, value=500, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    smooth_hv_curve_bool = widgets.Checkbox(layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), style={&#39;description_width&#39;: &#39;initial&#39;}, value=True)
    smooth_hv_curve = widgets.IntText(description=&#39;Smooth H/V Curve&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=51, value=51, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    hvsr_band_hbox_hvsrSet = widgets.HBox([hvsr_band_min_box, hvsr_band_max_box],layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))

    peak_freq_range_hbox_hvsrSet = widgets.HBox([peak_freq_range_min_box, peak_freq_range_max_box],layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))

    peak_selection_type = widgets.Dropdown(description=&#39;Peak Selection Method&#39;, value=&#39;max&#39;,
                                    options=[(&#39;Highest Peak&#39;, &#39;max&#39;),
                                             (&#39;Best Scored&#39;,&#39;scored&#39;)],
                                    style={&#39;description_width&#39;: &#39;initial&#39;},  layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    process_hvsr_call_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;process_hvsr&#39; + &#39;&lt;/p&gt;&#39;, 
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;, align_content=&#39;flex-start&#39;))
    process_hvsr_call = widgets.HTML(value=&#39;()&#39;)
    process_hvsr_call_hbox = widgets.HBox([process_hvsr_call_prefix, process_hvsr_call])

    # Update process_hvsr call
    def update_process_hvsr_call():
        ph_kwargs = get_process_hvsr_kwargs()
        ph_text = f&#34;&#34;&#34;(hvsr_data=hvsr_data, 
                        method={ph_kwargs[&#39;method&#39;]}, 
                        smooth={ph_kwargs[&#39;smooth&#39;]}, 
                        freq_smooth={ph_kwargs[&#39;freq_smooth&#39;]}, 
                        f_smooth_width={ph_kwargs[&#39;f_smooth_width&#39;]}, 
                        resample={ph_kwargs[&#39;resample&#39;]}, 
                        outlier_curve_rmse_percentile={ph_kwargs[&#39;outlier_curve_rmse_percentile&#39;]}, 
                        verbose={verbose_check.value})&#34;&#34;&#34;
        process_hvsr_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + ph_text + &#39;&lt;/p&gt;&#39;
    update_process_hvsr_call()

    check_peaks_call_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39;+&#39;check_peaks&#39; + &#39;&lt;/p&gt;&#39;,
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    check_peaks_call = widgets.HTML(value=&#39;()&#39;)
    check_peaks_call_hbox = widgets.HBox([check_peaks_call_prefix, check_peaks_call])

    # Update process_hvsr call
    def update_check_peaks_call():
        cp_kwargs = get_check_peaks_kwargs()
        cp_text = f&#34;&#34;&#34;(hvsr_data=hvsr_data, 
                        hvsr_band={cp_kwargs[&#39;hvsr_band&#39;]}, 
                        peak_selection={cp_kwargs[&#39;peak_selection&#39;]}, 
                        peak_freq_range={cp_kwargs[&#39;peak_freq_range&#39;]}, 
                        verbose={verbose_check.value})&#34;&#34;&#34;
        check_peaks_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + cp_text + &#39;&lt;/p&gt;&#39;
    update_check_peaks_call()

    freq_smooth_hbox = widgets.HBox([freq_smoothing, freq_smooth_width])
    resample_hbox = widgets.HBox([resample_hv_curve_bool, resample_hv_curve])
    smooth_hbox = widgets.HBox([smooth_hv_curve_bool, smooth_hv_curve])
    
    # Set up vbox for hvsr_settings subtab
    hvsr_settings_tab = widgets.VBox([h_combine_meth,
                                    freq_smooth_hbox,
                                    resample_hbox,
                                    smooth_hbox,
                                    hvsr_band_hbox_hvsrSet,
                                    peak_freq_range_hbox_hvsrSet,
                                    peak_selection_type,
                                    process_hvsr_call_hbox,
                                    check_peaks_call_hbox])

    # PLOT SETTINGS SUBTAB
    hv_plot_label = widgets.Label(value=&#39;HVSR Plot&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;))
    component_plot_label = widgets.Label(value=&#39;Component Plot&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;))
    spec_plot_label = widgets.Label(value=&#39;Spectrogram Plot&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;))

    use_plot_label = widgets.Label(value=&#39;Use Plot&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    use_plot_hv = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    use_plot_comp = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    use_plot_spec = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    comibne_plot_label = widgets.Label(value=&#39;Combine HV and Comp. Plot&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    combine_hv_comp = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    show_peak_label = widgets.Label(value=&#39;Show Best Peak&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_best_peak_hv = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_best_peak_comp = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_best_peak_spec = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    annotate_peak_label = widgets.Label(value=&#39;Annotate Best Peak&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    ann_best_peak_hv = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    ann_best_peak_comp = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    ann_best_peak_spec = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    show_all_peaks_label = widgets.Label(value=&#39;Show All Peaks&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_all_peaks_hv = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    show_all_curves_label = widgets.Label(value=&#39;Show All Curves&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_all_curves_hv = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_all_curves_comp = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    show_ind_peaks_label = widgets.Label(value=&#39;Show Individual Peaks&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_ind_peaks_hv = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_ind_peaks_spec = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                       style={&#39;description_width&#39;: &#39;initial&#39;})

    show_std_label = widgets.Label(value=&#39;Show Standard Deviation&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_std_hv = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_std_comp = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    show_legend_label = widgets.Label(value=&#39;Show Legend&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_legend_hv = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_legend_comp = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_legend_spec = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    x_type_label = widgets.Label(value=&#39;X Type&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    x_type = widgets.Dropdown(options=[(&#39;Frequency&#39;, &#39;freq&#39;), (&#39;Period&#39;, &#39;period&#39;)],
                              layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), style={&#39;description_width&#39;: &#39;initial&#39;})

    plotly_kwargs_label = widgets.Label(value=&#39;Plotly Kwargs&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    plotly_kwargs = widgets.Text(style={&#39;description_width&#39;: &#39;initial&#39;},
                                layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    mpl_kwargs_label = widgets.Label(value=&#39;Matplotlib Kwargs&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    mpl_kwargs = widgets.Text(style={&#39;description_width&#39;: &#39;initial&#39;},
                                layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    plot_hvsr_call = widgets.Label(value=f&#34;Plot String: &#39;{get_default(sprit_hvsr.get_report, &#39;plot_type&#39;)}&#39;&#34;)
    def update_plot_string():
        plot_hvsr_text = f&#34;&#34;&#34;Plot String: {get_get_report_kwargs()[&#39;plot_type&#39;]}&#34;&#34;&#34;
        plot_hvsr_call.value = plot_hvsr_text
    update_plot_string()

    update_plot_button = widgets.Button(description=&#39;Update Plot&#39;,button_style=&#39;info&#39;,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    def manually_update_results_fig(change):
        plot_string = get_get_report_kwargs()[&#39;plot_type&#39;]
        update_results_fig(hvsr_results, plot_string)
        sprit_tabs.selected_index = 4

    # Set up grid for ppsd_settings subtab
    plot_settings_tab[0, 5:10]   = hv_plot_label
    plot_settings_tab[0, 10:15]  = component_plot_label
    plot_settings_tab[0, 15:] = spec_plot_label

    plot_settings_tab[1, :] = widgets.HTML(&#39;&lt;hr&gt;&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;))

    plot_settings_tab[2, :5] = use_plot_label
    plot_settings_tab[2, 5:10] = use_plot_hv
    plot_settings_tab[2, 10:15] = use_plot_comp
    plot_settings_tab[2, 15:] = use_plot_spec

    plot_settings_tab[3, :] = widgets.HTML(&#39;&lt;hr&gt;&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;))

    plot_settings_tab[4, :5] = comibne_plot_label
    plot_settings_tab[4, 10:15] = combine_hv_comp

    plot_settings_tab[5, :5] = show_peak_label
    plot_settings_tab[5, 5:10] = show_best_peak_hv
    plot_settings_tab[5, 10:15] = show_best_peak_comp
    plot_settings_tab[5, 15:] = show_best_peak_spec

    plot_settings_tab[6, :5] = annotate_peak_label
    plot_settings_tab[6, 5:10] = ann_best_peak_hv
    plot_settings_tab[6, 10:15] = ann_best_peak_comp
    plot_settings_tab[6, 15:] = ann_best_peak_spec

    plot_settings_tab[7, :5] = show_all_peaks_label
    plot_settings_tab[7, 5:10] = show_all_peaks_hv

    plot_settings_tab[8, :5] = show_all_curves_label
    plot_settings_tab[8, 5:10] = show_all_curves_hv
    plot_settings_tab[8, 10:15] = show_all_curves_comp

    plot_settings_tab[9, :5] = show_ind_peaks_label
    plot_settings_tab[9, 5:10] = show_ind_peaks_hv
    plot_settings_tab[9, 15:] = show_ind_peaks_spec
   
    plot_settings_tab[10, :5] = show_std_label
    plot_settings_tab[10, 5:10] = show_std_hv
    plot_settings_tab[10, 10:15] = show_std_comp

    plot_settings_tab[11, :5] = show_legend_label
    plot_settings_tab[11, 5:10] = show_legend_hv
    plot_settings_tab[11, 10:15] = show_legend_comp
    plot_settings_tab[11, 15:] = show_legend_spec

    plot_settings_tab[12, :] = widgets.HTML(&#39;&lt;hr&gt;&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;))

    plot_settings_tab[13, :5] = x_type_label
    plot_settings_tab[13, 6:] = x_type

    plot_settings_tab[14, :5] = plotly_kwargs_label
    plot_settings_tab[14, 6:] = plotly_kwargs

    plot_settings_tab[15, :5] = mpl_kwargs_label
    plot_settings_tab[15, 6:] = mpl_kwargs

    plot_settings_tab[16, :] = widgets.HTML(&#39;&lt;hr&gt;&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;))

    plot_settings_tab[17, :18] = plot_hvsr_call
    plot_settings_tab[17, 18:] = update_plot_button
    update_plot_button.on_click(manually_update_results_fig)

    # Place everything in Settings Tab
    settings_subtabs = widgets.Tab([ppsd_settings_tab, hvsr_settings_tab, outlier_settings_tab, plot_settings_tab])
    settings_tab = widgets.VBox(children=[settings_subtabs, settings_progress_hbox])
    settings_subtabs.set_title(0, &#34;PPSD Settings&#34;)
    settings_subtabs.set_title(1, &#34;HVSR Settings&#34;)
    settings_subtabs.set_title(2, &#34;Outlier Settings&#34;)
    settings_subtabs.set_title(3, &#34;Plot Settings&#34;)

    # LOG TAB - not currently using
    log_tab = widgets.VBox(children=[log_textArea])
    #log_textArea = widgets.Textarea(value=&#34;SESSION LOG&#34;, disabled=True, layout={&#39;height&#39;: &#39;99%&#39;,&#39;width&#39;: &#39;99%&#39;, &#39;overflow&#39;: &#39;scroll&#39;})

    # RESULTS TAB
    # PLOT SUBTAB
    subp = subplots.make_subplots(rows=3, cols=1, horizontal_spacing=0.01, vertical_spacing=0.01, row_heights=[2,1,1])
    results_fig = go.FigureWidget(subp)
    global results_graph_widget
    results_graph_widget = widgets.Output()   

    with results_graph_widget:
        display(results_fig)

    global printed_results_textArea
    printed_results_textArea = widgets.Textarea(value=&#34;RESULTS&#34;, disabled=True, layout={&#39;height&#39;: &#39;500px&#39;,&#39;width&#39;: &#39;99%&#39;, &#39;overflow&#39;: &#39;scroll&#39;})

    global results_table
    initialTableCols=[&#39;SiteName&#39;, &#39;Acq_Date&#39;, &#39;Longitude&#39;, &#39;Latitude&#39;, &#39;Elevation&#39;,
                      &#39;PeakFrequency&#39;, &#39;WindowLengthFreq.&#39;, &#39;SignificantCycles&#39;, &#39;LowCurveStDevOverTime&#39;, 
                      &#39;PeakProminenceBelow&#39;, &#39;PeakProminenceAbove&#39;, &#39;PeakAmpClarity&#39;, 
                      &#39;FreqStability&#39;, &#39;PeakStability_FreqStD&#39;, &#39;PeakStability_AmpStD&#39;, &#39;PeakPasses&#39;]
    results_table = widgets.HTML(value=pd.DataFrame(columns=initialTableCols).to_html())

    # A text box labeled Data Filepath
    export_results_table_filepath = widgets.Text(description=&#39;Export Filepath:&#39;,
                                    placeholder=&#39;&#39;, value=&#39;&#39;,
                                    style={&#39;description_width&#39;: &#39;initial&#39;},layout=widgets.Layout(width=&#39;90%&#39;))

    export_results_table_read_button = widgets.Button(description=&#39;&#39;, icon=&#39;fa-file-import&#39;,button_style=&#39;success&#39;,
                                            layout=widgets.Layout(width=&#39;10%&#39;))
    export_results_table_browse_button = widgets.Button(description=&#39;Export Table&#39;,
                                            layout=widgets.Layout(width=&#39;10%&#39;))
    def export_results_table(button):
        try:
            if button.value == &#39;Export Table&#39;:
                root = tk.Tk()
                root.wm_attributes(&#39;-topmost&#39;, True)
                root.withdraw()
                export_results_table_filepath.value = str(filedialog.asksaveasfilename(defaultextension=&#39;.csv&#39;, title=&#39;Save CSV Report&#39;))
                root.destroy()
        except Exception as e:
            print(e)
            export_results_table_browse_button.disabled=True
            export_results_table_browse_button.description=&#39;Use Text Field&#39;

        out_path = export_results_table_filepath.value
        sprit_hvsr.get_report(hvsr_results, report_format=&#39;csv&#39;, export_path=out_path,
                              csv_overwrite_opt=&#39;overwrite&#39;)

    export_results_table_browse_button.on_click(export_results_table)
    export_results_table_read_button.on_click(export_results_table)

    results_table_export_hbox = widgets.HBox([export_results_table_filepath, export_results_table_read_button, export_results_table_browse_button])
    results_table_vbox = widgets.VBox([results_table, results_table_export_hbox])
    global results_tab
    results_subtabs = widgets.Tab([results_graph_widget, printed_results_textArea, results_table_vbox])
    results_tab = widgets.VBox(children=[results_subtabs])
    results_subtabs.set_title(0, &#34;Plot&#34;)
    results_subtabs.set_title(1, &#34;Peak Tests&#34;)
    results_subtabs.set_title(2, &#34;Peak Table&#34;)

    widget_param_dict = {
        &#39;fetch_data&#39;: 
            {&#39;source&#39;: data_source_type,
            &#39;trim_dir&#39;: trim_directory,
            &#39;export_format&#39;: trim_export_dropdown,
            &#39;detrend&#39;: detrend_type_dropdown,
            &#39;detrend_order&#39;: detrend_order,
            &#39;verbose&#39;: verbose_check},
        &#39;remove_noise&#39;: 
            {
            &#39;sat_percent&#39;: max_saturation_pct,
            &#39;noise_percent&#39;: max_window_pct,
            &#39;sta&#39;: sta,
            &#39;lta&#39;: lta,
            &#39;stalta_thresh&#39;: [stalta_thresh_low, stalta_thresh_hi],
            &#39;warmup_time&#39;: warmup_time,
            &#39;cooldown_time&#39;: cooldown_time,
            &#39;min_win_size&#39;: noisy_window_length,
            &#39;remove_raw_noise&#39;: raw_data_remove_check,
            &#39;verbose&#39;: verbose_check},
        &#39;generate_ppsds&#39;: 
            {&#39;verbose&#39;: verbose_check,
             &#39;skip_on_gaps&#39;:skip_on_gaps, 
             &#39;db_bins&#39;:[db_bins_min, db_bins_max, db_bins_step],
             &#39;ppsd_length&#39;:ppsd_length, 
             &#39;overlap&#39;:overlap_pct, 
             &#39;special_handling&#39;:special_handling_dropdown, 
             &#39;period_smoothing_width_octaves&#39;:period_smoothing_width, 
             &#39;period_step_octaves&#39;:period_step_octave, 
             &#39;period_limits&#39;:[hvsr_band_min_box, hvsr_band_max_box]},
        &#39;process_hvsr&#39;: 
            {&#39;method&#39;: h_combine_meth,
            &#39;smooth&#39;: smooth_hv_curve,
            &#39;freq_smooth&#39;: freq_smoothing,
            &#39;f_smooth_width&#39;: freq_smooth_width,
            &#39;resample&#39;: resample_hv_curve,
            &#39;verbose&#39;: verbose_check},
        &#39;remove_outlier_curves&#39;: 
            {&#39;rmse_thresh&#39;: rmse_thresh,
            &#39;use_percentile&#39;: rmse_pctile_check,
            &#39;use_hv_curve&#39;: use_hv_curve_rmse,
            &#39;verbose&#39;: verbose_check},
        &#39;check_peaks&#39;: 
            {&#39;hvsr_band&#39;: [hvsr_band_min_box, hvsr_band_max_box],
            &#39;peak_freq_range&#39;: [peak_freq_range_min_box, peak_freq_range_max_box],
            &#39;verbose&#39;: verbose_check},
        &#39;get_report&#39;: 
            {
            &#39;export_path&#39;: export_results_table_filepath,
            &#39;verbose&#39;: verbose_check}}

    # SPRIT WIDGET
    # Add all  a tab and add the grid to it
    global sprit_tabs
    sprit_tabs = widgets.Tab([input_tab, preview_tab, settings_tab, log_tab, results_tab])
    sprit_tabs.set_title(0, &#34;Input&#34;)
    sprit_tabs.set_title(1, &#34;Preview&#34;)
    sprit_tabs.set_title(2, &#34;Settings&#34;)
    sprit_tabs.set_title(3, &#34;Log&#34;)
    sprit_tabs.set_title(4, &#34;Results&#34;)

    sprit_title = widgets.Label(value=&#39;SPRIT&#39;, layout=widgets.Layout(width=&#39;150px&#39;))
    sprit_subtitle = widgets.Label(value=&#39;Tools for ambient siesmic noise analysis using HVSR&#39;,
                                   layout=widgets.Layout(flex=&#39;1&#39;, justify_content=&#39;flex-start&#39;, align_content=&#39;flex-end&#39;))

    # Function to open a link
    def open_dist(button):
        link = &#39;https://pypi.org/project/sprit/&#39;
        webbrowser.open_new_tab(link)

    def open_repo(button):
        link = &#39;https://github.com/RJbalikian/SPRIT-HVSR&#39;
        webbrowser.open_new_tab(link)

    def open_docs(button):
        link = &#39;https://rjbalikian.github.io/SPRIT-HVSR/main.html&#39;
        webbrowser.open_new_tab(link)


    sourcebutton = widgets.Button(description=&#34;PyPI&#34;,
                                layout=widgets.Layout(width=&#39;4%&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-end&#39;))
    repobutton = widgets.Button(description=&#34;Repo&#34;,
                                layout=widgets.Layout(width=&#39;4%&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-end&#39;))
    docsbutton = widgets.Button(description=&#34;Docs&#34;,
                                layout=widgets.Layout(width=&#39;8%&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-end&#39;))

    # Attach the open_link function to the button&#39;s on_click event
    sourcebutton.on_click(open_dist)
    repobutton.on_click(open_repo)
    docsbutton.on_click(open_docs)

    titlehbox = widgets.HBox([sprit_title, sprit_subtitle, repobutton, sourcebutton, docsbutton],
                            layout = widgets.Layout(align_content=&#39;space-between&#39;))
    
    title_style = {
        &#39;font_family&#39;: &#39;Arial, sans-serif&#39;,
        &#39;font_size&#39;: &#39;36px&#39;,
        &#39;font_weight&#39;: &#39;bold&#39;,
        &#39;color&#39;: &#39;black&#39;
    }

    # Apply the style to the label
    sprit_title.style = title_style

    sprit_widget = widgets.VBox([titlehbox, sprit_tabs])

    def observe_children(widget, callback):
        if hasattr(widget, &#39;children&#39;):
            for child in widget.children:
                child.observe(callback)
                observe_children(child, callback)

    def any_update(change):
        update_input_param_call()
        update_fetch_data_call()
        update_remove_noise_call()
        update_generate_ppsd_call()
        update_process_hvsr_call()
        update_remove_outlier_curve_call()
        update_check_peaks_call()
        update_plot_string()

    observe_children(sprit_tabs, any_update)

    # Display the tab
    display(sprit_widget)</code></pre>
</details>
</dd>
<dt id="sprit.sprit_jupyter_UI.get_default"><code class="name flex">
<span>def <span class="ident">get_default</span></span>(<span>func, param)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_default(func, param):
    return inspect.signature(func).parameters[param].default</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sprit" href="index.html">sprit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sprit.sprit_jupyter_UI.create_jupyter_ui" href="#sprit.sprit_jupyter_UI.create_jupyter_ui">create_jupyter_ui</a></code></li>
<li><code><a title="sprit.sprit_jupyter_UI.get_default" href="#sprit.sprit_jupyter_UI.get_default">get_default</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>