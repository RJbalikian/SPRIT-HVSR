<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>sprit.sprit_tkinter_ui API documentation</title>
<meta name="description" content="This script contains all the functions, classes, etc. to create a tkinter app for graphical user interface.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sprit.sprit_tkinter_ui</code></h1>
</header>
<section id="section-intro">
<p>This script contains all the functions, classes, etc. to create a tkinter app for graphical user interface.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sprit.sprit_tkinter_ui.on_closing"><code class="name flex">
<span>def <span class="ident">on_closing</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprit.sprit_tkinter_ui.reboot_app"><code class="name flex">
<span>def <span class="ident">reboot_app</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Restarts the current program.
Note: this function does not return. Any cleanup action (like
saving data) must be done before calling this function.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sprit.sprit_tkinter_ui.SPRIT_App"><code class="flex name class">
<span>class <span class="ident">SPRIT_App</span></span>
<span>(</span><span>master)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SPRIT_App:
    global spritApp
    def __init__(self, master):
        self.master = master
        self.master.title(&#34;SPRIT&#34;)
        self.params = sprit_hvsr.HVSRData({&#39;site&#39;:&#39;&#39;})

        # Set the theme
        self.darkthemepath = pathlib.Path(pkg_resources.resource_filename(__name__, &#34;resources/themes/forest-dark.tcl&#34;))
        self.lightthemepath = pathlib.Path(pkg_resources.resource_filename(__name__, &#34;resources/themes/forest-light.tcl&#34;))
        

        
        # Create the style object
        self.style = ttk.Style(master)
        #
        #self.style.theme_use(&#39;forest-light&#39;)

        self.create_menubar()
        self.create_tabs()

        self.master.rowconfigure(0, weight=1)
        self.master.columnconfigure(0, weight=1)        


        if &#39;forest&#39; in current_theme_name:
            if &#39;light&#39; in current_theme_name:
                self.master.tk.call(&#39;source&#39;, self.lightthemepath)
            else:
                self.master.tk.call(&#39;source&#39;, self.darkthemepath)
        else:
            self.style.theme_use(current_theme_name)
        # Create the dark theme
        #self.style.theme_create(&#34;dark&#34;, parent=&#34;alt&#34;, settings={
        #    &#34;TLabel&#34;: {&#34;configure&#34;: {&#34;background&#34;: &#34;black&#34;, &#34;foreground&#34;: &#34;white&#34;}},
        #    &#34;TButton&#34;: {&#34;configure&#34;: {&#34;background&#34;: &#34;black&#34;, &#34;foreground&#34;: &#34;white&#34;}},
        #    # Add more options here to style other widgets
        #})
        
        # Create the light theme
        #self.style.theme_create(&#34;light&#34;, parent=&#34;alt&#34;, settings={
        #    &#34;TLabel&#34;: {&#34;configure&#34;: {&#34;background&#34;: &#34;white&#34;, &#34;foreground&#34;: &#34;black&#34;}},
        #    &#34;TButton&#34;: {&#34;configure&#34;: {&#34;background&#34;: &#34;white&#34;, &#34;foreground&#34;: &#34;black&#34;}},
        #    # Add more options here to style other widgets
        #})

    #Method to log error message
    def log_errorMsg(self, logMsg):

        self.log_text.insert(&#39;end&#39;, logMsg)
        self.tab_control.select(self.log_tab)

    #Not currently working
    def manual_label_update(self):
        for notebook in self.master.winfo_children():
            if isinstance(notebook, ttk.Notebook):
                for tab_id in notebook.tabs():
                    tab_frame = notebook.nametowidget(tab_id)

                    for frame in tab_frame.winfo_children():
                        if isinstance(frame, ttk.LabelFrame):
                            for widget in frame.winfo_children():
                                if isinstance(widget, ttk.Label):
                                    # apply the updated style to the label
                                    
                                    self.style.layout(&#39;CustTLabel&#39;, [(&#39;Label.border&#39;, {&#39;sticky&#39;: &#39;nswe&#39;, &#39;border&#39;: &#39;1&#39;, &#39;children&#39;: [(&#39;Label.padding&#39;, {&#39;sticky&#39;: &#39;nswe&#39;, &#39;children&#39;: [(&#39;Label.text&#39;, {&#39;sticky&#39;: &#39;nswe&#39;})]})]})])
                                    self.style.configure(&#39;CustTLabel&#39;, background=self.style.lookup(&#39;style&#39;, &#39;background&#39;), foreground=self.style.lookup(&#39;style&#39;, &#39;background&#39;))
                                    self.style.map(&#39;CustTLabel&#39;, {&#39;priority&#39;:[(&#39;CustTLabel&#39;,1)]})
                                    widget.configure(style=&#39;CustTLabel&#39;)

    def create_menubar(self):
        self.menubar = tk.Menu(self.master)
        self.master.config(menu=self.menubar)
        
        self.sprit_menu = tk.Menu(self.menubar, tearoff=0)

        def on_theme_select():
            # Set the theme based on the selected value
            self.style = ttk.Style()

            #Update the theme file so the new theme opens on reboot
            prev_theme = curr_gui_dict[&#39;theme_name&#39;]
            curr_gui_dict[&#39;theme_name&#39;] = self.theme_var.get()
            with open(gui_theme_file, &#39;w&#39;) as f:
                json.dump(curr_gui_dict, f)

            def apply_theme():
                if &#39;forest&#39; in self.theme_var.get():
                    if self.theme_var.get()==&#39;forest-dark&#39; and &#39;forest-dark&#39; not in self.style.theme_names():
                        self.master.tk.call(&#39;source&#39;, self.darkthemepath)
                    elif self.theme_var.get()==&#39;forest-light&#39; and &#39;forest-light&#39; not in self.style.theme_names():
                        self.master.tk.call(&#39;source&#39;, self.lightthemepath)            
                self.master.tk.call(&#34;ttk::style&#34;, &#34;theme&#34;, &#34;use&#34;, self.theme_var.get())

            if curr_gui_dict[&#39;theme_name&#39;]==&#39;forest-light&#39; or curr_gui_dict[&#39;theme_name&#39;] == &#39;forest-dark&#39;:
                do_reboot = messagebox.askyesno(&#39;App Restart Required&#39;, 
                                             f&#34;It is recommended to restart the SpRIT GUI at this time to apply this theme. If not, you may continue but theme errors may occur. Click No to retain current theme ({prev_theme}) \nReboot now?&#34;,
                                             )
                print(do_reboot)
                if do_reboot:
                    reboot_app()
                else:
                    self.theme_var.set(prev_theme)
            else:
                apply_theme()

            &#34;&#34;&#34;An attempt to get the backgrounds right
            def apply_to_all_children(widget, func):
                Recursively apply a function to all child widgets of a given widget
                children = widget.winfo_children()
                for child in children:
                    func(child)
                    apply_to_all_children(child, func)
                return

            def change_background_color(widget):
                if isinstance(widget, tk.Label):
                    widget.option_clear()
                    widget.configure(background=None, foreground=None)
                return
            
            apply_to_all_children(self.master, change_background_color)
            &#34;&#34;&#34;

            #self.master.tk.call(&#34;ttk::setTheme&#34;, self.theme_var.get())

            #self.style.theme_use(self.theme_var.get())
            #self.master.tk.call(&#39;source&#39;, self.lightthemepath)
            #self.style.theme_use(self.theme_var.get())
            #self.style.configure(&#34;TLabel&#34;, background=self.style.lookup(&#39;TLabel&#39;, &#39;background&#39;), foreground=self.style.lookup(&#39;TLabel&#39;, &#39;background&#39;))

        def import_parameters(self):
            filepath = filedialog.askopenfilename()
        
        
        def export_parameters(self):
            filepath = filedialog.asksaveasfilename()

        self.theme_menu = tk.Menu(self.menubar, tearoff=0)
        self.theme_var = tk.StringVar(value=current_theme_name)
        self.theme_menu.add_radiobutton(label=&#34;Default&#34;, variable=self.theme_var, value=&#34;default&#34;, command=on_theme_select)
        self.theme_menu.add_radiobutton(label=&#34;Clam&#34;, variable=self.theme_var, value=&#34;clam&#34;, command=on_theme_select)
        self.theme_menu.add_radiobutton(label=&#34;Alt&#34;, variable=self.theme_var, value=&#34;alt&#34;, command=on_theme_select)
        self.theme_menu.add_radiobutton(label=&#34;Forest Light (buggy)&#34;, variable=self.theme_var, value=&#34;forest-light&#34;, command=on_theme_select)
        self.theme_menu.add_radiobutton(label=&#34;Forest Dark (buggy)&#34;, variable=self.theme_var, value=&#34;forest-dark&#34;, command=on_theme_select)

        self.sprit_menu.add_cascade(label=&#34;Theme&#34;, menu=self.theme_menu)
        self.sprit_menu.add_command(label=&#34;Import Parameters&#34;, command=import_parameters)
        self.sprit_menu.add_command(label=&#34;Export Parameters&#34;, command=export_parameters)
        self.sprit_menu.add_separator()
        self.sprit_menu.add_command(label=&#34;Exit&#34;, command=self.master.quit)
        self.settings_menu = tk.Menu(self.menubar, tearoff=0)
        self.instrument_menu = tk.Menu(self.settings_menu, tearoff=0)
        self.instrument_var = tk.StringVar(value=&#34;Raspberry Shake&#34;)
        self.instrument_menu.add_radiobutton(label=&#34;Raspberry Shake&#34;, variable=self.instrument_var, value=&#34;Raspberry Shake&#34;)
        self.instrument_menu.add_radiobutton(label=&#34;Tromino&#34;, variable=self.instrument_var, value=&#34;Tromino&#34;)
        self.instrument_menu.add_radiobutton(label=&#34;Other&#34;, variable=self.instrument_var, value=&#34;Other&#34;)
        self.settings_menu.add_cascade(label=&#34;Instrument&#34;, menu=self.instrument_menu)
        self.settings_menu.add_command(label=&#34;Processing Settings&#34;, command=lambda: self.tab_control.select(self.settings_tab))

        self.menubar.add_cascade(label=&#34;SPRIT&#34;, menu=self.sprit_menu)
        self.menubar.add_cascade(label=&#34;Settings&#34;, menu=self.settings_menu)
    
    def create_tabs(self):
        self.style = ttk.Style(self.master)

        self.tab_control = ttk.Notebook(self.master)

        # INPUT TAB
        self.input_tab = ttk.Frame(self.tab_control)

        # Configure the row and column of the input_tab to have a non-zero weight
        hvsrFrame = ttk.LabelFrame(self.input_tab, text=&#34;Input Parameters&#34;)
        #hvsrFrame.rowconfigure(0, weight=1)
        hvsrFrame.columnconfigure(1, weight=1)

        # Logo and Site Name
        # Replace &#34;logo.png&#34; with the path to your logo image
        #self.logo = tk.PhotoImage(file=&#34;logo.png&#34;)
        #self.logo_label = ttk.Label(hvsrFrame, image=self.logo)
        #self.logo_label.grid(row=0, column=0)
        self.processingData = False

        
        def update_input_labels(hvsr_data):
            #Update labels for data preview tab
            self.input_data_label.configure(text=self.data_filepath_entry.get() + &#39;\n&#39; + str(hvsr_data[&#39;stream&#39;]))
            
            self.obspySreamLabel_settings.configure(text=str(hvsr_data[&#39;stream&#39;]))

            self.sensitivityLabelZ_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;Z&#39;][&#39;sensitivity&#39;])
            self.gainLabelZ_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;Z&#39;][&#39;gain&#39;])
            self.polesLabelZ_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;Z&#39;][&#39;poles&#39;])
            self.zerosLabelZ_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;Z&#39;][&#39;zeros&#39;])
            
            self.sensitivityLabelN_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;N&#39;][&#39;sensitivity&#39;])
            self.gainLabelN_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;N&#39;][&#39;gain&#39;])
            self.polesLabelN_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;N&#39;][&#39;poles&#39;])
            self.zerosLabelN_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;N&#39;][&#39;zeros&#39;])

            self.sensitivityLabelE_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;E&#39;][&#39;sensitivity&#39;])
            self.gainLabelE_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;E&#39;][&#39;gain&#39;])
            self.polesLabelE_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;E&#39;][&#39;poles&#39;])
            self.zerosLabelE_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;E&#39;][&#39;zeros&#39;])
            return
        
        self.data_read = False #Initialize
        #FUNCTION TO READ DATA
        @_catch_errors
        def read_data():
            update_progress_bars(prog_percent=0)
            #messagebox.showinfo(title=&#34;Reading Data&#34;, message=&#39;Reading Data...&#39;)
            self.log_text.insert(&#39;end&#39;, f&#39;\n\nReading data [{datetime.datetime.now()}]\n\n&#39;)
            self.starttime, self.endtime = get_times()


            self.log_text.insert(&#39;end&#39;, f&#34;{self.input_params_call[&#39;text&#39;]}\n\n&#34;)
            self.log_text.insert(&#39;end&#39;, f&#34;{self.fetch_data_call[&#39;text&#39;]}\n\n&#34;)

            if self.file_source.get() == &#39;batch&#39;:
                batchType = self.batch_type.get()
                if isinstance(self.fpath, str):
                    self.fpath = self.fpath
                elif isinstance(self.fpath, tuple) and len(self.fpath)==1:
                    self.fpath = self.fpath[0]
                elif len(self.fpath) &gt; 1:
                    self.fpath = list(self.fpath)
                else:
                    self.fpath = self.fpath[0]


                update_progress_bars(prog_percent=1)            
                self.params = sprit_hvsr.input_params(input_data=self.fpath,
                                    metapath = self.meta_path.get(),
                                    site=self.site_name.get(),
                                    network=self.network.get(),
                                    station=self.station.get(),
                                    location=self.location.get(),
                                    channels=[self.z_channel.get(), self.n_channel.get(), self.e_channel.get()],
                                    acq_date = self.starttime.date(),
                                    starttime = self.starttime,
                                    endtime = self.endtime,
                                    tzone = &#39;UTC&#39;, #Will always be converted to UTC before we get to this point when using gui
                                    xcoord = self.x.get(),
                                    ycoord =  self.y.get(),
                                    elevation = self.z.get(),
                                    input_crs= self.input_crs.get(),
                                    output_crs= self.output_crs.get(),
                                    elev_unit= self.elev_unit.get(),
                                    instrument = self.instrumentSel.get(),
                                    hvsr_band = [self.hvsrBand_min.get(), self.hvsrBand_max.get()] )

                if self.trim_dir.get()==&#39;&#39;:
                    trimDir=None
                else:
                    trimDir=self.trim_dir.get()

                update_progress_bars(prog_percent=2)            
                self.hvsr_data = sprit_hvsr.fetch_data(params=self.params,
                                            source=self.file_source.get(), 
                                            trim_dir=trimDir, 
                                            export_format=self.export_format.get(), 
                                            detrend=self.detrend.get(), 
                                            detrend_options=self.detrend_options.get())
                
                update_progress_bars(prog_percent=10)                                
                self.site_options = self.hvsr_data.sites

                self.log_text.insert(&#39;end&#39;, f&#34;{self.site_options}\n\n&#34;)

                firstSite = self.hvsr_data[list(self.hvsr_data.keys())[0]]
                update_input_labels(firstSite)
                update_site_dropdown()

                #Plot data in data preview tab
                self.fig_pre, self.ax_pre = sprit_plot._plot_simple_stream_obspy(stream=firstSite[&#39;stream&#39;], params=firstSite, fig=self.fig_pre, axes=self.ax_pre, return_fig=True)

                #Plot data in noise preview tab
                self.fig_noise, self.ax_noise = sprit_plot._plot_simple_stream_obspy(stream=firstSite[&#39;stream&#39;], params=firstSite, fig=self.fig_noise, ax=self.ax_noise, fill_gaps=0, component=&#39;Z&#39;, stack_type=&#39;linear&#39;, detrend=&#39;mean&#39;, dbscale=True, return_fig=True, cmap_per=[0.1,0.9])
                select_windows(event=None, initialize=True)
                plot_noise_windows(self.hvsr_data)

            else:
                if isinstance(self.fpath, str):
                    pass
                elif len(self.fpath) &gt; 1:
                    self.fpath = list(self.fpath)
                else:
                    self.fpath = self.fpath[0]

                update_progress_bars(prog_percent=1)
                self.params = sprit_hvsr.input_params( input_data=self.fpath,
                                    metapath = self.meta_path.get(),
                                    site=self.site_name.get(),
                                    network=self.network.get(), 
                                    station=self.station.get(), 
                                    location=self.location.get(), 
                                    channels=[self.z_channel.get(), self.n_channel.get(), self.e_channel.get()],
                                    acq_date = self.starttime.date(),
                                    starttime = self.starttime,
                                    endtime = self.endtime,
                                    tzone = &#39;UTC&#39;, #Will always be converted to UTC before we get to this point when using gui
                                    xcoord = self.x.get(),
                                    ycoord =  self.y.get(),
                                    elevation = self.z.get(),
                                    input_crs= self.input_crs.get(),
                                    output_crs= self.output_crs.get(),
                                    elev_unit= self.elev_unit.get(),
                                    instrument = self.instrumentSel.get(),
                                    hvsr_band = [self.hvsrBand_min.get(), self.hvsrBand_max.get()] )
                self.hvsr_data = self.params

                if self.trim_dir.get()==&#39;&#39;:
                    trimDir=None
                else:
                    trimDir=self.trim_dir.get()
                
                update_progress_bars(prog_percent=2)
                try:
                    self.hvsr_data = sprit_hvsr.fetch_data(params=self.params,
                                            source=self.file_source.get(),
                                            trim_dir=trimDir, 
                                            export_format=self.export_format.get(), 
                                            detrend=self.detrend.get(), 
                                            detrend_options=self.detrend_options.get())
                except:
                    traceback.print_exc()

                update_progress_bars(prog_percent=10)
                update_input_labels(self.hvsr_data)

                # Plot data in data preview tab
                self.fig_pre = sprit_plot._plot_simple_stream_obspy(stream=self.hvsr_data[&#39;stream&#39;], params=self.hvsr_data, fig=self.fig_pre, axes=self.ax_pre, return_fig=True)

                # Plot data in noise preview tab
                self.fig_noise = sprit_plot._plot_input_stream_mpl(stream=self.hvsr_data[&#39;stream&#39;], hv_data=self.hvsr_data, fig=self.fig_noise, ax=self.ax_noise, fill_gaps=0, component=&#39;Z&#39;, stack_type=&#39;linear&#39;, detrend=&#39;mean&#39;, dbscale=True, return_fig=True, cmap_per=[0.1,0.9])
                select_windows(event=None, initialize=True)
                plot_noise_windows(self.hvsr_data)

            self.data_read = True
            if not self.processingData:
                update_progress_bars(prog_percent=100)
                self.tab_control.select(self.preview_data_tab)
            return self.hvsr_data
        
        def report_results(hvsr_results, azimuth=&#39;HV&#39;):
            self.curveTest1ResultText.configure(text=hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;Report&#39;][&#39;Lw&#39;][:-1])
            self.curveTest1Result.configure(text=hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;Report&#39;][&#39;Lw&#39;][-1])

            self.curveTest2ResultText.configure(text=hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;Report&#39;][&#39;Nc&#39;][:-1])
            self.curveTest2Result.configure(text=hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;Report&#39;][&#39;Nc&#39;][-1])

            self.curveTest3ResultText.configure(text=hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;Report&#39;][&#39;σ_A(f)&#39;][:-1])
            self.curveTest3Result.configure(text=hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;Report&#39;][&#39;σ_A(f)&#39;][-1])

            curvePass = (hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;WindowLengthFreq.&#39;] +
                                hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;SignificantCycles&#39;]+
                                hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;LowCurveStDevOverTime&#39;]) &gt; 2
            if curvePass:
                self.totalCurveResult.configure(text=sprit_utils._check_mark(), font=(&#34;TkDefaultFont&#34;, 16, &#34;bold&#34;), foreground=&#39;green&#39;)
            else:
                self.totalCurveResult.configure(text=sprit_utils._x_mark(), font=(&#34;TkDefaultFont&#34;, 16, &#34;bold&#34;), foreground=&#39;red&#39;)

            self.peakTest1ResultText.configure(text=hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;Report&#39;][&#39;A(f-)&#39;][:-1])
            self.peakTest1Result.configure(text=hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;Report&#39;][&#39;A(f-)&#39;][-1])
            
            self.peakTest2ResultText.configure(text=hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;Report&#39;][&#39;A(f+)&#39;][:-1])
            self.peakTest2Result.configure(text=hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;Report&#39;][&#39;A(f+)&#39;][-1])
            
            self.peakTest3ResultText.configure(text=hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;Report&#39;][&#39;A0&#39;][:-1])
            self.peakTest3Result.configure(text=hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;Report&#39;][&#39;A0&#39;][-1])

            self.peakTest4ResultText.configure(text=hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;Report&#39;][&#39;P-&#39;][:5] + &#39; and &#39; +hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;Report&#39;][&#39;P+&#39;][:-1])
            if hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;FreqStability&#39;]:
                self.peakTest4Result.configure(text=sprit_utils._check_mark())
            else:
                self.peakTest4Result.configure(text=sprit_utils._x_mark())

            self.peakTest5ResultText.configure(text=hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;Report&#39;][&#39;Sf&#39;][:-1])
            self.peakTest5Result.configure(text=hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;Report&#39;][&#39;Sf&#39;][-1])
            
            self.peakTest6ResultText.configure(text=hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;Report&#39;][&#39;Sa&#39;][:-1])
            self.peakTest6Result.configure(text=hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;Report&#39;][&#39;Sa&#39;][-1])

            peakPass = (hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;PeakProminenceBelow&#39;] +
                    hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;PeakProminenceAbove&#39;]+
                    hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;PeakAmpClarity&#39;]+
                    hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;FreqStability&#39;]+
                    hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;PeakStability_FreqStD&#39;]+
                    hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;PeakStability_AmpStD&#39;]) &gt;= 5
            if peakPass:
                self.totalPeakResult.configure(text=sprit_utils._check_mark(), font=(&#34;TkDefaultFont&#34;, 16, &#34;bold&#34;), foreground=&#39;green&#39;)
            else:
                self.totalPeakResult.configure(text=sprit_utils._x_mark(), font=(&#34;TkDefaultFont&#34;, 16, &#34;bold&#34;), foreground=&#39;red&#39;)

            if curvePass and peakPass:
                self.totalResult.configure(text=f&#39;Pass {sprit_utils._check_mark()}&#39;, font=(&#34;TkDefaultFont&#34;, 22, &#34;bold&#34;), foreground=&#39;green&#39;)
            else:
                self.totalResult.configure(text=f&#39;Fail {sprit_utils._x_mark()}&#39;, font=(&#34;TkDefaultFont&#34;, 22, &#34;bold&#34;), foreground=&#39;red&#39;)

            sprit_hvsr.plot_hvsr(hvsr_results, plot_type=get_kindstr(), fig=self.fig_results, ax=self.ax_results, use_subplots=True, clear_fig=False)

        # FUNCTION TO PROCESS DATA
        @_catch_errors
        def process_data():
            update_progress_bars(prog_percent=0)
            #messagebox.showinfo(&#34;Processing Data&#34;, &#39;Processing Data...&#39;)
            self.processingData = True #Set to true while data processing algorithm is being run
            
            if not self.data_read:
                self.hvsr_data = read_data()
                update_progress_bars(prog_percent=12)

            self.log_text.insert(&#39;end&#39;, f&#34;\n\nProcessing Data [{datetime.datetime.now()}]\n\n&#34;)
            self.log_text.insert(&#39;end&#39;, f&#34;{self.generate_ppsd_call[&#39;text&#39;]}\n\n&#34;)

            
            self.hvsr_data = sprit_hvsr.remove_noise(hvsr_data=self.hvsr_data,
                                                     remove_method=&#39;auto&#39;,
                                                     sat_percent=0.995,
                                                     noise_percent=0.8,
                                                     sta=2,
                                                     lta=30,
                                                     stalta_thresh=[0.5, 5],
                                                     warmup_time=0,
                                                     cooldown_time=0,
                                                     min_win_size=1,
                                                     remove_raw_noise=False)
            update_progress_bars(prog_percent=12)
            self.hvsr_data = plot_noise_windows(self.hvsr_data)

            update_progress_bars(prog_percent=15)
            self.hvsr_data = sprit_hvsr.generate_psds(hvsr_data=self.hvsr_data, 
                                                remove_outliers=self.remove_outliers.get(),
                                                outlier_std=self.outlier_std.get(),
                                                ppsd_length=self.ppsd_length.get(),
                                                overlap=self.overlap.get(),
                                                period_step_octaves=self.perStepOct.get(),
                                                skip_on_gaps=self.skip_on_gaps.get(),
                                                db_bins=self.db_bins,
                                                period_limits=self.period_limits,
                                                period_smoothing_width_octaves=self.perSmoothWidthOct.get(),
                                                special_handling=special_handling#, verbose=True
                                               )
            update_progress_bars(prog_percent=50)

            self.hvsr_data = sprit_hvsr.remove_outlier_curves(hvsr_data=self.hvsr_data,
                                            rmse_thresh=98,
                                            use_percentile=True,
                                            use_hv_curve = False,
                                            show_plot = False)
            update_progress_bars(prog_percent=60)

            self.log_text.insert(&#39;end&#39;, f&#34;{self.procHVSR_call[&#39;text&#39;]}\n\n&#34;)
            self.hvsr_results = sprit_hvsr.process_hvsr(hvsr_data=self.hvsr_data,
                                                   method=self.method_ind,
                                                   smooth=self.hvsmooth_param,
                                                   freq_smooth=self.freq_smooth.get(),
                                                   f_smooth_width=self.fSmoothWidth.get(),
                                                   resample=self.hvresample_int,
                                                   outlier_curve_rmse_percentile=True)
            update_progress_bars(prog_percent=90)


            self.log_text.insert(&#39;end&#39;, f&#34;{self.checkPeaks_Call[&#39;text&#39;]}\n\n&#34;)
            self.hvsr_results = sprit_hvsr.check_peaks(hvsr_data=self.hvsr_results, 
                                                  hvsr_band = [self.hvsrBand_min.get(), self.hvsrBand_max.get()],
                                                  peak_freq_range=[self.peakFreqRange_min.get(), self.peakFreqRange_max.get()])
            update_progress_bars(prog_percent=95)


            self.log_text.insert(&#39;end&#39;, f&#34;{self.checkPeaks_Call[&#39;text&#39;]}\n\n&#34;)
            if isinstance(self.hvsr_results, sprit_hvsr.HVSRData):
                report_results(self.hvsr_results)
                self.results_siteSelectFrame.grid_forget()
            elif isinstance(self.hvsr_results, sprit_hvsr.HVSRBatch):
                self.results_siteSelectFrame.grid(row=0, column=0, columnspan=10, sticky=&#39;ew&#39;)
                report_results(self.hvsr_results[self.hvsr_results.sites[0]])
            else:
                warnings.warn(f&#39;Data is of type {type(self.hvsr_results)}; should be HVSRData or HVSRBatch type.&#39;)

            #Log results
            self.log_text.insert(&#39;end&#39;, f&#34;Processing completed at [{datetime.datetime.now()}]\n\n&#34;)
            self.hvsr_results = sprit_hvsr.get_report(self.hvsr_results, report_format=&#39;print&#39;, no_output=True)
            if isinstance(self.hvsr_results, sprit_hvsr.HVSRData):
                #format data to be same as HVSRBatch
                hvsrResults = {&#39;sitename_placeholder&#39;:self.hvsr_results}
            else:
                hvsrResults = self.hvsr_results

            for sitename in hvsrResults.keys():
                self.log_text.insert(&#39;end&#39;, f&#34;{hvsrResults[sitename][&#39;Print_Report&#39;]}\n\n&#34;)
            
            self.processingData = False
            self.tab_control.select(self.results_tab)
            update_progress_bars(prog_percent=100)

        global update_progress_bars
        def update_progress_bars(prog_percent, process_name=&#39;Processing&#39;):
            progBarListList = [[self.inputProgBar,(0,0), True], 
                                [self.prevProgBar,(0,0), True], 
                                [self.noiseProgBar,(0,0), True], 
                                [self.settingsProgBar_ppsd, (0, 0), True],
                                [self.settingsProgBar_hvsr, (0,0), True],
                                [self.settingsProgBar_plot,(0,0), True], 
                                [self.logProgBar,(0,11), False], 
                                [self.resultsProgBar,(0,26), False]]
            
            def prog_bar_update(progBarListList, progPercent, processName):
                for bar in progBarListList:
                    progBar = bar[0]
                    barLoc = bar[1]

                    progBar[&#39;value&#39;] = progPercent

                    if progPercent==0:
                        progBar.master.columnconfigure(0, weight=1)
                        progBar.grid(row=barLoc[0],column=barLoc[1], sticky=&#39;ew&#39;)
                    elif progPercent==100:
                        progBar.grid_forget()

                    progBar.update()

            threading.Thread(target=prog_bar_update(progBarListList=progBarListList, progPercent=prog_percent, processName=process_name)).start()
            #self.update_idletasks()

        def update_input_params_call():
            prevCall = self.input_params_call.cget(&#39;text&#39;)
            self.input_params_call.configure(text=&#34;input_params( input_data=&#39;{}&#39;, metapath={}, site=&#39;{}&#39;, instrument=&#39;{}&#39;,\n\tnetwork=&#39;{}&#39;, station=&#39;{}&#39;, location=&#39;{}&#39;, channels=[{}, {}, {}], \n\tacq_date=&#39;{}&#39;, starttime=&#39;{}&#39;, endttime=&#39;{}&#39;, tzone=&#39;{}&#39;, \n\txcoord={}, ycoord={}, elevation={}, input_crs=&#39;{}&#39;, output_crs=&#39;{}&#39;, elev_unit=&#39;{}&#39;,  \n\thvsr_band=[{}, {}], peak_freq_range=[{}, {}])&#34;.format(
                                            self.data_path.get(), self.meta_path.get(), self.site_name.get(), self.instrumentSel.get(),
                                            self.network.get(), self.station.get(), self.location.get(),
                                            self.z_channel.get(), self.e_channel.get(), self.n_channel.get(),
                                            self.acq_date, self.starttime.time(), self.endtime.time(), self.tz,
                                            self.x.get(), self.y.get(), self.z.get(), 
                                            self.input_crs.get(), self.output_crs.get(), self.elev_unit.get(), 
                                            self.hvsrBand_min.get(), self.hvsrBand_max.get(),
                                            self.peakFreqRange_min.get(), self.peakFreqRange_max.get()))
            
            newCall = self.input_params_call.cget(&#39;text&#39;)
            if prevCall==newCall:
                self.data_read=True
            else:
                self.data_read = False

        #Specify site name        
        siteLabel = ttk.Label(hvsrFrame, text=&#34;Site Name&#34;)
        siteLabel.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5)
        self.site_name = tk.StringVar()
        self.site_name.set(&#39;HVSR Site&#39;)
        self.site_name_entry = ttk.Entry(hvsrFrame, textvariable=self.site_name, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.site_name_entry.grid(row=0, column=1, columnspan=1, sticky=&#39;ew&#39;, padx=5)
        
        def on_source_select():
            self.data_read = False
            try:
                str(self.file_source.get())
                sourceLabel.configure(text=&#34;source=&#39;{}&#39;&#34;.format(self.file_source.get()))
                update_fetch_call()

                if self.file_source.get() == &#39;raw&#39; or self.file_source.get() == &#39;dir&#39;:
                    self.browse_data_filepath_button.configure(text=&#39;Browse Folder&#39;)
                    self.batch_options_frame.grid_forget()
                elif self.file_source.get() == &#39;batch&#39;:
                    self.batch_options_frame.grid(row=11, column=0, columnspan=7, sticky=&#39;ew&#39;)
                    self.browse_data_filepath_button.configure(text=&#39;Browse File(s)&#39;)
                else:
                    self.browse_data_filepath_button.configure(text=&#39;Browse File(s)&#39;)
                    self.batch_options_frame.grid_forget()
                return True
            except ValueError:
                return False

        sourceLabel = ttk.Label(master=hvsrFrame, text=&#34;source=&#39;file&#39;&#34;)

        ttk.Label(master=hvsrFrame, text=&#39;Data Source Type [str]&#39;).grid(row=0, column=3, sticky=&#39;e&#39;, padx=5)
        sourcFrame= ttk.Frame(hvsrFrame)
        sourcFrame.grid(row=0, column=4, sticky=&#39;w&#39;, columnspan=3)
        self.file_source = tk.StringVar()
        self.file_source.set(&#39;file&#39;)
        ttk.Radiobutton(master=sourcFrame, text=&#39;File&#39;, variable=self.file_source, value=&#39;file&#39;, command=on_source_select).grid(row=0, column=0, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=sourcFrame, text=&#39;Raw&#39;, variable=self.file_source, value=&#39;raw&#39;, command=on_source_select).grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=sourcFrame, text=&#39;Batch&#39;, variable=self.file_source, value=&#39;batch&#39;, command=on_source_select).grid(row=0, column=2, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=sourcFrame, text=&#39;Directory&#39;, variable=self.file_source, value=&#39;dir&#39;, command=on_source_select).grid(row=0, column=3, sticky=&#39;w&#39;, padx=(5, 10))

        #Instrument select
        ttk.Label(hvsrFrame, text=&#34;Instrument&#34;).grid(row=0, column=6, sticky=&#39;e&#39;, padx=5)
        inst_options = [&#34;Raspberry Shake&#34;, &#34;Tromino&#34;, &#34;Other&#34;]

        
        def on_option_select(self, inst):
            update_input_params_call()
            if inst == &#34;Raspberry Shake&#34;:
                self.network_entry.configure(state=&#39;normal&#39;)
                self.station_entry.configure(state=&#39;normal&#39;)
                self.location_entry.configure(state=&#39;normal&#39;)
                
                self.z_channel_entry.delete(0, &#39;end&#39;)
                self.e_channel_entry.delete(0, &#39;end&#39;)
                self.n_channel_entry.delete(0, &#39;end&#39;)
                
                self.z_channel_entry.insert(0,&#34;EHZ&#34;)
                self.e_channel_entry.insert(0,&#34;EHE&#34;)
                self.n_channel_entry.insert(0,&#34;EHN&#34;)

                self.network_entry.delete(0, &#39;end&#39;)
                self.network_entry.insert(0,&#34;AM&#34;)

                self.station_entry.delete(0, &#39;end&#39;)
                self.station_entry.insert(0,&#34;RAC84&#34;)

                self.location_entry.delete(0, &#39;end&#39;)
                self.location_entry.insert(0,&#34;00&#34;)
            else:
                self.network_entry.configure(state=&#39;disabled&#39;)
                self.station_entry.configure(state=&#39;disabled&#39;)
                self.location_entry.configure(state=&#39;disabled&#39;)

        self.instrumentSel = tk.StringVar(value=inst_options[0])
        self.instrument_dropdown = ttk.OptionMenu(hvsrFrame, self.instrumentSel, inst_options[0], *inst_options, command=on_option_select)
        self.instrument_dropdown.config(width=20)
        self.instrument_dropdown.grid(row=0, column=7, columnspan=1, sticky=&#39;ew&#39;)

        # Data Filepath
        dataLabel= ttk.Label(hvsrFrame, text=&#34;Data Filepath&#34;)
        dataLabel.grid(row=1, column=0, sticky=&#39;e&#39;, padx=5, pady=(5,2.55))
    
        #Function to set self.data_read False whenever the data_path is updated
        
        def on_data_path_change(data_path, index, trace_mode):
            #If our data path changes, data is registered as not having been read
            #This is primarily so that if just the Run button is pushed, it will know to first read the data
            self.data_read = False
        
        def filepath_update():
            self.data_read = False
            self.fpath = self.data_path.get()
            self.data_read = False
            update_input_params_call()

        self.data_path = tk.StringVar()
        self.data_path.set(&#39;sample&#39;)
        self.fpath = self.data_path.get()
        self.data_path.trace_add(&#39;write&#39;, on_data_path_change)
        self.data_filepath_entry = ttk.Entry(hvsrFrame, textvariable=self.data_path, validate=&#39;focusout&#39;, validatecommand=filepath_update)
        self.data_filepath_entry.grid(row=1, column=1, columnspan=6, sticky=&#39;ew&#39;, padx=5, pady=(5,2.55))

        
        def browse_data_filepath():
            if self.file_source.get() == &#39;raw&#39; or self.file_source.get() == &#39;dir&#39;:
                self.fpath = filedialog.askdirectory()
                if self.fpath:
                    self.data_filepath_entry.delete(0, &#39;end&#39;)
                    self.data_filepath_entry.insert(0, self.fpath)
            else:
                self.fpath = filedialog.askopenfilenames()
                
                #fpath will always be tuple
                self.no_data_files = len(self.fpath)
                    
                if self.fpath:
                    self.data_filepath_entry.delete(0, &#39;end&#39;)
                    for f in self.fpath:
                        self.data_filepath_entry.insert(&#39;end&#39;, self.fpath)
                
            update_input_params_call()

        buttonFrame = ttk.Frame(hvsrFrame)
        buttonFrame.grid(row=1, column=7, sticky=&#39;ew&#39;)

        self.browse_data_filepath_button = ttk.Button(buttonFrame, text=&#34;Browse File(s)&#34;, command=browse_data_filepath)

        #self.browse_data_filepath_button.grid(row=1, column=6, sticky=&#39;ew&#39;)
        self.browse_data_filepath_button.pack(side=&#34;left&#34;, fill=&#34;x&#34;, expand=True, padx=(0,2), pady=(5,2.55))

        # Metadata Filepath
        ttk.Label(hvsrFrame, text=&#34;Metadata Filepath&#34;).grid(row=2, column=0, sticky=&#39;e&#39;, padx=5, pady=(2.5,5))
        self.meta_path = tk.StringVar()
        self.meta_path.set(&#39;&#39;)
        self.metadata_filepath_entry = ttk.Entry(hvsrFrame, textvariable=self.meta_path, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.metadata_filepath_entry.grid(row=2, column=1, columnspan=6, sticky=&#39;ew&#39;, padx=5, pady=(2.5,5))
        
        
        def browse_metadata_filepath():
            self.data_read = False #New file will not have been read, set to False
            filepath = filedialog.askopenfilename()
            if filepath:
                self.metadata_filepath_entry.delete(0, &#39;end&#39;)
                self.metadata_filepath_entry.insert(0, filepath)
            update_input_params_call()

        self.browse_metadata_filepath_button = ttk.Button(hvsrFrame, text=&#34;Browse&#34;, command=browse_metadata_filepath)
        self.browse_metadata_filepath_button.grid(row=2, column=7, sticky=&#39;ew&#39;, padx=0, pady=(2.5,5))

        
        def update_acq_date():
            aMonth = self.acq_month.get()
            if str(aMonth)[0]==&#39;0&#39;:
                aMonth = str(aMonth)[-1]

            aDay = self.acq_day.get()
            if str(aDay)[0]==&#39;0&#39;:
                aDay = str(aDay)[-1]

            self.acq_date = datetime.date(year=self.acq_year.get(), month=aMonth, day=aDay)
            self.day_of_year = self.acq_date.timetuple().tm_yday
            self.doy_label.configure(text=str(self.day_of_year))
            update_input_params_call()

        # Date and Time
        dateFrame = ttk.Frame(hvsrFrame)
        dateFrame.grid(row=3, column=1, columnspan=2, sticky=&#39;e&#39;, padx=5)
        ttk.Label(dateFrame, text=&#34;Date&#34;).grid(row=1, column=1, sticky=&#39;e&#39;, padx=5)

        self.acq_year = tk.IntVar()
        self.acq_year.set(int(datetime.datetime.today().year))
        self.acq_year_entry = ttk.Spinbox(dateFrame, from_=0, to=10000, width=7, textvariable=self.acq_year, validate=&#39;focusout&#39;, validatecommand=update_acq_date) 
        self.acq_year_entry.grid(row=1, column=2, sticky=&#39;ew&#39;, padx=1)

        self.acq_month = tk.IntVar()
        self.acq_month.set(int(datetime.datetime.today().month))
        self.acq_month_entry = ttk.Spinbox(dateFrame, from_=0, to=12, width=3, textvariable=self.acq_month, validate=&#39;focusout&#39;, validatecommand=update_acq_date) 
        self.acq_month_entry.grid(row=1, column=3, sticky=&#39;ew&#39;, padx=1)

        self.acq_day = tk.IntVar()
        self.acq_day.set(int(datetime.datetime.today().day))
        self.acq_day_entry = ttk.Spinbox(dateFrame, from_=0, to=31, width=3, textvariable=self.acq_day, validate=&#39;focusout&#39;, validatecommand=update_acq_date) 
        self.acq_day_entry.grid(row=1, column=4, sticky=&#39;ew&#39;, padx=1)

        self.acq_date = datetime.date.today()
        
        sTimeFrame = ttk.Frame(hvsrFrame)
        sTimeFrame.grid(row=3, column=4, sticky=&#39;ew&#39;)

        def get_times():
            #Format starttime as datetime object (in timezone as originally entered)
            self.acq_date = datetime.date(year=self.acq_year.get(), month=self.acq_month.get(), day=self.acq_day.get())

            sHour = self.start_hour.get()
            if str(sHour)[0] == &#39;0&#39;:
                sHour = int(str(sHour)[-1])

            sMin = self.start_minute.get()
            if str(sMin)[0] == &#39;0&#39;:
                sMin = int(str(sMin)[-1])

            self.starttime = datetime.datetime(year = int(self.acq_date.year),
                                          month = int(self.acq_date.month),
                                          day = int(self.acq_date.day),
                                          hour = int(sHour),
                                          minute = int(sMin),
                                          tzinfo=self.tz)
            
            #Get duration, as originally entered
            hour_dur = self.end_hour.get() - self.start_hour.get()
            if hour_dur &lt; 0:
                hour_dur = self.end_hour.get() + 24 - self.start_hour.get()
            min_dur = self.end_minute.get() - self.start_minute.get()

            #Convert starttime to utc
            #self.starttime = self.tz.normalize(self.tz.localize(self.starttime)).astimezone(pytz.utc)
            self.starttime  = self.starttime.astimezone(datetime.timezone.utc)

            #Get endttime based on utc starttime and original duration
            self.endtime = self.starttime + datetime.timedelta(hours=hour_dur, minutes=min_dur)

            return self.starttime, self.endtime

        self.tz = datetime.timezone.utc

        
        def any_time_change():
            self.data_read = False #New file will not have been read, set to False            
            self.acq_date = datetime.date(year=self.acq_year.get(), month=self.acq_month.get(), day=self.acq_day.get())
            self.starttime, self.endtime = get_times()
            update_input_params_call()

        ttk.Label(hvsrFrame, text=&#34;Start Time&#34;).grid(row=3, column=3, sticky=&#39;e&#39;, padx=5) 
        colonLabel= ttk.Label(sTimeFrame, text=&#34;:&#34;)#.grid(row=3, column=4, padx=(20,0), sticky=&#39;w&#39;)
        self.start_hour = tk.IntVar()
        self.start_hour.set(00)
        self.start_time_hour_entry = ttk.Spinbox(sTimeFrame, from_=0, to=23, width=5, textvariable=self.start_hour, validate=&#39;focusout&#39;, validatecommand=any_time_change) 
        self.start_time_hour_entry#.grid(row=3, column=4, sticky=&#39;w&#39;) 
        self.start_minute = tk.DoubleVar()
        self.start_minute.set(00)
        self.start_time_min_entry = ttk.Spinbox(sTimeFrame, from_=0, to=59, width=5, textvariable=self.start_minute, validate=&#39;focusout&#39;, validatecommand=any_time_change)
        self.start_time_min_entry#.grid(row=3, column=4, padx=80, sticky=&#39;w&#39;) 
        
        #sTLabel.pack(side=&#34;left&#34;, fill=&#34;x&#34;, expand=True)
        self.start_time_hour_entry.pack(side=&#39;left&#39;, expand=True)
        colonLabel.pack(side=&#34;left&#34;, fill=&#34;x&#34;)
        self.start_time_min_entry.pack(side=&#39;right&#39;, expand=True)
        
        eTimeFrame = ttk.Frame(hvsrFrame)
        eTimeFrame.grid(row=3, column=6, sticky=&#39;ew&#39;)
        ttk.Label(hvsrFrame, text=&#34;End Time&#34;).grid(row=3, column=5, sticky=&#39;e&#39;, padx=5) 
        colonLabel = ttk.Label(eTimeFrame, text=&#34;:&#34;)#.grid(row=3, column=6, padx=(20,0), sticky=&#39;w&#39;)  
        self.end_hour = tk.IntVar()
        self.end_hour.set(23)
        self.end_time_hour_entry = ttk.Spinbox(eTimeFrame, from_=0, to=23, width=5, textvariable=self.end_hour, validate=&#39;focusout&#39;, validatecommand=any_time_change) 
        self.end_time_hour_entry#.grid(row=3, column=+, sticky=&#39;w&#39;) 
        self.end_minute = tk.DoubleVar()
        self.end_minute.set(59)
        self.end_time_min_entry = ttk.Spinbox(eTimeFrame, from_=0, to=59, width=5, textvariable=self.end_minute, validate=&#39;focusout&#39;, validatecommand=any_time_change)
        self.end_time_min_entry#.grid(row=3, column=+, padx=80, sticky=&#39;w&#39;) 

        #eTLabel.pack(side=&#34;left&#34;, fill=&#34;x&#34;, expand=True)
        self.end_time_hour_entry.pack(side=&#39;left&#39;, expand=True)
        colonLabel.pack(side=&#34;left&#34;, fill=&#34;x&#34;)
        self.end_time_min_entry.pack(side=&#39;right&#39;, expand=True)

        self.acq_date = datetime.date(year=self.acq_year.get(), month=self.acq_month.get(), day=self.acq_day.get())
        self.starttime, self.endtime = get_times()

        
        def onTimezoneSelect(event):
            #Listbox &#34;loses&#34; selection and triggers an event sometimes, so need to check if that is just what happened
            if self.timezone_listbox.curselection():
                #If it was an actual selection, update timezone
                self.tz = zoneinfo.ZoneInfo(self.timezone_listbox.get(self.timezone_listbox.curselection()))
            else:
                #If it was just the listbox losing the selection, don&#39;t change anything
                pass
            update_input_params_call()

        self.timezone_listbox = tk.Listbox(hvsrFrame, selectmode=&#39;browse&#39;, height=25)

        self.timezone_listbox.insert(&#39;end&#39;, &#39;UTC&#39;)
        self.timezone_listbox.insert(&#39;end&#39;, &#39;US/Central&#39;)

        for tz in zoneinfo.available_timezones():# pytz.all_timezones:
            if tz !=&#39;UTC&#39;:
                self.timezone_listbox.insert(&#39;end&#39;, tz)
        self.timezone_listbox.selection_set(0)
        self.timezone_listbox.bind(&#39;&lt;&lt;ListboxSelect&gt;&gt;&#39;, onTimezoneSelect)

        ttk.Label(hvsrFrame,text=&#34;Timezone&#34;).grid(row=3,column=7, sticky=&#39;w&#39;, padx=5)
        self.timezone_listbox.grid(row=4,column=7, rowspan=26, sticky=&#39;nsew&#39;, padx=5)

        # DOY
        self.day_of_year = self.acq_date.timetuple().tm_yday

        ttk.Label(hvsrFrame,text=&#34;Day of Year:&#34;).grid(row=4, column=1, sticky=&#39;e&#39;, padx=5, pady=10)
        self.doy_label = ttk.Label(hvsrFrame, text=str(self.day_of_year))
        self.doy_label.grid(row=4, column=2, sticky=&#39;w&#39;)

        # UTC Time Output
        ttk.Label(hvsrFrame,text=&#34;UTC Time:&#34;).grid(row=4, column=3, sticky=&#39;e&#39;, padx=5, pady=10)
        self.utc_time_output_label = ttk.Label(hvsrFrame, text=&#34;&#34;)
        self.utc_time_output_label.grid(row=4, column=4)

        # Initialize as UTC
        self.tz = datetime.timezone.utc


        self.starttime, self.endtime = get_times()

        # X Y Z CRS Depth
        ttk.Label(hvsrFrame,text=&#34;X&#34;).grid(row=5,column=1, sticky=&#39;e&#39;, padx=5, pady=10)
        self.x = tk.DoubleVar()
        self.x.set(0)
        self.x_entry = ttk.Entry(hvsrFrame, textvariable=self.x, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.x_entry.grid(row=5,column=2, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;Y&#34;).grid(row=5,column=3, sticky=&#39;e&#39;, padx=5, pady=10)
        self.y = tk.DoubleVar()
        self.y.set(0)
        self.y_entry = ttk.Entry(hvsrFrame, textvariable=self.y, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.y_entry.grid(row=5, column=4, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;Z&#34;).grid(row=5,column=5, sticky=&#39;e&#39;, padx=5, pady=10)
        self.z = tk.DoubleVar()
        self.z.set(0)
        self.z_entry = ttk.Entry(hvsrFrame, textvariable=self.z, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.z_entry.grid(row=5,column=6, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;Input CRS&#34;).grid(row=6,column=1, sticky=&#39;e&#39;, padx=5, pady=10)
        self.input_crs = tk.StringVar()
        self.input_crs.set(&#39;EPSG:4326&#39;)
        self.input_crs_entry = ttk.Entry(hvsrFrame, textvariable=self.input_crs, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.input_crs_entry.grid(row=6,column=2, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;Output CRS&#34;).grid(row=6,column=3, sticky=&#39;e&#39;, padx=5, pady=10)
        self.output_crs = tk.StringVar()
        self.output_crs.set(&#39;EPSG:4326&#39;)
        self.output_crs_entry = ttk.Entry(hvsrFrame, textvariable=self.output_crs, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.output_crs_entry.grid(row=6, column=4, sticky=&#39;w&#39;, padx=0)

        ttk.Label(master=hvsrFrame, text=&#39;Elevation Unit&#39;).grid(row=6, column=5, sticky=&#39;e&#39;, padx=5, pady=10)
        elevUnitFrame= ttk.Frame(hvsrFrame)
        elevUnitFrame.grid(row=6, column=6, sticky=&#39;w&#39;, columnspan=3)
        self.elev_unit = tk.StringVar()
        self.elev_unit.set(&#39;meters&#39;)
        ttk.Radiobutton(master=elevUnitFrame, text=&#39;Meters&#39;, variable=self.elev_unit, value=&#39;meters&#39;, command=update_input_params_call).grid(row=0, column=0, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=elevUnitFrame, text=&#39;Feet&#39;, variable=self.elev_unit, value=&#39;feet&#39;, command=update_input_params_call).grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))

        # Network Station Location
        ttk.Label(hvsrFrame,text=&#34;Network&#34;).grid(row=7,column=1, sticky=&#39;e&#39;, padx=5, pady=10)
        self.network = tk.StringVar()
        self.network.set(&#39;AM&#39;)
        self.network_entry = ttk.Entry(hvsrFrame, textvariable=self.network, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.network_entry.grid(row=7,column=2, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;Station&#34;).grid(row=7,column=3, sticky=&#39;e&#39;, padx=5, pady=10)
        self.station = tk.StringVar()
        self.station.set(&#39;RAC84&#39;)
        self.station_entry = ttk.Entry(hvsrFrame, textvariable=self.station, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.station_entry.grid(row=7,column=4, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;Location&#34;).grid(row=7,column=5, sticky=&#39;e&#39;, padx=5, pady=10)
        self.location = tk.StringVar()
        self.location.set(&#39;00&#39;)
        self.location_entry = ttk.Entry(hvsrFrame, textvariable=self.location, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.location_entry.grid(row=7,column=6, sticky=&#39;w&#39;, padx=0)

        # Z N E Channels
        ttk.Label(hvsrFrame,text=&#34;Z Channel&#34;).grid(row=8,column=1, sticky=&#39;e&#39;, padx=5, pady=10)
        self.z_channel = tk.StringVar()
        self.z_channel.set(&#39;EHZ&#39;)
        self.z_channel_entry = ttk.Entry(hvsrFrame, textvariable=self.z_channel, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.z_channel_entry.grid(row=8,column=2, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;N Channel&#34;).grid(row=8,column=3, sticky=&#39;e&#39;, padx=5, pady=10)
        self.n_channel = tk.StringVar()
        self.n_channel.set(&#39;EHN&#39;)
        self.n_channel_entry = ttk.Entry(hvsrFrame, textvariable=self.n_channel, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.n_channel_entry.grid(row=8,column=4, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;E Channel&#34;).grid(row=8,column=5, sticky=&#39;e&#39;, padx=5, pady=10)
        self.e_channel = tk.StringVar()
        self.e_channel.set(&#39;EHE&#39;)
        self.e_channel_entry = ttk.Entry(hvsrFrame, textvariable=self.e_channel, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.e_channel_entry.grid(row=8,column=6, sticky=&#39;w&#39;, padx=0)

        # HVSR Band
        def on_hvsrband_update():
            try:
                float(self.hvsrBand_min.get())
                float(self.hvsrBand_max.get())

                hvsrBandLabel.configure(text=&#39;hvsr_band=[{}, {}]&#39;.format(self.hvsrBand_min.get(), self.hvsrBand_max.get()))                
                update_check_peaks_call(self.checkPeaks_Call)
                update_input_params_call()
                return True
            except ValueError:
                return False      
        
        ttk.Label(hvsrFrame,text=&#34;HVSR Band&#34;).grid(row=9,column=1, sticky=&#39;e&#39;, padx=10, pady=10)
        hvsrbandframe= ttk.Frame(hvsrFrame)
        hvsrbandframe.grid(row=9, column=2,sticky=&#39;w&#39;)
        self.hvsrBand_min = tk.DoubleVar()
        self.hvsrBand_min.set(0.4)
        hvsr_band_min_entry = ttk.Entry(hvsrbandframe, width=9, textvariable=self.hvsrBand_min, validate=&#39;focusout&#39;, validatecommand=on_hvsrband_update)
        hvsr_band_min_entry.grid(row=0, column=0, sticky=&#39;ew&#39;, padx=(0,2))

        self.hvsrBand_max = tk.DoubleVar()
        self.hvsrBand_max.set(40)
        hvsr_band_max_entry = ttk.Entry(hvsrbandframe, width=9,textvariable=self.hvsrBand_max, validate=&#39;focusout&#39;, validatecommand=on_hvsrband_update)
        hvsr_band_max_entry.grid(row=0,column=1, sticky=&#39;ew&#39;, padx=(2,0))

        # Peak Freq Range Band
        def on_peakFreqRange_update():
            try:
                float(self.peakFreqRange_min.get())
                float(self.peakFreqRange_max.get())

                peakFreqRangeLabel.configure(text=&#39;peak_freq_range=[{}, {}]&#39;.format(self.peakFreqRange_min.get(), self.peakFreqRange_max.get()))                
                update_check_peaks_call(self.checkPeaks_Call)
                update_input_params_call()
                return True
            except ValueError:
                return False      
        
        ttk.Label(hvsrFrame,text=&#34;Peak Freq. Range&#34;).grid(row=9,column=3, sticky=&#39;e&#39;, padx=10, pady=10)
        peakFreqRangeframe= ttk.Frame(hvsrFrame)
        peakFreqRangeframe.grid(row=9, column=4,sticky=&#39;w&#39;)
        self.peakFreqRange_min = tk.DoubleVar()
        self.peakFreqRange_min.set(0.4)
        peakFreqRange_min_entry = ttk.Entry(peakFreqRangeframe, width=9, textvariable=self.peakFreqRange_min, validate=&#39;focusout&#39;, validatecommand=on_peakFreqRange_update)
        peakFreqRange_min_entry.grid(row=0, column=0, sticky=&#39;ew&#39;, padx=(0,2))

        self.peakFreqRange_max = tk.DoubleVar()
        self.peakFreqRange_max.set(40)
        peakFreqRange_max_entry = ttk.Entry(peakFreqRangeframe, width=9,textvariable=self.peakFreqRange_max, validate=&#39;focusout&#39;, validatecommand=on_peakFreqRange_update)
        peakFreqRange_max_entry.grid(row=0,column=1, sticky=&#39;ew&#39;, padx=(2,0))

        #BATCH Section
        def update_batch_data_read_call():
            self.batch_read_data_call.configure(text=&#34;batch_data_read(input_data, batch_type=&#39;{}&#39;, param_col={}, batch_params={})&#34;.format(
                                                                                        self.batch_type.get(), self.param_col.get(), self.batch_params.get()))
            return
        
        def on_batch_type_select():
            update_batch_data_read_call()
            return

        self.batch_options_frame = ttk.LabelFrame(hvsrFrame, text=&#39;Batch Options&#39;)
        ttk.Label(self.batch_options_frame, text=&#34;Batch Type&#34;).grid(row=0,column=0, sticky=&#39;e&#39;, padx=10, pady=10)
        batchTypeFrame= ttk.Frame(self.batch_options_frame)
        batchTypeFrame.grid(row=0, column=1, sticky=&#39;w&#39;, columnspan=3)
        self.batch_type = tk.StringVar()
        self.batch_type.set(&#39;table&#39;)
        ttk.Radiobutton(master=batchTypeFrame, text=&#39;Table&#39;, variable=self.batch_type, value=&#39;table&#39;, command=on_batch_type_select).grid(row=0, column=0, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=batchTypeFrame, text=&#39;File list&#39;, variable=self.batch_type, value=&#39;filelist&#39;, command=on_batch_type_select).grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))

        ttk.Label(self.batch_options_frame,text=&#34;Parameter column name&#34;).grid(row=0,column=4, sticky=&#39;e&#39;, padx=5)
        self.param_col = tk.StringVar()
        self.param_col.set(None)
        self.param_col_entry = ttk.Entry(self.batch_options_frame, textvariable=self.param_col, validate=&#39;focusout&#39;, validatecommand=update_batch_data_read_call)
        self.param_col_entry.grid(row=0, column=5, sticky=&#39;w&#39;, padx=0)
        ttk.Label(self.batch_options_frame,text=&#34;For batch_type=&#39;table&#39; with single parameter column only&#34;).grid(row=1,column=4, columnspan=2, sticky=&#39;w&#39;, padx=5)

        ttk.Label(self.batch_options_frame,text=&#34;Batch parameters&#34;).grid(row=0,column=6, sticky=&#39;e&#39;, padx=5)
        self.batch_params = tk.StringVar()
        self.batch_params.set(None)
        self.batch_params_entry = ttk.Entry(self.batch_options_frame, textvariable=self.batch_params, validate=&#39;focusout&#39;, validatecommand=update_batch_data_read_call, width=75)
        self.batch_params_entry.grid(row=0, column=7, columnspan=3, sticky=&#39;ew&#39;, padx=0)
        ttk.Label(self.batch_options_frame,text=&#34;To specify parameters used for reading in data&#34;).grid(row=1,column=6, columnspan=2, sticky=&#39;w&#39;, padx=5)

        self.batch_read_data_call = ttk.Label(self.batch_options_frame, text=&#34;batch_data_read(input_data, batch_type={}, param_col={}, batch_params={})&#34;.format(
                                                                                        self.batch_type.get(), self.param_col.get(), self.batch_params.get() ))
        self.batch_read_data_call.grid(row=2,column=0, columnspan=10, sticky=&#39;w&#39;, padx=10, pady=10)

        self.batch_options_frame.grid(row=11, column=0, columnspan=7, sticky=&#39;ew&#39;)
        self.batch_options_frame.grid_forget()
        
        separator = ttk.Separator(hvsrFrame, orient=&#39;horizontal&#39;)
        separator.grid(row=12, column=0, columnspan=7, sticky=&#39;ew&#39;, padx=10)

        
        def update_fetch_call():
            prevCall = self.input_params_call.cget(&#39;text&#39;)
            if self.trim_dir.get()==&#39;&#39;:
                trim_dir = None
            else:
                trim_dir = self.trim_dir.get()
            self.data_read = False #New file will not have been read, set to False
            self.fetch_data_call.configure(text=&#34;fetch_data(params, source=&#39;{}&#39;, trim_dir={}, export_format=&#39;{}&#39;, detrend=&#39;{}&#39;, detrend_options={})&#34;
                                            .format(self.file_source.get(), trim_dir, self.export_format.get(), self.detrend.get(), self.detrend_options.get()))
            
            newCall = self.input_params_call.cget(&#39;text&#39;)
            if prevCall==newCall:
                self.data_read=True
            else:
                self.data_read = False
        #export_format=&#39;.mseed&#39;
        
        def on_obspyFormatSelect(self):
            update_fetch_call()
        ttk.Label(hvsrFrame, text=&#34;Data Format&#34;).grid(row=13, column=1, sticky=&#39;e&#39;, padx=5)
        obspyformats =  [&#39;AH&#39;, &#39;ALSEP_PSE&#39;, &#39;ALSEP_WTH&#39;, &#39;ALSEP_WTN&#39;, &#39;CSS&#39;, &#39;DMX&#39;, &#39;GCF&#39;, &#39;GSE1&#39;, &#39;GSE2&#39;, &#39;KINEMETRICS_EVT&#39;, &#39;KNET&#39;, &#39;MSEED&#39;, &#39;NNSA_KB_CORE&#39;, &#39;PDAS&#39;, &#39;PICKLE&#39;, &#39;Q&#39;, &#39;REFTEK130&#39;, &#39;RG16&#39;, &#39;SAC&#39;, &#39;SACXY&#39;, &#39;SEG2&#39;, &#39;SEGY&#39;, &#39;SEISAN&#39;, &#39;SH_ASC&#39;, &#39;SLIST&#39;, &#39;SU&#39;, &#39;TSPAIR&#39;, &#39;WAV&#39;, &#39;WIN&#39;, &#39;Y&#39;]

        self.export_format = tk.StringVar(value=obspyformats[11])
        self.data_format_dropdown = ttk.OptionMenu(hvsrFrame, self.export_format, obspyformats[11], *obspyformats, command=on_obspyFormatSelect)
        self.data_format_dropdown.grid(row=13, column=2, columnspan=3, sticky=&#39;ew&#39;)

        #detrend=&#39;spline&#39;
        
        def on_detrend_select():
            try:
                str(self.detrend.get())
                update_fetch_call()
                return True
            except ValueError:
                return False

        sourceLabel = ttk.Label(master=hvsrFrame, text=&#34;source=&#39;raw&#39;&#34;)

        ttk.Label(master=hvsrFrame, text=&#39;Detrend type [str]&#39;).grid(row=14, column=1, sticky=&#39;e&#39;, padx=5)
        detrendFrame= ttk.Frame(hvsrFrame)
        detrendFrame.grid(row=14, column=2, sticky=&#39;w&#39;, columnspan=3)
        self.detrend = tk.StringVar()
        self.detrend.set(&#39;spline&#39;)
        ttk.Radiobutton(master=detrendFrame, text=&#39;Spline&#39;, variable=self.detrend, value=&#39;spline&#39;, command=on_detrend_select).grid(row=0, column=0, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=detrendFrame, text=&#39;Polynomial&#39;, variable=self.detrend, value=&#39;polynomial&#39;, command=on_detrend_select).grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=detrendFrame, text=&#39;None&#39;, variable=self.detrend, value=&#39;none&#39;, command=on_detrend_select).grid(row=0, column=2, sticky=&#39;w&#39;, padx=(5, 10))

        #detrend_options=2
        
        def on_detrend_order():
            try:
                int(self.detrend_options.get())
                update_fetch_call()
                return True
            except ValueError:
                return False
                     
        ttk.Label(hvsrFrame,text=&#34;Detrend Order [int]&#34;).grid(row=14,column=5, sticky=&#39;e&#39;, padx=5, pady=10)
        self.detrend_options = tk.IntVar()
        self.detrend_options.set(2)
        self.detrend_order_entry = ttk.Entry(hvsrFrame, textvariable=self.detrend_options, validate=&#39;focusout&#39;, validatecommand=on_detrend_order)
        self.detrend_order_entry.grid(row=14,column=6, sticky=&#39;w&#39;, padx=0)
        
        #trim_dir=False
        def on_trim_dir():
            try:
                str(self.trim_dir.get())
                update_fetch_call()
                return True
            except ValueError:
                return False
            
        ttk.Label(hvsrFrame, text=&#34;Output Directory (trimmed data)&#34;).grid(row=15, column=0, sticky=&#39;e&#39;, padx=5, pady=(2.5,5))
        self.trim_dir = tk.StringVar()
        self.trim_dir_entry = ttk.Entry(hvsrFrame, textvariable=self.trim_dir, validate=&#39;focusout&#39;, validatecommand=on_trim_dir)
        self.trim_dir_entry.grid(row=15, column=1, columnspan=5, sticky=&#39;ew&#39;, padx=5, pady=(2.5,5))
        
        
        def browse_trim_dir_filepath():
            filepath = filedialog.askdirectory()
            if filepath:
                self.trim_dir_entry.delete(0, &#39;end&#39;)
                self.trim_dir_entry.insert(0, filepath)
        
        self.trim_dir_filepath_button = ttk.Button(hvsrFrame, text=&#34;Browse&#34;, command=browse_trim_dir_filepath)
        self.trim_dir_filepath_button.grid(row=15, column=6, sticky=&#39;ew&#39;, padx=0, pady=(2.5,5))

        #self.starttime, self.endtime = get_times()
        input_params_LF = ttk.LabelFrame(master=self.input_tab, text=&#39;input_params() call&#39;)
        self.input_params_call = ttk.Label(master=input_params_LF, text=&#34;input_params( input_data=&#39;{}&#39;, metapath={}, site=&#39;{}&#39;, instrument=&#39;{}&#39;,\n\tnetwork=&#39;{}&#39;, station=&#39;{}&#39;, location=&#39;{}&#39;, channels=[{}, {}, {}], \n\tacq_date=&#39;{}&#39;, starttime=&#39;{}&#39;, endttime=&#39;{}&#39;, tzone=&#39;{}&#39;, \n\txcoord={}, ycoord={}, elevation={}, input_crs=&#39;{}&#39;, output_crs=&#39;{}&#39;, elev_unit=&#39;{}&#39;,   \n\thvsr_band=[{}, {}], peak_freq_range=[{}, {}])&#34;.format(
                                            self.data_path.get(), self.meta_path.get(), self.site_name.get(), self.instrumentSel.get(),
                                            self.network.get(), self.station.get(), self.location.get(),
                                            self.z_channel.get(), self.e_channel.get(), self.n_channel.get(),
                                            self.acq_date, self.starttime.time(), self.endtime.time(), self.tz,
                                            self.x.get(), self.y.get(), self.z.get(), 
                                            self.input_crs.get(), self.output_crs.get(), self.elev_unit.get(), 
                                            self.hvsrBand_min.get(), self.hvsrBand_max.get(),
                                            self.peakFreqRange_min.get(), self.peakFreqRange_max.get()))
        self.input_params_call.pack(anchor=&#39;w&#39;, expand=True, padx=20)

        #fetch_data() call
        fetch_data_LF = ttk.LabelFrame(master=self.input_tab, text=&#39;fetch_data() call&#39;)
        self.fetch_data_call = ttk.Label(master=fetch_data_LF, text=&#34;fetch_data(params, source={}, trim_dir={}, export_format={}, detrend={}, detrend_options={})&#34;
                                                                .format(self.file_source.get(), None, self.export_format.get(), self.detrend.get(), self.detrend_options.get()))
        self.fetch_data_call.pack(anchor=&#39;w&#39;, expand=True, padx=20)

        #Set up frame for reading and running
        runFrame_hvsr = ttk.Frame(self.input_tab)
        runFrame_hvsr.columnconfigure(0, weight=1)

        self.inputProgBar = ttk.Progressbar(runFrame_hvsr, orient=&#39;horizontal&#39;)
        self.inputProgBar.grid(row=0, column=0, sticky=&#39;ew&#39;)#.pack(fill=&#39;both&#39;,expand=True, side=&#39;left&#39;, anchor=&#39;sw&#39;)

        self.style.configure(style=&#39;Custom.TButton&#39;, background=&#39;#d49949&#39;)
        self.read_button = ttk.Button(runFrame_hvsr, text=&#34;Read Data&#34;, command=read_data, width=30, style=&#39;Custom.TButton&#39;)

        self.style.configure(&#39;Run.TButton&#39;, background=&#39;#8b9685&#39;, width=10, height=3)
        self.run_button = ttk.Button(runFrame_hvsr, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)        
        self.run_button.grid(row=0, column=2, sticky=&#39;nsew&#39;, padx=2.5)#.pack(side=&#39;right&#39;, anchor=&#39;se&#39;, padx=(10,0))
        self.read_button.grid(row=0, column=1, sticky=&#39;nsew&#39;, padx=2.5)#.pack(side=&#39;right&#39;, anchor=&#39;se&#39;)

        hvsrFrame.pack(fill=&#39;both&#39;, expand=True, side=&#39;top&#39;)#.grid(row=0, sticky=&#34;nsew&#34;)
        runFrame_hvsr.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;)
        fetch_data_LF.pack(fill=&#39;x&#39;, side=&#39;bottom&#39;)
        input_params_LF.pack(fill=&#39;x&#39;, side=&#39;bottom&#39;)
        self.input_tab.pack(fill=&#39;both&#39;, expand=True)
        self.tab_control.add(self.input_tab, text=&#34;Input&#34;)

        #Data Preview Tab
        self.preview_data_tab = ttk.Frame(self.tab_control)

        # Configure the row and column of the input_tab to have a non-zero weight
        self.preview_data_tab.pack(expand=1)

        self.inputdataFrame = ttk.LabelFrame(self.preview_data_tab, text=&#34;Input Data Viewer&#34;)
        self.inputdataFrame.pack(expand=True, fill=&#39;both&#39;)
            
        self.inputInfoFrame = ttk.LabelFrame(self.inputdataFrame, text=&#34;Input Data Info&#34;)
        self.input_data_label = ttk.Label(self.inputInfoFrame, text=self.data_filepath_entry.get())
        self.input_data_label.pack(anchor=&#39;w&#39;, fill=&#39;both&#39;, expand=True, padx=15)                
        self.inputInfoFrame.pack(expand=True, fill=&#39;both&#39;, side=&#39;top&#39;)
        
        self.inputDataViewFrame = ttk.LabelFrame(self.inputdataFrame, text=&#34;Input Data Plot&#34;)
                    
        ttk.Label(master=self.inputInfoFrame, text=self.data_filepath_entry.get()).pack()#.grid(row=0, column=0)

        #Set up plot
        #Reset axes, figure, and canvas widget
        self.fig_pre = plt.figure()

        prev_mosaic = [[&#39;Z&#39;],[&#39;N&#39;],[&#39;E&#39;]]
        self.ax_pre = self.fig_pre.subplot_mosaic(prev_mosaic, sharex=True)  

        self.canvas_pre = FigureCanvasTkAgg(self.fig_pre, master=self.inputDataViewFrame)  # A tk.DrawingArea.
        self.canvas_pre.draw()
        self.canvasPreWidget = self.canvas_pre.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
        self.preview_toolbar = NavigationToolbar2Tk(self.canvas_pre, self.inputDataViewFrame, pack_toolbar=False)
        self.preview_toolbar.update()
    
        #self.canvas_pre.mpl_connect(&#34;button_release_event&#34;, select_windows)

        #Save preview figure
        savePrevFigFrame = ttk.Frame(master=self.inputDataViewFrame)
        
        ttk.Label(savePrevFigFrame, text=&#34;Export Figure&#34;).grid(row=0, column=0, sticky=&#39;ew&#39;, padx=5)
        self.previewFig_dir = tk.StringVar()
        self.previewFig_dir_entry = ttk.Entry(savePrevFigFrame, textvariable=self.previewFig_dir)
        self.previewFig_dir_entry.grid(row=0, column=1, columnspan=5, sticky=&#39;ew&#39;)
        
        
        def filepath_preview_fig():
            filepath = filedialog.asksaveasfilename(defaultextension=&#39;.png&#39;, initialdir=pathlib.Path(self.data_path.get()).parent)
            if filepath:
                self.previewFig_dir_entry.delete(0, &#39;end&#39;)
                self.previewFig_dir_entry.insert(0, filepath)
        
        
        def save_preview_fig():
            self.fig_pre.savefig(self.previewFig_dir.get())
        
        self.browsePreviewFig = ttk.Button(savePrevFigFrame, text=&#34;Browse&#34;,command=filepath_preview_fig)
        self.browsePreviewFig.grid(row=0, column=7, sticky=&#39;ew&#39;, padx=2.5)
        
        self.savePreviewFig = ttk.Button(savePrevFigFrame, text=&#34;Save&#34;,command=save_preview_fig)
        self.savePreviewFig.grid(row=0, column=8, columnspan=2, sticky=&#39;ew&#39;, padx=2.5)

        savePrevFigFrame.columnconfigure(1, weight=1)

        savePrevFigFrame.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, expand=False)
        self.preview_toolbar.pack(side=tk.BOTTOM, fill=tk.X)            
        self.canvasPreWidget.pack(fill=&#39;both&#39;, expand=True)#.grid(row=0, column=0, sticky=&#39;nsew&#39;)

        self.inputDataViewFrame.pack(expand=True, fill=&#39;both&#39;, side=&#39;bottom&#39;)
        
        #preview-Run button
        runFrame_dataPrev = ttk.Frame(self.preview_data_tab)
        runFrame_dataPrev.columnconfigure(0, weight=1)

        self.prevProgBar = ttk.Progressbar(runFrame_dataPrev, orient=&#39;horizontal&#39;)
        self.prevProgBar.grid(row=0, column=0, sticky=&#39;ew&#39;)#.pack(fill=&#39;both&#39;,expand=True, side=&#39;left&#39;, anchor=&#39;sw&#39;)

        self.run_button = ttk.Button(runFrame_dataPrev, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)
        self.run_button.grid(row=0, column=1, sticky=&#39;nsew&#39;, padx=2.5)#.pack(side=&#39;bottom&#39;, anchor=&#39;e&#39;)#.grid(row=2, column=9, columnspan=20, sticky=&#39;e&#39;)
        runFrame_dataPrev.pack(side=&#39;bottom&#39;, anchor=&#39;e&#39;, fill=&#39;both&#39;)#grid(row=1, sticky=&#39;e&#39;)

        self.tab_control.add(self.preview_data_tab, text=&#34;Data Preview&#34;)

        # NOISE TAB
        self.noise_tab = ttk.Frame(self.tab_control)
        self.canvasFrame_noise = ttk.LabelFrame(self.noise_tab, text=&#39;Noise Viewer&#39;)

        #Helper function for updating the canvas and drawing/deleted the boxes
        
        def __draw_windows(event, pathlist, ax_key, windowDrawn, winArtist, xWindows, fig, ax):
            &#34;&#34;&#34;Helper function for updating the canvas and drawing/deleted the boxes&#34;&#34;&#34;
            for i, pa in enumerate(pathlist):
                for j, p in enumerate(pa): 
                    if windowDrawn[i][j]:
                        pass
                    else:
                        patch = matplotlib.patches.PathPatch(p, facecolor=&#39;k&#39;, alpha=0.75)                            
                        winArt = ax[ax_key].add_patch(patch)
                        windowDrawn[i][j] = True
                        winArtist[i][j] = winArt

            if event.button is MouseButton.RIGHT:
                fig.canvas.draw()

        #Helper function for manual window selection 
        
        def __draw_boxes(event, clickNo, xWindows, pathList, windowDrawn, winArtist, lineArtist, x0, fig, ax):
            &#34;&#34;&#34;Helper function for manual window selection to draw boxes to show where windows have been selected for removal&#34;&#34;&#34;
            #Create an axis dictionary if it does not already exist so all functions are the same

            if isinstance(ax, np.ndarray) or isinstance(ax, dict):
                ax = ax
            else:
                ax = {&#39;a&#39;:ax}

            
            if len(ax) &gt; 1:
                if type(ax) is not dict:
                    axDict = {}
                    for i, a in enumerate(ax):
                        axDict[str(i)] = a
                    ax = axDict
            #else:
            #    ax = {&#39;a&#39;:ax}
            
            #if event.inaxes!=ax: return
            #y0, y1 = ax.get_ylim()
            y0 = []
            y1 = []
            kList = []
            for k in ax.keys():
                kList.append(k)
                y0.append(ax[k].get_ylim()[0])
                y1.append(ax[k].get_ylim()[1])
            #else:
            #    y0 = [ax.get_ylim()[0]]
            #    y1 = [ax.get_ylim()[1]]

            if self.clickNo == 0:
                #y = np.linspace(ax.get_ylim()[0], ax.get_ylim()[1], 2)
                self.x0 = event.xdata
                self.clickNo = 1   
                self.lineArtist.append([])
                winNums = len(self.xWindows)
                for i, k in enumerate(ax.keys()):
                    linArt = ax[k].axvline(self.x0, 0, 1, color=&#39;k&#39;, linewidth=1, zorder=100)
                    self.lineArtist[winNums].append([linArt, linArt])
                #else:
                #    linArt = plt.axvline(self.x0, y0[i], y1[i], color=&#39;k&#39;, linewidth=1, zorder=100)
                #    self.lineArtist.append([linArt, linArt])
            else:
                x1 = event.xdata
                self.clickNo = 0

                windowDrawn.append([])
                winArtist.append([])  
                pathList.append([])
                winNums = len(self.xWindows)
                for i, key in enumerate(kList):
                    path_data = [
                        (matplotlib.path.Path.MOVETO, (self.x0, y0[i])),
                        (matplotlib.path.Path.LINETO, (x1, y0[i])),
                        (matplotlib.path.Path.LINETO, (x1, y1[i])),
                        (matplotlib.path.Path.LINETO, (self.x0, y1[i])),
                        (matplotlib.path.Path.LINETO, (self.x0, y0[i])),
                        (matplotlib.path.Path.CLOSEPOLY, (self.x0, y0[i])),
                    ]
                    codes, verts = zip(*path_data)
                    path = matplotlib.path.Path(verts, codes)

                    windowDrawn[winNums].append(False)
                    winArtist[winNums].append(None)

                    pathList[winNums].append(path)
                    __draw_windows(event=event, pathlist=pathList, ax_key=key, windowDrawn=windowDrawn, winArtist=winArtist, xWindows=self.xWindows, fig=fig, ax=ax)
                    linArt = ax[key].axvline(x1, 0, 1, color=&#39;k&#39;, linewidth=0.5, zorder=100)

                    [self.lineArtist[winNums][i].pop(-1)]
                    self.lineArtist[winNums][i].append(linArt)
                x_win = [self.x0, x1]
                x_win.sort() #Make sure they are in the right order
                self.xWindows.append(x_win)
            fig.canvas.draw()
            return self.clickNo, self.x0

        #Helper function for manual window selection to draw boxes to deslect windows for removal
        
        def __remove_on_right(event, xWindows, pathList, windowDrawn, winArtist,  lineArtist, fig, ax):
            &#34;&#34;&#34;Helper function for manual window selection to draw boxes to deslect windows for removal&#34;&#34;&#34;

            if self.xWindows is not None:
                for i, xWins in enumerate(self.xWindows):
                    if event.xdata &gt; xWins[0] and event.xdata &lt; xWins[1]:
                        linArtists = self.lineArtist[i]
                        pathList.pop(i)
                        for j, a in enumerate(linArtists):
                            winArtist[i][j].remove()#.pop(i)
                            self.lineArtist[i][j][0].remove()#.pop(i)#[i].pop(j)
                            self.lineArtist[i][j][1].remove()
                        windowDrawn.pop(i)
                        self.lineArtist.pop(i)#[i].pop(j)
                        winArtist.pop(i)#[i].pop(j)
                        self.xWindows.pop(i)
            fig.canvas.draw() 
               
        
        def select_windows(event, input=None, initialize=False):
            &#34;&#34;&#34;Function to manually select windows for exclusion from data.

            Parameters
            ----------
            input : dict
                Dictionary containing all the hvsr information.

            Returns
            -------
            self.xWindows : list
                List of two-item lists containing start and end times of windows to be removed.
            &#34;&#34;&#34;
            from matplotlib.backend_bases import MouseButton
            import matplotlib.pyplot as plt
            
            #self.fig_noise, self.ax_noise = sprit_hvsr._plot_simple_stream_obspy(stream=input[&#39;stream&#39;], params=input, fig=self.fig_noise, ax=self.ax_noise, component=&#39;Z&#39;, stack_type=&#39;linear&#39;, detrend=&#39;mean&#39;, fill_gaps=0, dbscale=True, return_fig=True, cmap_per=[0.1,0.9])
            #self.fig_noise.canvas.draw()
            
            #if &#39;stream&#39; in input.keys():
            #    self.fig_noise, self.ax_noise = sprit_hvsr._plot_simple_stream_obspy(stream=self.params[&#39;stream&#39;], params=self.params, fig=self.fig_noise, ax=self.ax_noise, component=&#39;Z&#39;, stack_type=&#39;linear&#39;, detrend=&#39;mean&#39;, fill_gaps=0, dbscale=True, return_fig=True, cmap_per=[0.1,0.9])
            #else:
            #    params = input.copy()
            #    input = input[&#39;stream&#39;]
            
            #if isinstance(input, obspy.core.stream.Stream):
            #    fig, ax = sprit_hvsr._plot_simple_stream_obspy(input, component=[&#39;Z&#39;])
            #elif isinstance(input, obspy.core.trace.Trace):
            #    fig, ax = sprit_hvsr._plot_simple_stream_obspy(input)
            if initialize:
                self.lineArtist = []
                self.winArtist = []
                self.windowDrawn = []
                self.pathList = []
                self.xWindows = []
                self.x0 = 0
                self.clickNo = 0
            
            if not initialize:
                __on_click(event)
                self.hvsr_data[&#39;xwindows_out&#39;] = self.xWindows


                #self.fig_closed
                #fig_closed = False
                #while fig_closed is False:
                #    #fig.canvas.mpl_connect(&#39;button_press_event&#39;, __on_click)#(self.clickNo, self.xWindows, pathList, windowDrawn, winArtist, lineArtist, self.x0, fig, ax))
                #    fig.canvas.mpl_connect(&#39;close_event&#39;, _on_fig_close)#(self.clickNo, self.xWindows, pathList, windowDrawn, winArtist, lineArtist, self.x0, fig, ax))
                #    plt.pause(0.5)
                
                #output[&#39;xwindows_out&#39;] = self.xWindows
                #output[&#39;fig&#39;] = fig
                #output[&#39;ax&#39;] = ax
                noEvent = True
            return self.hvsr_data

        #Support function to help select_windows run properly
        
        def _on_fig_close(event):
            #self.fig_closed
            fig_closed = True
            return

        
        def __on_click(event):

            if event.button is MouseButton.RIGHT:
                __remove_on_right(event, self.xWindows, self.pathList, self.windowDrawn, self.winArtist, self.lineArtist, self.fig_noise, self.ax_noise)

            if event.button is MouseButton.LEFT:            
                self.clickNo, self.x0 = __draw_boxes(event, self.clickNo, self.xWindows, self.pathList, self.windowDrawn, self.winArtist, self.lineArtist, self.x0, self.fig_noise, self.ax_noise)    
        
        #if &#39;hvsr_data&#39; not in dir(self):
        #    self.hvsr_data = {&#39;placeholder&#39;:None}
            
        def plot_noise_windows(hvsr_data={&#39;placeholder&#39;:None}, initial_setup=False):
            if &#39;hvsr_data&#39; in dir(self):
                hvsr_data = self.hvsr_data
                
            if isinstance(hvsr_data, sprit_hvsr.HVSRBatch):
                batch_data = hvsr_data.copy()
                hvsr_data = hvsr_data[list(hvsr_data.keys())[0]]
            else:
                batch_data = None

            if initial_setup:
                self.xWindows=[]
            else:
                #Clear everything
                for key in self.ax_noise:
                    self.ax_noise[key].clear()
                self.fig_noise.clear()

                #Really make sure it&#39;s out of memory
                self.fig_noise = []
                self.ax_noise = []
                try:
                    self.fig_noise.get_children()
                except:
                    pass
                try:
                    self.ax_noise.get_children()
                except:
                    pass

            #Reset axes, figure, and canvas widget
            self.fig_noise = plt.figure()
    
            noise_mosaic = [[&#39;spec&#39;],[&#39;spec&#39;],[&#39;spec&#39;],
                    [&#39;spec&#39;],[&#39;spec&#39;],[&#39;spec&#39;],
                    [&#39;signalz&#39;],[&#39;signalz&#39;], [&#39;signaln&#39;], [&#39;signale&#39;]]
            self.ax_noise = self.fig_noise.subplot_mosaic(noise_mosaic, sharex=True)  


            if not initial_setup:
                self.noise_canvasWidget.destroy()
                self.noise_toolbar.destroy()
                self.fig_noise = sprit_plot._plot_simple_stream_obspy(stream=hvsr_data[&#39;stream&#39;], hv_data=hvsr_data, fig=self.fig_noise, ax=self.ax_noise, component=&#39;Z&#39;, stack_type=&#39;linear&#39;, detrend=&#39;mean&#39;, fill_gaps=0, dbscale=True, return_fig=True, cmap_per=[0.1,0.9])

            self.noise_canvas = FigureCanvasTkAgg(self.fig_noise, master=self.canvasFrame_noise)  # A tk.DrawingArea.
            self.noise_canvas.draw()
            #self.noise_canvasWidget = self.noise_canvas.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
            # pack_toolbar=False will make it easier to use a layout manager later on.
            self.noise_toolbar = NavigationToolbar2Tk(self.noise_canvas, self.canvasFrame_noise, pack_toolbar=False)
            self.noise_toolbar.update()
        
            self.noise_canvasWidget = self.noise_canvas.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
            self.noise_canvas.mpl_connect(&#34;button_release_event&#34;, select_windows)

            self.noise_toolbar.pack(side=tk.BOTTOM, fill=tk.X)            
            self.noise_canvasWidget.pack(fill=&#39;both&#39;)#.grid(row=0, column=0, sticky=&#39;nsew&#39;)

            if not initial_setup:
                if batch_data is None:
                    hvsr_data = {&#39;SITENAME&#39;:hvsr_data}
                else:
                    hvsr_data = batch_data

                for i, (k, hv_data) in enumerate(hvsr_data.items()):
                    #Reset edited data every time plot_noise_windows is run
                    #v_data[&#39;stream&#39;] = hv_data[&#39;input_stream&#39;].copy()                    
                    #Set initial input
                    #input = hv_data#[&#39;input_stream&#39;]

                    if self.do_stalta.get():
                        hv_data = sprit_hvsr.remove_noise(hvsr_data=hv_data, remove_method=&#39;stalta&#39;, sta=self.sta.get(), lta=self.lta.get(), stalta_thresh=[self.stalta_thresh_low.get(), self.stalta_thresh_hi.get()])

                    if self.do_pctThresh.get():
                        hv_data = sprit_hvsr.remove_noise(hvsr_data=hv_data, remove_method=&#39;saturation&#39;,  sat_percent=self.pct.get())

                    if self.do_noiseWin.get():
                        hv_data = sprit_hvsr.remove_noise(hvsr_data=hv_data, remove_method=&#39;noise&#39;, noise_percent=self.noise_amp_pct.get(), lta=self.lta_noise.get(), min_win_size=self.win_size_thresh.get())
                
                    if self.do_warmup.get():
                        hv_data = sprit_hvsr.remove_noise(hvsr_data=hv_data, remove_method=&#39;warmup&#39;, warmup_time=self.warmup_time.get(), cooldown_time=self.cooldown_time.get())

                    if i==0:
                        self.fig_noise, self.ax_noise, self.noise_windows_line_artists, self.noise_windows_window_artists = sprit_hvsr._get_removed_windows(input=hv_data, fig=self.fig_noise, ax=self.ax_noise, existing_xWindows=self.xWindows, time_type=&#39;matplotlib&#39;)
                        self.fig_noise.canvas.draw()

                if batch_data is None:
                    hvsr_data = hvsr_data[&#39;SITENAME&#39;]

                return hvsr_data
            
            self.fig_noise.canvas.draw()
            return

        plot_noise_windows({&#39;placeholder&#39;:None}, initial_setup=True)
        self.canvasFrame_noise.pack(fill=&#39;both&#39;)#.grid(row=0, column=0, sticky=&#34;nsew&#34;)

        #noise_mosaic = [[&#39;spec&#39;],[&#39;spec&#39;],[&#39;spec&#39;],
        #        [&#39;spec&#39;],[&#39;spec&#39;],[&#39;spec&#39;],
        #        [&#39;signalz&#39;],[&#39;signalz&#39;], [&#39;signaln&#39;], [&#39;signale&#39;]]
        #self.fig_noise, self.ax_noise = plt.subplot_mosaic(noise_mosaic, sharex=True)  
        #self.canvasFrame_noise = ttk.LabelFrame(self.noise_tab, text=&#39;Noise Viewer&#39;)
        #self.canvasFrame_noise.pack(fill=&#39;both&#39;)#.grid(row=0, column=0, sticky=&#34;nsew&#34;)

        #self.noise_canvas = FigureCanvasTkAgg(self.fig_noise, master=self.canvasFrame_noise)
        #self.noise_canvas.draw()
        #self.noise_canvasWidget = self.noise_canvas.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
        #self.noise_canvasWidget.pack(fill=&#39;both&#39;)#.grid(row=0, column=0, sticky=&#39;nsew&#39;)

        #Run button frame
        runFrame_noise = ttk.Frame(self.noise_tab)
        runFrame_noise.columnconfigure(0, weight=1)

        #Run area
        #Progress Bar
        self.noiseProgBar = ttk.Progressbar(runFrame_noise, orient=&#39;horizontal&#39;)
        self.noiseProgBar.grid(row=0, column=0, sticky=&#39;ew&#39;)#.pack(fill=&#39;both&#39;,expand=True, side=&#39;left&#39;, anchor=&#39;sw&#39;)

        #Update Noise Windows button
        self.style.configure(style=&#39;Noise.TButton&#39;, background=&#39;#86a5ba&#39;)
        self.noise_button = ttk.Button(runFrame_noise, text=&#34;Update Noise Windows&#34;, command=plot_noise_windows, width=30, style=&#39;Noise.TButton&#39;)
        
        self.noise_windows_line_artists = []
        self.noise_windows_window_artists = []

        self.style.configure(&#39;Run.TButton&#39;, background=&#39;#8b9685&#39;, width=10, height=3)
        self.run_button = ttk.Button(runFrame_noise, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)        
        self.noise_button.grid(row=0, column=1, sticky=&#39;nsew&#39;, padx=2.5)#.pack(side=&#39;right&#39;, anchor=&#39;se&#39;)
        self.run_button.grid(row=0, column=2, sticky=&#39;nsew&#39;, padx=2.5)#.pack(side=&#39;right&#39;, anchor=&#39;se&#39;, padx=(10,0))

        runFrame_noise.pack(fill=&#39;both&#39;,side=&#39;bottom&#39;, anchor=&#39;e&#39;)    


        def update_remove_noise_call():
            if &#39;prevAutoState&#39; not in dir(self):
                self.prevAutoState=self.do_auto.get()

            if self.prevAutoState and not self.do_auto.get():
                self.do_stalta.set(False)
                self.do_pctThresh.set(False)
                self.do_noiseWin.set(False)
                self.do_warmup.set(False)
            #Get method
            remMethDict = {&#39;auto&#39;:self.do_auto.get(),
                           &#39;stalta&#39;:self.do_stalta.get(),
                           &#39;sat_per&#39;:self.do_pctThresh.get(),
                           &#39;noise_per&#39;:self.do_noiseWin.get(),
                           &#39;warmcool&#39;:self.do_warmup.get(),
                           }

            remMethList = []
            for k, v in remMethDict.items():
                if v:
                    if k==&#39;auto&#39;:
                        remMethList = [&#39;auto&#39;]
                        break
                    remMethList.append(k)

            if len(remMethList)==1:
                remMethList = remMethList[0]
            
            if remMethList==&#39;auto&#39;:
                remMethList = &#39;auto&#39;
                self.do_auto.set(True)
                set_auto()

            if len(remMethList)==0:
                remMethList=None

            self.remove_noise_call.configure(text=&#34;remove_noise(hvsr_data, remove_method={}, sat_percent={}, noise_percent={}, sta={}, lta={}, stalta_thresh=[{},{}], warmup_time={}, cooldown_time={}, min_win_size={}, remove_raw_noise={})&#34;.format(
                                                                remMethList, self.pct.get(), self.noise_amp_pct.get(), self.sta.get(), self.lta.get(), self.stalta_thresh_low.get(), self.stalta_thresh_hi.get(), 
                                                                self.warmup_time.get(), self.cooldown_time.get(), self.win_size_thresh.get(),self.use_raw_data.get() ))

            self.prevAutoState = self.do_auto.get()


        #remove_noise Frame
        removeNoiseFrame = ttk.LabelFrame(self.noise_tab, text=&#39;remove_noise() call&#39;)

        self.remove_noise_call = ttk.Label(master=removeNoiseFrame, text=&#34;remove_noise(hvsr_data, remove_method=&#39;auto&#39;,sat_percent=0.995, noise_percent=0.80, sta=2, lta=30, stalta_thresh=[0.5,5], warmup_time=0, cooldown_time=0, min_win_size=1, remove_raw_noise=False)&#34;)
        self.remove_noise_call.grid(row=0, column=0, padx=5, pady=(0,5))
        removeNoiseFrame.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;)#.grid(row=0, column=1, sticky=&#39;nsew&#39;)

        noiseFrame = ttk.LabelFrame(self.noise_tab, text=&#39;Noise Removal&#39;)
        noiseFrame.pack(fill=&#39;both&#39;)#.grid(row=1, columnspan=2, sticky=&#39;nsew&#39;)

        #Options for doing stalta antitrigger for noise removal
        stltaremoveFrame = ttk.LabelFrame(noiseFrame, text=&#39;STA/LTA Antitrigger&#39;)
        stltaremoveFrame.grid(row=0, column=0, columnspan=1, sticky=&#39;nsew&#39;)
        
        self.do_stalta = tk.BooleanVar()
        staltaBool = ttk.Checkbutton(master=stltaremoveFrame, text=&#34;&#34;, variable=self.do_stalta, command=update_remove_noise_call) # create the Checkbutton widget
        staltaBool.grid(row=0, column=0, sticky=&#39;ew&#39;)
        
        ttk.Label(master=stltaremoveFrame, text=&#34;STA [s]&#34;).grid(row=0, column=1)
        self.sta = tk.DoubleVar()
        self.sta.set(5)
        staEntry = ttk.Entry(master=stltaremoveFrame, textvariable=self.sta, width=5, validate=&#39;focusout&#39;, validatecommand=update_remove_noise_call) # create the Entry widget
        staEntry.grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5,10))

        ttk.Label(master=stltaremoveFrame, text=&#34;LTA [s]&#34;).grid(row=0, column=3)
        self.lta = tk.DoubleVar()
        self.lta.set(30)
        ltaEntry = ttk.Entry(master=stltaremoveFrame, textvariable=self.lta, width=5, validate=&#39;focusout&#39;, validatecommand=update_remove_noise_call) # create the Entry widget
        ltaEntry.grid(row=0, column=4, sticky=&#39;ew&#39;, padx=(5,10))

        ttk.Label(master=stltaremoveFrame, text=&#34;STA/LTA Thresholds (Low, High)&#34;).grid(row=0, column=5)
        self.stalta_thresh_low = tk.DoubleVar()
        self.stalta_thresh_low.set(0.5)
        staltaLowEntry = ttk.Entry(master=stltaremoveFrame, textvariable=self.stalta_thresh_low, width=5, validate=&#39;focusout&#39;, validatecommand=update_remove_noise_call) # create the Entry widget
        staltaLowEntry.grid(row=0, column=6, sticky=&#39;ew&#39;, padx=(5,0))
        
        self.stalta_thresh_hi = tk.DoubleVar()
        self.stalta_thresh_hi.set(5)
        staltaHiEntry = ttk.Entry(master=stltaremoveFrame, textvariable=self.stalta_thresh_hi, width=5, validate=&#39;focusout&#39;, validatecommand=update_remove_noise_call) # create the Entry widget
        staltaHiEntry.grid(row=0, column=7, sticky=&#39;ew&#39;)
        
        #Options for Percentage threshold removal
        pctThresFrame = ttk.LabelFrame(noiseFrame, text=&#39;Percentage Threshold&#39;)
        pctThresFrame.grid(row=1, column=0, sticky=&#39;nsew&#39;)

        self.do_pctThresh= tk.BooleanVar()
        pctBool = ttk.Checkbutton(master=pctThresFrame, text=&#34;&#34;, variable=self.do_pctThresh, command=update_remove_noise_call) # create the Checkbutton widget
        pctBool.grid(row=0, column=0, sticky=&#39;ew&#39;)
 
        ttk.Label(master=pctThresFrame, text=&#34;Max Saturation %&#34;).grid(row=0, column=1)
        self.pct = tk.DoubleVar()
        self.pct.set(0.995)
        pctEntry = ttk.Entry(master=pctThresFrame, textvariable=self.pct, width=10, validate=&#39;focusout&#39;, validatecommand=update_remove_noise_call) # create the Entry widget
        pctEntry.grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5,10))

        ttk.Label(master=pctThresFrame, text=&#34;&#34;, width=27).grid(row=0, column=3, columnspan=2)

        #Options for noisy window
        noisyWindowFrame = ttk.LabelFrame(noiseFrame, text=&#39;Noisy Windows&#39;)
        noisyWindowFrame.grid(row=2, column=0, sticky=&#39;nsew&#39;)

        self.do_noiseWin = tk.BooleanVar()
        winNoiseBool = ttk.Checkbutton(master=noisyWindowFrame, text=&#34;&#34;, variable=self.do_noiseWin, command=update_remove_noise_call) # create the Checkbutton widget
        winNoiseBool.grid(row=0, column=0, sticky=&#39;ew&#39;)
 
        ttk.Label(master=noisyWindowFrame, text=&#34;Max Window %&#34;).grid(row=0, column=1)
        self.noise_amp_pct = tk.DoubleVar()
        self.noise_amp_pct.set(0.80)
        winamppctEntry = ttk.Entry(master=noisyWindowFrame, textvariable=self.noise_amp_pct, width=10, validate=&#39;focusout&#39;, validatecommand=update_remove_noise_call) # create the Entry widget
        winamppctEntry.grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5,10))

        ttk.Label(master=noisyWindowFrame, text=&#34;Window Length [sec]&#34;).grid(row=0, column=3)
        self.lta_noise = tk.DoubleVar()
        self.lta_noise.set(30)
        winamppctEntry = ttk.Entry(master=noisyWindowFrame, textvariable=self.lta_noise, width=10, validate=&#39;focusout&#39;, validatecommand=update_remove_noise_call) # create the Entry widget
        winamppctEntry.grid(row=0, column=4, sticky=&#39;ew&#39;, padx=(5,10))

        ttk.Label(master=noisyWindowFrame, text=&#34;Min. Window Size [sec]&#34;).grid(row=0, column=5)
        self.win_size_thresh = tk.DoubleVar()
        self.win_size_thresh.set(0)
        win_size_Entry = ttk.Entry(master=noisyWindowFrame, textvariable=self.win_size_thresh, width=10, validate=&#39;focusout&#39;, validatecommand=update_remove_noise_call) # create the Entry widget
        win_size_Entry.grid(row=0, column=6, sticky=&#39;e&#39;, padx=(5,10))

        #Options for warmup
        warmupFrame = ttk.LabelFrame(noiseFrame, text=&#39;Warmup &amp; Cooldown Time&#39;)
        warmupFrame.grid(row=0, column=1, sticky=&#39;nsew&#39;)

        self.do_warmup= tk.BooleanVar()
        warmupBool = ttk.Checkbutton(master=warmupFrame, text=&#34;&#34;, variable=self.do_warmup, command=update_remove_noise_call) # create the Checkbutton widget
        warmupBool.grid(row=0, column=0, sticky=&#39;ew&#39;)
 
        ttk.Label(master=warmupFrame, text=&#34;Warmup time [s]&#34;).grid(row=0, column=1)
        self.warmup_time = tk.DoubleVar()
        warmupEntry = ttk.Entry(master=warmupFrame, textvariable=self.warmup_time, width=10, validate=&#39;focusout&#39;, validatecommand=update_remove_noise_call) # create the Entry widget
        warmupEntry.grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5,10))
        warmupEntry.delete(0, &#39;end&#39;)
        warmupEntry.insert(0, &#39;0&#39;)
 
        ttk.Label(master=warmupFrame, text=&#34;Cooldown Time [s]&#34;).grid(row=0, column=3)
        self.cooldown_time = tk.DoubleVar()
        cooldownEntry = ttk.Entry(master=warmupFrame, textvariable=self.cooldown_time, width=10, validate=&#39;focusout&#39;, validatecommand=update_remove_noise_call) # create the Entry widget
        cooldownEntry.grid(row=0, column=5, sticky=&#39;ew&#39;, padx=(5,10))
        cooldownEntry.delete(0, &#39;end&#39;)
        cooldownEntry.insert(0, &#39;0&#39;)

        #Options for doing stdev noise removal
        stdremoveFrame = ttk.LabelFrame(noiseFrame, text=&#39;Standard Deviation Antitrigger (not yet implemented)&#39;)
        stdremoveFrame.grid(row=1, column=1, columnspan=1, sticky=&#39;nsew&#39;)
        
        self.do_stdev = tk.BooleanVar()
        stdBool = ttk.Checkbutton(master=stdremoveFrame, text=&#34;&#34;, variable=self.do_stdev, state=&#39;disabled&#39;, command=update_remove_noise_call) # create the Checkbutton widget
        stdBool.grid(row=0, column=0, sticky=&#39;ew&#39;)
        
        ttk.Label(master=stdremoveFrame, text=&#34;Std Deviation Ratio (moving stdev/total stdev)&#34;).grid(row=0, column=1)
        self.stdRatio = tk.DoubleVar()
        stdRatEntry = ttk.Entry(master=stdremoveFrame, textvariable=self.stdRatio, width=5, state=&#39;disabled&#39;, validate=&#39;focusout&#39;, validatecommand=update_remove_noise_call) # create the Entry widget
        stdRatEntry.grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5,10))
        stdRatEntry.delete(0, &#39;end&#39;)
        stdRatEntry.insert(0, &#39;1&#39;)
        
        ttk.Label(master=stdremoveFrame, text=&#34;Window Length [s]&#34;).grid(row=0, column=3)
        self.stdWinLen = tk.DoubleVar()
        stdWinLenEntry = ttk.Entry(master=stdremoveFrame, textvariable=self.stdWinLen, width=5, state=&#39;disabled&#39;,validate=&#39;focusout&#39;, validatecommand=update_remove_noise_call) # create the Entry widget
        stdWinLenEntry.grid(row=0, column=4, sticky=&#39;ew&#39;, padx=(5,10))
        stdWinLenEntry.delete(0, &#39;end&#39;)
        stdWinLenEntry.insert(0, &#39;5&#39;)

        #Quick set the auto 
        #autoFrame = ttk.LabelFrame(noiseFrame, text=&#39;Auto Run&#39;)
        #autoFrame.grid(row=2, column=1, columnspan=1, sticky=&#39;nsew&#39;)

        
        def set_auto():
            if self.do_auto.get():
                self.do_stalta.set(True)
                self.do_stdev.set(True)
                self.do_warmup.set(True)
                self.do_noiseWin.set(True)
                self.do_pctThresh.set(True)
            else:
                self.do_stalta.set(False)
                self.do_stdev.set(False)
                self.do_warmup.set(False)
                self.do_noiseWin.set(False)
                self.do_pctThresh.set(False)                
                pass
            

        #Additional options
        addOptionsFrame = ttk.LabelFrame(noiseFrame, text=&#39;&#39;)
        addOptionsFrame.grid(row=2, column=1, columnspan=1, sticky=&#39;nsew&#39;)


        self.do_auto= tk.BooleanVar()
        autoBool = ttk.Checkbutton(master=addOptionsFrame, text=&#34;Set Auto Run&#34;, variable=self.do_auto, command=update_remove_noise_call) # create the Checkbutton widget
        autoBool.grid(row=0, column=0, sticky=&#39;nsew&#39;, padx=5)

        self.use_raw_data= tk.BooleanVar()
        rawDataRemoveBool = ttk.Checkbutton(master=addOptionsFrame, text=&#34;Remove from raw data&#34;, variable=self.use_raw_data, command=update_remove_noise_call) # create the Checkbutton widget
        rawDataRemoveBool.grid(row=0, column=1, sticky=&#39;nsew&#39;, padx=5)

        #Export noise windows
        ttk.Label(noiseFrame, text=&#34;Export Figure&#34;).grid(row=4, column=0, sticky=&#39;ew&#39;, padx=5)
        self.results_noise_dir = tk.StringVar()
        self.results_noise_dir_entry = ttk.Entry(noiseFrame, textvariable=self.results_noise_dir)
        self.results_noise_dir_entry.grid(row=4, column=0, columnspan=5, sticky=&#39;ew&#39;, padx=(100,5))
        
        
        def filepath_noise_fig():
            filepath = filedialog.asksaveasfilename(defaultextension=&#39;png&#39;, initialdir=pathlib.Path(self.data_path.get()).parent, initialfile=self.params[&#39;site&#39;]+&#39;_noisewindows.png&#39;)
            if filepath:
                self.results_noise_dir_entry.delete(4, &#39;end&#39;)
                self.results_noise_dir_entry.insert(4, filepath)
        
        
        def save_noise_fig():
            self.fig_noise.savefig(self.results_noise_dir.get())
        
        self.browse_noise_fig = ttk.Button(noiseFrame, text=&#34;Browse&#34;,command=filepath_noise_fig)
        self.browse_noise_fig.grid(row=4, column=7, sticky=&#39;ew&#39;, padx=2.5)
        
        self.save_noise_fig = ttk.Button(noiseFrame, text=&#34;Save&#34;,command=save_noise_fig)
        self.save_noise_fig.grid(row=4, column=8, columnspan=2, sticky=&#39;ew&#39;, padx=2.5)

        self.noise_tab.pack(expand=1)
        self.tab_control.add(self.noise_tab, text=&#34;Noise&#34;)

        # SETTINGS TAB
        self.settings_tab = ttk.Frame(self.tab_control)
        
        self.tab_control.add(self.settings_tab, text=&#34;Settings&#34;)
        
        # Create a new Notebook widget within the Settings tab
        settings_notebook = ttk.Notebook(self.settings_tab)

        # Create the tabs within the Settings tab
        #PPSD SETTINGS SUBTAB
        ppsd_settings_tab = ttk.Frame(settings_notebook)
        ppsdSettingsFrame = ttk.LabelFrame(ppsd_settings_tab, text=&#39;Input Settings&#39;)#.pack(fill=&#39;both&#39;)
        ppsdParamsFrame = ttk.LabelFrame(ppsd_settings_tab, text=&#39;PPSD Parameters&#39;)#.pack(fill=&#39;both&#39;)

        # ppsd_length=30.0
        
        def on_ppsd_length():
            try:
                float(self.ppsd_length.get())
                ppsdLenLabel.configure(text=&#39;ppsd_length={}&#39;.format(self.ppsd_length.get()))
                update_ppsd_call(self.ppsd_call)
                return True
            except ValueError:
                return False
        ppsdLenLabel = ttk.Label(master=ppsdParamsFrame, text=&#39;ppsd_length=30.0 &#39;)#.grid(row=0, column=0)
        ppsdLenLabel.grid(row=0, column=0, sticky=&#39;w&#39;, pady=(6,6), padx=5)
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;PPSD Length (in seconds) [float]&#39;).grid(row=0, column=0, sticky=&#39;w&#39;, padx=5)
        self.ppsd_length = tk.DoubleVar()
        self.ppsd_length.set(30)
        ppsdLenEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=self.ppsd_length, width=10, validate=&#39;focusout&#39;, validatecommand=on_ppsd_length)
        ppsdLenEntry.grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))

        # overlap=0.5, 
        
        def on_overlap():
            try:
                overlap = float(self.overlap.get())
                if overlap &gt; 1:
                    self.overlap.set(overlap/100)
                overlapLabel.configure(text=&#39;overlap={}&#39;.format(self.overlap.get()))
                update_ppsd_call(self.ppsd_call)
                return True
            except ValueError:
                return False
        overlapLabel = ttk.Label(master=ppsdParamsFrame, text=&#39;overlap=0.5 &#39;)#.grid(row=0, column=0)
        overlapLabel.grid(row=1, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Overlap % (0-1) [float]&#39;).grid(row=1, column=0, sticky=&#39;w&#39;, padx=5)
        self.overlap = tk.DoubleVar()
        self.overlap.set(0.5)
        overlapEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=self.overlap, width=10, validate=&#39;focusout&#39;, validatecommand=on_overlap)
        overlapEntry.grid(row=1, column=1, sticky=&#39;w&#39;, padx=(5, 10))

        # period_step_octaves=0.0625, 
        
        def on_per_step_oct():
            try:
                float(self.perStepOct.get())
                
                pStepOctLabel.configure(text=&#39;period_step_octaves={}&#39;.format(self.perStepOct.get()))
                update_ppsd_call(self.ppsd_call)            
                return True
            except ValueError:
                return False
        pStepOctLabel = ttk.Label(master=ppsdParamsFrame, text=&#39;period_step_octaves=0.0625&#39;)#.grid(row=0, column=0)
        pStepOctLabel.grid(row=2, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Period Step Octave [float]&#39;).grid(row=2, column=0, sticky=&#39;w&#39;, padx=5)
        self.perStepOct = tk.DoubleVar()
        self.perStepOct.set(0.0625)
        pStepOctEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=self.perStepOct, width=10, validate=&#39;focusout&#39;, validatecommand=on_per_step_oct)
        pStepOctEntry.grid(row=2, column=1, sticky=&#39;w&#39;, padx=(5, 10))

        #skip_on_gaps
        
        def show_sog():
            if self.skip_on_gaps.get():
                sogLabel.configure(text =&#39;skip_on_gaps=True&#39;)
            else:
                sogLabel.configure(text =&#39;skip_on_gaps=False&#39;)
            update_ppsd_call(self.ppsd_call)
            
        self.skip_on_gaps = tk.BooleanVar()
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Skip on Gaps [bool]: &#39;, justify=&#39;left&#39;).grid(row=3, column=0, sticky=&#39;w&#39;, padx=5)
        sogCheckButton = ttk.Checkbutton(master=ppsdSettingsFrame, text=&#39;&#39;, variable=self.skip_on_gaps, command=show_sog) # create the Entry widget
        sogCheckButton.grid(row=3, column=1, sticky=&#39;ew&#39;, padx=(5,10))
        sogLabel = ttk.Label(master=ppsdParamsFrame, text=&#39;skip_on_gaps=False&#39;)
        sogLabel.grid(row=3, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

        # db_bins=(-200, -50, 1.0), 
        
        def show_dbbins():
            try:
                float(minDB.get())
                float(maxDB.get())
                float(dB_step.get())
                dbbinsLabel.configure(text=&#39;db_bins=({}, {}, {})&#39;.format(
                    minDB.get(), maxDB.get(), dB_step.get()))
                self.db_bins = (minDB.get(), maxDB.get(), dB_step.get())
                update_ppsd_call(self.ppsd_call)
                return True
            except ValueError:
                return False

        dbbinsLabel = ttk.Label(master=ppsdParamsFrame,
                                text=&#39;db_bins=(-200, -50, 1.0)&#39;)
        dbbinsLabel.grid(row=4, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
        ttk.Label(master=ppsdSettingsFrame, text=&#39;dB Bins (Y Axis) [tuple]&#39;, justify=&#39;left&#39;).grid(row=4, column=0, sticky=&#39;w&#39;, padx=5)
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Min. dB&#39;).grid(row=4, column=1, sticky=&#39;e&#39;, padx=5)
        minDB = tk.DoubleVar()
        minDB.set(-200)
        minDBEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=minDB,
                            validate=&#34;focusout&#34;, validatecommand=show_dbbins, width=10)
        minDBEntry.grid(row=4, column=2, sticky=&#39;w&#39;, padx=(5, 10))
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Max. dB&#39;).grid(row=4, column=3, sticky=&#39;e&#39;, padx=5)
        maxDB = tk.DoubleVar()
        maxDB.set(-50)
        maxDBEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=maxDB,
                            validate=&#34;focusout&#34;, validatecommand=show_dbbins, width=10)
        maxDBEntry.grid(row=4, column=4, sticky=&#39;w&#39;, padx=(5, 10))

        ttk.Label(master=ppsdSettingsFrame, text=&#39;dB Step&#39;).grid(row=4, column=5, sticky=&#39;e&#39;, padx=5)
        dB_step = tk.DoubleVar()
        dB_step.set(1.0)
        stepEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=dB_step,
                            validate=&#34;focusout&#34;, validatecommand=(show_dbbins), width=10)
        stepEntry.grid(row=4, column=6, sticky=&#39;w&#39;, padx=(5, 10))
        self.db_bins = (minDB.get(), maxDB.get(), dB_step.get())

        # period_limits=None,
        
        def show_per_lims():
            try:
                if minPerLim.get() == &#39;None&#39;:
                    pass
                else:
                    float(minPerLim.get())
                    
                if maxPerLim.get() == &#39;None&#39;:
                    pass
                else:
                    float(maxPerLim.get())
                    
                if minPerLim.get() == &#39;None&#39; or maxPerLim.get() == &#39;None&#39;:
                    perLimsLabel.configure(text=&#39;period_limits=None&#39;)
                else:
                    perLimsLabel.configure(text=&#39;period_limits=[{}, {}]&#39;.format(minPerLim.get(), maxPerLim.get()))
                    self.period_limits = [float(minPerLim.get()), float(maxPerLim.get())]
                update_ppsd_call(self.ppsd_call)
                return True
            except ValueError:
                return False

        perLimsLabel = ttk.Label(master=ppsdParamsFrame,
                                text=&#39;period_limits=None&#39;)
        perLimsLabel.grid(row=5, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Period Limits [list of floats or None]&#39;, justify=&#39;left&#39;).grid(row=5, column=0, sticky=&#39;w&#39;, padx=5)
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Min. Period Limit&#39;).grid(row=5, column=1, sticky=&#39;e&#39;, padx=5)
        minPerLim = tk.StringVar()
        minPerLim.set(None)
        minPerLimEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=minPerLim,
                            validate=&#34;focusout&#34;, validatecommand=(show_per_lims), width=10)
        minPerLimEntry.grid(row=5, column=2, sticky=&#39;w&#39;, padx=(5, 10))
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Max. Period Limit&#39;).grid(row=5, column=3, sticky=&#39;e&#39;, padx=5)
        maxPerLim = tk.StringVar()
        maxPerLim.set(None)
        maxPerLimEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=maxPerLim,
                            validate=&#34;focusout&#34;, validatecommand=(show_per_lims), width=10)
        maxPerLimEntry.grid(row=5, column=4, sticky=&#39;w&#39;, padx=(5, 10))

        if minPerLim.get() == &#39;None&#39; or maxPerLim.get() == &#39;None&#39;:
            self.period_limits = None
        else:
            self.period_limits = [float(minPerLim.get()), float(maxPerLim.get())]

        # period_smoothing_width_octaves=1.0,
        
        def on_per_smoothwidth_oct():
            try:
                float(self.perSmoothWidthOct.get())
                
                pSmoothWidthLabel.configure(text=&#39;period_smoothing_width_octaves={}&#39;.format(self.perSmoothWidthOct.get()))
                update_ppsd_call(self.ppsd_call)
                return True
            except ValueError:
                return False
        pSmoothWidthLabel = ttk.Label(master=ppsdParamsFrame, text=&#39;period_smoothing_width_octaves=1.0&#39;)#.grid(row=0, column=0)
        pSmoothWidthLabel.grid(row=6, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Period Smoothing Width (octaves) [float]&#39;).grid(row=6, column=0, sticky=&#39;w&#39;, padx=5)
        self.perSmoothWidthOct = tk.DoubleVar()
        self.perSmoothWidthOct.set(1.0)
        pSmoothWidthEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=self.perSmoothWidthOct, width=10, validate=&#39;focusout&#39;, validatecommand=on_per_smoothwidth_oct)
        pSmoothWidthEntry.grid(row=6, column=1, sticky=&#39;w&#39;, padx=(5, 10))
        
        # special_handling=None, 
        
        def on_special_handling():
            try:
                str(self.special_handling.get())
                if self.special_handling.get() == &#39;None&#39;:
                    specialHandlingLabel.configure(text=&#34;special_handling={}&#34;.format(self.special_handling.get()))
                    special_handling = None
                else:
                    specialHandlingLabel.configure(text=&#34;special_handling=&#39;{}&#39;&#34;.format(self.special_handling.get()))
                    special_handling = self.special_handling.get()
                update_ppsd_call(self.ppsd_call)
                return True
            except ValueError:
                return False

        specialHandlingLabel = ttk.Label(master=ppsdParamsFrame, text=&#34;special_handling=None&#34;)
        specialHandlingLabel.grid(row=7, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

        ttk.Label(master=ppsdSettingsFrame, text=&#39;Special Handling [str]&#39;).grid(row=7, column=0, sticky=&#39;w&#39;, padx=5)

        self.special_handling = tk.StringVar()
        self.special_handling.set(&#39;None&#39;)
        ttk.Radiobutton(master=ppsdSettingsFrame, text=&#39;None&#39;, variable=self.special_handling, value=&#39;None&#39;, command=on_special_handling).grid(row=7, column=1, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=ppsdSettingsFrame, text=&#39;Ringlaser&#39;, variable=self.special_handling, value=&#39;ringlaser&#39;, command=on_special_handling).grid(row=7, column=2, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=ppsdSettingsFrame, text=&#39;Hydrophone&#39;, variable=self.special_handling, value=&#39;hydrophone&#39;, command=on_special_handling).grid(row=7, column=3, sticky=&#39;w&#39;, padx=(5, 10))

        if self.special_handling.get()==&#39;None&#39;:
            special_handling = None
        else:
            special_handling = self.special_handling.get()

        separator = ttk.Separator(ppsdSettingsFrame, orient=&#39;horizontal&#39;)
        separator.grid(row=8, columnspan=8, sticky=&#39;ew&#39;, pady=10, padx=5)

        separator = ttk.Separator(ppsdParamsFrame, orient=&#39;horizontal&#39;)
        separator.grid(row=8, sticky=&#39;ew&#39;, pady=10, padx=5)

        #remove_outliers
        
        def show_rem_outliers():
            if self.remove_outliers.get():
                rem_outliers_Label.configure(text =&#39;remove_outliers=True&#39;)
            else:
                rem_outliers_Label.configure(text =&#39;remove_outliers=False&#39;)
            update_ppsd_call(self.ppsd_call)
            
        self.remove_outliers = tk.BooleanVar()
        self.remove_outliers.set(True)
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Remove outlier curves [bool]: &#39;, justify=&#39;left&#39;).grid(row=9, column=0, sticky=&#39;w&#39;, padx=5)
        rem_outliers_CheckButton = ttk.Checkbutton(master=ppsdSettingsFrame, text=&#39;&#39;, variable=self.remove_outliers, command=show_rem_outliers) # create the Entry widget
        rem_outliers_CheckButton.grid(row=9, column=1, sticky=&#39;ew&#39;, padx=(5,10))
        rem_outliers_Label = ttk.Label(master=ppsdParamsFrame, text=&#39;remove_outliers=True&#39;)
        rem_outliers_Label.grid(row=9, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

        # outlier_std=1.5, 
        
        def on_outlier_std():
            try:
                float(self.outlier_std.get())
                outlier_std_Label.configure(text=&#39;outlier_std={}&#39;.format(self.outlier_std.get()))
                update_ppsd_call(self.ppsd_call)            
                return True
            except ValueError:
                return False
        outlier_std_Label = ttk.Label(master=ppsdParamsFrame, text=&#39;outlier_std=1.5&#39;)#.grid(row=0, column=0)
        outlier_std_Label.grid(row=10, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;St. Dev. for Outliers [float]&#39;).grid(row=10, column=0, sticky=&#39;w&#39;, padx=5)
        self.outlier_std = tk.DoubleVar()
        self.outlier_std.set(1.5)
        outlier_std_Entry = ttk.Entry(master=ppsdSettingsFrame, textvariable=self.outlier_std, width=10, validate=&#39;focusout&#39;, validatecommand=on_outlier_std)
        outlier_std_Entry.grid(row=10, column=1, sticky=&#39;w&#39;, padx=(5, 10))


        #PPSD Function Call
        ppsdCallFrame = ttk.LabelFrame(ppsd_settings_tab, text=&#39;sprit_hvsr.generate_psds() and obspy PPSD() call&#39;)#.pack(fill=&#39;both&#39;) 
       
        self.ppsd_call = ttk.Label(master=ppsdCallFrame, text=&#39;obspy...PPSD({}, {}, {}, {}, {}, {}, \n\t{}, {}, {}, {})&#39;
                  .format(&#39;stats&#39;, &#39;metadata&#39;, ppsdLenLabel.cget(&#39;text&#39;), overlapLabel.cget(&#39;text&#39;), pStepOctLabel.cget(&#39;text&#39;), sogLabel.cget(&#39;text&#39;), 
                          dbbinsLabel.cget(&#39;text&#39;), perLimsLabel.cget(&#39;text&#39;), pSmoothWidthLabel.cget(&#39;text&#39;), specialHandlingLabel.cget(&#39;text&#39;)))
        self.ppsd_call.pack(side=&#39;bottom&#39;, anchor=&#39;w&#39;, padx=(25,0), pady=(10,10))

        self.generate_ppsd_call = ttk.Label(master=ppsdCallFrame, text=&#39;generate_psds({}, remove_outliers={}, outlier_std={},...\n\t{}, {}, {}, {}, {}, \n\t{}, {}, {})&#39;
                  .format(&#39;hvsr_data&#39;, self.remove_outliers.get(), self.outlier_std.get(), 
                          ppsdLenLabel.cget(&#39;text&#39;), overlapLabel.cget(&#39;text&#39;), pStepOctLabel.cget(&#39;text&#39;), sogLabel.cget(&#39;text&#39;), 
                          dbbinsLabel.cget(&#39;text&#39;), perLimsLabel.cget(&#39;text&#39;), pSmoothWidthLabel.cget(&#39;text&#39;), specialHandlingLabel.cget(&#39;text&#39;)))
        self.generate_ppsd_call.pack(side=&#39;bottom&#39;, anchor=&#39;w&#39;, padx=(25,0), pady=(10,10))
        
        
        def update_ppsd_call(ppsd_call):
            ppsd_call.configure(text=&#39;obspy...PPSD({}, {}, {}, {}, {}, {}, \n\t{}, {}, {}, {})&#39;.format(&#39;stats&#39;, &#39;metadata&#39;, ppsdLenLabel.cget(&#39;text&#39;), 
                                                                                                    overlapLabel.cget(&#39;text&#39;), pStepOctLabel.cget(&#39;text&#39;), sogLabel.cget(&#39;text&#39;), 
                          dbbinsLabel.cget(&#39;text&#39;), perLimsLabel.cget(&#39;text&#39;), pSmoothWidthLabel.cget(&#39;text&#39;), specialHandlingLabel.cget(&#39;text&#39;)))

            self.generate_ppsd_call.configure(text=&#39;generate_psds({}, remove_outliers={}, outlier_std={},...\n\t{}, {}, {}, {}, {}, \n\t{}, {}, {})&#39;
                            .format(&#39;hvsr_data&#39;, self.remove_outliers.get(), self.outlier_std.get(), 
                                    ppsdLenLabel.cget(&#39;text&#39;), overlapLabel.cget(&#39;text&#39;), pStepOctLabel.cget(&#39;text&#39;), sogLabel.cget(&#39;text&#39;), 
                                    dbbinsLabel.cget(&#39;text&#39;), perLimsLabel.cget(&#39;text&#39;), pSmoothWidthLabel.cget(&#39;text&#39;), specialHandlingLabel.cget(&#39;text&#39;)))
                    

        #Stats from trace(s)
        obspyStatsFrame = ttk.LabelFrame(ppsd_settings_tab, text=&#39;Data Trace Stats&#39;)#.pack(fill=&#39;both&#39;)
        self.obspySreamLabel_settings = ttk.Label(obspyStatsFrame, text=&#39;Stats&#39;)
        self.obspySreamLabel_settings.pack(anchor=&#39;nw&#39;, padx=5)

        #Metadata (PAZ)
        obspyMetadataFrame = ttk.LabelFrame(ppsd_settings_tab, text=&#39;Metadata Poles and Zeros&#39;)#.pack(fill=&#39;both&#39;)

        self.metadataZ_settings = ttk.Label(obspyMetadataFrame, text=&#39;Z: &#39;)
        self.metadataZ_settings.grid(row=1, column=0, padx=5)
        self.metadataZ_settings.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))
        self.sensitivityLabelZ_settings = ttk.Label(obspyMetadataFrame, text=&#39;Sensitivity_Z&#39;)
        self.sensitivityLabelZ_settings.grid(row=1, column=1, padx=5)
        self.gainLabelZ_settings = ttk.Label(obspyMetadataFrame, text=&#39;Gain_Z&#39;)
        self.gainLabelZ_settings.grid(row=1, column=2, padx=5)
        self.polesLabelZ_settings = ttk.Label(obspyMetadataFrame, text=&#39;Poles_Z&#39;)
        self.polesLabelZ_settings.grid(row=1, column=3, padx=5)
        self.zerosLabelZ_settings = ttk.Label(obspyMetadataFrame, text=&#39;Zeros_Z&#39;)
        self.zerosLabelZ_settings.grid(row=1, column=4, padx=5)
 
        self.metadataN_settings = ttk.Label(obspyMetadataFrame, text=&#39;N: &#39;)
        self.metadataN_settings.grid(row=2, column=0, padx=5)
        self.metadataN_settings.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))
        self.sensitivityLabelN_settings = ttk.Label(obspyMetadataFrame, text=&#39;Sensitivity_N&#39;)
        self.sensitivityLabelN_settings.grid(row=2, column=1, padx=5)
        self.gainLabelN_settings = ttk.Label(obspyMetadataFrame, text=&#39;Gain_N&#39;)
        self.gainLabelN_settings.grid(row=2, column=2, padx=5)
        self.polesLabelN_settings = ttk.Label(obspyMetadataFrame, text=&#39;Poles_N&#39;)
        self.polesLabelN_settings.grid(row=2, column=3, padx=5)
        self.zerosLabelN_settings = ttk.Label(obspyMetadataFrame, text=&#39;Zeros_N&#39;)
        self.zerosLabelN_settings.grid(row=2, column=4, padx=5)
 
        self.metadataE_settings = ttk.Label(obspyMetadataFrame, text=&#39;E: &#39;)
        self.metadataE_settings.grid(row=3, column=0, padx=5)
        self.metadataE_settings.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))
        self.sensitivityLabelE_settings = ttk.Label(obspyMetadataFrame, text=&#39;Sensitivity_E&#39;)
        self.sensitivityLabelE_settings.grid(row=3, column=1)
        self.gainLabelE_settings = ttk.Label(obspyMetadataFrame, text=&#39;Gain_E&#39;)
        self.gainLabelE_settings.grid(row=3, column=2, padx=5)
        self.polesLabelE_settings = ttk.Label(obspyMetadataFrame, text=&#39;Poles_E&#39;)
        self.polesLabelE_settings.grid(row=3, column=3, padx=5)
        self.zerosLabelE_settings = ttk.Label(obspyMetadataFrame, text=&#39;Zeros_E&#39;)
        self.zerosLabelE_settings.grid(row=3, column=4, padx=5)

        self.metadata_sensitivity = ttk.Label(obspyMetadataFrame, text=&#39;Sensitivity&#39;)
        self.metadata_sensitivity.grid(row=0, column=1, padx=5)
        self.metadata_sensitivity.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))

        self.metadata_gain = ttk.Label(obspyMetadataFrame, text=&#39;Gain&#39;)
        self.metadata_gain.grid(row=0, column=2, padx=5)
        self.metadata_gain.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))

        self.metadata_poles = ttk.Label(obspyMetadataFrame, text=&#39;Poles&#39;)
        self.metadata_poles.grid(row=0, column=3, padx=5)
        self.metadata_poles.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))

        self.metadata_zeros = ttk.Label(obspyMetadataFrame, text=&#39;Zeros&#39;)
        self.metadata_zeros.grid(row=0, column=4, padx=5)
        self.metadata_zeros.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))

        #Run button frame
        runFrame_set_ppsd = ttk.Frame(ppsd_settings_tab)
        self.run_button = ttk.Button(runFrame_set_ppsd, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)
        self.run_button.grid(row=0, column=11, sticky=&#39;ew&#39;, padx=2.5)

        self.settingsProgBar_ppsd = ttk.Progressbar(runFrame_set_ppsd, orient=&#39;horizontal&#39;)
        self.settingsProgBar_ppsd.grid(row=0, column=0, columnspan=10, sticky=&#39;ew&#39;)
        runFrame_set_ppsd.columnconfigure(0, weight=1)

        runFrame_set_ppsd.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;, anchor=&#39;e&#39;)            
        obspyMetadataFrame.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;,expand=True)#.grid(row=7, column=0, columnspan=6, sticky=&#39;nsew&#39;)#.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
        obspyStatsFrame.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;,expand=True)#.grid(row=6, column=0, columnspan=6, sticky=&#39;nsew&#39;)#.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
        ppsdCallFrame.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;,expand=True)#row=5, column=0, columnspan=6, sticky=&#39;nsew&#39;)#.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
        ppsdParamsFrame.pack(fill=&#39;both&#39;, side=&#39;right&#39;)#.grid(row=0, column=5, rowspan=4, sticky=&#39;nsew&#39;)#.pack(side=&#39;right&#39;,fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
        ppsdSettingsFrame.pack(fill=&#39;both&#39;, expand=True, side=&#39;top&#39;, anchor=&#39;w&#39;)#.grid(row=0, column=0, columnspan=4, rowspan=4, sticky=&#39;nsew&#39;)#.pack(side=&#39;left&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
    
        ppsd_settings_tab.pack(fill=&#39;both&#39;, expand=True)
        settings_notebook.add(ppsd_settings_tab, text=&#34;PPSD&#34;)

        #HVSR SETTINGS SUBTAB
        hvsr_settings_tab = ttk.Frame(settings_notebook)
        
        hvsrSettingsFrame = ttk.LabelFrame(hvsr_settings_tab, text=&#39;H/V Processing Settings&#39;)#.pack(fill=&#39;both&#39;)
        
        hvsrParamsFrame = ttk.LabelFrame(hvsr_settings_tab, text=&#39;Process HVSR Parameters&#39;)#.pack(fill=&#39;both&#39;)
        
        #Method selection, method=4
        ttk.Label(hvsrSettingsFrame, text=&#34;Horizontal Combine Method [int]&#34;).grid(row=0, column=0, padx=(5,0), sticky=&#39;w&#39;)
        method_options = [&#39;&#39;, #Empty to make intuitive and match sprit_hvsr.py
                          &#34;1.Diffuse Field Assumption (not currently implemented)&#34;, 
                          &#34;2. Arithmetic Mean H ≡ (N + E)/2&#34;,
                          &#34;3. Geometric Mean: H ≡ √(N · E) (recommended by SESEAME Project (2004))&#34;,
                          &#34;4. Vector Summation: H ≡ √(N^2 + E^2)&#34;,
                          &#34;5. Quadratic Mean: H ≡ √(N^2 + E^2)/2&#34;,
                          &#34;6. Maximum Horizontal Value: H ≡ max(N, E)&#34;
                          ]

        
        def on_method_select(meth, meth_opts=method_options):
            self.method_ind = meth_opts.index(meth)

            try:
                int(self.method_ind)
                hCombMethodLabel.configure(text=&#34;method={}&#34;.format(self.method_ind))
                update_procHVSR_call(self.procHVSR_call)
                return True
            except ValueError:
                return False

        defaultMeth=3
        hCombMethodLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;method={}&#34;.format(defaultMeth), width=30)
        hCombMethodLabel.grid(row=0, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

        self.method_sel = tk.StringVar(value=method_options[defaultMeth])
        self.method_ind = method_options.index(self.method_sel.get())       
        self.method_dropdown = ttk.OptionMenu(hvsrSettingsFrame, self.method_sel, method_options[defaultMeth], *method_options, command=on_method_select)
        self.method_dropdown.config(width=50)
        self.method_dropdown.grid(row=0, column=1, columnspan=8, sticky=&#39;ew&#39;)
        
        #smooth=True, 
        
        def curve_smooth():
            try:
                int(self.hvsmooth.get())
                bool(self.hvsmoothbool.get())
                if not self.hvsmoothbool.get():
                    hvSmoothLabel.configure(text=&#39;smooth={}&#39;.format(self.hvsmoothbool.get()))
                    self.hvsmooth_param = False
                else:
                    hvSmoothLabel.configure(text=&#39;smooth={}&#39;.format(self.hvsmooth.get()))
                    self.hvsmooth_param = self.hvsmooth.get()              
                update_procHVSR_call(self.procHVSR_call)
                return True
            except ValueError:
                return False
            
        hvSmoothLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;smooth=True&#34;, width=30)
        hvSmoothLabel.grid(row=1, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

        ttk.Label(master=hvsrSettingsFrame, text=&#39;Smooth H/V Curve [bool]&#39;).grid(row=1, column=0, padx=(5,0), sticky=&#39;w&#39;)

        self.hvsmoothbool = tk.BooleanVar()
        self.hvsmoothbool.set(True)
        self.hvsmooth_param=True
        smoothCurveBool = ttk.Checkbutton(master=hvsrSettingsFrame, text=&#34;&#34;, compound=&#39;left&#39;, variable=self.hvsmoothbool, command=curve_smooth) # create the Checkbutton widget
        smoothCurveBool.grid(row=1, column=1, sticky=&#39;w&#39;)

        self.hvsmooth = tk.IntVar()
        self.hvsmooth.set(51)
        smoothCurveSamples = ttk.Entry(master=hvsrSettingsFrame, textvariable=self.hvsmooth, width=10, validate=&#39;focusout&#39;, validatecommand=curve_smooth)
        smoothCurveSamples.grid(row=1, column=2, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Label(master=hvsrSettingsFrame, text=&#39;[int] # pts in smoothing window (default=51)&#39;).grid(row=1, column=3, padx=(0,0))
        
        #freq_smooth=&#39;konno ohmachi&#39;, 
        freqSmoothLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;freq_smooth=&#39;konno ohmachi&#39;&#34;, width=30)
        freqSmoothLabel.grid(row=2, column=0, sticky=&#39;w&#39;, pady=(16,16), padx=5)

        
        def on_freq_smooth():
            try:
                str(self.freq_smooth.get())
                freqSmoothLabel.configure(text=&#34;freq_smooth={}&#34;.format(self.freq_smooth.get()))
                update_procHVSR_call(self.procHVSR_call)
                return True
            except ValueError:
                return False

        self.freq_smooth = tk.StringVar()
        self.freq_smooth.set(&#39;konno ohmachi&#39;)
        ttk.Label(master=hvsrSettingsFrame, text=&#39;Frequency Smoothing [str]&#39;).grid(row=2, column=0, padx=(5,0), sticky=&#39;w&#39;)
        fsmoothOptFrame = ttk.LabelFrame(master=hvsrSettingsFrame, text=&#39;Frequency Smoothing Operations&#39;)
        fsmoothOptFrame.grid(row=2, column=1, columnspan=7, padx=5, sticky=&#39;nsew&#39;)
        ttk.Radiobutton(master=fsmoothOptFrame, text=&#39;Konno-Ohmachi&#39;, variable=self.freq_smooth, value=&#39;konno ohmachi&#39;, command=on_freq_smooth).grid(row=0, column=0, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=fsmoothOptFrame, text=&#39;Constant&#39;, variable=self.freq_smooth, value=&#39;constant&#39;, command=on_freq_smooth).grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=fsmoothOptFrame, text=&#39;Proportional&#39;, variable=self.freq_smooth, value=&#39;proportional&#39;, command=on_freq_smooth).grid(row=0, column=2, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=fsmoothOptFrame, text=&#39;None&#39;, variable=self.freq_smooth, value=&#39;None&#39;, command=on_freq_smooth).grid(row=0, column=3, sticky=&#39;w&#39;, padx=(5, 10))

        #f_smooth_width=40, 
        fSmoothWidthlabel = ttk.Label(master=hvsrParamsFrame, text=&#34;f_smooth_width=40&#34;, width=30)
        fSmoothWidthlabel.grid(row=3, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

        
        def on_smooth_width():
            try:
                int(self.fSmoothWidth.get())
                fSmoothWidthlabel.configure(text=&#39;f_smooth_width={}&#39;.format(self.fSmoothWidth.get()))                
                update_procHVSR_call(self.procHVSR_call)
                return True
            except ValueError:
                return False
            
        ttk.Label(master=hvsrSettingsFrame, text=&#39;Bandwidth of freq. smoothing [int]&#39;).grid(row=3, column=0, padx=(5,0), sticky=&#39;w&#39;)
        self.fSmoothWidth = tk.IntVar()
        self.fSmoothWidth.set(40)
        fSmoothWidthEntry = ttk.Entry(master=hvsrSettingsFrame, justify=&#39;left&#39;, textvariable=self.fSmoothWidth, validate=&#39;focusout&#39;, validatecommand=on_smooth_width, width=10)
        fSmoothWidthEntry.grid(row=3, column=1, sticky=&#39;w&#39;, padx=(5, 10))
        
        #resample=True, 
        resampleLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;resample=True&#34;, width=30)
        resampleLabel.grid(row=4, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
        
        def on_curve_resample():
            try:
                if not self.resamplebool.get():
                    resampleLabel.configure(text=&#39;resample={}&#39;.format(self.resamplebool.get()))
                    self.hvresample_int=self.hvresample.get()
                else:
                    resampleLabel.configure(text=&#39;resample={}&#39;.format(self.hvresample.get()))
                    self.hvresample_int=self.hvresample.get()    
                update_procHVSR_call(self.procHVSR_call)
                return True
            except ValueError:
                return False
            
        self.resamplebool = tk.BooleanVar()
        self.resamplebool.set(True)
        ttk.Label(master=hvsrSettingsFrame, text=&#39;Resample H/V Curve [bool]&#39;).grid(row=4, column=0, padx=(5,0), sticky=&#39;w&#39;)
        resampleCurveBool = ttk.Checkbutton(master=hvsrSettingsFrame, text=&#34;&#34;, compound=&#39;left&#39;, variable=self.resamplebool, command=on_curve_resample) # create the Checkbutton widget
        resampleCurveBool.grid(row=4, column=1, sticky=&#39;w&#39;)

        self.hvresample = tk.IntVar()
        self.hvresample.set(1000)
        self.hvresample_int = self.hvresample.get()
        resampleCurveSamples = ttk.Entry(master=hvsrSettingsFrame, textvariable=self.hvresample, width=10, validate=&#39;focusout&#39;, validatecommand=on_curve_resample)
        resampleCurveSamples.grid(row=4, column=2, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Label(master=hvsrSettingsFrame, text=&#39;[int] # pts in resampled curve (default=1000)&#39;).grid(row=4, column=3, padx=(0,0), sticky=&#39;w&#39;)

        #outlier_curve_std=1.75
        outlierValLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;outlier_curve_std=1.75&#34;, width=30)
        outlierValLabel.grid(row=5, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)        

        ttk.Label(master=hvsrSettingsFrame, text=&#39;Outlier St. Dev. [float]&#39;).grid(row=6, column=0, columnspan=2, padx=(5,0), sticky=&#39;w&#39;)
        self.outlierRemStDev = tk.DoubleVar()
        self.outlierRemStDev.set(1.75)
        outlierRemStDev = ttk.Entry(master=hvsrSettingsFrame, textvariable=self.outlierRemStDev, width=10, validate=&#39;focusout&#39;, validatecommand=on_outlier_std)
        outlierRemStDev.grid(row=6, column=1, sticky=&#39;w&#39;, padx=(5, 10))

        separator = ttk.Separator(hvsrSettingsFrame, orient=&#39;horizontal&#39;)
        separator.grid(row=7, columnspan=7, sticky=&#39;ew&#39;, pady=10)

        #hvsr_band=[0.4, 40]
        hvsrBandLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;hvsr_band=[0.4,40]&#34;, width=30)
        hvsrBandLabel.grid(row=7, column=0, sticky=&#39;w&#39;, pady=(20,6), padx=5)

        ttk.Label(hvsrSettingsFrame,text=&#34;HVSR Band [Hz]&#34;).grid(row=8,column=0, sticky=&#39;w&#39;, padx=(5,0))

        hvsr_band_min_settingsEntry = ttk.Entry(hvsrSettingsFrame, width=10, textvariable=self.hvsrBand_min, validate=&#39;focusout&#39;, validatecommand=on_hvsrband_update)
        hvsr_band_min_settingsEntry.grid(row=8,column=1, sticky=&#39;ew&#39;)

        hvsr_band_max_settingsEntry = ttk.Entry(hvsrSettingsFrame, width=10, textvariable=self.hvsrBand_max, validate=&#39;focusout&#39;, validatecommand=on_hvsrband_update)
        hvsr_band_max_settingsEntry.grid(row=8,column=2, sticky=&#39;ew&#39;)
   
        #peak_freq_range=[0.4, 40]
        peakFreqRangeLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;peak_freq_range=[0.4,40]&#34;, width=30)
        peakFreqRangeLabel.grid(row=8, column=0, sticky=&#39;w&#39;, pady=(20,6), padx=5)

        ttk.Label(hvsrSettingsFrame,text=&#34;Peak Frequency Range [Hz]&#34;).grid(row=9,column=0, sticky=&#39;w&#39;, padx=(5,0))

        hvsr_band_min_settingsEntry = ttk.Entry(hvsrSettingsFrame, width=10, textvariable=self.peakFreqRange_min, validate=&#39;focusout&#39;, validatecommand=on_peakFreqRange_update)
        hvsr_band_min_settingsEntry.grid(row=9,column=1, sticky=&#39;ew&#39;)

        hvsr_band_max_settingsEntry = ttk.Entry(hvsrSettingsFrame, width=10, textvariable=self.peakFreqRange_max, validate=&#39;focusout&#39;, validatecommand=on_peakFreqRange_update)
        hvsr_band_max_settingsEntry.grid(row=9,column=2, sticky=&#39;ew&#39;)
       
        #Process HVSR Function Call
        hvsrCallFrame = ttk.LabelFrame(hvsr_settings_tab, text=&#39;sprit_hvsr.process_hvsr() Call&#39;)#.pack(fill=&#39;both&#39;)
        
        self.procHVSR_call = ttk.Label(master=hvsrCallFrame, text=&#39;process_hvsr({}, {}, {}, {}, {}, \n\t{}, {}, {})&#39;
                  .format(&#39;hvsr_data&#39;, hCombMethodLabel.cget(&#39;text&#39;), hvSmoothLabel.cget(&#39;text&#39;), freqSmoothLabel.cget(&#39;text&#39;), fSmoothWidthlabel.cget(&#39;text&#39;), resampleLabel.cget(&#39;text&#39;), 
                           outlierValLabel.cget(&#39;text&#39;), hvsrBandLabel.cget(&#39;text&#39;)))
        self.procHVSR_call.pack(anchor=&#39;w&#39;, padx=(25,0), pady=(10,10))

        
        def update_procHVSR_call(procHVSR_call):
            procHVSR_call.configure(text=&#39;process_hvsr({}, {}, {}, {}, {}, \n\t{}, {}, {})&#39;
                  .format(&#39;hvsr_data&#39;, hCombMethodLabel.cget(&#39;text&#39;), hvSmoothLabel.cget(&#39;text&#39;), freqSmoothLabel.cget(&#39;text&#39;), fSmoothWidthlabel.cget(&#39;text&#39;), resampleLabel.cget(&#39;text&#39;), 
                          outlierValLabel.cget(&#39;text&#39;), hvsrBandLabel.cget(&#39;text&#39;)))
        
        #Check Peaks Function Call
        checkPeaksCallFrame = ttk.LabelFrame(hvsr_settings_tab, text=&#39;sprit_hvsr.check_peaks() Call&#39;)#.pack(fill=&#39;both&#39;)

        self.checkPeaks_Call = ttk.Label(master=checkPeaksCallFrame, text=&#39;check_peaks({}, {}, {})&#39;
                  .format(&#39;hvsr_data&#39;, hvsrBandLabel.cget(&#39;text&#39;), peakFreqRangeLabel.cget(&#39;text&#39;)))
        self.checkPeaks_Call.pack(anchor=&#39;w&#39;, padx=(25,0), pady=(10,10))

        #check_peaks(hvsr_dict, hvsr_band=[0.4, 40], peak_water_level=1.8)
        
        def update_check_peaks_call(checkPeaks_Call):
            checkPeaks_Call.configure(text=&#39;check_peaks({}, {}, {})&#39;
                  .format(&#39;hvsr_data&#39;, hvsrBandLabel.cget(&#39;text&#39;), peakFreqRangeLabel.cget(&#39;text&#39;)))


        #Run button frame
        runFrame_set_hvsr = ttk.Frame(hvsr_settings_tab)
        runFrame_set_hvsr.columnconfigure(0, weight=1)

        self.settingsProgBar_hvsr = ttk.Progressbar(runFrame_set_hvsr, orient=&#39;horizontal&#39;)
        self.settingsProgBar_hvsr.grid(row=0, column=0, sticky=&#39;nsew&#39;)#.pack(fill=&#39;both&#39;,expand=True, side=&#39;left&#39;, anchor=&#39;sw&#39;)

        self.run_button = ttk.Button(runFrame_set_hvsr, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)
        self.run_button.grid(row=0, column=1, sticky=&#39;nsew&#39;, padx=2.5)#.pack(side=&#39;bottom&#39;, anchor=&#39;e&#39;)

        #Pack tab
        runFrame_set_hvsr.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;, anchor=&#39;e&#39;)    
        checkPeaksCallFrame.pack(fill=&#39;both&#39;, expand=True, side=&#39;bottom&#39;)#.grid(row=10, column=0, columnspan=6, sticky=&#39;nsew&#39;)#.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
        hvsrCallFrame.pack(fill=&#39;both&#39;, expand=True, side=&#39;bottom&#39;)#.grid(row=9, column=0, columnspan=6, sticky=&#39;nsew&#39;)#.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
        hvsrParamsFrame.pack(fill=&#39;both&#39;, side=&#39;right&#39;)#.grid(row=0, column=6, rowspan=4, sticky=&#39;nsew&#39;)#.pack(side=&#39;right&#39;,fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
        hvsrSettingsFrame.pack(fill=&#39;both&#39;, expand=True, side=&#39;top&#39;)#.grid(row=0, column=0, columnspan=6, rowspan=4, sticky=&#39;nsew&#39;)#.pack(fill=&#39;both&#39;, expand=True)
        
        hvsr_settings_tab.pack(fill=&#39;both&#39;, expand=True)           
        settings_notebook.add(hvsr_settings_tab, text=&#34;HVSR Settings&#34;)

        #PLOT SETTINGS TAB
        plot_settings_tab = ttk.Frame(settings_notebook)

        # Create the Plot Options LabelFrame
        plot_options_frame = ttk.LabelFrame(plot_settings_tab, text=&#34;Plot Options&#34;)

        
        def update_hvplot_call():
            kindstr = get_kindstr()
            hvplot_label.configure(text=&#34;plot_hvsr({}, plot_type={}, xtype=&#39;{}&#39;, show_legend={}, {}, {})&#34;.format(&#39;hvsr_data&#39;, kindstr, self.x_type.get(), self.show_legend.get(), &#39;[...]&#39;, &#39;kwargs&#39;))

        # Create the Checkbuttons for the plot options
        ttk.Label(plot_options_frame, text=&#39;HVSR Plot&#39;, justify=&#39;center&#39;).grid(row=0, column=1, sticky=&#39;ew&#39;, padx=(5, 5))
        ttk.Label(plot_options_frame, text=&#39;Components H/V Plot&#39;, justify=&#39;center&#39;).grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5, 5))
        ttk.Label(plot_options_frame, text=&#39;Spectrogram Plot&#39;, justify=&#39;center&#39;).grid(row=0, column=3, sticky=&#39;ew&#39;, padx=(5, 5))

        self.hvsr_chart_bool = tk.BooleanVar()
        self.hvsr_chart_bool.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#39;&#39;, variable=self.hvsr_chart_bool, command=update_hvplot_call).grid(row=1, column=1, sticky=&#39;nsew&#39;, padx=15, pady=(5, 20))
        self.ind_comp_chart_bool = tk.BooleanVar()
        self.ind_comp_chart_bool.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#39;&#39;, variable=self.ind_comp_chart_bool, command=update_hvplot_call).grid(row=1, column=2, sticky=&#39;nsew&#39;, padx=50, pady=(5, 20))
        self.spec_chart_bool = tk.BooleanVar()
        self.spec_chart_bool.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#39;&#39;, variable=self.spec_chart_bool, command=update_hvplot_call).grid(row=1, column=3, sticky=&#39;nsew&#39;, padx=25, pady=(5, 20))
        
        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=2, columnspan=5, sticky=&#39;ew&#39;, pady=5)
        
        #Separate component chart: c+
        ttk.Label(plot_options_frame, text=&#39;Show Components on same chart as H/V Curve:&#39;).grid(row=3, column=0, sticky=&#39;w&#39;, padx=5)
        
        
        def disable_comp_buttons():
            if self.show_comp_with_hv.get():
                self.annotate_best_peak_comp.set(False)
                self.show_best_peak_comp.set(False)
                bestPeakCompButton.config(state=&#34;disabled&#34;) 
                bestPeakCompAnnButton.config(state=&#39;disabled&#39;)
            else:
                bestPeakCompButton.config(state=&#34;normal&#34;) 
                bestPeakCompAnnButton.config(state=&#39;normal&#39;)
            update_hvplot_call()

        self.show_comp_with_hv = tk.BooleanVar()
        self.show_comp_with_hv.set(False)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_comp_with_hv, 
                        command=disable_comp_buttons).grid(row=3, column=2, sticky=&#34;ew&#34;, padx=50)

        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=4, columnspan=5, sticky=&#39;ew&#39;, pady=5)

        #Show Best Peak: p
        ttk.Label(plot_options_frame, text=&#39;Show Best Peak:&#39;).grid(row=5, column=0, sticky=&#39;w&#39;, padx=5)

        self.show_best_peak_hv = tk.BooleanVar()
        self.show_best_peak_hv.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_best_peak_hv, command=update_hvplot_call).grid(row=5, column=1, sticky=&#34;ew&#34;, padx=15)

        self.show_best_peak_comp = tk.BooleanVar()
        self.show_best_peak_comp.set(True)
        bestPeakCompButton=ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_best_peak_comp, command=update_hvplot_call)
        bestPeakCompButton.grid(row=5, column=2, sticky=&#34;ew&#34;, padx=50)

        self.show_best_peak_spec = tk.BooleanVar()
        self.show_best_peak_spec.set(False)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_best_peak_spec, command=update_hvplot_call).grid(row=5, column=3, sticky=&#34;ew&#34;, padx=25)

        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=6, columnspan=5, sticky=&#39;ew&#39;)

        #Annotate Best Peak: ann
        ttk.Label(plot_options_frame, text=&#39;Annotate Best Peak:&#39;).grid(row=7, column=0, sticky=&#39;w&#39;, padx=5)

        self.annotate_best_peak_hv = tk.BooleanVar()
        self.annotate_best_peak_hv.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.annotate_best_peak_hv, command=update_hvplot_call).grid(row=7, column=1, sticky=&#34;ew&#34;, padx=15)

        self.annotate_best_peak_comp = tk.BooleanVar()
        self.annotate_best_peak_comp.set(True)
        bestPeakCompAnnButton=ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.annotate_best_peak_comp, command=update_hvplot_call)
        bestPeakCompAnnButton.grid(row=7, column=2, sticky=&#34;ew&#34;, padx=50)

        self.annotate_best_peak_spec = tk.BooleanVar()
        self.annotate_best_peak_spec.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.annotate_best_peak_spec, command=update_hvplot_call).grid(row=7, column=3, sticky=&#34;ew&#34;, padx=25)

        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=8, columnspan=5, sticky=&#39;ew&#39;)


        #Show all peaks (main H/V curve): all
        ttk.Label(plot_options_frame, text=&#39;Show All Peaks (H/V Curve):&#39;).grid(row=9, column=0, sticky=&#39;w&#39;, padx=5)

        self.show_all_peaks_hv = tk.BooleanVar()
        self.show_all_peaks_hv.set(False)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_all_peaks_hv, command=update_hvplot_call).grid(row=9, column=1, sticky=&#34;ew&#34;, padx=15)

        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=10, columnspan=5, sticky=&#39;ew&#39;)

        #Show all curves: t
        ttk.Label(plot_options_frame, text=&#39;Show All H/V Curves:&#39;).grid(row=11, column=0, sticky=&#39;w&#39;, padx=5)

        self.show_ind_curves = tk.BooleanVar()
        self.show_ind_curves.set(False)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_ind_curves, command=update_hvplot_call).grid(row=11, column=1, sticky=&#34;ew&#34;, padx=15)

        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=12, columnspan=5, sticky=&#39;ew&#39;)

        #Show individual peaks (tp): tp
        ttk.Label(plot_options_frame, text=&#39;Show Individual Peaks:&#39;).grid(row=13, column=0, sticky=&#39;w&#39;, padx=5)

        self.show_ind_peaks = tk.BooleanVar()
        self.show_ind_peaks.set(False)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_ind_peaks, command=update_hvplot_call).grid(row=13, column=1, sticky=&#34;ew&#34;, padx=15)

        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=14, columnspan=5, sticky=&#39;ew&#39;)

        #Show individual peaks (tp): tp
        ttk.Label(plot_options_frame, text=&#39;Show Standard Deviation:&#39;).grid(row=15, column=0, sticky=&#39;w&#39;, padx=5)

        self.show_stDev_hv = tk.BooleanVar()
        self.show_stDev_hv.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_stDev_hv, command=update_hvplot_call).grid(row=15, column=1, sticky=&#34;ew&#34;, padx=15)

        self.show_stDev_comp = tk.BooleanVar()
        self.show_stDev_comp.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_stDev_comp, command=update_hvplot_call).grid(row=15, column=2, sticky=&#34;ew&#34;, padx=50)

        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=16, columnspan=5, sticky=&#39;ew&#39;)

        ttk.Label(plot_options_frame, text=&#39;Show Legend:&#39;).grid(row=17, column=0, sticky=&#39;w&#39;, padx=5)

        self.show_legend = tk.BooleanVar()
        self.show_legend.set(False)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_legend, command=update_hvplot_call).grid(row=17, column=2, sticky=&#34;ew&#34;, padx=50)


        #Specify X-Type
        ttk.Label(plot_options_frame, text=&#39;X Type:&#39;).grid(row=18, column=0, sticky=&#39;w&#39;, padx=5, pady=10)

        self.x_type = tk.StringVar()
        self.x_type.set(&#39;freq&#39;)
        ttk.Radiobutton(master=plot_options_frame, text=&#39;Frequency&#39;, variable=self.x_type, value=&#39;freq&#39;, command=update_hvplot_call).grid(row=18, column=1, sticky=&#39;w&#39;, padx=(5, 10), pady=10)
        ttk.Radiobutton(master=plot_options_frame, text=&#39;Period&#39;, variable=self.x_type, value=&#39;period&#39;, command=update_hvplot_call).grid(row=18, column=2, sticky=&#39;w&#39;, padx=(5, 10), pady=10)

        #kwargs
        ttk.Label(plot_options_frame, text=&#39;Matplotlib Keyword Arguments (not implemented):&#39;).grid(row=19, column=0, sticky=&#39;w&#39;, padx=5, pady=10)

        self.plot_kwargs = tk.StringVar()
        self.plot_kwargs.set(&#34;cmap=&#39;turbo&#39;&#34;)
        ttk.Entry(plot_options_frame, textvariable=self.plot_kwargs).grid(row=19, column=1, columnspan=3, sticky=&#34;ew&#34;, pady=10)

        plot_options_frame.pack(fill=&#39;both&#39;, expand=True)#.grid(row=1, column=0, padx=10, pady=10, sticky=&#34;nsew&#34;)

        # Create the plot_hvsr Call LabelFrame
        hvplot_call_frame = ttk.LabelFrame(plot_settings_tab, text=&#34;plot_hvsr() Call&#34;)

        #HVSR
        
        def get_kindstr():
            if self.hvsr_chart_bool.get():
                kindstr_hv = &#39;HVSR&#39;
                if self.show_best_peak_hv.get():
                    kindstr_hv = kindstr_hv + &#39; p&#39;
                if self.annotate_best_peak_hv.get():
                    kindstr_hv = kindstr_hv + &#39; ann&#39;
                if self.show_all_peaks_hv.get():
                    kindstr_hv = kindstr_hv + &#39; all&#39;
                if self.show_ind_curves.get():
                    kindstr_hv = kindstr_hv + &#39; t&#39;
                if self.show_ind_peaks.get():
                    kindstr_hv = kindstr_hv.replace(&#39;t&#39;, &#39;tp&#39;)
                    if &#39;tp&#39; not in kindstr_hv:
                        kindstr_hv = kindstr_hv+ &#39; tp&#39;
                if not self.show_stDev_hv.get():
                    kindstr_hv = kindstr_hv + &#39; -s&#39;
            else:
                kindstr_hv = &#39;&#39;

            #Comp
            if self.ind_comp_chart_bool.get():
                kindstr_c = &#39;c&#39;

                if not self.show_comp_with_hv.get():
                    kindstr_c = kindstr_c + &#39;+&#39;

                    if self.show_best_peak_comp.get():
                        kindstr_c = kindstr_c + &#39; p&#39;
                    if self.annotate_best_peak_comp.get():
                        kindstr_c = kindstr_c + &#39; ann&#39;
                if not self.show_stDev_comp.get():
                    kindstr_c = kindstr_c + &#39; -s&#39;
            else:
                kindstr_c = &#39;&#39;

            #Specgram
            if self.spec_chart_bool.get():
                kindstr_spec = &#39;Spec&#39;

                if self.show_best_peak_spec.get():
                    kindstr_spec = kindstr_spec + &#39; p&#39;
                if self.annotate_best_peak_spec.get():
                    kindstr_spec = kindstr_spec + &#39; ann&#39;
            else:
                kindstr_spec = &#39;&#39;
            kindstr = kindstr_hv + &#39; &#39; +  kindstr_c + &#39; &#39; + kindstr_spec
            return kindstr
        

        # Add a Label widget to the plot_hvsr Call Label section
        hvplot_label = ttk.Label(hvplot_call_frame, text=&#34;plot_hvsr({}, remove_method=&#39;{}&#39;, xtype=&#39;{}&#39;, show_legend={}, {}, {})&#34;.format(&#39;hvsr_data&#39;, get_kindstr(), self.x_type.get(), self.show_legend.get(), &#39;[...]&#39;, &#39;kwargs&#39;))

        #Run button frame
        runFrame_set_plot = ttk.Frame(plot_settings_tab)
        runFrame_set_plot.columnconfigure(0, weight=1)

        self.settingsProgBar_plot = ttk.Progressbar(runFrame_set_plot, orient=&#39;horizontal&#39;)
        self.settingsProgBar_plot.grid(row=0, column=0, columnspan=10, sticky=&#39;ew&#39;)#.pack(fill=&#39;both&#39;,expand=True, side=&#39;left&#39;, anchor=&#39;sw&#39;)
        self.run_button = ttk.Button(runFrame_set_plot, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)

        
        def update_results_plot():
            self.tab_control.select(self.results_tab)
            sprit_hvsr.plot_hvsr(self.hvsr_results, plot_type=get_kindstr(), fig=self.fig_results, ax=self.ax_results, show_legend=self.show_legend.get(), use_subplots=True, clear_fig=False)

        self.update_results_plot_button = ttk.Button(runFrame_set_plot, text=&#34;Update Plot&#34;, style=&#39;Noise.TButton&#39;, command=update_results_plot, width=30)
        
        self.update_results_plot_button.grid(row=0, column=11, padx=2.5)#pack(side=&#39;right&#39;, anchor=&#39;se&#39;)
        self.run_button.grid(row=0, column=12, padx=2.5)#(side=&#39;right&#39;, anchor=&#39;se&#39;, padx=(10,0))

        runFrame_set_plot.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;, anchor=&#39;e&#39;)
        hvplot_label.pack(fill=&#39;both&#39;, expand=True, padx=(10,0))#.grid(column=0, row=0, padx=10, pady=10, sticky=&#34;w&#34;)
        hvplot_call_frame.pack(fill=&#39;both&#39;, expand=True)#.grid(row=2, column=0, padx=10, pady=10, sticky=&#34;nsew&#34;)

        plot_settings_tab.pack(fill=&#39;both&#39;, expand=True)
        settings_notebook.add(plot_settings_tab, text=&#34;Plot Settings&#34;)

        # Pack the settings Notebook widget
        settings_notebook.pack(expand=True, fill=&#39;both&#39;)
        self.tab_control.add(self.settings_tab, text=&#34;Settings&#34;)

        # RESULTS TAB
        self.results_tab = ttk.Frame(self.tab_control)
        self.hvsr_results = {&#39;site&#39;:&#39;&#39;}#Just initialize for now

        # Create the Batch Site selection LabelFrame
        self.results_siteSelectFrame = ttk.LabelFrame(self.results_tab, text=&#34;HVSR Results&#34;)
        self.results_siteSelectLabel = ttk.Label(self.results_siteSelectFrame, text=&#39;Select Site &#39;)

        def on_site_select():
            sitename =self.selectedSite.get()
            try: 
                report_results(self.hvsr_results[sitename])
            except:
                if sitename==&#39;&#39;:
                    pass
                else:
                    messagebox.showwarning(title=&#39;WARNING&#39;, message=f&#34;Site {sitename} does not exist&#34;)
                                                   
        if isinstance(self.hvsr_results, sprit_hvsr.HVSRBatch):
            sites = self.hvsr_results.sites
        else:
            sites = [self.hvsr_results[&#39;site&#39;]]
        self.site_options = sites
        self.selectedSite = tk.StringVar(value=sites[0])
        self.site_dropdown = ttk.Combobox(self.results_siteSelectFrame, textvariable=self.selectedSite, values=self.site_options, validate=&#39;focusout&#39;, validatecommand=on_site_select)
        self.site_dropdown.config(width=30)
        self.results_siteSelectLabel.grid(row=0, column=0, columnspan=1, sticky=&#39;ew&#39;)
        self.site_dropdown.grid(row=0, column=1, columnspan=4, sticky=&#39;ew&#39;)

        self.browse_results_fig = ttk.Button(self.results_siteSelectFrame, text=&#34;Update site&#34;,command=on_site_select)
        self.browse_results_fig.grid(row=0, column=8, sticky=&#39;ew&#39;, padx=5)

        self.results_siteSelectFrame.columnconfigure(9, weight=1)


        def update_site_dropdown():
            self.site_dropdown[&#39;values&#39;] = self.site_options


        #lambda value=string: self.om_variable.set(value)
        # Create the plot_hvsr Call LabelFrame
        self.results_chartFrame = ttk.LabelFrame(self.results_tab, text=&#34;Data Plots&#34;)

        #Set up plot     
        self.fig_results = plt.figure()
        results_mosaic = [[&#39;hvsr&#39;],[&#39;comp&#39;],[&#39;spec&#39;]]
        self.ax_results = self.fig_results.subplot_mosaic(results_mosaic)

        self.results_canvas = FigureCanvasTkAgg(self.fig_results, master=self.results_chartFrame)  # A tk.DrawingArea.
        self.results_canvas.draw()
        self.results_canvasWidget = self.results_canvas.get_tk_widget()
        self.results_toolbar = NavigationToolbar2Tk(self.results_canvas, self.results_chartFrame, pack_toolbar=False)
        self.results_toolbar.update()
        self.results_toolbar.pack(fill=tk.X, side=tk.BOTTOM, expand=False)
        self.results_canvasWidget.pack(fill=&#39;both&#39;, expand=True)

        #Peak report
        self.results_peakInfoFrame = ttk.LabelFrame(self.results_tab, text=&#34;Peak Report&#34;)
        self.curveTitleLabel = ttk.Label(self.results_peakInfoFrame, text=&#39;Criteria for Reliable H/V Curve (all 3 must pass)&#39;)
        self.curveTest1Label = ttk.Label(self.results_peakInfoFrame, text=&#39;Window Length for Frequency&#39;)
        self.curveTest1ResultFrame = ttk.Frame(self.results_peakInfoFrame)
        self.curveTest1ResultText = ttk.Label(self.curveTest1ResultFrame, text=&#39;&#39;)
        self.curveTest1Result = ttk.Label(self.curveTest1ResultFrame, text=&#39;&#39;)

        self.curveTest2Label = ttk.Label(self.results_peakInfoFrame, text=&#39;Number of Significant Cycles&#39;)
        self.curveTest2ResultFrame = ttk.Frame(self.results_peakInfoFrame)
        self.curveTest2ResultText = ttk.Label(self.curveTest2ResultFrame, text=&#39;&#39;)
        self.curveTest2Result = ttk.Label(self.curveTest2ResultFrame, text=&#39;&#39;)

        self.curveTest3Label = ttk.Label(self.results_peakInfoFrame, text=&#39;Low Curve Standard Deviation for Frequencies Near Peak Over Time&#39;)
        self.curveTest3ResultFrame = ttk.Frame(self.results_peakInfoFrame)
        self.curveTest3ResultText = ttk.Label(self.curveTest3ResultFrame, text=&#39;&#39;)
        self.curveTest3Result = ttk.Label(self.curveTest3ResultFrame, text=&#39;&#39;)

        self.totalCurveResult = ttk.Label(self.results_peakInfoFrame, text=&#39;&#39;)

        self.peakTitleLabel = ttk.Label(self.results_peakInfoFrame, text=&#39;Criteria for a Clear H/V Peak (5/6 must pass)&#39;)
        self.peakTest1Label = ttk.Label(self.results_peakInfoFrame, text=&#39;H/V Amplitude is low Below Peak Frequency&#39;)
        self.peakTest1ResultFrame = ttk.Frame(self.results_peakInfoFrame)
        self.peakTest1ResultText = ttk.Label(self.peakTest1ResultFrame, text=&#39;&#39;)
        self.peakTest1Result = ttk.Label(self.peakTest1ResultFrame, text=&#39;&#39;)
        
        self.peakTest2Label = ttk.Label(self.results_peakInfoFrame, text=&#39;H/V Amplitude is low Above Peak Frequency&#39;)
        self.peakTest2ResultFrame = ttk.Frame(self.results_peakInfoFrame)
        self.peakTest2ResultText = ttk.Label(self.peakTest2ResultFrame, text=&#39;&#39;)
        self.peakTest2Result = ttk.Label(self.peakTest2ResultFrame, text=&#39;&#39;)
        
        self.peakTest3Label = ttk.Label(self.results_peakInfoFrame, text=&#39;Peak is Prominent&#39;)
        self.peakTest3ResultFrame = ttk.Frame(self.results_peakInfoFrame)
        self.peakTest3ResultText = ttk.Label(self.peakTest3ResultFrame, text=&#39;&#39;)
        self.peakTest3Result = ttk.Label(self.peakTest3ResultFrame, text=&#39;&#39;)
        
        self.peakTest4Label = ttk.Label(self.results_peakInfoFrame, text=&#39;Frequency of Peak is Stationary Over Time&#39;)
        self.peakTest4ResultFrame = ttk.Frame(self.results_peakInfoFrame)
        self.peakTest4ResultText = ttk.Label(self.peakTest4ResultFrame, text=&#39;&#39;)
        self.peakTest4Result = ttk.Label(self.peakTest4ResultFrame, text=&#39;&#39;)
        
        self.peakTest5Label = ttk.Label(self.results_peakInfoFrame, text=&#39;Standard Deviation of Peak Frequency is low &#39;)
        self.peakTest5ResultFrame = ttk.Frame(self.results_peakInfoFrame)
        self.peakTest5ResultText = ttk.Label(self.peakTest5ResultFrame, text=&#39;&#39;)
        self.peakTest5Result = ttk.Label(self.peakTest5ResultFrame, text=&#39;&#39;)
        
        self.peakTest6Label = ttk.Label(self.results_peakInfoFrame, text=&#39;Standard Deviation of Peak Amplitude is low&#39;)
        self.peakTest6ResultFrame = ttk.Frame(self.results_peakInfoFrame)
        self.peakTest6ResultText = ttk.Label(self.peakTest6ResultFrame, text=&#39;&#39;)
        self.peakTest6Result = ttk.Label(self.peakTest6ResultFrame, text=&#39;&#39;)

        self.totalPeakResult = ttk.Label(self.results_peakInfoFrame, text=&#39;&#39;)

        self.totalResult = ttk.Label(self.results_peakInfoFrame, text=&#39;&#39;)

        self.curveTitleLabel.grid(row=0, sticky=&#39;w&#39;, padx=5, pady=2.5)
        self.curveTitleLabel.configure(font=(&#34;TkDefaultFont&#34;, 12, &#39;underline&#39;, &#39;bold&#39;))
        self.curveTest1Label.grid(row=1, sticky=&#39;w&#39;, padx=5, pady=2.5)
        self.curveTest1ResultFrame.grid(row=2, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        self.curveTest1ResultFrame.columnconfigure(0, weight=1)
        self.curveTest1ResultFrame.columnconfigure(1, weight=6)
        self.curveTest1ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        self.curveTest1Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        self.curveTest2Label.grid(row=3, sticky=&#39;w&#39;, padx=5, pady=2.5)
        self.curveTest2ResultFrame.grid(row=4, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        self.curveTest2ResultFrame.columnconfigure(0, weight=1)
        self.curveTest2ResultFrame.columnconfigure(1, weight=6)
        self.curveTest2ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        self.curveTest2Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        self.curveTest3Label.grid(row=5, sticky=&#39;w&#39;, padx=5, pady=2.5)
        self.curveTest3ResultFrame.grid(row=6, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        self.curveTest3ResultFrame.columnconfigure(0, weight=1)
        self.curveTest3ResultFrame.columnconfigure(1, weight=6)
        self.curveTest3ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        self.curveTest3Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        self.totalCurveResult.grid(row=7, sticky=&#39;e&#39;, padx=5, pady=10 )

        ttk.Separator(self.results_peakInfoFrame).grid(row=8, sticky=&#39;ew&#39;, pady=5)
        
        self.peakTitleLabel.grid(row=9, sticky=&#39;w&#39;, padx=5, pady=2.5)
        self.peakTitleLabel.configure(font=(&#34;TkDefaultFont&#34;, 12, &#39;underline&#39;, &#39;bold&#39;))
        
        self.peakTest1Label.grid(row=11, sticky=&#39;w&#39;, padx=5, pady=2.5)
        self.peakTest1ResultFrame.grid(row=12, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        self.peakTest1ResultFrame.columnconfigure(0, weight=1)
        self.peakTest1ResultFrame.columnconfigure(1, weight=6)
        self.peakTest1ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        self.peakTest1Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        self.peakTest2Label.grid(row=13, sticky=&#39;w&#39;, padx=5, pady=2.5)
        self.peakTest2ResultFrame.grid(row=14, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        self.peakTest2ResultFrame.columnconfigure(0, weight=1)
        self.peakTest2ResultFrame.columnconfigure(1, weight=6)
        self.peakTest2ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        self.peakTest2Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        self.peakTest3Label.grid(row=15, sticky=&#39;w&#39;, padx=5, pady=2.5)
        self.peakTest3ResultFrame.grid(row=16, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        self.peakTest3ResultFrame.columnconfigure(0, weight=1)
        self.peakTest3ResultFrame.columnconfigure(1, weight=6)
        self.peakTest3ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        self.peakTest3Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        self.peakTest4Label.grid(row=17, sticky=&#39;w&#39;, padx=5, pady=2.5)
        self.peakTest4ResultFrame.grid(row=18, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        self.peakTest4ResultFrame.columnconfigure(0, weight=1)
        self.peakTest4ResultFrame.columnconfigure(1, weight=6)
        self.peakTest4ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        self.peakTest4Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        self.peakTest5Label.grid(row=19, sticky=&#39;w&#39;, padx=5, pady=2.5)
        self.peakTest5ResultFrame.grid(row=20, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        self.peakTest5ResultFrame.columnconfigure(0, weight=1)
        self.peakTest5ResultFrame.columnconfigure(1, weight=6)
        self.peakTest5ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        self.peakTest5Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        self.peakTest6Label.grid(row=21, sticky=&#39;w&#39;, padx=5, pady=2.5)
        self.peakTest6ResultFrame.grid(row=22, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        self.peakTest6ResultFrame.columnconfigure(0, weight=1)
        self.peakTest6ResultFrame.columnconfigure(1, weight=6)
        self.peakTest6ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        self.peakTest6Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        self.totalPeakResult.grid(row=23, sticky=&#39;e&#39;, padx=5, pady=10 )

        ttk.Separator(self.results_peakInfoFrame).grid(row=24, sticky=&#39;ew&#39;, pady=5)

        self.totalResult.grid(row=25, sticky=&#39;e&#39;, padx=5, pady=10 )

        self.resultsProgBar = ttk.Progressbar(self.results_peakInfoFrame, orient=&#39;horizontal&#39;)
        self.resultsProgBar.grid(row=26, column=0, sticky=&#39;ew&#39;)

        #Export results
        self.results_export_Frame = ttk.LabelFrame(self.results_tab, text=&#34;Export Results&#34;)
        
        ttk.Label(self.results_export_Frame, text=&#34;Export Figure&#34;).grid(row=0, column=0, sticky=&#39;ew&#39;, padx=5)
        self.results_fig_dir = tk.StringVar()
        self.results_fig_dir_entry = ttk.Entry(self.results_export_Frame, textvariable=self.results_fig_dir)
        self.results_fig_dir_entry.grid(row=0, column=1, columnspan=5, sticky=&#39;ew&#39;)
        
        def filepath_results_fig():
            filepath = filedialog.asksaveasfilename(defaultextension=&#39;png&#39;, initialdir=pathlib.Path(self.data_path.get()).parent, initialfile=self.params[&#39;site&#39;]+&#39;_results.png&#39;)
            if filepath:
                self.results_fig_dir_entry.delete(0, &#39;end&#39;)
                self.results_fig_dir_entry.insert(0, filepath)
           
        def save_results_fig():
            if not self.save_ind_subplots.get():
                self.fig_results.savefig(self.results_fig_dir.get())
            else:
                for key in self.ax_results.keys():
                    extent = self.ax_results[key].get_tightbbox(self.fig_results.canvas.renderer).transformed(self.fig_results.dpi_scale_trans.inverted())
                    self.fig_results.savefig(pathlib.Path(self.results_fig_dir.get()).parent.as_posix()+&#39;/Subplot&#39;+key+&#39;.png&#39;,  bbox_inches=extent)
        

        self.browse_results_fig = ttk.Button(self.results_export_Frame, text=&#34;Browse&#34;,command=filepath_results_fig)
        self.browse_results_fig.grid(row=0, column=7, sticky=&#39;ew&#39;, padx=2.5)
        
        self.save_results_fig = ttk.Button(self.results_export_Frame, text=&#34;Save&#34;,command=save_results_fig)
        self.save_results_fig.grid(row=0, column=8, columnspan=2, sticky=&#39;ew&#39;, padx=2.5)

        #Save subplots individually
        self.save_ind_subplots = tk.BooleanVar()
        self.save_ind_subplots.set(False)
        ttk.Checkbutton(self.results_export_Frame, text=&#34;Save ind. subplots&#34;, variable=self.save_ind_subplots).grid(row=0, column=10, sticky=&#34;ew&#34;, padx=5)

        #Export Peak Report        
        ttk.Label(self.results_export_Frame, text=&#34;Export Peak Report&#34;).grid(row=1, column=0, sticky=&#39;ew&#39;, padx=5)
        self.results_report_dir = tk.StringVar()
        self.results_report_dir_entry = ttk.Entry(self.results_export_Frame, textvariable=self.results_report_dir)
        self.results_report_dir_entry.grid(row=1, column=1, columnspan=5, sticky=&#39;ew&#39;)
        
        def filepath_report_fig():
            filepath = filedialog.asksaveasfilename(defaultextension=&#39;csv&#39;, initialdir=pathlib.Path(self.data_path.get()).parent, initialfile=self.params[&#39;site&#39;]+&#39;_peakReport.csv&#39;)
            if filepath:
                self.results_report_dir_entry.delete(0, &#39;end&#39;)
                self.results_report_dir_entry.insert(0, filepath)
        
        def save_report_fig():
            sprit_hvsr.get_report(self.hvsr_results, format=&#39;plot&#39;,  export=self.results_report_dir.get())

        self.browse_results_fig = ttk.Button(self.results_export_Frame, text=&#34;Browse&#34;,command=filepath_report_fig)
        self.browse_results_fig.grid(row=1, column=7, sticky=&#39;ew&#39;, padx=2.5)
        
        self.save_results_fig = ttk.Button(self.results_export_Frame, text=&#34;Save&#34;,command=save_report_fig)
        self.save_results_fig.grid(row=1, column=8, columnspan=2, sticky=&#39;ew&#39;, padx=2.5)
        self.results_export_Frame.columnconfigure(1, weight=1)
        
        self.results_siteSelectFrame.grid(row=0,column=0, columnspan=8, rowspan=2, sticky=&#39;ew&#39;)
        self.results_peakInfoFrame.grid(row=0,  column=9, columnspan=2, rowspan=8, sticky=&#39;nsew&#39;)#.pack(side=&#39;right&#39;, fill=&#39;both&#39;)
        self.results_chartFrame.grid(row=2,     column=0, columnspan=8, rowspan=6, sticky=&#39;nsew&#39;)#.pack(side=&#39;top&#39;, expand=True, fill=&#39;both&#39;)
        self.results_export_Frame.grid(row=9,   column=0, columnspan=11,rowspan=2,sticky=&#39;nsew&#39;)#.pack(side=&#39;bottom&#39;, fill=&#39;x&#39;)
        self.results_tab.columnconfigure(0, weight=1)
        self.results_tab.rowconfigure(2, weight=1)
        

        # LOG TAB
        self.log_tab = ttk.Frame(self.tab_control)
        
        from tkinter import scrolledtext
        self.logFrame = ttk.LabelFrame(self.log_tab, text=&#39;Log&#39;)
        self.logFrame.columnconfigure(0, weight=1)
        self.logFrame.rowconfigure(0, weight=1)
        
        self.log_text = scrolledtext.ScrolledText(self.logFrame, wrap = tk.WORD)#, width=200, height=50)
        self.log_text.configure(font=(&#34;Courier&#34;, 11))
        #text_area.grid(row=0, column=0, sticky=&#39;nsew&#39;)
        self.log_text.grid(row=0, rowspan=10, column=0, sticky=&#39;nsew&#39;)#.pack(fill=&#39;both&#39;, expand=True)

        self.logProgBar = ttk.Progressbar(self.logFrame, orient=&#39;horizontal&#39;)
        self.logProgBar.grid(row=11, column=0, sticky=&#39;nsew&#39;)

        introLogText = &#34;Log of active session:\n&#34;
        self.log_text.insert(&#39;end&#39;, introLogText)
        #log_text.configure(bg=&#39;black&#39;, fg=&#39;white&#39;)


        self.logFrame.pack(fill=&#39;both&#39;, expand=True)#.pack(fill=&#39;both&#39;, expand=True, side=&#39;top&#39;, anchor=&#39;nw&#39;)
        self.log_tab.pack(fill=&#39;both&#39;, expand=True, side=&#39;left&#39;, anchor=&#39;nw&#39;)
        
        # Add log tab to tab control
        self.tab_control.add(self.log_tab, text=&#34;Log&#34;)
        # Add result tab to tab control
        self.tab_control.add(self.results_tab, text=&#34;Results&#34;.center(11, &#39; &#39;).center(13,&#39;|&#39;))

        # Pack tab control
        self.tab_control.pack(expand=True, fill=&#34;both&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="sprit.sprit_tkinter_ui.SPRIT_App.create_menubar"><code class="name flex">
<span>def <span class="ident">create_menubar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprit.sprit_tkinter_ui.SPRIT_App.create_tabs"><code class="name flex">
<span>def <span class="ident">create_tabs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprit.sprit_tkinter_ui.SPRIT_App.log_errorMsg"><code class="name flex">
<span>def <span class="ident">log_errorMsg</span></span>(<span>self, logMsg)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprit.sprit_tkinter_ui.SPRIT_App.manual_label_update"><code class="name flex">
<span>def <span class="ident">manual_label_update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sprit" href="index.html">sprit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sprit.sprit_tkinter_ui.on_closing" href="#sprit.sprit_tkinter_ui.on_closing">on_closing</a></code></li>
<li><code><a title="sprit.sprit_tkinter_ui.reboot_app" href="#sprit.sprit_tkinter_ui.reboot_app">reboot_app</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sprit.sprit_tkinter_ui.SPRIT_App" href="#sprit.sprit_tkinter_ui.SPRIT_App">SPRIT_App</a></code></h4>
<ul class="">
<li><code><a title="sprit.sprit_tkinter_ui.SPRIT_App.create_menubar" href="#sprit.sprit_tkinter_ui.SPRIT_App.create_menubar">create_menubar</a></code></li>
<li><code><a title="sprit.sprit_tkinter_ui.SPRIT_App.create_tabs" href="#sprit.sprit_tkinter_ui.SPRIT_App.create_tabs">create_tabs</a></code></li>
<li><code><a title="sprit.sprit_tkinter_ui.SPRIT_App.log_errorMsg" href="#sprit.sprit_tkinter_ui.SPRIT_App.log_errorMsg">log_errorMsg</a></code></li>
<li><code><a title="sprit.sprit_tkinter_ui.SPRIT_App.manual_label_update" href="#sprit.sprit_tkinter_ui.SPRIT_App.manual_label_update">manual_label_update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
