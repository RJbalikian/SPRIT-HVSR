<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>sprit.sprit_hvsr API documentation</title>
<meta name="description" content="This module is the main SpRIT module that contains all the functions needed to run HVSR analysis …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sprit.sprit_hvsr</code></h1>
</header>
<section id="section-intro">
<p>This module is the main SpRIT module that contains all the functions needed to run HVSR analysis.</p>
<p>The functions defined here are read both by the SpRIT graphical user interface and by the command-line interface to run HVSR analysis on input data.</p>
<p>See documentation for individual functions for more information.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sprit.sprit_hvsr.batch_data_read"><code class="name flex">
<span>def <span class="ident">batch_data_read</span></span>(<span>batch_data, batch_type='table', param_col=None, batch_params=None, verbose=False, **readcsv_getMeta_fetch_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to read data in data as a batch of multiple data files.
This is best used through sprit.fetch_data(<em>args, source='batch', </em>*other_kwargs).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>batch_data</code></strong> :&ensp;<code>filepath</code> or <code>list</code></dt>
<dd>Input data information for how to read in data as batch. Can be filepath or list of filepaths/stream objects.
If filepath, should point to .csv (or similar that can be read by pandas.read_csv()) with batch data information.</dd>
<dt><strong><code>batch_type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Type of batch read, only 'table' and 'filelist' accepted.
If 'table', will read data from a file read in using pandas.read_csv(), by default 'table'</dd>
<dt><strong><code>param_col</code></strong> :&ensp;<code>None</code> or <code>str</code>, optional</dt>
<dd>Name of parameter column from batch information file. Only used if a batch_type='table' and single parameter column is used, rather than one column per parameter (for single parameter column, parameters are formatted with = between keys/values and , between item pairs), by default None</dd>
<dt><strong><code>batch_params</code></strong> :&ensp;<code>list, dict,</code> or <code>None</code>, default <code>= None</code></dt>
<dd>Parameters to be used if batch_type='filelist'. If it is a list, needs to be the same length as batch_data. If it is a dict, will be applied to all files in batch_data and will combined with extra keyword arguments caught by **readcsv_getMeta_fetch_kwargs.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print information to terminal during batch read, by default False</dd>
<dt><strong><code>**readcsv_getMeta_fetch_kwargs</code></strong></dt>
<dd>Keyword arguments that will be read into pandas.read_csv(), sprit.input_params, sprit.get_metadata(), and/or sprit.fetch_data()</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hvsrBatch</code></dt>
<dd>HVSRBatch object with each item representing a different HVSRData object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>IndexError</code></dt>
<dd><em>description</em></dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.calculate_azimuth"><code class="name flex">
<span>def <span class="ident">calculate_azimuth</span></span>(<span>hvsr_data, azimuth_angle=45, azimuth_type='multiple', azimuth_unit='degrees', show_az_plot=False, verbose=False, **plot_azimuth_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to calculate azimuthal horizontal component at specified angle(s).
Adds each new horizontal component as a radial component to obspy.Stream object at hvsr_data['stream']</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code><a title="sprit.sprit_hvsr.HVSRData" href="#sprit.sprit_hvsr.HVSRData">HVSRData</a></code></dt>
<dd>Input HVSR data</dd>
<dt><strong><code>azimuth_angle</code></strong> :&ensp;<code>int</code>, default=<code>10</code></dt>
<dd>If <code>azimuth_type='multiple'</code>, this is the angular step (in unit <code>azimuth_unit</code>) of each of the azimuthal measurements.
If <code>azimuth_type='single'</code> this is the angle (in unit <code>azimuth_unit</code>) of the single calculated azimuthal measruement. By default 10.</dd>
<dt><strong><code>azimuth_type</code></strong> :&ensp;<code>str</code>, default=<code>'multiple'</code></dt>
<dd>What type of azimuthal measurement to make, by default 'multiple'.
If 'multiple' (or {'multi', 'mult', 'm'}), will take a measurement at each angular step of azimuth_angle of unit azimuth_unit.
If 'single' (or {'sing', 's'}), will take a single azimuthal measurement at angle specified in azimuth_angle.</dd>
<dt><strong><code>azimuth_unit</code></strong> :&ensp;<code>str</code>, default=<code>'degrees'</code></dt>
<dd>Angular unit used to specify <code>azimuth_angle</code> parameter. By default 'degrees'.
If 'degrees' (or {'deg', 'd'}), will use degrees.
If 'radians' (or {'rad', 'r'}), will use radians.</dd>
<dt><strong><code>show_az_plot</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to show azimuthal plot, by default False.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to print terminal output, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sprit.sprit_hvsr.HVSRData" href="#sprit.sprit_hvsr.HVSRData">HVSRData</a></code></dt>
<dd>Updated HVSRData object specified in hvsr_data with hvsr_data['stream'] attribute containing additional components (EHR-***),
with *** being zero-padded (3 digits) azimuth angle in degrees.</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.check_instance"><code class="name flex">
<span>def <span class="ident">check_instance</span></span>(<span>init)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprit.sprit_hvsr.check_peaks"><code class="name flex">
<span>def <span class="ident">check_peaks</span></span>(<span>hvsr_data, hvsr_band=[0.5, 40], peak_selection='max', peak_freq_range=[0.5, 40], azimuth='HV', verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to run tests on HVSR peaks to find best one and see if it passes SESAME quality checks</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary containing all the calculated information about the HVSR data (i.e., hvsr_out returned from process_hvsr)</dd>
<dt><strong><code>hvsr_band</code></strong> :&ensp;<code>tuple</code> or <code>list</code>, default=<code>[0.1, 50]</code></dt>
<dd>2-item tuple or list with lower and upper limit of frequencies to analyze</dd>
<dt><strong><code>peak_selection</code></strong> :&ensp;<code>str</code> or <code>numeric</code>, default=<code>'max'</code></dt>
<dd>How to select the "best" peak used in the analysis. For peak_selection="max" (default value), the highest peak within peak_freq_range is used.
For peak_selection='scored', an algorithm is used to select the peak based in part on which peak passes the most SESAME criteria.
If a numeric value is used (e.g., int or float), this should be a frequency value to manually select as the peak of interest.</dd>
<dt><strong><code>peak_freq_range</code></strong> :&ensp;<code>tuple</code> or <code>list</code>, default=<code>[0.1, 50];</code></dt>
<dd>The frequency range within which to check for peaks. If there is an HVSR curve with multiple peaks, this allows the full range of data to be processed while limiting peak picks to likely range.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to print results and inputs to terminal.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hvsr_data
: HVSRData</code> or <code><a title="sprit.sprit_hvsr.HVSRBatch" href="#sprit.sprit_hvsr.HVSRBatch">HVSRBatch</a> object</code></dt>
<dd>Object containing previous input data, plus information about peak tests</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.export_data"><code class="name flex">
<span>def <span class="ident">export_data</span></span>(<span>hvsr_data, data_export_path, data_export_format='mseed', starttime=None, endtime=None, tzone=None, export_edited_stream=False, site=None, project=None, verbose=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Export data stream to file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code><a title="sprit.sprit_hvsr.HVSRData" href="#sprit.sprit_hvsr.HVSRData">HVSRData</a>, <a title="sprit.sprit_hvsr.HVSRBatch" href="#sprit.sprit_hvsr.HVSRBatch">HVSRBatch</a>, obspy.Stream, obspy.Trace</code></dt>
<dd>Input stream or HVSR object</dd>
<dt><strong><code>data_export_path</code></strong> :&ensp;<code>pathlike-object</code></dt>
<dd>Filepath at which to format data. If directory (recommended), filename will be generated automatically.</dd>
<dt><strong><code>data_export_format</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Format of data, should be file format supported by obspy.write(), by default 'mseed'</dd>
<dt><strong><code>starttime</code></strong> :&ensp;<code>str, UTCDateTime,</code> or <code>datetime.datetime</code>, optional</dt>
<dd>Starttime of stream, if trimming is desired, by default None</dd>
<dt><strong><code>endtime</code></strong> :&ensp;<code>str, UTCDateTime,</code> or <code>datetime.datetime</code>, optional</dt>
<dd>Endtime of stream, if trimming is desired, by default None</dd>
<dt><strong><code>tzone</code></strong> :&ensp;<code>str, zoneinfo.Zoneinfo</code>, optional</dt>
<dd>String readable by zoneinfo.Zoneinfo() or Zoneinfo object, by default None</dd>
<dt><strong><code>export_edited_stream</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to export the raw stream or edited stream in HVSRData object, by default False</dd>
<dt><strong><code>site</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Site name, to be used in filename generation, by default None</dd>
<dt><strong><code>project</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Project or county name, to be used in filename generation, by default None</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print information to terminal, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>obspy.Stream</code></dt>
<dd>Stream object exported</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>hvsr_data must be of type HVSRData, HVSRBatch, obspy.Stream, or obspy.Trace</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.export_hvsr"><code class="name flex">
<span>def <span class="ident">export_hvsr</span></span>(<span>hvsr_data, hvsr_export_path=None, ext='hvsr', export_plots=False, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Export data into pickle format that can be read back in using import_data().
Intended so data does not need to be processed each time it needs to be used.
Default extension is .hvsr but it is still a pickled file that can be read in using pickle.load().</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code><a title="sprit.sprit_hvsr.HVSRData" href="#sprit.sprit_hvsr.HVSRData">HVSRData</a></code> or <code><a title="sprit.sprit_hvsr.HVSRBatch" href="#sprit.sprit_hvsr.HVSRBatch">HVSRBatch</a></code></dt>
<dd>Data to be exported</dd>
<dt><strong><code>hvsr_export_path</code></strong> :&ensp;<code>str</code> or <code>filepath object</code>, default <code>= None</code></dt>
<dd>String or filepath object to be read by pathlib.Path() and/or a with open(hvsr_export_path, 'wb') statement. If None, defaults to input input_data directory, by default None</dd>
<dt><strong><code>ext</code></strong> :&ensp;<code>str</code>, default <code>= 'hvsr'</code></dt>
<dd>Filepath extension to use for data file, by default 'hvsr'</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.export_report"><code class="name flex">
<span>def <span class="ident">export_report</span></span>(<span>hvsr_results, report_export_path=None, report_export_format=['pdf'], azimuth='HV', csv_handling='rename', show_report=True, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to export reports to disk. Exportable formats for report_export_format include:
* 'table': saves a pandas DataFrame as a csv)
* 'plot': saves the matplotlib or plotly plot figure (depending on what is designated via plot_engine) as an image (png by default)
* 'print': saves the print report as a .txt file
* 'html': saves the html report as a .html file
* 'pdf': saves the pdf report as a .pdf file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_results</code></strong> :&ensp;<code><a title="sprit.sprit_hvsr.HVSRData" href="#sprit.sprit_hvsr.HVSRData">HVSRData</a> object</code></dt>
<dd>HVSRData object containing the HVSR data</dd>
<dt><strong><code>report_export_path</code></strong> :&ensp;<code>path-like object</code>, optional</dt>
<dd>The path to where the report should be exported.
If this is None (default), this is written to the home directory.
If this is a True, uses the same directory as the input data, but generates a filename.
If this is a directory, generates a filename.
If filename is specified and the extension does not match the report type, the extension is adjusted.
Otherwise, this is the output file or , by default None</dd>
<dt><strong><code>csv_handling</code></strong> :&ensp;<code>{'rename', 'append', 'overwrite', 'keep'}</code>, optional</dt>
<dd>If table is the report type, this can prevent overwriting data, by default 'rename'.
* "rename" (or "keep"): renames the new file to prevent overwrite, appends a digit to the end of filename
* "append": appends the new data to the existing file
* "overwrite": overwrites the existing file</dd>
<dt><strong><code>report_export_format</code></strong> :&ensp;<code>str</code> or <code>list</code>, optional</dt>
<dd>The format (or a list of formats) to export the report, by default ['pdf'].</dd>
<dt><strong><code>show_report</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to show the designated reports that were chosen for export, by default True</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print progress and other information to terminal, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sprit.sprit_hvsr.HVSRData" href="#sprit.sprit_hvsr.HVSRData">HVSRData</a></code></dt>
<dd>An HVSRData object that is the same as hvsr_results, but with any additionally generated reports.</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.export_settings"><code class="name flex">
<span>def <span class="ident">export_settings</span></span>(<span>hvsr_data, export_settings_path='default', export_settings_type='all', include_location=False, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Save processing settings to json file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>export_settings_path</code></strong> :&ensp;<code>str</code>, default=<code>"default"</code></dt>
<dd>Where to save the json file(s) containing the settings, by default 'default'.
If "default," will save to sprit package resources. Otherwise, set a filepath location you would like for it to be saved to.
If 'all' is selected, a directory should be supplied.
Otherwise, it will save in the directory of the provided file, if it exists. Otherwise, defaults to the home directory.</dd>
<dt><strong><code>export_settings_type</code></strong> :&ensp;<code>str, {'all', 'instrument', 'processing'}</code></dt>
<dd>What kind of settings to save.
If 'all', saves all possible types in their respective json files.
If 'instrument', save the instrument settings to their respective file.
If 'processing', saves the processing settings to their respective file. By default 'all'</dd>
<dt><strong><code>include_location</code></strong> :&ensp;<code>bool</code>, default=<code>False, input CRS</code></dt>
<dd>Whether to include the location parametersin the exported settings document.This includes xcoord, ycoord, elevation, elev_unit, and input_crs</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to print outputs and information to the terminal</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.fetch_data"><code class="name flex">
<span>def <span class="ident">fetch_data</span></span>(<span>params, source='file', data_export_path=None, data_export_format='mseed', detrend='spline', detrend_options=2, filter_type=None, filter_options={}, update_metadata=True, plot_input_stream=False, plot_engine='matplotlib', show_plot=True, verbose=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch ambient seismic data from a source to read into obspy stream. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>params
: dict</dt>
<dt>Dictionary containing all the necessary params to get data.</dt>
<dt>Parameters defined using input_params() function.</dt>
<dt _batch_="'batch'" _dir_="'dir'," _file_="'file'," _raw_="'raw',">source
: str,</dt>
<dt>String indicating where/how data file was created. For example, if raw data, will need to find correct channels.</dt>
<dt>'raw' finds raspberry shake data, from raw output copied using scp directly from Raspberry Shake, either in folder or subfolders;</dt>
<dt>'dir' is used if the day's 3 component files (currently Raspberry Shake supported only) are all 3 contained in a directory by themselves.</dt>
<dt>'file' is used if the params['input_data'] specified in input_params() is the direct filepath to a single file to be read directly into an obspy stream.</dt>
<dt>'batch' is used to read a list or specified set of seismic files.</dt>
<dt>Most commonly, a csv file can be read in with all the parameters. Each row in the csv is a separate file. Columns can be arranged by parameter.</dt>
<dt><strong><code>data_export_path</code></strong> :&ensp;<code>None</code> or <code>str</code> or <code>pathlib obj</code>, default=<code>None</code></dt>
<dd>If None (or False), data is not trimmed in this function.
Otherwise, this is the directory to save trimmed and exported data.</dd>
<dt><strong><code>data_export_format</code></strong> :&ensp;<code>str='mseed'</code></dt>
<dd>If data_export_path is not None, this is the format in which to save the data</dd>
<dt><strong><code>detrend</code></strong> :&ensp;<code>str</code> or <code>bool</code>, default=<code>'spline'</code></dt>
<dd>If False, data is not detrended.
Otherwise, this should be a string accepted by the type parameter of the obspy.core.trace.Trace.detrend method: <a href="https://docs.obspy.org/packages/autogen/obspy.core.trace.Trace.detrend.html">https://docs.obspy.org/packages/autogen/obspy.core.trace.Trace.detrend.html</a></dd>
<dt><strong><code>detrend_options</code></strong> :&ensp;<code>int</code>, default=<code>2</code></dt>
<dd>If detrend parameter is 'spline' or 'polynomial', this is passed directly to the order parameter of obspy.core.trace.Trace.detrend method.</dd>
<dt><strong><code>filter_type</code></strong> :&ensp;<code>None, str</code></dt>
<dd>Type of filter to use on raw data.
This should either be None or any of {'bandpass', 'bandstop', 'lowpass', 'highpass', 'lowpass_cheby_2', 'lowpass_fir', 'remez_fir'}.
This passes <code>filter_type</code> to the <code>type</code> parameter and <code>**filter_options</code> to the <code>**options</code> parameter of the obspy.Stream filter() method.
See here for more information: <a href="https://docs.obspy.org/packages/autogen/obspy.core.stream.Stream.filter.html">https://docs.obspy.org/packages/autogen/obspy.core.stream.Stream.filter.html</a>
If None, no filtering is done on the input seismic data.</dd>
<dt><strong><code>filter_options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary that will be unpacked into the <code>**options</code> parameter of the filter() method of the obspy.Stream class.
This should fit the parameters of whichever filter type is specifed by filter_type.
Example options for the 'bandpass' filter_type might be: <code>filter_options={'freqmin': 0.1, 'freqmax':50, 'df':100, 'corners':4, 'zerophase':True}</code>.
See here for more information: <a href="https://docs.obspy.org/packages/autogen/obspy.core.stream.Stream.filter.html">https://docs.obspy.org/packages/autogen/obspy.core.stream.Stream.filter.html</a></dd>
<dt><strong><code>update_metadata</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to update the metadata file, used primarily with Raspberry Shake data which uses a generic inventory file.</dd>
<dt><strong><code>plot_input_stream</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to plot the raw input stream. This plot includes a spectrogram (Z component) and the raw (with decimation for speed) plots of each component signal.</dd>
<dt><strong><code>plot_engine</code></strong> :&ensp;<code>str</code>, default=<code>'matplotlib'</code></dt>
<dd>Which plotting library/engine to use for plotting the Input stream. Options are 'matplotlib', 'plotly', or 'obspy' (not case sensitive).</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to print outputs and inputs to the terminal</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keywords arguments, primarily for 'batch' and 'dir' sources</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code><a title="sprit.sprit_hvsr.HVSRData" href="#sprit.sprit_hvsr.HVSRData">HVSRData</a></code> or <code><a title="sprit.sprit_hvsr.HVSRBatch" href="#sprit.sprit_hvsr.HVSRBatch">HVSRBatch</a> object</code></dt>
<dd>Same as params parameter, but with an additional "stream" attribute with an obspy data stream with 3 traces: Z (vertical), N (North-south), and E (East-west)</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.generate_ppsds"><code class="name flex">
<span>def <span class="ident">generate_ppsds</span></span>(<span>hvsr_data, **gen_psds_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is to maintain backwards compatibility with previous version</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="sprit.sprit_hvsr.generate_psds" href="#sprit.sprit_hvsr.generate_psds">generate_psds()</a></code></p></div>
</dd>
<dt id="sprit.sprit_hvsr.generate_psds"><code class="name flex">
<span>def <span class="ident">generate_psds</span></span>(<span>hvsr_data, window_length=30.0, overlap_pct=0.5, window_type='hann', window_length_method='length', remove_response=False, skip_on_gaps=True, num_freq_bins=512, hvsr_band=[0.5, 40], obspy_ppsds=False, azimuthal_psds=False, verbose=False, plot_psds=False, **obspy_ppsd_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate Power Spectral Density (PSD) curves for each channel.
Uses the <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.welch.html">scipy.signal.welch()</a> function
to generate PSDs by default, or can use Obspy's PPSD class.
Info on Obspy PPSD creation here (if obspy_ppsds=True): <a href="https://docs.obspy.org/packages/autogen/obspy.signal.spectral_estimation.PPSD.html">https://docs.obspy.org/packages/autogen/obspy.signal.spectral_estimation.PPSD.html</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>dict, <a title="sprit.sprit_hvsr.HVSRData" href="#sprit.sprit_hvsr.HVSRData">HVSRData</a> object,</code> or <code><a title="sprit.sprit_hvsr.HVSRBatch" href="#sprit.sprit_hvsr.HVSRBatch">HVSRBatch</a> object</code></dt>
<dd>Data object containing all the parameters and other data of interest (stream and paz, for example)</dd>
<dt><strong><code>window_length</code></strong> :&ensp;<code>float</code></dt>
<dd>Length of the window, in seconds, to use for each PSD calculation. Defaults to 30.0.</dd>
<dt><strong><code>overlap_pct</code></strong> :&ensp;<code>float</code></dt>
<dd>Percentage (should be 0-1) for overlapping each window used for PSD calculation. Defaults to 0.5.</dd>
<dt><strong><code>window_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of window to use. This is passed to the window parameter of the scipy.signal.welch function</dd>
<dt><strong><code>window_length_method</code></strong> :&ensp;<code>str = {'length', 'number'}</code></dt>
<dd>Whether the window length should be a measure of length in seconds or number of windows.
If number of windows uses integer value.</dd>
<dt><strong><code>remove_response</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to remove the instrument response from the data traces before calculating PSD data.
If True, the appropriate metadata (i.e., obspy.Inventory object) must be attached to the stream and should be stored in the 'inv' attribute of hvsr_data.</dd>
<dt><strong><code>skip_on_gaps</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to skip data gaps when processing windows.
This is passed to the skip_on_gaps parameter of the Obspy PPSD class.</dd>
<dt><strong><code>num_freq_bins</code></strong> :&ensp;<code>int</code>, default=<code>512</code></dt>
<dd>Number of frequency bins to use. When using the default (i.e., scipy.signal.welch) PSD function, the frequency bins are created manually for processing.</dd>
<dt><strong><code>obspy_ppsds</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to use the Obspy PPSD class.</dd>
<dt><strong><code>azimuthal_psds</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to generate PPSDs for azimuthal data</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to print inputs and results to terminal</dd>
<dt><strong><code>plot_psds</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to show a plot of the psds here.</dd>
<dt><strong><code>**obspy_ppsd_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with keyword arguments that are passed directly to obspy.signal.PPSD.
If the following keywords are not specified, their defaults are amended in this function from the obspy defaults for its PPSD function. Specifically:
- ppsd_length defaults to 30 (seconds) here instead of 3600
- skip_on_gaps defaults to True instead of False
- period_step_octaves defaults to 0.03125 instead of 0.125</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>ppsds : HVSRData object
    Dictionary containing entries with ppsds for each channel
</code></pre>
<h2 id="see-also">See Also</h2>
<p><code>scipy.signal.welch</code>
<code>obspy.signal.spectral_estimation.PPSD</code></p></div>
</dd>
<dt id="sprit.sprit_hvsr.get_metadata"><code class="name flex">
<span>def <span class="ident">get_metadata</span></span>(<span>params, write_path='', update_metadata=True, source=None, verbose=False, **read_inventory_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get metadata and calculate or get paz parameter needed for PSD
Adds an obspy.Inventory object to the "inv" attribute or key of params</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary containing all the input and other parameters needed for processing
Ouput from input_params() function</dd>
<dt><strong><code>write_path</code></strong> :&ensp;<code>str</code></dt>
<dd>String with output filepath of where to write updated inventory or metadata file
If not specified, does not write file</dd>
<dt><strong><code>update_metadata</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to update the metadata file itself, or just read as-is. If using provided raspberry shake metadata file, select True.</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>str</code>, default=<code>None</code></dt>
<dd>This passes the source variable value to _read_RS_metadata. It is expected that this is passed directly from the source parameter of sprit.fetch_data()</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Modified input dictionary with additional key:value pair containing paz dictionary (key = "paz")</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.get_report"><code class="name flex">
<span>def <span class="ident">get_report</span></span>(<span>hvsr_results, report_formats=['print', 'table', 'plot', 'html', 'pdf'], azimuth='HV', plot_type='HVSR p ann COMP+ p ann SPEC p ann', plot_engine='matplotlib', show_print_report=True, show_table_report=False, show_plot_report=False, show_html_report=False, show_pdf_report=True, suppress_report_outputs=False, show_report_outputs=False, csv_handling='append', report_export_format=None, report_export_path=None, verbose=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate and/or print and/or export a report of the HVSR analysis in a variety of formats. </p>
<p>Formats include:
* 'print': A (monospace) text summary of the HVSR results
* 'table': A pandas.DataFrame summary of the HVSR Results.
This is useful for copy/pasting directly into a larger worksheet.
* 'plot': A plot summary of the HVSR results, generated using the plot_hvsr() function.
* 'html': An HTML document/text of the HVSR results. This includes the table, print, and plot reports in one document.
* 'pdf': A PDF document showing the summary of the HVSR Results.
The PDF report is simply the HTML report saved to an A4-sized PDF document.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_results</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary containing all the information about the processed hvsr data</dd>
<dt><strong><code>report_formats</code></strong> :&ensp;<code>{'table', 'print', plot}</code></dt>
<dd>Format in which to print or export the report.
The following report_formats return the following items in the following attributes:
- 'plot': hvsr_results['Print_Report'] as a str
- 'print': hvsr_results['Plot_Report'] - matplotlib.Figure object
- 'table':
hvsr_results['Table_Report']- pandas.DataFrame object
- list/tuple - a list or tuple of the above objects, in the same order they are in the report_formats list
- 'html': hvsr_results['HTML_Report'] - a string containing the text for an HTML document
- 'pdf': currently does not save to the HVSRData object itself, can only be saved to the disk directly</dd>
<dt><strong><code>plot_type</code></strong> :&ensp;<code>str</code>, default <code>= 'HVSR p ann C+ p ann Spec p ann'</code></dt>
<dd>What type of plot to plot, if 'plot' part of report_formats input</dd>
<dt><strong><code>azimuth</code></strong> :&ensp;<code>str</code>, default <code>= 'HV'</code></dt>
<dd>Which azimuth to plot, by default "HV" which is the main "azimuth" combining the E and N components</dd>
<dt><strong><code>csv_handling</code></strong> :&ensp;<code>str, {'append', 'overwrite', 'keep/rename'}</code></dt>
<dd>How to handle table report outputs if the designated csv output file already exists. By default, appends the new information to the end of the existing file.</dd>
<dt><strong><code>suppress_report_outputs</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>If True, only reads output to appropriate attribute of data class (ie, print does not print, only reads text into variable). If False, performs as normal.</dd>
<dt><strong><code>report_export_format</code></strong> :&ensp;<code>list</code> or <code>str</code>, default=<code>['pdf']</code></dt>
<dd>A string or list of strings indicating which report formats should be exported to disk.</dd>
<dt><strong><code>report_export_path</code></strong> :&ensp;<code>None, bool,</code> or <code>filepath</code>, default <code>= None</code></dt>
<dd>If None or False, does not export; if True, will export to same directory as the input_data parameter in the input_params() function.
Otherwise, it should be a string or path object indicating where to export results. May be a file or directory.
If a directory is specified, the filename will be
"<site_name><em><acq_date></em><UTC start time>-<UTC end time>".
The extension/suffix defaults to png for report_formats="plot", csv for 'table', txt for 'print', html for 'html', and pdf for 'pdf.'</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to print the results to terminal. This is the same output as report_formats='print', and will not repeat if that is already selected</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sprit.HVSRData" href="index.html#sprit.HVSRData">HVSRData</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.gui"><code class="name flex">
<span>def <span class="ident">gui</span></span>(<span>kind: str = 'browser')</span>
</code></dt>
<dd>
<div class="desc"><p>Function to open a graphical user interface (gui)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>kind</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>What type of gui to open:
* "browser" or "default" opens browser interface (using streamlit)
* "widget" opens jupyter widget (using ipywidgets)
* "window" opens windowed gui (using tkinter)</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.import_data"><code class="name flex">
<span>def <span class="ident">import_data</span></span>(<span>import_filepath, data_format='pickle', show_data=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to import .hvsr (or other extension) data exported using export_hvsr() function</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>import_filepath</code></strong> :&ensp;<code>str</code> or <code>path object</code></dt>
<dd>Filepath of file created using export_hvsr() function. This is usually a pickle file with a .hvsr extension</dd>
<dt><strong><code>data_format</code></strong> :&ensp;<code>str</code>, default=<code>'pickle'</code></dt>
<dd>Type of format data is in. Currently, only 'pickle' supported. Eventually, json or other type may be supported, by default 'pickle'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sprit.sprit_hvsr.HVSRData" href="#sprit.sprit_hvsr.HVSRData">HVSRData</a></code> or <code><a title="sprit.sprit_hvsr.HVSRBatch" href="#sprit.sprit_hvsr.HVSRBatch">HVSRBatch</a> object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.import_settings"><code class="name flex">
<span>def <span class="ident">import_settings</span></span>(<span>settings_import_path, settings_import_type='instrument', verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to import settings, intended for use with settings saved to disk using export_settings</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>settings_import_path</code></strong> :&ensp;<code>pathlike object</code></dt>
<dd>Filepath to exported settings document</dd>
<dt><strong><code>settings_import_type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>What type of settings to export (can be 'instrument' or 'all'), by default 'instrument'</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print information to terminal, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the function names as keys of internal dictionaries,
with key:value pairs for each parameter name:value in that function.</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.input_params"><code class="name flex">
<span>def <span class="ident">input_params</span></span>(<span>input_data, site='HVSRSite', project=None, network='AM', station='NONE', location='00', channels=['EHZ', 'EHN', 'EHE'], acq_date=None, starttime=None, endtime=None, tzone='UTC', xcoord=-88.229, ycoord=40.101, elevation=225, input_crs='EPSG:4326', output_crs=None, elev_unit='meters', depth=0, instrument='Seismometer', metadata=None, hvsr_band=[0.5, 40], peak_freq_range=[0.5, 40], processing_parameters={}, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for designating input parameters for reading in and processing data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>input_data</code></strong> :&ensp;<code>str</code> or <code>pathlib.Path object</code></dt>
<dd>Filepath of data. This can be a directory or file, but will need to match with what is chosen later as the source parameter in fetch_data()</dd>
<dt><strong><code>site</code></strong> :&ensp;<code>str</code>, default=<code>"HVSR Site"</code></dt>
<dd>Site name as designated by user for ease of reference. Used for plotting titles, filenames, etc.</dd>
<dt><strong><code>project</code></strong> :&ensp;<code>str</code>, default=<code>None</code></dt>
<dd>A prefix that may be used to create unique identifiers for each site.
The identifier created is saved as the ['HVSR_ID'] attribute of the HVSRData object,
and is equivalent to the following formatted string:
f"{project}-{acq_date.strftime("%Y%m%d")}-{starttime.strftime("%H%M")}-{station}".</dd>
<dt><strong><code>network</code></strong> :&ensp;<code>str</code>, default=<code>'AM'</code></dt>
<dd>The network designation of the seismometer. This is necessary for data from Raspberry Shakes. 'AM' is for Amateur network, which fits Raspberry Shakes.</dd>
<dt><strong><code>station</code></strong> :&ensp;<code>str</code>, default=<code>'None'</code></dt>
<dd>The station name of the seismometer. This is necessary for data from Raspberry Shakes.</dd>
<dt><strong><code>location</code></strong> :&ensp;<code>str</code>, default=<code>'00'</code></dt>
<dd>Location information of the seismometer.</dd>
<dt><strong><code>channels</code></strong> :&ensp;<code>list</code>, default=<code>['EHZ', 'EHN', 'EHE']</code></dt>
<dd>The three channels used in this analysis, as a list of strings. Preferred that Z component is first, but not necessary</dd>
<dt><strong><code>acq_date</code></strong> :&ensp;<code>str, int, date object,</code> or <code>datetime object</code></dt>
<dd>If string, preferred format is 'YYYY-MM-DD'.
If int, this will be interpreted as the time_int of year of current year (e.g., 33 would be Feb 2 of current year)
If date or datetime object, this will be the date. Make sure to account for time change when converting to UTC (if UTC is the following time_int, use the UTC time_int).</dd>
<dt><strong><code>starttime</code></strong> :&ensp;<code>str, time object,</code> or <code>datetime object</code>, default=<code>'00:00:00.00'</code></dt>
<dd>Start time of data stream. This is necessary for Raspberry Shake data in 'raw' form, or for trimming data. Format can be either 'HH:MM:SS.micros' or 'HH:MM' at minimum.</dd>
<dt><strong><code>endtime</code></strong> :&ensp;<code>str, time obejct,</code> or <code>datetime object</code>, default=<code>'23:59:99.99'</code></dt>
<dd>End time of data stream. This is necessary for Raspberry Shake data in 'raw' form, or for trimming data. Same format as starttime.</dd>
<dt><strong><code>tzone</code></strong> :&ensp;<code>str</code> or <code>int</code>, default <code>= 'UTC'</code></dt>
<dd>Timezone of input data. If string, 'UTC' will use the time as input directly. Any other string value needs to be a TZ identifier in the IANA database, a wikipedia page of these is available here: <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.">https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.</a>
If int, should be the int value of the UTC offset (e.g., for American Eastern Standard Time: -5).
This is necessary for Raspberry Shake data in 'raw' format.</dd>
<dt><strong><code>xcoord</code></strong> :&ensp;<code>float</code>, default=<code>-88.2290526</code></dt>
<dd>Longitude (or easting, or, generally, X coordinate) of data point, in Coordinate Reference System (CRS) designated by input_crs. Currently only used in table output, but will likely be used in future for mapping/profile purposes.</dd>
<dt><strong><code>ycoord</code></strong> :&ensp;<code>float</code>, default=<code>40.1012122</code></dt>
<dd>Latitute (or northing, or, generally, X coordinate) of data point, in Coordinate Reference System (CRS) designated by input_crs. Currently only used in table output, but will likely be used in future for mapping/profile purposes.</dd>
<dt><strong><code>input_crs</code></strong> :&ensp;<code>str</code> or <code>other format read by pyproj</code>, default=<code>'EPSG:4326'</code></dt>
<dd>Coordinate reference system of input data, as used by pyproj.CRS.from_user_input()</dd>
<dt><strong><code>output_crs</code></strong> :&ensp;<code>str</code> or <code>other format read by pyproj</code>, default=<code>'EPSG:4326'</code></dt>
<dd>Coordinate reference system to which input data will be transformed, as used by pyproj.CRS.from_user_input()</dd>
<dt><strong><code>elevation</code></strong> :&ensp;<code>float</code>, default=<code>755</code></dt>
<dd>Surface elevation of data point. Not currently used (except in table output), but will likely be used in the future.</dd>
<dt><strong><code>depth</code></strong> :&ensp;<code>float</code>, default=<code>0</code></dt>
<dd>Depth of seismometer. Not currently used, but will likely be used in the future.</dd>
<dt><strong><code>instrument</code></strong> :&ensp;<code>str {'Raspberry Shake', "Tromino"}</code></dt>
<dd>Instrument from which the data was acquired.</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>str</code> or <code>pathlib.Path object</code>, default=<code>None</code></dt>
<dd>Filepath of metadata, in format supported by obspy.read_inventory. If default value of None, will read from resources folder of repository (only supported for Raspberry Shake).</dd>
<dt><strong><code>hvsr_band</code></strong> :&ensp;<code>list</code>, default=<code>[0.1, 50]</code></dt>
<dd>Two-element list containing low and high "corner" frequencies (in Hz) for processing. This can specified again later.</dd>
<dt><strong><code>peak_freq_range</code></strong> :&ensp;<code>list</code> or <code>tuple</code>, default=<code>[0.1, 50]</code></dt>
<dd>Two-element list or tuple containing low and high frequencies (in Hz) that are used to check for HVSR Peaks. This can be a tigher range than hvsr_band, but if larger, it will still only use the hvsr_band range.</dd>
<dt>processing_parameters={} : dict or filepath, default={}</dt>
<dt>If filepath, should point to a .proc json file with processing parameters (i.e, an output from sprit.export_settings()).</dt>
<dt>Note that this only applies to parameters for the functions: 'fetch_data', 'remove_noise', 'generate_psds', 'process_hvsr', 'check_peaks', and 'get_report.'</dt>
<dt>If dictionary, dictionary containing nested dictionaries of function names as they key, and the parameter names/values as key/value pairs for each key.</dt>
<dt>If a function name is not present, or if a parameter name is not present, default values will be used.</dt>
<dt>For example:</dt>
<dt><code>{ 'fetch_data' : {'source':'batch', 'data_export_path':"/path/to/trimmed/data", 'data_export_format':'mseed', 'detrend':'spline', 'plot_input_stream':True, 'verbose':False, kwargs:{'kwargskey':'kwargsvalue'}} }</code></dt>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to print output and results to terminal</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="index.html#sprit.HVSRData">HVSRData</a></code></dt>
<dd>sprit.HVSRData class containing input parameters, including data file path and metadata path. This will be used as an input to other functions. If batch processing, params will be converted to batch type in fetch_data() step.</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.plot_azimuth"><code class="name flex">
<span>def <span class="ident">plot_azimuth</span></span>(<span>hvsr_data, fig=None, ax=None, show_azimuth_peaks=False, interpolate_azimuths=True, show_azimuth_grid=False, show_plot=True, **plot_azimuth_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to plot azimuths when azimuths are calculated</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code><a title="sprit.sprit_hvsr.HVSRData" href="#sprit.sprit_hvsr.HVSRData">HVSRData</a></code> or <code><a title="sprit.sprit_hvsr.HVSRBatch" href="#sprit.sprit_hvsr.HVSRBatch">HVSRBatch</a></code></dt>
<dd>HVSRData that has gone through at least the sprit.fetch_data() step, and before sprit.generate_psds()</dd>
<dt><strong><code>show_azimuth_peaks</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to display the peak value at each azimuth calculated on the chart, by default False</dd>
<dt><strong><code>interpolate_azimuths</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to interpolate the azimuth data to get a smoother plot.
This is just for visualization, does not change underlying data.
It takes a lot of time to process the data, but interpolation for vizualization can happen fairly fast. By default True.</dd>
<dt><strong><code>show_azimuth_grid</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to display the grid on the chart, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>matplotlib.Figure, matplotlib.Axis</code></dt>
<dd>Figure and axis of resulting azimuth plot</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.plot_hvsr"><code class="name flex">
<span>def <span class="ident">plot_hvsr</span></span>(<span>hvsr_data, plot_type='HVSR p ann COMP+ p ann SPEC p ann', azimuth='HV', use_subplots=True, fig=None, ax=None, return_fig=False, plot_engine='matplotlib', save_dir=None, save_suffix='', show_legend=False, show_plot=True, close_figs=False, clear_fig=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to plot HVSR data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>dict
</code></dt>
<dd>Dictionary containing output from process_hvsr function</dd>
<dt><strong><code>plot_type</code></strong> :&ensp;<code>str</code> or <code>list</code>, default <code>= 'HVSR ann p C+ ann p SPEC ann p'</code></dt>
<dd>The plot_type of plot(s) to plot. If list, will plot all plots listed
- 'HVSR' - Standard HVSR plot, including standard deviation. Options are included below:
- 'p' shows a vertical dotted line at frequency of the "best" peak
- 'ann' annotates the frequency value of of the "best" peak
- 'all' shows all the peaks identified in check_peaks() (by default, only the max is identified)
- 't' shows the H/V curve for all time windows
- 'tp' shows all the peaks from the H/V curves of all the time windows
- 'fr' shows the window within which SpRIT will search for peak frequencies, as set by peak_freq_range
- 'test' shows a visualization of the results of the peak validity test(s). Examples:
- 'tests' visualizes the results of all the peak tests (not the curve tests)
- 'test12' shows the results of tests 1 and 2.
- Append any number 1-6 after 'test' to show a specific test result visualized
- 'COMP' - plot of the PPSD curves for each individual component ("C" also works)
- '+' (as a suffix in 'C+' or 'COMP+') plots C on a plot separate from HVSR (C+ is default, but without + will plot on the same plot as HVSR)
- 'p' shows a vertical dotted line at frequency of the "best" peak
- 'ann' annotates the frequency value of of the "best" peak
- 'all' shows all the peaks identified in check_peaks() (by default, only the max is identified)
- 't' shows the H/V curve for all time windows
- 'SPEC' - spectrogram style plot of the H/V curve over time
- 'p' shows a horizontal dotted line at the frequency of the "best" peak
- 'ann' annotates the frequency value of the "best" peak
- 'all' shows all the peaks identified in check_peaks()
- 'tp' shows all the peaks of the H/V curve at all time windows
- 'AZ' - circular plot of calculated azimuthal HV curves, similar in style to SPEC plot.
- 'p' shows a point at each calculated (not interpolated) azimuth peak
- 'g' shows grid lines at various angles
- 'i' interpolates so that there is an interpolated azimuth at each degree interval (1 degree step)
This is the default, so usually 'i' is not needed.
- '-i' prohibits interpolation (only shows the calculated azimuths, as determined by azimuth_angle (default = 30))</dd>
<dt><strong><code>azimuth</code></strong> :&ensp;<code>str</code>, default <code>= 'HV'</code></dt>
<dd>What 'azimuth' to plot, default being standard N E components combined</dd>
<dt><strong><code>use_subplots</code></strong> :&ensp;<code>bool</code>, default <code>= True</code></dt>
<dd>Whether to output the plots as subplots (True) or as separate plots (False)</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.Figure</code>, default <code>= None</code></dt>
<dd>If not None, matplotlib figure on which plot is plotted</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.Axis</code>, default <code>= None</code></dt>
<dd>If not None, matplotlib axis on which plot is plotted</dd>
<dt><strong><code>return_fig</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return figure and axis objects</dd>
<dt><strong><code>plot_engine</code></strong> :&ensp;<code>str</code>, default=<code>'Matplotlib'</code></dt>
<dd>Which engine to use for plotting. Both "matplotlib" and "plotly" are acceptable. For shorthand, 'mpl', 'm' also work for matplotlib; 'plty' or 'p' also work for plotly. Not case sensitive.</dd>
<dt><strong><code>save_dir</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>Directory in which to save figures</dd>
<dt><strong><code>save_suffix</code></strong> :&ensp;<code>str</code></dt>
<dd>Suffix to add to end of figure filename(s), if save_dir is used</dd>
<dt><strong><code>show_legend</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to show legend in plot</dd>
<dt><strong><code>show_plot</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show plot</dd>
<dt><strong><code>close_figs</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to close figures before plotting</dd>
<dt><strong><code>clear_fig</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to clear figures before plotting</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>keyword arguments</code></dt>
<dd>Keyword arguments for matplotlib.pyplot</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong>, <strong><code>ax</code></strong> :&ensp;<code>matplotlib figure and axis objects</code></dt>
<dd>Returns figure and axis matplotlib.pyplot objects if return_fig=True, otherwise, simply plots the figures</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.process_hvsr"><code class="name flex">
<span>def <span class="ident">process_hvsr</span></span>(<span>hvsr_data, horizontal_method=None, smooth=True, freq_smooth='konno ohmachi', f_smooth_width=40, resample=True, outlier_curve_percentile_threshold=False, azimuth=None, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Process the input data and get HVSR data</p>
<p>This is the main function that uses other (private) functions to do
the bulk of processing of the HVSR data and the data quality checks.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>hvsr_data
: HVSRData or HVSRBatch</dt>
<dt>Data object containing all the parameters input and generated by the user (usually, during sprit.input_params(), sprit.fetch_data(), sprit.generate_psds() and/or sprit.remove_noise()).</dt>
<dt>horizontal_method
: int or str, default=3</dt>
<dt>Method to use for combining the horizontal components. Default is 3) Geometric Mean</dt>
<dt>0) (not used)</dt>
<dt>1) 'Diffuse field assumption'
H = √( (eie_E + eie_N) / eie_Z), eie = equal interval energy</dt>
<dt>2) 'Arithmetic Mean'
H ≡ (HN + HE)/2</dt>
<dt>3) 'Geometric Mean'
H ≡ √(HN · HE), recommended by the SESAME project (2004)</dt>
<dt>4) 'Vector Summation'
H ≡ √(HN^2 + HE^2)</dt>
<dt>5) 'Quadratic Mean'
H ≡ √(HN^2 + HE^2)/2</dt>
<dt HE HN_="HN,">6) 'Maximum Horizontal Value'
H ≡ max</dt>
<dt HE HN_="HN,">7) 'Minimum Horizontal Valey'
H ≡ min</dt>
<dt>8) 'Single Azimuth'
H = H2·cos(az) + H1·sin(az)</dt>
<dt>smooth
: bool, default=True</dt>
<dt>bool or int may be used.</dt>
<dt>If True, default to smooth H/V curve to using savgoy filter with window length of 51 (works well with default resample of 1000 pts)</dt>
<dt>If int, the length of the window in the savgoy filter.</dt>
<dt><strong><code>freq_smooth</code></strong> :&ensp;<code>str {'konno ohmachi', 'constant', 'proportional'}</code></dt>
<dd>Which frequency smoothing method to use. By default, uses the 'konno ohmachi' method.
- The Konno &amp; Ohmachi method uses the obspy.signal.konnoohmachismoothing.konno_ohmachi_smoothing() function: <a href="https://docs.obspy.org/packages/autogen/obspy.signal.konnoohmachismoothing.konno_ohmachi_smoothing.html">https://docs.obspy.org/packages/autogen/obspy.signal.konnoohmachismoothing.konno_ohmachi_smoothing.html</a>
- The constant method uses a window of constant length f_smooth_width
- The proportional method uses a window the percentage length of the frequncy steps/range (f_smooth_width now refers to percentage)
See here for more information: <a href="https://www.geopsy.org/documentation/geopsy/hv-processing.html">https://www.geopsy.org/documentation/geopsy/hv-processing.html</a></dd>
<dt><strong><code>f_smooth_width</code></strong> :&ensp;<code>int</code>, default <code>= 40</code></dt>
<dd>
<ul>
<li>For 'konno ohmachi': passed directly to the bandwidth parameter of the konno_ohmachi_smoothing() function, determines the width of the smoothing peak, with lower values resulting in broader peak. Must be &gt; 0.</li>
<li>For 'constant': the size of a triangular smoothing window in the number of frequency steps</li>
<li>For 'proportional': the size of a triangular smoothing window in percentage of the number of frequency steps (e.g., if 1000 frequency steps/bins and f_smooth_width=40, window would be 400 steps wide)</li>
</ul>
</dd>
<dt>resample
: bool, default = True</dt>
<dt>bool or int.</dt>
<dt>If True, default to resample H/V data to include 1000 frequency values for the rest of the analysis</dt>
<dt>If int, the number of data points to interpolate/resample/smooth the component psd/HV curve data to.</dt>
<dt><strong><code>outlier_curve_percentile_threshold</code></strong> :&ensp;<code>bool, float</code>, default <code>= False</code></dt>
<dd>If False, outlier curve removal is not carried out here.
If True, defaults to 98 (98th percentile).
Otherwise, float of percentile used as outlier_threshold of remove_outlier_curve().</dd>
<dt><strong><code>azimuth</code></strong> :&ensp;<code>float</code>, default <code>= None</code></dt>
<dd>The azimuth angle to use when method is single azimuth.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool, defualt=False</code></dt>
<dd>Whether to print output to terminal</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>hvsr_out    : dict
    Dictionary containing all the information about the data, including input parameters
</code></pre></div>
</dd>
<dt id="sprit.sprit_hvsr.read_tromino_files"><code class="name flex">
<span>def <span class="ident">read_tromino_files</span></span>(<span>input_data, struct_format='H', tromino_model=None, sampling_rate=None, set_record_duration=None, start_byte=24576, verbose=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to read data from tromino. Specifically, this has been lightly tested on Tromino 3G+ and Blue machines</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>input_data</code></strong> :&ensp;<code>str</code></dt>
<dd>Falseilepath to .trc file</dd>
<dt><strong><code>struct_format</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>This is the format used in the struct module.
Usually should not be changed, by default 'H'</dd>
<dt><strong><code>tromino_model</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Which tromino model is being read.
Currently only "Yellow" and "Blue" are supported.
If None, assumes "Yellow", by default None.</dd>
<dt><strong><code>sampling_rate</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Sampling rate (samples per second) used during acquisition.
This may later be detected automatically.
If None, 128 used, by default None</dd>
<dt><strong><code>set_record_duration</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Duration of record to set manually in minutes, by default None</dd>
<dt><strong><code>start_byte</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Used internally, by default 24576</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print information to terminal, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>obspy.stream.Stream</code></dt>
<dd>Obspy Stream object with Tromino data</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.remove_noise"><code class="name flex">
<span>def <span class="ident">remove_noise</span></span>(<span>hvsr_data, remove_method=None, processing_window=None, sat_percent=0.995, noise_percent=0.8, sta=2, lta=30, stalta_thresh=[8, 16], std_ratio_thresh=2.0, std_window_size=20.0, min_std_win=5.0, warmup_time=0, cooldown_time=0, min_win_size=1, remove_raw_noise=False, show_stalta_plot=False, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to remove noisy windows from data, using various methods.</p>
<p>Methods include
- Manual window selection (by clicking on a chart with spectrogram and stream data),
- Auto window selection, which does the following two in sequence (these can also be done indepently):
- A sta/lta "antitrigger" method (using stalta values to automatically remove triggered windows where there appears to be too much noise)
- A noise threshold method, that cuts off all times where the noise threshold equals more than (by default) 80% of the highest amplitude noise sample for the length specified by lta (in seconds)
- A saturation threshold method, that cuts off all times where the noise threshold equals more than (by default) 99.5% of the highest amplitude noise sample.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>dict, obspy.Stream,</code> or <code>obspy.Trace</code></dt>
<dd>Dictionary containing all the data and parameters for the HVSR analysis</dd>
<dt><strong><code>remove_method</code></strong> :&ensp;<code>str, {'auto', 'manual', 'stalta'/'antitrigger', 'saturation threshold', 'noise threshold', 'warmup'/'cooldown'/'buffer'/'warm_cool'}</code></dt>
<dd>The different methods for removing noise from the dataset. A list of strings will also work, in which case, it should be a list of the above strings. See descriptions above for what how each method works. By default 'auto.'
If remove_method='auto', this is the equivalent of remove_method=['noise threshold', 'antitrigger', 'saturation threshold', 'warm_cool']</dd>
<dt><strong><code>processing_window</code></strong> :&ensp;<code>list, tuple,</code> or <code>None</code></dt>
<dd>A list/tuple of two items [s, e] or a list/tuple of two-item lists/tuples [[s0, e0], [s1,e1],&hellip;[sn, en]] with start and end time(s) for windows to <em>keep</em> for processing.
Data outside of these times will be excluded from processing.
Times should be obspy.UTCDateTime objects to ensure precision, but time strings ("13:05") will also work in most cases (excpetions may be when the data stream starts/ends on different UTC days)</dd>
<dt><strong><code>sat_percent</code></strong> :&ensp;<code>float</code>, default=<code>0.995</code></dt>
<dd>Percentage (between 0 and 1), to use as the threshold at which to remove data. This is used in the saturation method. By default 0.995.
If a value is passed that is greater than 1, it will be divided by 100 to obtain the percentage.</dd>
<dt><strong><code>noise_percent</code></strong> :&ensp;<code>float</code>, default <code>= 0.8</code></dt>
<dd>Percentage (between 0 and 1), to use as the threshold at which to remove data, if it persists for longer than time (in seconds (specified by min_win_size)). This is used in the noise threshold method. By default 0.8.
If a value is passed that is greater than 1, it will be divided by 100 to obtain the percentage.</dd>
<dt><strong><code>sta</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Short term average (STA) window (in seconds), by default 2. For use with sta/lta antitrigger method.</dd>
<dt><strong><code>lta</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Long term average (STA) window (in seconds), by default 30. For use with sta/lta antitrigger method.</dd>
<dt><strong><code>stalta_thresh</code></strong> :&ensp;<code>list</code>, default=<code>[0.5,5]</code></dt>
<dd>Two-item list or tuple with the thresholds for the stalta antitrigger. The first value (index [0]) is the lower threshold, the second value (index [1] is the upper threshold), by default [0.5,5]</dd>
<dt><strong><code>std_ratio_thresh</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The ratio to use as a threshold for removal of noise. The ratio represents the standard deviation value for a rolling window (the size of which is determined by the std_window_size parameter)
divided by the standard deviation calculated for the entire trace. This rolling window standard deviation method is similar to the default noise removal method used by the Grilla HVSR software.</dd>
<dt><strong><code>std_window_size</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The length of the window (in seconds) to use for calculating the rolling/moving standard deviation of a trace for the rolling standard deviation method.</dd>
<dt><strong><code>min_std_win</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The minimum size of "window" that will be remove using the rolling standard deviation method.</dd>
<dt><strong><code>warmup_time</code></strong> :&ensp;<code>int</code>, default=<code>0</code></dt>
<dd>Time in seconds to allow for warmup of the instrument (or while operator is still near instrument). This will renove any data before this time, by default 0.</dd>
<dt><strong><code>cooldown_time</code></strong> :&ensp;<code>int</code>, default=<code>0</code></dt>
<dd>Time in seconds to allow for cooldown of the instrument (or for when operator is nearing instrument). This will renove any data before this time, by default 0.</dd>
<dt><strong><code>min_win_size</code></strong> :&ensp;<code>float</code>, default=<code>1</code></dt>
<dd>The minumum size a window must be over specified threshold (in seconds) for it to be removed</dd>
<dt><strong><code>remove_raw_noise</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>If remove_raw_noise=True, will perform operation on raw data ('input_stream'), rather than potentially already-modified data ('stream').</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to print status of remove_noise</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>output</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary similar to hvsr_data, but containing modified data with 'noise' removed</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.remove_outlier_curves"><code class="name flex">
<span>def <span class="ident">remove_outlier_curves</span></span>(<span>hvsr_data, outlier_method='prototype', outlier_threshold=50, use_percentile=True, min_pts=5, use_hv_curves=False, plot_engine='matplotlib', show_outlier_plot=False, generate_outlier_plot=True, verbose=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Function used to remove outliers curves using Root Mean Square Error to calculate the error of each windowed
Probabilistic Power Spectral Density (PPSD) curve against the median PPSD value at each frequency step for all times.
It calculates the RMSE for the PPSD curves of each component individually. All curves are removed from analysis.</p>
<p>Some abberant curves often occur due to the remove_noise() function, so this should be run some time after remove_noise().
In general, the recommended workflow is to run this immediately following the generate_psds() function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Input dictionary containing all the values and parameters of interest</dd>
<dt><strong><code>outlier_method</code></strong> :&ensp;<code>str</code>, default=<code>'prototype'</code></dt>
<dd>The method to use for outlier detection. Currently, 'dbscan' and 'prototype' is supported.</dd>
<dt><strong><code>outlier_threshold</code></strong> :&ensp;<code>float</code> or <code>int</code>, default=<code>98</code></dt>
<dd>The Root Mean Square Error value to use as a threshold for determining whether a curve is an outlier.
This averages over each individual entire curve so that curves with very abberant data (often occurs when using the remove_noise() method), can be identified.
Otherwise, specify a float or integer to use as the cutoff RMSE value (all curves with RMSE above will be removed)</dd>
<dt><strong><code>use_percentile</code></strong> :&ensp;<code> float</code>, default=<code>True</code></dt>
<dd>Whether outlier_threshold should be interepreted as a raw RMSE value or as a percentile of the RMSE values.</dd>
<dt><strong><code>min_pts</code></strong> :&ensp;<code>int</code>, default=<code>5</code></dt>
<dd>The minimum number of points to use for the outlier detection method.
This is only used if outlier_method='dbscan'
This is minimum number of points a point needs in its neighborhood to not be considered an outlier.</dd>
<dt><strong><code>use_hv_curves</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to use the calculated HV Curve or the individual components. This can only be True after process_hvsr() has been run.</dd>
<dt><strong><code>show_plot</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to show a plot of the removed data</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to print output of function to terminal</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Input dictionary with values modified based on work of function.</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>input_data=None, source='file', azimuth_calculation=False, noise_removal=False, outlier_curves_removal=False, verbose=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The sprit.run() is the main function that allows you to do all your HVSR processing in one simple step (sprit.run() is how you would call it in your code, but it may also be called using sprit.sprit_hvsr.run())</p>
<p>The input_data parameter of sprit.run() is the only required parameter (if nothing entered, it will run sample data). This can be either a single file, a list of files (one for each component, for example), a directory (in which case, all obspy-readable files will be added to an HVSRBatch instance), a Rasp. Shake raw data directory, or sample data.</p>
<h2 id="notes">Notes</h2>
<p>The sprit.run() function calls the following functions. This is the recommended order/set of functions to run to process HVSR using SpRIT. See the API documentation for these functions for more information:
- input_params(): The input_data parameter of input_params() is the only required variable, though others may also need to be called for your data to process correctly.
- fetch_data(): the source parameter of fetch_data() is the only explicit variable in the sprit.run() function aside from input_data and verbose. Everything else gets delivered to the correct function via the kwargs dictionary
- remove_noise(): by default, the kind of noise removal is remove_method='auto'. See the remove_noise() documentation for more information. If remove_method is set to anything other than one of the explicit options in remove_noise, noise removal will not be carried out.
- calculate_azimuth(): calculate one or several azimuths. Single azimuth can be a way to combine H components too.
- generate_psds(): generates ppsds for each component, which will be combined/used later. Any parameter of obspy.signal.spectral_estimation.PPSD() may also be read into this function.
- remove_outlier_curves(): removes any outlier ppsd curves so that the data quality for when curves are combined will be enhanced. See the remove_outlier_curves() documentation for more information.
- process_hvsr(): this is the main function processing the hvsr curve and statistics. See process_hvsr() documentation for more details. The hvsr_band parameter sets the frequency spectrum over which these calculations occur.
- check_peaks(): this is the main function that will find and 'score' peaks to get a best peak. The parameter peak_freq_range can be set to limit the frequencies within which peaks are checked and scored.
- get_report(): this is the main function that will print, plot, and/or save the results of the data. See the get_report() API documentation for more information.
- export_hvsr(): this function exports the final data output as a pickle file (by default, this pickle object has a .hvsr extension). This can be used to read data back into SpRIT without having to reprocess data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>input_data</code></strong> :&ensp;<code>str</code> or <code>filepath object that can be read by obspy</code></dt>
<dd>Filepath to data to be processed. This may be a file or directory, depending on what kind of data is being processed (this can be specified with the source parameter).
For sample data, The following can be specified as the input_data parameter:
- Any integer 1-6 (inclusive), or the string (e.g., input_data="1" or input_data=1 will work)
- The word "sample" before any integer (e.g., input_data="sample1")
- The word "sample" will default to "sample1" if source='file'.
- If source='batch', input_data should be input_data='sample' or input_data='batch'. In this case, it will read and process all the sample files using the HVSRBatch class. Set verbose=True to see all the information in the sample batch csv file.</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd><em>description</em>, by default 'file'</dd>
<dt><strong><code>azimuth_calculation</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to perform azimuthal analysis, by default False.</dd>
<dt><strong><code>noise_removal</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to remove noise (before processing PPSDs)</dd>
<dt><strong><code>outlier_curves_removal</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to remove outlier curves from HVSR time windows</dd>
<dt><strong><code>show_plot</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to show plots. This does not affect whether the plots are created (and then inserted as an attribute of HVSRData), only whether they are shown.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd><em>description</em>, by default False</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for the functions listed above. The keyword arguments are unique, so they will get parsed out and passed into the appropriate function.</dd>
<dt><strong><code>input_params</code></strong> :&ensp;<code>function name (not an actual parameter) </code></dt>
<dd>Function for designating input parameters for reading in and processing data
See API documentation: <a href="https://sprit.readthedocs.io/en/latest/sprit.html#sprit.input_params">input_params()</a></dd>
<dt><strong><code>input_data</code></strong> :&ensp;<code>any</code>, default <code>= '&lt;no default&gt;'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="index.html#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>site</code></strong> :&ensp;<code>any</code>, default <code>= 'HVSRSite'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="index.html#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>project</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.input_params" href="#sprit.sprit_hvsr.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>network</code></strong> :&ensp;<code>any</code>, default <code>= 'AM'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="index.html#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>station</code></strong> :&ensp;<code>any</code>, default <code>= 'NONE'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="index.html#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>location</code></strong> :&ensp;<code>any</code>, default <code>= '00'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="index.html#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>channels</code></strong> :&ensp;<code>any</code>, default <code>= ['EHZ', 'EHN', 'EHE']</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.input_params" href="#sprit.sprit_hvsr.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>acq_date</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.input_params" href="#sprit.sprit_hvsr.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>starttime</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.input_params" href="#sprit.sprit_hvsr.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>endtime</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.input_params" href="#sprit.sprit_hvsr.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>tzone</code></strong> :&ensp;<code>any</code>, default <code>= 'UTC'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="index.html#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>xcoord</code></strong> :&ensp;<code>any</code>, default <code>= -88.229</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.input_params" href="#sprit.sprit_hvsr.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>ycoord</code></strong> :&ensp;<code>any</code>, default <code>= 40.101</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.input_params" href="#sprit.sprit_hvsr.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>elevation</code></strong> :&ensp;<code>any</code>, default <code>= 225</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.input_params" href="#sprit.sprit_hvsr.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>input_crs</code></strong> :&ensp;<code>any</code>, default <code>= 'EPSG:4326'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="index.html#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>output_crs</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.input_params" href="#sprit.sprit_hvsr.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>elev_unit</code></strong> :&ensp;<code>any</code>, default <code>= 'meters'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="index.html#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>depth</code></strong> :&ensp;<code>any</code>, default <code>= 0</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.input_params" href="#sprit.sprit_hvsr.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>instrument</code></strong> :&ensp;<code>any</code>, default <code>= 'Seismometer'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="index.html#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.input_params" href="#sprit.sprit_hvsr.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>hvsr_band</code></strong> :&ensp;<code>any</code>, default <code>= [0.5, 40]</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.input_params" href="#sprit.sprit_hvsr.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>peak_freq_range</code></strong> :&ensp;<code>any</code>, default <code>= [0.5, 40]</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.input_params" href="#sprit.sprit_hvsr.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>processing_parameters</code></strong> :&ensp;<code>any</code>, default <code>= {}</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.input_params" href="#sprit.sprit_hvsr.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.input_params" href="#sprit.sprit_hvsr.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>fetch_data</code></strong> :&ensp;<code>function name (not an actual parameter) </code></dt>
<dd>Fetch ambient seismic data from a source to read into obspy stream.
See API documentation: <a href="https://sprit.readthedocs.io/en/latest/sprit.html#sprit.fetch_data">fetch_data()</a></dd>
<dt><strong><code>params</code></strong> :&ensp;<code>any</code>, default <code>= '&lt;output</code> of <code>previous function&gt;'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.fetch_data" href="index.html#sprit.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>any</code>, default <code>= 'file'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.fetch_data" href="index.html#sprit.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>data_export_path</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.fetch_data" href="#sprit.sprit_hvsr.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>data_export_format</code></strong> :&ensp;<code>any</code>, default <code>= 'mseed'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.fetch_data" href="index.html#sprit.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>detrend</code></strong> :&ensp;<code>any</code>, default <code>= 'spline'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.fetch_data" href="index.html#sprit.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>detrend_options</code></strong> :&ensp;<code>any</code>, default <code>= 2</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.fetch_data" href="#sprit.sprit_hvsr.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>filter_type</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.fetch_data" href="#sprit.sprit_hvsr.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>filter_options</code></strong> :&ensp;<code>any</code>, default <code>= {}</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.fetch_data" href="#sprit.sprit_hvsr.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>update_metadata</code></strong> :&ensp;<code>any</code>, default <code>= True</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.fetch_data" href="#sprit.sprit_hvsr.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>plot_input_stream</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.fetch_data" href="#sprit.sprit_hvsr.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>plot_engine</code></strong> :&ensp;<code>any</code>, default <code>= 'matplotlib'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.fetch_data" href="index.html#sprit.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>show_plot</code></strong> :&ensp;<code>any</code>, default <code>= True</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.fetch_data" href="#sprit.sprit_hvsr.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.fetch_data" href="#sprit.sprit_hvsr.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>any</code>, default <code>= {}</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.fetch_data" href="#sprit.sprit_hvsr.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>calculate_azimuth</code></strong> :&ensp;<code>function name (not an actual parameter) </code></dt>
<dd>Function to calculate azimuthal horizontal component at specified angle(s).
See API documentation: <a href="https://sprit.readthedocs.io/en/latest/sprit.html#sprit.calculate_azimuth">calculate_azimuth()</a></dd>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>any</code>, default <code>= '&lt;output</code> of <code>previous function&gt;'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.calculate_azimuth" href="index.html#sprit.calculate_azimuth">calculate_azimuth()</a>)</code> for specifics.</dd>
<dt><strong><code>azimuth_angle</code></strong> :&ensp;<code>any</code>, default <code>= 45</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.calculate_azimuth" href="#sprit.sprit_hvsr.calculate_azimuth">calculate_azimuth()</a>)</code> for specifics.</dd>
<dt><strong><code>azimuth_type</code></strong> :&ensp;<code>any</code>, default <code>= 'multiple'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.calculate_azimuth" href="index.html#sprit.calculate_azimuth">calculate_azimuth()</a>)</code> for specifics.</dd>
<dt><strong><code>azimuth_unit</code></strong> :&ensp;<code>any</code>, default <code>= 'degrees'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.calculate_azimuth" href="index.html#sprit.calculate_azimuth">calculate_azimuth()</a>)</code> for specifics.</dd>
<dt><strong><code>show_az_plot</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.calculate_azimuth" href="#sprit.sprit_hvsr.calculate_azimuth">calculate_azimuth()</a>)</code> for specifics.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.calculate_azimuth" href="#sprit.sprit_hvsr.calculate_azimuth">calculate_azimuth()</a>)</code> for specifics.</dd>
<dt><strong><code>plot_azimuth_kwargs</code></strong> :&ensp;<code>any</code>, default <code>= {}</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.calculate_azimuth" href="#sprit.sprit_hvsr.calculate_azimuth">calculate_azimuth()</a>)</code> for specifics.</dd>
<dt><strong><code>remove_noise</code></strong> :&ensp;<code>function name (not an actual parameter) </code></dt>
<dd>Function to remove noisy windows from data, using various methods.
See API documentation: <a href="https://sprit.readthedocs.io/en/latest/sprit.html#sprit.remove_noise">remove_noise()</a></dd>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>any</code>, default <code>= '&lt;output</code> of <code>previous function&gt;'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_noise" href="index.html#sprit.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>remove_method</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_noise" href="#sprit.sprit_hvsr.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>processing_window</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_noise" href="#sprit.sprit_hvsr.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>sat_percent</code></strong> :&ensp;<code>any</code>, default <code>= 0.995</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_noise" href="#sprit.sprit_hvsr.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>noise_percent</code></strong> :&ensp;<code>any</code>, default <code>= 0.8</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_noise" href="#sprit.sprit_hvsr.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>sta</code></strong> :&ensp;<code>any</code>, default <code>= 2</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_noise" href="#sprit.sprit_hvsr.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>lta</code></strong> :&ensp;<code>any</code>, default <code>= 30</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_noise" href="#sprit.sprit_hvsr.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>stalta_thresh</code></strong> :&ensp;<code>any</code>, default <code>= [8, 16]</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_noise" href="#sprit.sprit_hvsr.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>std_ratio_thresh</code></strong> :&ensp;<code>any</code>, default <code>= 2.0</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_noise" href="#sprit.sprit_hvsr.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>std_window_size</code></strong> :&ensp;<code>any</code>, default <code>= 20.0</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_noise" href="#sprit.sprit_hvsr.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>min_std_win</code></strong> :&ensp;<code>any</code>, default <code>= 5.0</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_noise" href="#sprit.sprit_hvsr.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>warmup_time</code></strong> :&ensp;<code>any</code>, default <code>= 0</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_noise" href="#sprit.sprit_hvsr.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>cooldown_time</code></strong> :&ensp;<code>any</code>, default <code>= 0</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_noise" href="#sprit.sprit_hvsr.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>min_win_size</code></strong> :&ensp;<code>any</code>, default <code>= 1</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_noise" href="#sprit.sprit_hvsr.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>remove_raw_noise</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_noise" href="#sprit.sprit_hvsr.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>show_stalta_plot</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_noise" href="#sprit.sprit_hvsr.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_noise" href="#sprit.sprit_hvsr.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>generate_psds</code></strong> :&ensp;<code>function name (not an actual parameter) </code></dt>
<dd>Calculate Power Spectral Density (PSD) curves for each channel.
See API documentation: <a href="https://sprit.readthedocs.io/en/latest/sprit.html#sprit.generate_psds">generate_psds()</a></dd>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>any</code>, default <code>= '&lt;output</code> of <code>previous function&gt;'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.generate_psds" href="index.html#sprit.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>window_length</code></strong> :&ensp;<code>any</code>, default <code>= 30.0</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.generate_psds" href="#sprit.sprit_hvsr.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>overlap_pct</code></strong> :&ensp;<code>any</code>, default <code>= 0.5</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.generate_psds" href="#sprit.sprit_hvsr.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>window_type</code></strong> :&ensp;<code>any</code>, default <code>= 'hann'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.generate_psds" href="index.html#sprit.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>window_length_method</code></strong> :&ensp;<code>any</code>, default <code>= 'length'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.generate_psds" href="index.html#sprit.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>remove_response</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.generate_psds" href="#sprit.sprit_hvsr.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>skip_on_gaps</code></strong> :&ensp;<code>any</code>, default <code>= True</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.generate_psds" href="#sprit.sprit_hvsr.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>num_freq_bins</code></strong> :&ensp;<code>any</code>, default <code>= 512</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.generate_psds" href="#sprit.sprit_hvsr.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>hvsr_band</code></strong> :&ensp;<code>any</code>, default <code>= [0.5, 40]</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.generate_psds" href="#sprit.sprit_hvsr.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>obspy_ppsds</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.generate_psds" href="#sprit.sprit_hvsr.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>azimuthal_psds</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.generate_psds" href="#sprit.sprit_hvsr.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.generate_psds" href="#sprit.sprit_hvsr.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>plot_psds</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.generate_psds" href="#sprit.sprit_hvsr.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>obspy_ppsd_kwargs</code></strong> :&ensp;<code>any</code>, default <code>= {}</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.generate_psds" href="#sprit.sprit_hvsr.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>process_hvsr</code></strong> :&ensp;<code>function name (not an actual parameter) </code></dt>
<dd>Process the input data and get HVSR data
See API documentation: <a href="https://sprit.readthedocs.io/en/latest/sprit.html#sprit.process_hvsr">process_hvsr()</a></dd>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>any</code>, default <code>= '&lt;output</code> of <code>previous function&gt;'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.process_hvsr" href="index.html#sprit.process_hvsr">process_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>horizontal_method</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.process_hvsr" href="#sprit.sprit_hvsr.process_hvsr">process_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>smooth</code></strong> :&ensp;<code>any</code>, default <code>= True</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.process_hvsr" href="#sprit.sprit_hvsr.process_hvsr">process_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>freq_smooth</code></strong> :&ensp;<code>any</code>, default <code>= 'konno ohmachi'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.process_hvsr" href="index.html#sprit.process_hvsr">process_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>f_smooth_width</code></strong> :&ensp;<code>any</code>, default <code>= 40</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.process_hvsr" href="#sprit.sprit_hvsr.process_hvsr">process_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>resample</code></strong> :&ensp;<code>any</code>, default <code>= True</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.process_hvsr" href="#sprit.sprit_hvsr.process_hvsr">process_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>outlier_curve_percentile_threshold</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.process_hvsr" href="#sprit.sprit_hvsr.process_hvsr">process_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>azimuth</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.process_hvsr" href="#sprit.sprit_hvsr.process_hvsr">process_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.process_hvsr" href="#sprit.sprit_hvsr.process_hvsr">process_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>remove_outlier_curves</code></strong> :&ensp;<code>function name (not an actual parameter) </code></dt>
<dd>Function used to remove outliers curves using Root Mean Square Error to calculate the error of each
See API documentation: <a href="https://sprit.readthedocs.io/en/latest/sprit.html#sprit.remove_outlier_curves">remove_outlier_curves()</a></dd>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>any</code>, default <code>= '&lt;output</code> of <code>previous function&gt;'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_outlier_curves" href="index.html#sprit.remove_outlier_curves">remove_outlier_curves()</a>)</code> for specifics.</dd>
<dt><strong><code>outlier_method</code></strong> :&ensp;<code>any</code>, default <code>= 'prototype'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_outlier_curves" href="index.html#sprit.remove_outlier_curves">remove_outlier_curves()</a>)</code> for specifics.</dd>
<dt><strong><code>outlier_threshold</code></strong> :&ensp;<code>any</code>, default <code>= 50</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_outlier_curves" href="#sprit.sprit_hvsr.remove_outlier_curves">remove_outlier_curves()</a>)</code> for specifics.</dd>
<dt><strong><code>use_percentile</code></strong> :&ensp;<code>any</code>, default <code>= True</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_outlier_curves" href="#sprit.sprit_hvsr.remove_outlier_curves">remove_outlier_curves()</a>)</code> for specifics.</dd>
<dt><strong><code>min_pts</code></strong> :&ensp;<code>any</code>, default <code>= 5</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_outlier_curves" href="#sprit.sprit_hvsr.remove_outlier_curves">remove_outlier_curves()</a>)</code> for specifics.</dd>
<dt><strong><code>use_hv_curves</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_outlier_curves" href="#sprit.sprit_hvsr.remove_outlier_curves">remove_outlier_curves()</a>)</code> for specifics.</dd>
<dt><strong><code>plot_engine</code></strong> :&ensp;<code>any</code>, default <code>= 'matplotlib'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_outlier_curves" href="index.html#sprit.remove_outlier_curves">remove_outlier_curves()</a>)</code> for specifics.</dd>
<dt><strong><code>show_outlier_plot</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_outlier_curves" href="#sprit.sprit_hvsr.remove_outlier_curves">remove_outlier_curves()</a>)</code> for specifics.</dd>
<dt><strong><code>generate_outlier_plot</code></strong> :&ensp;<code>any</code>, default <code>= True</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_outlier_curves" href="#sprit.sprit_hvsr.remove_outlier_curves">remove_outlier_curves()</a>)</code> for specifics.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_outlier_curves" href="#sprit.sprit_hvsr.remove_outlier_curves">remove_outlier_curves()</a>)</code> for specifics.</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>any</code>, default <code>= {}</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.remove_outlier_curves" href="#sprit.sprit_hvsr.remove_outlier_curves">remove_outlier_curves()</a>)</code> for specifics.</dd>
<dt><strong><code>check_peaks</code></strong> :&ensp;<code>function name (not an actual parameter) </code></dt>
<dd>Function to run tests on HVSR peaks to find best one and see if it passes SESAME quality checks
See API documentation: <a href="https://sprit.readthedocs.io/en/latest/sprit.html#sprit.check_peaks">check_peaks()</a></dd>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>any</code>, default <code>= '&lt;output</code> of <code>previous function&gt;'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.check_peaks" href="index.html#sprit.check_peaks">check_peaks()</a>)</code> for specifics.</dd>
<dt><strong><code>hvsr_band</code></strong> :&ensp;<code>any</code>, default <code>= [0.5, 40]</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.check_peaks" href="#sprit.sprit_hvsr.check_peaks">check_peaks()</a>)</code> for specifics.</dd>
<dt><strong><code>peak_selection</code></strong> :&ensp;<code>any</code>, default <code>= 'max'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.check_peaks" href="index.html#sprit.check_peaks">check_peaks()</a>)</code> for specifics.</dd>
<dt><strong><code>peak_freq_range</code></strong> :&ensp;<code>any</code>, default <code>= [0.5, 40]</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.check_peaks" href="#sprit.sprit_hvsr.check_peaks">check_peaks()</a>)</code> for specifics.</dd>
<dt><strong><code>azimuth</code></strong> :&ensp;<code>any</code>, default <code>= 'HV'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.check_peaks" href="index.html#sprit.check_peaks">check_peaks()</a>)</code> for specifics.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.check_peaks" href="#sprit.sprit_hvsr.check_peaks">check_peaks()</a>)</code> for specifics.</dd>
<dt><strong><code>get_report</code></strong> :&ensp;<code>function name (not an actual parameter) </code></dt>
<dd>Generate and/or print and/or export a report of the HVSR analysis in a variety of formats.
See API documentation: <a href="https://sprit.readthedocs.io/en/latest/sprit.html#sprit.get_report">get_report()</a></dd>
<dt><strong><code>hvsr_results</code></strong> :&ensp;<code>any</code>, default <code>= '&lt;output</code> of <code>previous function&gt;'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.get_report" href="index.html#sprit.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>report_formats</code></strong> :&ensp;<code>any</code>, default <code>= ['print', 'table', 'plot', 'html', 'pdf']</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.get_report" href="#sprit.sprit_hvsr.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>azimuth</code></strong> :&ensp;<code>any</code>, default <code>= 'HV'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.get_report" href="index.html#sprit.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>plot_type</code></strong> :&ensp;<code>any</code>, default <code>= 'HVSR p ann COMP+ p ann SPEC p ann'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.get_report" href="index.html#sprit.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>plot_engine</code></strong> :&ensp;<code>any</code>, default <code>= 'matplotlib'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.get_report" href="index.html#sprit.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>show_print_report</code></strong> :&ensp;<code>any</code>, default <code>= True</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.get_report" href="#sprit.sprit_hvsr.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>show_table_report</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.get_report" href="#sprit.sprit_hvsr.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>show_plot_report</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.get_report" href="#sprit.sprit_hvsr.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>show_html_report</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.get_report" href="#sprit.sprit_hvsr.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>show_pdf_report</code></strong> :&ensp;<code>any</code>, default <code>= True</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.get_report" href="#sprit.sprit_hvsr.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>suppress_report_outputs</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.get_report" href="#sprit.sprit_hvsr.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>show_report_outputs</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.get_report" href="#sprit.sprit_hvsr.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>csv_handling</code></strong> :&ensp;<code>any</code>, default <code>= 'append'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.get_report" href="index.html#sprit.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>report_export_format</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.get_report" href="#sprit.sprit_hvsr.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>report_export_path</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.get_report" href="#sprit.sprit_hvsr.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.get_report" href="#sprit.sprit_hvsr.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>any</code>, default <code>= {}</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.get_report" href="#sprit.sprit_hvsr.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>export_hvsr</code></strong> :&ensp;<code>function name (not an actual parameter) </code></dt>
<dd>Export data into pickle format that can be read back in using import_data().
See API documentation: <a href="https://sprit.readthedocs.io/en/latest/sprit.html#sprit.export_hvsr">export_hvsr()</a></dd>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>any</code>, default <code>= '&lt;output</code> of <code>previous function&gt;'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.export_hvsr" href="index.html#sprit.export_hvsr">export_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>hvsr_export_path</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.export_hvsr" href="#sprit.sprit_hvsr.export_hvsr">export_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>ext</code></strong> :&ensp;<code>any</code>, default <code>= 'hvsr'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.export_hvsr" href="index.html#sprit.export_hvsr">export_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>export_plots</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.export_hvsr" href="#sprit.sprit_hvsr.export_hvsr">export_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.sprit_hvsr.export_hvsr" href="#sprit.sprit_hvsr.export_hvsr">export_hvsr()</a>)</code> for specifics.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>hvsr_results</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="index.html#sprit.HVSRData">HVSRData</a></code> or <code><a title="sprit.HVSRBatch" href="index.html#sprit.HVSRBatch">HVSRBatch</a> object</code></dt>
<dd>If a single file/data point is being processed, a HVSRData object will be returned. Otherwise, it will be a HVSRBatch object. See their documention for more information.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="sprit.sprit_hvsr.input_params" href="#sprit.sprit_hvsr.input_params">input_params()</a></code>
<code><a title="sprit.sprit_hvsr.fetch_data" href="#sprit.sprit_hvsr.fetch_data">fetch_data()</a></code>
<code><a title="sprit.sprit_hvsr.remove_noise" href="#sprit.sprit_hvsr.remove_noise">remove_noise()</a></code>
<code><a title="sprit.sprit_hvsr.calculate_azimuth" href="#sprit.sprit_hvsr.calculate_azimuth">calculate_azimuth()</a></code>
<code><a title="sprit.sprit_hvsr.generate_psds" href="#sprit.sprit_hvsr.generate_psds">generate_psds()</a></code>
<code><a title="sprit.sprit_hvsr.remove_outlier_curves" href="#sprit.sprit_hvsr.remove_outlier_curves">remove_outlier_curves()</a></code>
<code><a title="sprit.sprit_hvsr.process_hvsr" href="#sprit.sprit_hvsr.process_hvsr">process_hvsr()</a></code>
<code><a title="sprit.sprit_hvsr.check_peaks" href="#sprit.sprit_hvsr.check_peaks">check_peaks()</a></code>
<code><a title="sprit.sprit_hvsr.get_report" href="#sprit.sprit_hvsr.get_report">get_report()</a></code>
<code><a title="sprit.sprit_hvsr.export_hvsr" href="#sprit.sprit_hvsr.export_hvsr">export_hvsr()</a> </code>Raises</p>
<hr>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If the input parameter may not be read correctly. This is raised if the input_params() function fails. This raises an error since no other data processing or reading steps will be able to carried out correctly.</dd>
<dt><code>RuntimeError</code></dt>
<dd>If the data is not read/fetched correctly using fetch_data(), an error will be raised. This is raised if the fetch_data() function fails. This raises an error since no other data processing steps will be able to carried out correctly.</dd>
<dt><code>RuntimeError</code></dt>
<dd>If the data being processed is a single file, an error will be raised if generate_psds() does not work correctly. No errors are raised for remove_noise() errors (since that is an optional step) and the process_hvsr() step (since that is the last processing step) .</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.test_function"><code class="name flex">
<span>def <span class="ident">test_function</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sprit.sprit_hvsr.update_elevation"><code class="name flex">
<span>def <span class="ident">update_elevation</span></span>(<span>hvsr_data, updated_surface_elevation, updated_elevation_unit)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to quickly update all attributes associated with elevation of an HVSRData object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code><a title="sprit.sprit_hvsr.HVSRData" href="#sprit.sprit_hvsr.HVSRData">HVSRData</a></code> or <code><a title="sprit.sprit_hvsr.HVSRBatch" href="#sprit.sprit_hvsr.HVSRBatch">HVSRBatch</a></code></dt>
<dd>HVSRData or HVSRBatch object containing attributes related to elevation.
If HVSRBatch, updated_surface_elevation should be list or tuple and
updated_elevation_unit may either be str or
list/tuple of strings.</dd>
<dt><strong><code>updated_surface_elevation</code></strong> :&ensp;<code>numbers.Number</code></dt>
<dd>Number (float or int) with the updated elevation.
Meters is the preferred unit. If feet are used instead, it will be converted to meters.</dd>
<dt><strong><code>updated_elevation_unit</code></strong> :&ensp;<code>str</code></dt>
<dd>Unit used for updated_surface_elevation. If 'feet', it will be converted to meters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sprit.sprit_hvsr.HVSRData" href="#sprit.sprit_hvsr.HVSRData">HVSRData</a></code></dt>
<dd>HVSRData object with all attributes related to elevation updated</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.update_resp_file"><code class="name flex">
<span>def <span class="ident">update_resp_file</span></span>(<span>resp_file, new_network, new_station, return_inv=True, new_channels='CHZ', new_location='', starttime_new=None, endtime_new=None, new_resp_file=None, existing_starttime='2015,001,00:00:00.0000', existing_endtime='No Ending Time', existing_network='XX', existing_station='NS124', existing_channel='CHZ', existing_location='??')</span>
</code></dt>
<dd>
<div class="desc"><p>Function to update headers in .RESP instrument response files for easy copying.
It is recommended to read this into a variable and set it as the metadata parameter of input_params
if it is desired to correct for instrument response, for example.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>resp_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Filepath to input response file</dd>
<dt><strong><code>new_network</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of network to update header to.</dd>
<dt><strong><code>new_station</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of station to update header to.</dd>
<dt><strong><code>return_inv</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to return an obspy inventory object.
If False, a .RESP file will be saved in the same directory as resp_file, by default True</dd>
<dt><strong><code>new_channels</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name or list of channels to update the header to.
If list, multiple inventory objects will be created/saved, by default 'CHZ'</dd>
<dt><strong><code>new_location</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>New instrument location attribute to update header to, by default ""</dd>
<dt><strong><code>starttime</code></strong> :&ensp;<code>obspy.UTCDateTime</code>, optional</dt>
<dd>Input to update starttime. Must be readable by obspy.UTCDateTime(), by default None</dd>
<dt><strong><code>endtime</code></strong> :&ensp;<code>obspy.UTCDateTime</code>, optional</dt>
<dd>Input to update endtime. Must be readable by obspy.UTCDateTime(), by default None</dd>
<dt><strong><code>new_resp_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Filepath to designate for .RESP file output, if desired (and return_inv=False)
If None, uses same directory as resp_file, by default None</dd>
<dt><strong><code>existing_network</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of network as specified in input file, by default 'XX'</dd>
<dt><strong><code>existing_station</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>name of station as specified in input file, by default 'NS124'</dd>
<dt><strong><code>existing_channel</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of channel as specified in input file, by default 'CHZ'</dd>
<dt><strong><code>existing_location</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of location as specified in input file, by default '??'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>obspy.Inventory</code></dt>
<dd>Only returned if return_inv = True</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sprit.sprit_hvsr.HVSRBatch"><code class="flex name class">
<span>class <span class="ident">HVSRBatch</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>HVSRBatch is the data container used for batch processing.
It contains several HVSRData objects (one for each site).
These can be accessed using their site name,
either square brackets (HVSRBatchVariable["SiteName"]) or the dot (HVSRBatchVariable.SiteName) accessor.</p>
<p>The dot accessor may not work if there is a space in the site name.</p>
<p>All of the
functions in the sprit package are designed to perform the bulk of their operations iteratively
on the individual HVSRData objects contained in the HVSRBatch object, and do little with the HVSRBatch object itself,
besides using it determine which sites are contained within it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HVSRBatch:
    &#34;&#34;&#34;HVSRBatch is the data container used for batch processing. 
    It contains several HVSRData objects (one for each site). 
    These can be accessed using their site name, 
    either square brackets (HVSRBatchVariable[&#34;SiteName&#34;]) or the dot (HVSRBatchVariable.SiteName) accessor.
    
    The dot accessor may not work if there is a space in the site name.
    
    All of the  functions in the sprit package are designed to perform the bulk of their operations iteratively
    on the individual HVSRData objects contained in the HVSRBatch object, and do little with the HVSRBatch object itself, 
    besides using it determine which sites are contained within it.
    
    &#34;&#34;&#34;
    @check_instance
    def __init__(self, batch_input, batch_ext=None, batch_use=None, df_as_read=None):
        &#34;&#34;&#34;HVSR Batch initializer

        Parameters
        ----------
        batch_input : dict, list, tuple, HVSRData, or filepath(s)
            If:

            * dict, dictionary containing Key value pairs with {sitename: HVSRData object}.
            * list or tuple, assumed to be dicts, HVSRData objects, or filepaths to processed .hvsr files or seismic data to be processed.
            * HVSRData object, will transform into HVSRBatch object with single HVSRData object. The add() or append() methods, or using square brackes can be used to add additional sites.
            * filepaths, if:
                * If directory, will use `batch_ext` as the input to a `glob()` function to get all files in that directory and add them to batch. Defaults to &#39;.hvsr&#39; files if `batch_ext` not specified.
                * Filepath, will make a HVSRBatch object importing that single file, or if readable by pandas.read_csv() will use in conjunction with `batch_use` (see below)
        batch_ext : str or None
            Filepath extension to use in `glob()` function for filetypes to import, if batch_input is a filepath.
        batch_use : {dict, list, tuple, None}
            Intended to be used as dict with keys &#34;site&#34;, &#34;filepath&#34;, and &#34;batch&#34;. 
            In this case, should be {&#39;site&#39;:&#34;name_of_df_col_with_sitenames&#34;, &#39;filepath&#39;:&#34;name_of_df_col_with_filepaths_to_data&#34;, &#39;batch&#39;:values_to_include}.
            values_to_include can be a value (or list of values) in a column called &#34;batch&#34; to specify that that row should be included in the HVSRBatch object or
            a dictionary where they keys are column names and the values are the values to look for in each column name for inclusion in HVSRBatch object.
            If not specified, defaults to None and uses all rows in dataframe.

        df_as_read : {None, pd.DataFrame}
            Used in various sprit functions to allow original DataFrame used to create HVSRBatch object to be carried through.        
        &#34;&#34;&#34;

        # Just return it as-is if it&#39;s already Batch object
        if isinstance(batch_input, HVSRBatch):
            return batch_input
        
        self._batch_input = batch_input
        self.batch_input = self._batch_input
        
        self._batch_dict = self.batch_dict = {}

        self._input_df = df_as_read
        self.input_df = self._input_df
        
        self.batch = True
        
        if isinstance(batch_input, (list, tuple,)):
            # This is for a list/tuple with the following structure:
            # batch_input = [HVSRData, HVSRData, HVSRData]
            # or batch_input = [&#39;/file/path1.hvsr&#39;, &#39;/file/path2.hvsr&#39;]
            # Can also be mixed: [HVSRData, &#39;/file/path3/.hvsr&#39;]
            siteNo = 0
            zfilldigs = len(str(len(batch_input)))
            
            for hvdata in batch_input:
                if isinstance(hvdata, (dict, HVSRData)):
                    if hasattr(hvdata, &#39;site&#39;):
                        sitename = hvdata.site
                    elif hasattr(hvdata, &#39;Table_Report&#39;) and &#39;Site Name&#39; in hvdata.Table_Report.columns:
                        sitename = hvdata.Table_Report[&#39;Site Name&#39;][0]
                    else:
                        sitename = f&#34;HVSRSite{str(siteNo).zfill(zfilldigs)}&#34;
                        siteNo += 1
                    self.batch_dict[sitename] = hvdata
                elif pathlib.Path(hvdata).exists():
                    def _get_sitename(proposed_sitename, batch_dict):
                        # Get unique site name based on stem
                        j = 0
                        if proposed_sitename in batch_dict.keys():
                            # 100 is limit
                            for index in range(100):
                                if len(proposed_sitename.split(&#39;_&#39;)) &lt;= index:
                                    if proposed_sitename.split(&#39;_&#39;)[-1].isdigit():
                                        j = int(proposed_sitename.split(&#39;_&#39;)[-1]) + 1
                                        sitenameList = proposed_sitename.split(&#39;_&#39;)
                                        sitenameList[-1] = str(j)
                                        proposed_sitename = &#39;_&#39;.join(sitenameList)
                                        break
                                    else:
                                        proposed_sitename = proposed_sitename+&#39;_&#39;+str(j)
                                        break
                                    j += 1
                                else:
                                    proposed_sitename = &#39;_&#39;.join(proposed_sitename.split(&#39;_&#39;)[:index+1])
                        return proposed_sitename

                    if &#39;hvsr&#39; in pathlib.Path(hvdata).suffix:
                        sitename = pathlib.path(hvdata).stem
                        sitename = _get_sitename(sitename, batch_dict)

                        self.batch_dict[sitename] = hvdata
                    elif pathlib.Path(hvdata).suffix.upper()[1:] in OBSPY_FORMATS:
                        if verbose:
                            print(f&#34;Site specified for inclusion in HVSRBatch has not been processed. Processing. ({hvdata})&#34;)
                        sitename = pathlib.Path(hvdata).stem
                        sitename = _get_sitename(sitename, batch_dict)
                        self.batch_dict[sitename] = run(pathlib.Path(hvdata).as_posix())
                    else:
                        print(f&#34;Could not parse Batch input. Excluding from HVSRBatch object: {hvdata}&#34;)
        elif isinstance(batch_input, dict):
            # This is for a dictionary with the following structure:
            # batch_input = {&#34;SiteName1&#34;:HVSRData, &#34;Sitename2&#34;:HVSRData}
            self.batch_dict = batch_input
        elif isinstance(batch_input, HVSRData):
            # If iniitializing HVSRBatch with single HVSRData
            self.batch_dict[batch_input[&#39;site&#39;]] = batch_input
        elif pathlib.Path(batch_input).exists():
            # This is intended for filepaths
            if pathlib.Path(batch_input).is_dir():
                if batch_ext is not None:
                    batchfileglob = pathlib.Path(batch_input).glob(&#34;*.&#34;+batch_ext)
                    batchfiledict = {}
                    #if &#39;hvsr&#39; in batch_ext:
                    for hvfile in batchfileglob:
                        currhvfile = import_data(hvfile)
                        batchfiledict[currhvfile[&#39;site&#39;]] = currhvfile
                    self.batch_dict = self._batch_dict = batchfiledict
                else:
                    # Assume it is .hvsr file you wish to import
                    batchfileglob = []
                    batchfiledict = {}

                    batchfileglob = pathlib.Path(batch_input).glob(&#34;*&#34;)
                    for hvfile in batchfileglob:
                        if hvfile.as_posix().lower().endswith(&#39;hvsr&#39;):
                            currhvfile = import_data(hvfile.as_posix())
                            batchfiledict[currhvfile[&#39;site&#39;]] = currhvfile
                    self.batch_dict = self._batch_dict = batchfiledict           
            else:
                if &#39;.hvsr&#39; in pathlib.Path(batch_input).suffix:
                    # In this case, assume this is alreayd a batch file and import/return it
                    return import_data(batch_input)
                else:
                    # For reading in a csv and specifying column map
                    batch_df = pd.read_csv(batch_input)

                    # Convert columns to lowercase
                    batch_df.columns = [c.lower() for c in batch_df.columns]

                    # This is for if dictionary mapping is not specified
                    snList = [&#39;site&#39;, &#39;sitename&#39;, &#39;sites&#39;, &#39;sitenames&#39;, 
                                &#39;identifier&#39;, &#39;batch&#39;, &#39;profile&#39;, &#39;crosssection&#39;, &#39;group&#39;]
                    pathList = [&#39;hvsr_export_path&#39;, &#39;import_filepath&#39;, &#39;batch_input&#39;, &#39;filepath&#39;, &#39;input_data&#39;,
                                &#39;path&#39;, &#39;filepath&#39;, &#39;filename&#39;, &#39;file&#39;, &#39;hvsrdata&#39;, &#39;hvsr&#39;, &#39;data&#39;]

                    siteCol = batch_df.columns[0]
                    for sn in snList:
                        if sn in snList:
                            siteCol = sn
                            break

                    pathCol = batch_df.columns[1]
                    for pa in pathList:
                        if pa in pathList:
                            pathCol = pa
                            break

                    def _read_data_into_batch(batch_df_row, site_col, path_col):
                        if &#39;.hvsr&#39; in str(batch_df_row[path_col]):
                            dataObj = import_data(str(batch_df_row[path_col]))
                        elif pathlib.Path(batch_df_row[path_col]).suffix.upper()[1:] in OBSPY_FORMATS:
                            dataObj = run(pathlib.Path(batch_df_row[path_col]).as_posix())
                        else:
                            warnings.Warn(f&#34;Batch input specified as site {batch_df_row[site_col]} cannot be read, skipping: {batch_df_row[path_col]}&#34;)
                            dataObj = None
                        
                        return dataObj

                    if isinstance(batch_use, dict):
                        # Dictionary of {&#39;site&#39;:&#34;site_col&#34;, &#39;filepath&#39;:&#39;path_col&#39;, &#39;batch&#39;:values_in_batch_col_to_include}
                        if len(list(batch_use.keys())) != 3:
                            warnMsg = f&#34;batch_use dict should have three keys called &#39;site&#39;, &#39;filepath&#39;, and &#39;batch&#39; (not {len(list(batch_use.keys()))}: {list(batch_use.keys())}). \n\t&#39;batch&#39; may be changed to name of column you are using to specify inclusion in HVSRBatch object, or input DataFrame should have column called &#39;batch&#39;&#34;
                            warnings.Warn(warnMsg)

                        # Should be site and filepath, but just in case
                        for k in batch_use.keys():
                            if str(k).lower() in snList:
                                siteCol = batch_use[k]
                                siteKey = k

                            if str(k).lower() in pathList:
                                pathCol = batch_use[k]
                                pathKey = k

                            if str(k).lower() not in snList and str(k).lower() not in pathList:
                                includeMe = batch_use[k]
                                batchKey = k
    
                        # Get subset df with only rows that we want
                        #includeMe = batchCol#batch_use[batchCol]
                        if isinstance(includeMe, (list, tuple)):
                            sites_df = batch_df[batch_df[batchKey].isin(includeMe)]
                        elif isinstance(includeMe, dict):
                            sitesDFList = []
                            for batchCol, includeValue in includeMe.items():
                                sitesDFList.append(batch_df[batch_df[batchCol]==includeValue])
                            sites_df = pd.concat(sitesDFList, ignore_index=True)
                        else:
                            sites_df = batch_df[batch_df[batchKey]==includeMe]

                        # Import, process, or otherwise read data into batch object
                        for i, row in sites_df.iterrows():
                            dataObj = _read_data_into_batch(row, siteCol, pathCol)
                            if dataObj is not None:
                                self.batch_dict[str(row[siteCol])] = dataObj

                    elif isinstance(batch_use, (list, tuple)):
                        # This should be list/tuples of site names
                        sites_df = batch_df[batch_df[siteCol].isin(batch_use)]
                        for i, row in sites_df.iterrows():
                            dataObj = _read_data_into_batch(row, siteCol, pathCol)
                            if dataObj is not None:
                                self.batch_dict[str(row[siteCol])] = dataObj
                    
                    else:
                        # Use all rows (as possible)
                        print(f&#34;**NOTE**: All data specified will be read into batch object, from: {batch_input}&#34;)
                        for i, row in batch_df.iterrows():
                            dataObj = _read_data_into_batch(row, siteCol, pathCol)

                            if dataObj is not None:
                                self.batch_dict[str(row[siteCol])] = dataObj
        else:
            raise TypeError(f&#34;The batch_input parameter of the HVSRBatch class must be a dict of parameters, list or tuple of HVSRData obejcts, or an HVSRData object itself. {type(batch_input)}&#34;)


        self._batch_dict = self.batch_dict
        for sitename, hvsrdata in self.batch_dict.items():
            setattr(self, sitename, hvsrdata)
            self[sitename][&#39;batch&#39;] = True
        self.sites = list(self.batch_dict.keys())


    # METHODS
    def __to_json(self, filepath):
        &#34;&#34;&#34;Not yet implemented, but may allow import/export to json files in the future, rather than just .hvsr pickles

        Parameters
        ----------
        filepath : filepath object
            Location to save HVSRBatch object as json
        &#34;&#34;&#34;
        # open the file with the given filepath
        with open(filepath, &#39;w&#39;) as f:
            # dump the JSON string to the file
            json.dump(self, f, default=lambda o: o.__dict__, sort_keys=True, indent=4)


    def add(self, hvsr_data):
        &#34;&#34;&#34;Function to add HVSRData objects to existing HVSRBatch objects&#34;&#34;&#34;
        if isinstance(hvsr_data, (dict, HVSRData)):
            hvsr_data = [hvsr_data]

        if isinstance(hvsr_data, (list, tuple,)):
            siteNo = 0
            zfilldigs = len(str(len(hvsr_data)))

            for hvdata in hvsr_data:
                sitename = f&#34;HVSRSite{str(siteNo).zfill(zfilldigs)}&#34;

                if hasattr(hvdata, &#39;site&#39;):
                    sitename = hvdata.site
                elif hasattr(hvdata, &#39;Table_Report&#39;) and &#39;Site Name&#39; in hvdata.Table_Report.columns:
                    sitename = hvdata.Table_Report[&#39;Site Name&#39;][0]
                elif isinstance(hvdata, dict):
                    if &#39;site&#39; in hvdata.keys():
                        sitename = hvdata[&#39;site&#39;]

                self[sitename] = hvsr_data
        

    def append(self, hvsr_data):
        &#34;&#34;&#34;Alias of add()&#34;&#34;&#34;
        add(self, hvsr_data)
        

    def export(self, hvsr_export_path=True, ext=&#39;hvsr&#39;):
        &#34;&#34;&#34;Method to export HVSRData objects in HVSRBatch container to indivdual .hvsr pickle files.

        Parameters
        ----------
        hvsr_export_path : filepath, default=True
            Filepath to save file. Can be either directory (which will assign a filename based on the HVSRData attributes). By default True. If True, it will first try to save each file to the same directory as input_data, then if that does not work, to the current working directory, then to the user&#39;s home directory, by default True
        ext : str, optional
            The extension to use for the output, by default &#39;hvsr&#39;. This is still a pickle file that can be read with pickle.load(), but will have .hvsr extension.
        &#34;&#34;&#34;
        export_hvsr(hvsr_data=self, hvsr_export_path=hvsr_export_path, ext=ext)


    def keys(self):
        &#34;&#34;&#34;Method to return the &#34;keys&#34; of the HVSRBatch object. For HVSRBatch objects, these are the site names. Functions similar to dict.keys().

        Returns
        -------
        dict_keys
            A dict_keys object listing the site names of each of the HVSRData objects contained in the HVSRBatch object
        &#34;&#34;&#34;
        return self.batch_dict.keys()


    def items(self):
        &#34;&#34;&#34;Method to return both the site names and the HVSRData object as a set of dict_items tuples. Functions similar to dict.items().

        Returns
        -------
        _type_
            _description_
        &#34;&#34;&#34;
        return self.batch_dict.items()


    def copy(self, type=&#39;shallow&#39;):
        &#34;&#34;&#34;Make a copy of the HVSRBatch object. Uses python copy module.
        
        Parameters
        ----------
        type : str {&#39;shallow&#39;, &#39;deep&#39;}
            Based on input, creates either a shallow or deep copy of the HVSRBatch object. Shallow is equivalent of copy.copy(). Input of &#39;deep&#39; is equivalent of copy.deepcopy() (still experimental). Defaults to shallow.
    
        &#34;&#34;&#34;
        if type.lower()==&#39;deep&#39;:
            return HVSRBatch(copy.deepcopy(self._batch_dict), df_as_read=self._input_df)
        else:
            return HVSRBatch(copy.copy(self._batch_dict), df_as_read=self._input_df)


    #Method wrapper of sprit.plot_hvsr function
    def plot(self, **kwargs):
        &#34;&#34;&#34;Method to plot data, based on the sprit.plot_hvsr() function. 
        
        All the same kwargs and default values apply as plot_hvsr().
        For return_fig, returns it to the &#39;Plot_Report&#39; attribute of each HVSRData object

        Returns
        -------
        _type_
            _description_

        See Also
        --------
        plot_hvsr
        &#34;&#34;&#34;
        for sitename in self:
            if &#39;return_fig&#39; in kwargs.keys() and kwargs[&#39;return_fig&#39;]:
                self[sitename][&#39;Plot_Report&#39;] = plot_hvsr(self[sitename], **kwargs)
            else:
                plot_hvsr(self[sitename], **kwargs)

        return self
    
    def get_report(self, **kwargs):
        &#34;&#34;&#34;Method to get report from processed data, in print, graphical, or tabular format.

        Returns
        -------
        Variable
            May return nothing, pandas.Dataframe, or pyplot Figure, depending on input.

        See Also
        --------
        get_report
        &#34;&#34;&#34;
        if &#39;report_formats&#39; in kwargs.keys():
            if &#39;table&#39; == kwargs[&#39;report_formats&#39;]:
                for sitename in self:
                    rowList = []
                    rowList.append(get_report(self[sitename], **kwargs))
                return pd.concat(rowList, ignore_index=True)
            elif &#39;plot&#39; == kwargs[&#39;report_formats&#39;]:
                plotDict = {}
                for sitename in self:
                    if &#39;return_fig&#39; in kwargs.keys() and kwargs[&#39;return_fig&#39;]:
                        plotDict[sitename] = get_report(self[sitename], **kwargs)
                    else:
                        get_report(self[sitename], **kwargs)
                return plotDict
            
        #Only report_formats left is print, doesn&#39;t return anything, so doesn&#39;t matter if defalut or not
        for sitename in self:
            get_report(self[sitename], **kwargs)
        return

    def report(self, **kwargs):
        &#34;&#34;&#34;Wrapper of get_report()
        
        See Also
        --------
        get_report
        &#34;&#34;&#34;
        return self.get_report(**kwargs)

    def export_settings(self, site_name=None, export_settings_path=&#39;default&#39;, export_settings_type=&#39;all&#39;, include_location=False, verbose=True):
        &#34;&#34;&#34;Method to export settings from HVSRData object in HVSRBatch object. 
        
        Simply calls sprit.export_settings() from specified HVSRData object in the HVSRBatch object. 
        See sprit.export_settings() for more details.

        Parameters
        ----------
        site_name : str, default=None
            The name of the site whose settings should be exported. If None, will default to the first site, by default None.
        export_settings_path : str, optional
            Filepath to output file. If left as &#39;default&#39;, will save as the default value in the resources directory. If that is not possible, will save to home directory, by default &#39;default&#39;
        export_settings_type : str, {&#39;all&#39;, &#39;instrument&#39;, &#39;processing&#39;}, optional
            They type of settings to save, by default &#39;all&#39;
        include_location : bool, optional
            Whether to include the location information in the instrument settings, if that settings type is selected, by default False
        verbose : bool, optional
            Whether to print output (filepath and settings) to terminal, by default True
        
        
        See Also
        --------
        export_settings
        &#34;&#34;&#34;
        #If no site name selected, use first site
        if site_name is None:
            site_name = self.sites[0]
            
        export_settings(hvsr_data=self[site_name], 
                        export_settings_path=export_settings_path, export_settings_type=export_settings_type, include_location=include_location, verbose=verbose)

    def __iter__(self):
        return iter(self._batch_dict.keys())

    def __setitem__(self, key, value):
        setattr(self, key, value)

    def __getitem__(self, key):
        return getattr(self, key)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="sprit.sprit_hvsr.HVSRBatch.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, hvsr_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to add HVSRData objects to existing HVSRBatch objects</p></div>
</dd>
<dt id="sprit.sprit_hvsr.HVSRBatch.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, hvsr_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias of add()</p></div>
</dd>
<dt id="sprit.sprit_hvsr.HVSRBatch.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, type='shallow')</span>
</code></dt>
<dd>
<div class="desc"><p>Make a copy of the HVSRBatch object. Uses python copy module.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code>str {'shallow', 'deep'}</code></dt>
<dd>Based on input, creates either a shallow or deep copy of the HVSRBatch object. Shallow is equivalent of copy.copy(). Input of 'deep' is equivalent of copy.deepcopy() (still experimental). Defaults to shallow.</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.HVSRBatch.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, hvsr_export_path=True, ext='hvsr')</span>
</code></dt>
<dd>
<div class="desc"><p>Method to export HVSRData objects in HVSRBatch container to indivdual .hvsr pickle files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_export_path</code></strong> :&ensp;<code>filepath</code>, default=<code>True</code></dt>
<dd>Filepath to save file. Can be either directory (which will assign a filename based on the HVSRData attributes). By default True. If True, it will first try to save each file to the same directory as input_data, then if that does not work, to the current working directory, then to the user's home directory, by default True</dd>
<dt><strong><code>ext</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The extension to use for the output, by default 'hvsr'. This is still a pickle file that can be read with pickle.load(), but will have .hvsr extension.</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.HVSRBatch.export_settings"><code class="name flex">
<span>def <span class="ident">export_settings</span></span>(<span>self, site_name=None, export_settings_path='default', export_settings_type='all', include_location=False, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to export settings from HVSRData object in HVSRBatch object. </p>
<p>Simply calls sprit.export_settings() from specified HVSRData object in the HVSRBatch object.
See sprit.export_settings() for more details.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>site_name</code></strong> :&ensp;<code>str</code>, default=<code>None</code></dt>
<dd>The name of the site whose settings should be exported. If None, will default to the first site, by default None.</dd>
<dt><strong><code>export_settings_path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Filepath to output file. If left as 'default', will save as the default value in the resources directory. If that is not possible, will save to home directory, by default 'default'</dd>
<dt><strong><code>export_settings_type</code></strong> :&ensp;<code>str, {'all', 'instrument', 'processing'}</code>, optional</dt>
<dd>They type of settings to save, by default 'all'</dd>
<dt><strong><code>include_location</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to include the location information in the instrument settings, if that settings type is selected, by default False</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print output (filepath and settings) to terminal, by default True</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="sprit.sprit_hvsr.export_settings" href="#sprit.sprit_hvsr.export_settings">export_settings()</a></code></p></div>
</dd>
<dt id="sprit.sprit_hvsr.HVSRBatch.get_report"><code class="name flex">
<span>def <span class="ident">get_report</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to get report from processed data, in print, graphical, or tabular format.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Variable</code></dt>
<dd>May return nothing, pandas.Dataframe, or pyplot Figure, depending on input.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="sprit.sprit_hvsr.get_report" href="#sprit.sprit_hvsr.get_report">get_report()</a></code></p></div>
</dd>
<dt id="sprit.sprit_hvsr.HVSRBatch.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to return both the site names and the HVSRData object as a set of dict_items tuples. Functions similar to dict.items().</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>_type_</code></dt>
<dd><em>description</em></dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.HVSRBatch.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to return the "keys" of the HVSRBatch object. For HVSRBatch objects, these are the site names. Functions similar to dict.keys().</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict_keys</code></dt>
<dd>A dict_keys object listing the site names of each of the HVSRData objects contained in the HVSRBatch object</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.HVSRBatch.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to plot data, based on the sprit.plot_hvsr() function. </p>
<p>All the same kwargs and default values apply as plot_hvsr().
For return_fig, returns it to the 'Plot_Report' attribute of each HVSRData object</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>_type_</code></dt>
<dd><em>description</em></dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="sprit.sprit_hvsr.plot_hvsr" href="#sprit.sprit_hvsr.plot_hvsr">plot_hvsr()</a></code></p></div>
</dd>
<dt id="sprit.sprit_hvsr.HVSRBatch.report"><code class="name flex">
<span>def <span class="ident">report</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper of get_report()</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="sprit.sprit_hvsr.get_report" href="#sprit.sprit_hvsr.get_report">get_report()</a></code></p></div>
</dd>
</dl>
</dd>
<dt id="sprit.sprit_hvsr.HVSRData"><code class="flex name class">
<span>class <span class="ident">HVSRData</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>HVSRData is the basic data class of the sprit package.
It contains all the processed data, input parameters, and reports.</p>
<p>These attributes and objects can be accessed using square brackets or the dot accessor. For example, to access the site name, HVSRData['site'] and HVSRData.site will both return the site name.</p>
<p>Some of the methods that work on the HVSRData object (e.g., .plot() and .get_report()) are essentially wrappers for some of the main sprit package functions (sprit.plot_hvsr() and sprit.get_report(), respectively)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HVSRData:
    &#34;&#34;&#34;HVSRData is the basic data class of the sprit package. 
    It contains all the processed data, input parameters, and reports.
    
    These attributes and objects can be accessed using square brackets or the dot accessor. For example, to access the site name, HVSRData[&#39;site&#39;] and HVSRData.site will both return the site name.
    
    Some of the methods that work on the HVSRData object (e.g., .plot() and .get_report()) are essentially wrappers for some of the main sprit package functions (sprit.plot_hvsr() and sprit.get_report(), respectively)
    &#34;&#34;&#34;
    @check_instance    
    def __init__(self, params):
        self.params = params
        self.batch = False
        #self.tsteps_used = []

        for key, value in params.items():
            setattr(self, key, value)
            if key == &#39;input_params&#39;:
                for k, v in params[key].items():
                    setattr(self, k, v)

        self.processing_status = {&#39;input_params_status&#39;: None,
                                  &#39;fetch_data_status&#39;: None,
                                  &#39;calculate_azimuths_status&#39;: None,
                                  &#39;remove_noise_status&#39;: None,
                                  &#39;generate_psds_status&#39;: None,
                                  &#39;process_hvsr_status&#39;: None,
                                  &#39;remove_outlier_curves_status&#39;: None,
                                  &#39;overall_status&#39;: False}


    def __setitem__(self, key, value):
        setattr(self, key, value)

    def __getitem__(self, key):
        return getattr(self, key)

    def __str__(self):
        attrsToUse = [&#39;project&#39;, &#39;site&#39;, 
            &#39;instrument&#39;, &#39;network&#39;, &#39;station&#39;, &#39;location&#39;, &#39;channels&#39;,
            &#39;acq_date&#39;, &#39;starttime&#39;, &#39;endtime&#39;,
            &#39;xcoord&#39;, &#39;ycoord&#39;, &#39;input_crs&#39;, &#39;elevation&#39;, &#39;elev_unit&#39;,
            ]

        if not all([atu in self.keys() for atu in attrsToUse]):
            return &#39;String representation cannot be generated. Object not instatianted correctly using sprit.input_params()&#39;

        def __get_ip_default(parameter):
            if parameter in inspect.signature(input_params).parameters:
                return inspect.signature(input_params).parameters[parameter].default
            elif parameter in params:
                return params[parameter]
            else:
                return parameter

        # Get title lines formatted
        if self.project == __get_ip_default(&#39;project&#39;):
            projStr = &#39;No project specified&#39;
        else:
            projStr = self.project

        hvsrIDStr = &#39;&#39;
        if hasattr(self, &#39;hvsr_id&#39;):
            hvsrIDStr = self.hvsr_id
        elif &#39;hvsr_id&#39; in params:
            hvsrIDStr = params[&#39;hvsr_id&#39;]

        titleInfoStr =f&#34;\nSpRIT HVSR DATA INFORMATION\n&#34;
        titleLen = len(titleInfoStr)
        bigLineBreak = &#34;—&#34;*titleLen+ &#39;\n&#39;
        titleInfoStr += bigLineBreak
        titleInfoStr += f&#34;Site Name: {self.site}\nProject: ({projStr})\n&#34;
        titleInfoStr = f&#34;{titleInfoStr}HVSRID (autogenerated): {hvsrIDStr}\n&#34;
        titleInfoStr += bigLineBreak
        
        # Acquisition instrument information
        instInfoStr = &#34;\n\nINSTRUMENT INFO\n&#34;
        instInfoStr += &#39;-&#39;*(len(instInfoStr)-3) + &#39;\n&#39;

        instStr = f&#34;Instrument in use: {self.instrument}&#34;
        if self.instrument == __get_ip_default(&#39;instrument&#39;):
            instStr = &#39;No instrument type specified&#39;

        netStr = self.network
        staStr = self.station
        locStr = self.location
        chaStr = self.channels
        if chaStr == __get_ip_default(&#39;channels&#39;):
            chaStr = f&#39;No channels specified (using {chaStr})&#39;

        acqInstStr = instInfoStr
        acqInstStr += f&#34;{instStr}&#34;
        acqInstStr += f&#34;\n\tInstrument ID: {netStr}.{staStr}.{locStr}&#34;
        acqInstStr += f&#34;\n\t\tChannels: {chaStr}&#34;

        # Acquisition site information
        xcoordINStr = self.xcoord_input
        xcoordStr = self.xcoord
        lonStr = self.longitude
        ycoordINstr = self.ycoord_input
        ycoordStr = self.ycoord
        latStr = self.latitude
        inCRSStr = self.input_crs
        outCRSStr = self.output_crs

        inputLocStr = f&#34;{xcoordINStr}, {ycoordINstr} (as input in {inCRSStr})\n&#34;
        
        transLocStr = &#39;&#39;
        if inCRSStr != outCRSStr:
            transLocStr = f&#34;{xcoordStr}, {ycoordstr} (transformed to output_crs: {outCRSStr})\n&#34;

        wgs84Str = f&#34;{lonStr:.5f}°, {latStr:.5f}° | Lon/Lat in WGS84 (EPSG:4326)&#34;

        siteLocInfoStr = &#34;\n\nSITE INFO\n&#34;
        siteLocInfoStr += &#39;-&#39;*(len(siteLocInfoStr)-3) + &#39;\n&#39;
        siteLocInfoStr += inputLocStr + transLocStr + wgs84Str

        # Acquistion time information
        acqTimeStr = &#34;\n\nACQUISITION TIME\n&#34;
        acqTimeStr += &#39;-&#39;*(len(acqTimeStr)-3) + &#39;\n&#39;

        aDateStr = self.acq_date
        sTimeStr = self.starttime
        eTimeStr = self.endtime
        if hasattr(self, &#39;stream&#39;):
            dataST = self.stream
            utcSTime = dataST[0].stats.starttime
            utcETime = dataST[0].stats.endtime
        else:
            utcSTime = self.starttime
            utcETime = self.endtime
        
        minDur = int(str((utcETime - utcSTime)//60).split(&#39;.&#39;)[0])
        secDur = float(round((((utcETime - utcSTime) / 60) - int(minDur)) * 60, 3))
        if secDur &gt;= 60:
            minDur += int(secDur//60)
            secDur = secDur - (secDur//60)*60

        acqDurStr = f&#39;Record duration: {minDur}:{secDur:06.3f} ({utcETime-utcSTime} seconds)&#39;
        if aDateStr == __get_ip_default(&#39;acq_date&#39;) and sTimeStr == __get_ip_default(&#39;starttime&#39;):
            acqTimeStr += &#39;No acquisition time specified.\n&#39;
        else:
            acqTimeStr += f&#34;Acquisition Date: {aDateStr}\n&#34;
            acqTimeStr += f&#34;\tStarted at: {sTimeStr}\n&#34;
            acqTimeStr += f&#34;\tEnded at  : {eTimeStr}\n&#34;
        acqTimeStr += acqDurStr


        # PEAK INFORMATION (IF CALCULATED)
        peakInfoStr = &#39;&#39;
        azimuth=&#39;HV&#39;
        if &#39;BestPeak&#39; in self.keys():
            curvTestsPassed = (self[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;WinLen&#39;] +
                                self[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;SigCycles&#39;]+
                                self[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;LowCurveStD&#39;])
            curvePass = curvTestsPassed &gt; 2
            
            #Peak Pass?
            peakTestsPassed = ( self[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;ProminenceLow&#39;] +
                        self[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;ProminenceHi&#39;]+
                        self[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;AmpClarity&#39;]+
                        self[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;FreqStability&#39;]+
                        self[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;LowStDev_Freq&#39;]+
                        self[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;LowStDev_Amp&#39;])
            peakPass = peakTestsPassed &gt;= 5

            peakInfoStr = &#34;\nCALCULATED F₀\n&#34;
            peakInfoStr += &#34;-&#34;*(len(peakInfoStr) - 3) + &#39;\n&#39;
            peakInfoStr += &#39;{0:.3f} Hz ± {1:.4f} Hz&#39;.format(self[&#39;BestPeak&#39;][azimuth][&#39;f0&#39;], float(self[&#34;BestPeak&#34;][azimuth][&#39;Sf&#39;]))
            if curvePass and peakPass:
                peakInfoStr += &#39;\n\t  {} Peak at {} Hz passed SESAME quality tests! :D&#39;.format(sprit_utils._check_mark(), round(self[&#39;BestPeak&#39;][azimuth][&#39;f0&#39;],3))
            else:
                peakInfoStr += &#39;\n\t  {} Peak at {} Hz did NOT pass SESAME quality tests :(&#39;.format(sprit_utils._x_mark(), round(self[&#39;BestPeak&#39;][azimuth][&#39;f0&#39;],3))
        else:
            peakInfoStr = &#39;F₀ not Calculated&#39;

        printList = [
                    titleInfoStr,
                    peakInfoStr,
                    acqInstStr,
                    siteLocInfoStr,
                    acqTimeStr
                    ]

        strRep = &#39;&#39;
        for ps in printList:
            strRep += ps
        
        return strRep

        #try:
            # Check if running in IPython environment
        #    from IPython.display import display, HTML
        #    return f&#34;&lt;b&gt;Person Information:&lt;/b&gt;&lt;br&gt;Name: {self.name}&lt;br&gt;Age: {self.age}&#34;
        #except ImportError:
            # Fallback for terminal/console
        #    return f&#34;Person Information:\nName: {self.name}\nAge: {self.age}&#34;

    def __repr__(self):
        return self.__str__()

    # METHODS (many reflect dictionary methods)    
    def to_json(self, json_filepath, **kwargs):
        &#34;&#34;&#34;Not yet supported, will export HVSRData object to json&#34;&#34;&#34;

        class_keys_to_convert = (datetime.date, obspy.UTCDateTime, 
                             datetime.time, CRS, obspy.Inventory)

        def iterative_json_parser(input_attrib, level=0):
            outValue = input_attrib
            
            if isinstance(input_attrib, dict):  # simplified condition for demo
            # if isinstance(input_attrib, (dict, sprit.HVSRData)):  # use this line instead
                outValue = {}
                level += 1
                for i, (key, value) in enumerate(input_attrib.items()):
                    outKey = key
                    print(level, &#34;&#34;.join([&#39;  &#39;]*level), outKey)
                    if not isinstance(outKey, (str, int, float, bool, type(None))):
                        outKey = str(outKey)
                    
                    # Recursively process the value
                    processed_value = iterative_json_parser(value, level)
                    
                    # Apply string conversion if needed
                    if isinstance(processed_value, class_keys_to_convert):
                        processed_value = str(processed_value)
                    
                    outValue[outKey] = processed_value
                
                return outValue
            
            elif isinstance(input_attrib, list):
                outValue = []
                for item in input_attrib:
                    if isinstance(item, np.ndarray):
                        outValue.append(item.tolist())
                    else:
                        # Recursively process list items
                        outValue.append(iterative_json_parser(item, level))
                return outValue
            
            elif isinstance(input_attrib, np.ndarray):
                outValue = input_attrib.tolist()
                return outValue
            
            elif isinstance(input_attrib, pd.DataFrame):
                # Convert DataFrame to dict, but then recursively process it
                dict_value = input_attrib.to_dict()
                return iterative_json_parser(dict_value, level)
            
            elif isinstance(input_attrib, class_keys_to_convert):
                return str(input_attrib)
            
            else:
                return input_attrib

        sKeys = True
        if &#39;sort_keys&#39; in kwargs:
            sKeys = kwargs[&#39;sort_keys&#39;]
            del kwargs[&#39;sort_keys&#39;]

        indent = 4
        if &#39;indent&#39; in kwarg:
            indent = kwargs[&#39;indent&#39;]
            del kwargs[&#39;indent&#39;]

        with open(json_filepath, &#39;w&#39;) as f:
            # dump the JSON string to the file
            json.dump(self, fp=f, default=iterative_json_parser, 
                      sort_keys=True, indent=indent, **kwargs)

    def export(self, hvsr_export_path=None, ext=&#39;hvsr&#39;):
        &#34;&#34;&#34;Method to export HVSRData objects to .hvsr pickle files.

        Parameters
        ----------
        hvsr_export_path : filepath, default=True
            Filepath to save file. Can be either directory (which will assign a filename based on the HVSRData attributes). 
            By default True. 
            If True, it will first try to save each file to the same directory as input_data, then if that does not work, to the current working directory, then to the user&#39;s home directory, by default True
        ext : str, optional
            The extension to use for the output, by default &#39;hvsr&#39;. This is still a pickle file that can be read with pickle.load(), but will have .hvsr extension.
        
        See Also
        --------
        export_hvsr
        
        &#34;&#34;&#34;
        export_hvsr(hvsr_data=self, hvsr_export_path=hvsr_export_path, ext=ext)

    def copy(self, copy_type=&#39;shallow&#39;):
        &#34;&#34;&#34;Make a copy of the HVSRData object. Uses python copy module.
        
        Parameters
        ----------
        copy_type : str {&#39;shallow&#39;, &#39;deep&#39;}
            Based on input, creates either a shallow or deep copy of the HVSRData object. 
            Shallow is equivalent of copy.copy(). 
            Input of copy_type=&#39;deep&#39; is equivalent of copy.deepcopy() (still experimental). 
            Defaults to shallow.
    
        &#34;&#34;&#34;
        if copy_type.lower() == &#39;deep&#39;:
            return HVSRData(copy.deepcopy(self.params))
        else:
            return HVSRData(copy.copy(self.params))

    def export_settings(self, export_settings_path=&#39;default&#39;, export_settings_type=&#39;all&#39;, include_location=False, verbose=True):
        &#34;&#34;&#34;Method to export settings from HVSRData object. Simply calls sprit.export_settings() from the HVSRData object. See sprit.export_settings() for more details.

        Parameters
        ----------
        export_settings_path : str, optional
            Filepath to output file. If left as &#39;default&#39;, will save as the default value in the resources directory. If that is not possible, will save to home directory, by default &#39;default&#39;
        export_settings_type : str, {&#39;all&#39;, &#39;instrument&#39;, &#39;processing&#39;}, optional
            They type of settings to save, by default &#39;all&#39;
        include_location : bool, optional
            Whether to include the location information in the instrument settings, if that settings type is selected, by default False
        verbose : bool, optional
            Whether to print output (filepath and settings) to terminal, by default True
        &#34;&#34;&#34;
        export_settings(hvsr_data=self, 
                        export_settings_path=export_settings_path, export_settings_type=export_settings_type, include_location=include_location, verbose=verbose)

    def get_report(self, **kwargs):
        &#34;&#34;&#34;Method to get report from processed data, in print, graphical, or tabular format.

        Returns
        -------
        Variable
            May return nothing, pandas.Dataframe, or pyplot Figure, depending on input.

        See Also
        --------
        get_report
        &#34;&#34;&#34;
        report_return = get_report(hvsr_results=self, **kwargs)
        return report_return

    def items(self):
        &#34;&#34;&#34;Method to return the &#34;items&#34; of the HVSRData object. For HVSRData objects, this is a dict_items object with the keys and values in tuples. Functions similar to dict.items().

        Returns
        -------
        dict_items
            A dict_items object of the HVSRData objects attributes, parameters, etc.
        &#34;&#34;&#34;                
        return self.params.items()

    def keys(self):
        &#34;&#34;&#34;Method to return the &#34;keys&#34; of the HVSRData object. For HVSRData objects, these are the attributes and parameters of the object. Functions similar to dict.keys().

        Returns
        -------
        dict_keys
            A dict_keys object of the HVSRData objects attributes, parameters, etc.
        &#34;&#34;&#34;        
        keyList = []
        for k in dir(self):
            if not k.startswith(&#39;_&#39;):
                keyList.append(k)
        return keyList   
        
    def plot(self, **kwargs):
        &#34;&#34;&#34;Method to plot data, wrapper of sprit.plot_hvsr()

        Returns
        -------
        matplotlib.Figure, matplotlib.Axis (if return_fig=True)

        See Also
        --------
        plot_hvsr
        plot_azimuth
        &#34;&#34;&#34;
        if &#39;close_figs&#39; not in kwargs.keys():
            kwargs[&#39;close_figs&#39;]=True
        plot_return = plot_hvsr(self, **kwargs)
        plt.show()
        return plot_return

    def report(self, **kwargs):
        &#34;&#34;&#34;Wrapper of get_report()
        
        See Also
        --------
        get_report
        &#34;&#34;&#34;
        report_return = get_report(hvsr_results=self, **kwargs)
        return report_return
    
    def select(self, **kwargs):
        &#34;&#34;&#34;Wrapper for obspy select method on &#39;stream&#39; attribute of HVSRData object&#34;&#34;&#34;

        if hasattr(self, &#39;stream&#39;):
            stream = self[&#39;stream&#39;].select(**kwargs)
            return stream

        else:
            warnings.Warn(&#34;HVSRData.select() method applied, but &#39;stream&#39; attribute (obspy.Stream object) not found&#34;)

    # ATTRIBUTES
    @property
    def params(self):
        &#34;&#34;&#34;Dictionary containing the parameters used to process the data

        Returns
        -------
        dict
            Dictionary containing the process parameters
        &#34;&#34;&#34;
        return self._params

    @params.setter
    def params(self, value):
        if not (isinstance(value, dict)):
            raise ValueError(&#34;params must be a dict type, currently passing {} type.&#34;.format(type(value)))
        self._params = value
    
    # batch
    @property
    def batch(self):
        &#34;&#34;&#34;Whether this HVSRData object is part of an HVSRBatch object. This is used throughout the code to help direct the object into the proper processing pipeline.

        Returns
        -------
        bool
            True if HVSRData object is part of HVSRBatch object, otherwise, False
        &#34;&#34;&#34;
        return self._batch

    @batch.setter
    def batch(self, value):
        if value == 0:
            value = False
        elif value == 1:
            value = True
        else:
            value = None
        if not isinstance(value, bool):
            raise ValueError(&#34;batch must be boolean type&#34;)
        self._batch = value

    #PPSD object from obspy (static)
    @property
    def ppsds_obspy(self):
        &#34;&#34;&#34;The original ppsd information from the obspy.signal.spectral_estimation.PPSD(), so as to keep original if copy is manipulated/changed.&#34;&#34;&#34;        
        return self._ppsds_obspy

    @ppsds_obspy.setter
    def ppsds_obspy(self, value):
        &#34;&#34;&#34;Checks whether the ppsd_obspy is of the proper type before saving as attribute&#34;&#34;&#34;
        if not isinstance(value, obspy.signal.spectral_estimation.PPSD):
            if not isinstance(value, dict):
                raise ValueError(&#34;ppsds_obspy must be obspy.PPSD or dict with osbpy.PPSDs&#34;)
            else:
                for key in value.keys():
                    if not isinstance(value[key], obspy.signal.spectral_estimation.PPSD):
                        raise ValueError(&#34;ppsds_obspy must be obspy.PPSD or dict with osbpy.PPSDs&#34;)
        self._ppsds_obspy=value
                        
    #PPSD dict, copied from obspy ppsds (dynamic)
    @property
    def ppsds(self):
        &#34;&#34;&#34;Dictionary copy of the class object obspy.signal.spectral_estimation.PPSD(). The dictionary copy allows manipulation of the data in PPSD, whereas that data cannot be easily manipulated in the original Obspy object.

        Returns
        -------
        dict
            Dictionary copy of the PPSD information from generate_psds()
        &#34;&#34;&#34;
        return self._ppsds

    @ppsds.setter
    def ppsds(self, value):
        if not isinstance(value, dict):
            raise ValueError(&#34;ppsds dict with infomration from osbpy.PPSD (created by sprit.generate_psds())&#34;)                  
        self._ppsds=value</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="sprit.sprit_hvsr.HVSRData.batch"><code class="name">prop <span class="ident">batch</span></code></dt>
<dd>
<div class="desc"><p>Whether this HVSRData object is part of an HVSRBatch object. This is used throughout the code to help direct the object into the proper processing pipeline.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if HVSRData object is part of HVSRBatch object, otherwise, False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def batch(self):
    &#34;&#34;&#34;Whether this HVSRData object is part of an HVSRBatch object. This is used throughout the code to help direct the object into the proper processing pipeline.

    Returns
    -------
    bool
        True if HVSRData object is part of HVSRBatch object, otherwise, False
    &#34;&#34;&#34;
    return self._batch</code></pre>
</details>
</dd>
<dt id="sprit.sprit_hvsr.HVSRData.params"><code class="name">prop <span class="ident">params</span></code></dt>
<dd>
<div class="desc"><p>Dictionary containing the parameters used to process the data</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary containing the process parameters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def params(self):
    &#34;&#34;&#34;Dictionary containing the parameters used to process the data

    Returns
    -------
    dict
        Dictionary containing the process parameters
    &#34;&#34;&#34;
    return self._params</code></pre>
</details>
</dd>
<dt id="sprit.sprit_hvsr.HVSRData.ppsds"><code class="name">prop <span class="ident">ppsds</span></code></dt>
<dd>
<div class="desc"><p>Dictionary copy of the class object obspy.signal.spectral_estimation.PPSD(). The dictionary copy allows manipulation of the data in PPSD, whereas that data cannot be easily manipulated in the original Obspy object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary copy of the PPSD information from generate_psds()</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ppsds(self):
    &#34;&#34;&#34;Dictionary copy of the class object obspy.signal.spectral_estimation.PPSD(). The dictionary copy allows manipulation of the data in PPSD, whereas that data cannot be easily manipulated in the original Obspy object.

    Returns
    -------
    dict
        Dictionary copy of the PPSD information from generate_psds()
    &#34;&#34;&#34;
    return self._ppsds</code></pre>
</details>
</dd>
<dt id="sprit.sprit_hvsr.HVSRData.ppsds_obspy"><code class="name">prop <span class="ident">ppsds_obspy</span></code></dt>
<dd>
<div class="desc"><p>The original ppsd information from the obspy.signal.spectral_estimation.PPSD(), so as to keep original if copy is manipulated/changed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ppsds_obspy(self):
    &#34;&#34;&#34;The original ppsd information from the obspy.signal.spectral_estimation.PPSD(), so as to keep original if copy is manipulated/changed.&#34;&#34;&#34;        
    return self._ppsds_obspy</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sprit.sprit_hvsr.HVSRData.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, copy_type='shallow')</span>
</code></dt>
<dd>
<div class="desc"><p>Make a copy of the HVSRData object. Uses python copy module.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>copy_type</code></strong> :&ensp;<code>str {'shallow', 'deep'}</code></dt>
<dd>Based on input, creates either a shallow or deep copy of the HVSRData object.
Shallow is equivalent of copy.copy().
Input of copy_type='deep' is equivalent of copy.deepcopy() (still experimental).
Defaults to shallow.</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.HVSRData.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, hvsr_export_path=None, ext='hvsr')</span>
</code></dt>
<dd>
<div class="desc"><p>Method to export HVSRData objects to .hvsr pickle files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_export_path</code></strong> :&ensp;<code>filepath</code>, default=<code>True</code></dt>
<dd>Filepath to save file. Can be either directory (which will assign a filename based on the HVSRData attributes).
By default True.
If True, it will first try to save each file to the same directory as input_data, then if that does not work, to the current working directory, then to the user's home directory, by default True</dd>
<dt><strong><code>ext</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The extension to use for the output, by default 'hvsr'. This is still a pickle file that can be read with pickle.load(), but will have .hvsr extension.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="sprit.sprit_hvsr.export_hvsr" href="#sprit.sprit_hvsr.export_hvsr">export_hvsr()</a></code></p></div>
</dd>
<dt id="sprit.sprit_hvsr.HVSRData.export_settings"><code class="name flex">
<span>def <span class="ident">export_settings</span></span>(<span>self, export_settings_path='default', export_settings_type='all', include_location=False, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to export settings from HVSRData object. Simply calls sprit.export_settings() from the HVSRData object. See sprit.export_settings() for more details.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>export_settings_path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Filepath to output file. If left as 'default', will save as the default value in the resources directory. If that is not possible, will save to home directory, by default 'default'</dd>
<dt><strong><code>export_settings_type</code></strong> :&ensp;<code>str, {'all', 'instrument', 'processing'}</code>, optional</dt>
<dd>They type of settings to save, by default 'all'</dd>
<dt><strong><code>include_location</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to include the location information in the instrument settings, if that settings type is selected, by default False</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print output (filepath and settings) to terminal, by default True</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.HVSRData.get_report"><code class="name flex">
<span>def <span class="ident">get_report</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to get report from processed data, in print, graphical, or tabular format.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Variable</code></dt>
<dd>May return nothing, pandas.Dataframe, or pyplot Figure, depending on input.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="sprit.sprit_hvsr.get_report" href="#sprit.sprit_hvsr.get_report">get_report()</a></code></p></div>
</dd>
<dt id="sprit.sprit_hvsr.HVSRData.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to return the "items" of the HVSRData object. For HVSRData objects, this is a dict_items object with the keys and values in tuples. Functions similar to dict.items().</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict_items</code></dt>
<dd>A dict_items object of the HVSRData objects attributes, parameters, etc.</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.HVSRData.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to return the "keys" of the HVSRData object. For HVSRData objects, these are the attributes and parameters of the object. Functions similar to dict.keys().</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict_keys</code></dt>
<dd>A dict_keys object of the HVSRData objects attributes, parameters, etc.</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_hvsr.HVSRData.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to plot data, wrapper of sprit.plot_hvsr()</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>matplotlib.Figure, matplotlib.Axis (if return_fig=True)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="sprit.sprit_hvsr.plot_hvsr" href="#sprit.sprit_hvsr.plot_hvsr">plot_hvsr()</a></code>
<code><a title="sprit.sprit_hvsr.plot_azimuth" href="#sprit.sprit_hvsr.plot_azimuth">plot_azimuth()</a></code></p></div>
</dd>
<dt id="sprit.sprit_hvsr.HVSRData.report"><code class="name flex">
<span>def <span class="ident">report</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper of get_report()</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="sprit.sprit_hvsr.get_report" href="#sprit.sprit_hvsr.get_report">get_report()</a></code></p></div>
</dd>
<dt id="sprit.sprit_hvsr.HVSRData.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper for obspy select method on 'stream' attribute of HVSRData object</p></div>
</dd>
<dt id="sprit.sprit_hvsr.HVSRData.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self, json_filepath, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Not yet supported, will export HVSRData object to json</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sprit" href="index.html">sprit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sprit.sprit_hvsr.batch_data_read" href="#sprit.sprit_hvsr.batch_data_read">batch_data_read</a></code></li>
<li><code><a title="sprit.sprit_hvsr.calculate_azimuth" href="#sprit.sprit_hvsr.calculate_azimuth">calculate_azimuth</a></code></li>
<li><code><a title="sprit.sprit_hvsr.check_instance" href="#sprit.sprit_hvsr.check_instance">check_instance</a></code></li>
<li><code><a title="sprit.sprit_hvsr.check_peaks" href="#sprit.sprit_hvsr.check_peaks">check_peaks</a></code></li>
<li><code><a title="sprit.sprit_hvsr.export_data" href="#sprit.sprit_hvsr.export_data">export_data</a></code></li>
<li><code><a title="sprit.sprit_hvsr.export_hvsr" href="#sprit.sprit_hvsr.export_hvsr">export_hvsr</a></code></li>
<li><code><a title="sprit.sprit_hvsr.export_report" href="#sprit.sprit_hvsr.export_report">export_report</a></code></li>
<li><code><a title="sprit.sprit_hvsr.export_settings" href="#sprit.sprit_hvsr.export_settings">export_settings</a></code></li>
<li><code><a title="sprit.sprit_hvsr.fetch_data" href="#sprit.sprit_hvsr.fetch_data">fetch_data</a></code></li>
<li><code><a title="sprit.sprit_hvsr.generate_ppsds" href="#sprit.sprit_hvsr.generate_ppsds">generate_ppsds</a></code></li>
<li><code><a title="sprit.sprit_hvsr.generate_psds" href="#sprit.sprit_hvsr.generate_psds">generate_psds</a></code></li>
<li><code><a title="sprit.sprit_hvsr.get_metadata" href="#sprit.sprit_hvsr.get_metadata">get_metadata</a></code></li>
<li><code><a title="sprit.sprit_hvsr.get_report" href="#sprit.sprit_hvsr.get_report">get_report</a></code></li>
<li><code><a title="sprit.sprit_hvsr.gui" href="#sprit.sprit_hvsr.gui">gui</a></code></li>
<li><code><a title="sprit.sprit_hvsr.import_data" href="#sprit.sprit_hvsr.import_data">import_data</a></code></li>
<li><code><a title="sprit.sprit_hvsr.import_settings" href="#sprit.sprit_hvsr.import_settings">import_settings</a></code></li>
<li><code><a title="sprit.sprit_hvsr.input_params" href="#sprit.sprit_hvsr.input_params">input_params</a></code></li>
<li><code><a title="sprit.sprit_hvsr.plot_azimuth" href="#sprit.sprit_hvsr.plot_azimuth">plot_azimuth</a></code></li>
<li><code><a title="sprit.sprit_hvsr.plot_hvsr" href="#sprit.sprit_hvsr.plot_hvsr">plot_hvsr</a></code></li>
<li><code><a title="sprit.sprit_hvsr.process_hvsr" href="#sprit.sprit_hvsr.process_hvsr">process_hvsr</a></code></li>
<li><code><a title="sprit.sprit_hvsr.read_tromino_files" href="#sprit.sprit_hvsr.read_tromino_files">read_tromino_files</a></code></li>
<li><code><a title="sprit.sprit_hvsr.remove_noise" href="#sprit.sprit_hvsr.remove_noise">remove_noise</a></code></li>
<li><code><a title="sprit.sprit_hvsr.remove_outlier_curves" href="#sprit.sprit_hvsr.remove_outlier_curves">remove_outlier_curves</a></code></li>
<li><code><a title="sprit.sprit_hvsr.run" href="#sprit.sprit_hvsr.run">run</a></code></li>
<li><code><a title="sprit.sprit_hvsr.test_function" href="#sprit.sprit_hvsr.test_function">test_function</a></code></li>
<li><code><a title="sprit.sprit_hvsr.update_elevation" href="#sprit.sprit_hvsr.update_elevation">update_elevation</a></code></li>
<li><code><a title="sprit.sprit_hvsr.update_resp_file" href="#sprit.sprit_hvsr.update_resp_file">update_resp_file</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sprit.sprit_hvsr.HVSRBatch" href="#sprit.sprit_hvsr.HVSRBatch">HVSRBatch</a></code></h4>
<ul class="two-column">
<li><code><a title="sprit.sprit_hvsr.HVSRBatch.add" href="#sprit.sprit_hvsr.HVSRBatch.add">add</a></code></li>
<li><code><a title="sprit.sprit_hvsr.HVSRBatch.append" href="#sprit.sprit_hvsr.HVSRBatch.append">append</a></code></li>
<li><code><a title="sprit.sprit_hvsr.HVSRBatch.copy" href="#sprit.sprit_hvsr.HVSRBatch.copy">copy</a></code></li>
<li><code><a title="sprit.sprit_hvsr.HVSRBatch.export" href="#sprit.sprit_hvsr.HVSRBatch.export">export</a></code></li>
<li><code><a title="sprit.sprit_hvsr.HVSRBatch.export_settings" href="#sprit.sprit_hvsr.HVSRBatch.export_settings">export_settings</a></code></li>
<li><code><a title="sprit.sprit_hvsr.HVSRBatch.get_report" href="#sprit.sprit_hvsr.HVSRBatch.get_report">get_report</a></code></li>
<li><code><a title="sprit.sprit_hvsr.HVSRBatch.items" href="#sprit.sprit_hvsr.HVSRBatch.items">items</a></code></li>
<li><code><a title="sprit.sprit_hvsr.HVSRBatch.keys" href="#sprit.sprit_hvsr.HVSRBatch.keys">keys</a></code></li>
<li><code><a title="sprit.sprit_hvsr.HVSRBatch.plot" href="#sprit.sprit_hvsr.HVSRBatch.plot">plot</a></code></li>
<li><code><a title="sprit.sprit_hvsr.HVSRBatch.report" href="#sprit.sprit_hvsr.HVSRBatch.report">report</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sprit.sprit_hvsr.HVSRData" href="#sprit.sprit_hvsr.HVSRData">HVSRData</a></code></h4>
<ul class="two-column">
<li><code><a title="sprit.sprit_hvsr.HVSRData.batch" href="#sprit.sprit_hvsr.HVSRData.batch">batch</a></code></li>
<li><code><a title="sprit.sprit_hvsr.HVSRData.copy" href="#sprit.sprit_hvsr.HVSRData.copy">copy</a></code></li>
<li><code><a title="sprit.sprit_hvsr.HVSRData.export" href="#sprit.sprit_hvsr.HVSRData.export">export</a></code></li>
<li><code><a title="sprit.sprit_hvsr.HVSRData.export_settings" href="#sprit.sprit_hvsr.HVSRData.export_settings">export_settings</a></code></li>
<li><code><a title="sprit.sprit_hvsr.HVSRData.get_report" href="#sprit.sprit_hvsr.HVSRData.get_report">get_report</a></code></li>
<li><code><a title="sprit.sprit_hvsr.HVSRData.items" href="#sprit.sprit_hvsr.HVSRData.items">items</a></code></li>
<li><code><a title="sprit.sprit_hvsr.HVSRData.keys" href="#sprit.sprit_hvsr.HVSRData.keys">keys</a></code></li>
<li><code><a title="sprit.sprit_hvsr.HVSRData.params" href="#sprit.sprit_hvsr.HVSRData.params">params</a></code></li>
<li><code><a title="sprit.sprit_hvsr.HVSRData.plot" href="#sprit.sprit_hvsr.HVSRData.plot">plot</a></code></li>
<li><code><a title="sprit.sprit_hvsr.HVSRData.ppsds" href="#sprit.sprit_hvsr.HVSRData.ppsds">ppsds</a></code></li>
<li><code><a title="sprit.sprit_hvsr.HVSRData.ppsds_obspy" href="#sprit.sprit_hvsr.HVSRData.ppsds_obspy">ppsds_obspy</a></code></li>
<li><code><a title="sprit.sprit_hvsr.HVSRData.report" href="#sprit.sprit_hvsr.HVSRData.report">report</a></code></li>
<li><code><a title="sprit.sprit_hvsr.HVSRData.select" href="#sprit.sprit_hvsr.HVSRData.select">select</a></code></li>
<li><code><a title="sprit.sprit_hvsr.HVSRData.to_json" href="#sprit.sprit_hvsr.HVSRData.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
