<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sprit.sprit_gui API documentation</title>
<meta name="description" content="This script contains all the functions, classes, etc. to create a tkinter app for graphical user interface …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sprit.sprit_gui</code></h1>
</header>
<section id="section-intro">
<p>This script contains all the functions, classes, etc. to create a tkinter app for graphical user interface</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Na</code></dt>
<dd>No returns</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This script contains all the functions, classes, etc. to create a tkinter app for graphical user interface

Returns
-------
Na
    No returns
&#34;&#34;&#34;

import datetime
import functools
import os
import pathlib
import pkg_resources
import sys
import tkinter as tk
from tkinter import filedialog
from tkinter import ttk
from tkinter.simpledialog import askinteger
from tkinter import messagebox
import traceback
import warnings
import zoneinfo

import matplotlib
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import (FigureCanvasTkAgg, NavigationToolbar2Tk)
from matplotlib.backend_bases import MouseButton, MouseEvent
import numpy as np
matplotlib.use(&#39;TkAgg&#39;)

from sprit import sprit_utils
from sprit import sprit_hvsr

#Decorator that catches errors and warnings (to be modified later for gui)
def catch_errors(func):
    #Define a local function to get a list of warnings that we&#39;ll use in the output
    def get_warning_msg_list(w):
        messageList = []
        #Collect warnings that happened before we got to the error
        if w:
            hasWarnings = True
            for warning in w:
                warning_category = type(warning.message).__name__.title().replace(&#39;warning&#39;,&#39;Warning&#39;)
                warning_message = str(warning.message)
                # append the warning category and message to messageList so we get all warnings
                messageList.append(f&#39;{warning_category}: {warning_message}&#39;)
        return messageList
    
    # use functools.wraps to preserve the original function&#39;s metadata
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        result = None
        # use the global keyword to access the error_message and error_category variables
        global error_message
        global error_category

        messageList = []
        hasWarnings = False
        # use a try-except block to catch any exceptions
        try:
            # use a context manager to catch any warnings
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter(&#39;always&#39;)
                # call the original function with the given arguments
                result = func(*args, **kwargs)
                
                #Get message list, [] if no messages, doesn&#39;t run at all if Error/exception in func
                messageList = get_warning_msg_list(w)
                if messageList == []:
                    return result
                else:
                    warningMessage = &#34;WARNING:&#34;
                    for msg in messageList:
                        warningMessage = &#34;\n {}&#34;.format(msg)

                    messagebox.showwarning(title=&#39;WARNINGS&#39;, message=warningMessage)
                    
        except Exception as e:
            messageList = get_warning_msg_list(w)
            
            error_category = type(e).__name__.title().replace(&#39;error&#39;, &#39;Error&#39;)
            error_message = str(e)

            #Print the linenumber where error occured to terminal
            #print(traceback.extract_tb(sys.exc_info()[2])[-1].lineno)
            #Print the function name where the error occured
            #print(func.__name__)

            #Get message list, [] if no messages, doesn&#39;t run at all if Error/exception in func
            warningMessageList = get_warning_msg_list(w)
            
            fullErrorMessage = f&#39;PRIMARY ERROR ({error_category}): {error_message}&#39;
            if messageList == []:
                pass
            else:
                
                fullErrorMessage = fullErrorMessage+&#34;\n\n  Additional Warnings along the way:&#34;
                for addMsg in warningMessageList:
                    fullErrorMessage = &#34;\n{}\n   {}&#34;.format(fullErrorMessage, addMsg)

            messagebox.showerror(title=f&#39;ERROR ({error_category})&#39;,
                                    message=fullErrorMessage)
                
        # return the result of the function or the error/warning messages and categories
        return result
    # return the wrapper function
    return wrapper

class SPRIT_App:
    def __init__(self, master):
        self.master = master
        self.master.title(&#34;SPRIT&#34;)
        self.params = sprit_hvsr.HVSRData({&#39;site&#39;:&#39;&#39;})

        # Set the theme
        self.darkthemepath = pathlib.Path(pkg_resources.resource_filename(__name__, &#34;resources/themes/forest-dark.tcl&#34;))
        self.lightthemepath = pathlib.Path(pkg_resources.resource_filename(__name__, &#34;resources/themes/forest-light.tcl&#34;))
        
        # Create the style object
        self.style = ttk.Style(master)
        self.master.tk.call(&#39;source&#39;, self.lightthemepath)
        #self.style.theme_use(&#39;default&#39;)
        self.style.theme_use(&#39;forest-light&#39;)

        self.create_menubar()
        self.create_tabs()

        self.master.rowconfigure(0, weight=1)
        self.master.columnconfigure(0, weight=1)        

        # Create the dark theme
        #self.style.theme_create(&#34;dark&#34;, parent=&#34;alt&#34;, settings={
        #    &#34;TLabel&#34;: {&#34;configure&#34;: {&#34;background&#34;: &#34;black&#34;, &#34;foreground&#34;: &#34;white&#34;}},
        #    &#34;TButton&#34;: {&#34;configure&#34;: {&#34;background&#34;: &#34;black&#34;, &#34;foreground&#34;: &#34;white&#34;}},
        #    # Add more options here to style other widgets
        #})
        
        # Create the light theme
        #self.style.theme_create(&#34;light&#34;, parent=&#34;alt&#34;, settings={
        #    &#34;TLabel&#34;: {&#34;configure&#34;: {&#34;background&#34;: &#34;white&#34;, &#34;foreground&#34;: &#34;black&#34;}},
        #    &#34;TButton&#34;: {&#34;configure&#34;: {&#34;background&#34;: &#34;white&#34;, &#34;foreground&#34;: &#34;black&#34;}},
        #    # Add more options here to style other widgets
        #})
        
    #Not currently working
    def manual_label_update(self):
        for notebook in self.master.winfo_children():
            if isinstance(notebook, ttk.Notebook):
                for tab_id in notebook.tabs():
                    tab_frame = notebook.nametowidget(tab_id)
                    #print(type(tab_frame))
                    for frame in tab_frame.winfo_children():
                        if isinstance(frame, ttk.LabelFrame):
                            for widget in frame.winfo_children():
                                if isinstance(widget, ttk.Label):
                                    # apply the updated style to the label
                                    
                                    self.style.layout(&#39;CustTLabel&#39;, [(&#39;Label.border&#39;, {&#39;sticky&#39;: &#39;nswe&#39;, &#39;border&#39;: &#39;1&#39;, &#39;children&#39;: [(&#39;Label.padding&#39;, {&#39;sticky&#39;: &#39;nswe&#39;, &#39;children&#39;: [(&#39;Label.text&#39;, {&#39;sticky&#39;: &#39;nswe&#39;})]})]})])
                                    self.style.configure(&#39;CustTLabel&#39;, background=self.style.lookup(&#39;style&#39;, &#39;background&#39;), foreground=self.style.lookup(&#39;style&#39;, &#39;background&#39;))
                                    self.style.map(&#39;CustTLabel&#39;, {&#39;priority&#39;:[(&#39;CustTLabel&#39;,1)]})
                                    widget.configure(style=&#39;CustTLabel&#39;)

    def create_menubar(self):
        self.menubar = tk.Menu(self.master)
        self.master.config(menu=self.menubar)
        
        self.sprit_menu = tk.Menu(self.menubar, tearoff=0)

        def on_theme_select():
            # Set the theme based on the selected value
            self.style = ttk.Style()
            
            &#34;&#34;&#34;An attempt to get the backgrounds right
            def apply_to_all_children(widget, func):
                Recursively apply a function to all child widgets of a given widget
                children = widget.winfo_children()
                for child in children:
                    func(child)
                    apply_to_all_children(child, func)
                return

            def change_background_color(widget):
                if isinstance(widget, tk.Label):
                    widget.option_clear()
                    widget.configure(background=None, foreground=None)
                return
            
            apply_to_all_children(self.master, change_background_color)
            &#34;&#34;&#34;
            if &#39;forest&#39; in self.theme_var.get():
                if self.theme_var.get()==&#39;forest-dark&#39; and &#39;forest-dark&#39; not in self.style.theme_names():
                    self.master.tk.call(&#39;source&#39;, self.darkthemepath)
                elif self.theme_var.get()==&#39;forest-light&#39; and &#39;forest-light&#39; not in self.style.theme_names():
                    self.master.tk.call(&#39;source&#39;, self.lightthemepath)            
            self.master.tk.call(&#34;ttk::style&#34;, &#34;theme&#34;, &#34;use&#34;, self.theme_var.get())
            #self.master.tk.call(&#34;ttk::setTheme&#34;, self.theme_var.get())

            #self.style.theme_use(self.theme_var.get())
            #self.master.tk.call(&#39;source&#39;, self.lightthemepath)
            #self.style.theme_use(self.theme_var.get())
            #self.style.configure(&#34;TLabel&#34;, background=self.style.lookup(&#39;TLabel&#39;, &#39;background&#39;), foreground=self.style.lookup(&#39;TLabel&#39;, &#39;background&#39;))

        def import_parameters(self):
            filepath = filedialog.askopenfilename()
        
        
        def export_parameters(self):
            filepath = filedialog.asksaveasfilename()

        self.theme_menu = tk.Menu(self.menubar, tearoff=0)
        self.theme_var = tk.StringVar(value=&#34;Default&#34;)
        self.theme_menu.add_radiobutton(label=&#34;Default&#34;, variable=self.theme_var, value=&#34;default&#34;, command=on_theme_select)
        self.theme_menu.add_radiobutton(label=&#34;Clam&#34;, variable=self.theme_var, value=&#34;clam&#34;, command=on_theme_select)
        self.theme_menu.add_radiobutton(label=&#34;Alt&#34;, variable=self.theme_var, value=&#34;alt&#34;, command=on_theme_select)
        self.theme_menu.add_radiobutton(label=&#34;Forest Light (buggy)&#34;, variable=self.theme_var, value=&#34;forest-light&#34;, command=on_theme_select)
        self.theme_menu.add_radiobutton(label=&#34;Forest Dark (buggy)&#34;, variable=self.theme_var, value=&#34;forest-dark&#34;, command=on_theme_select)

        self.sprit_menu.add_cascade(label=&#34;Theme&#34;, menu=self.theme_menu)
        self.sprit_menu.add_command(label=&#34;Import Parameters&#34;, command=import_parameters)
        self.sprit_menu.add_command(label=&#34;Export Parameters&#34;, command=export_parameters)
        self.sprit_menu.add_separator()
        self.sprit_menu.add_command(label=&#34;Exit&#34;, command=self.master.quit)
        self.settings_menu = tk.Menu(self.menubar, tearoff=0)
        self.instrument_menu = tk.Menu(self.settings_menu, tearoff=0)
        self.instrument_var = tk.StringVar(value=&#34;Raspberry Shake&#34;)
        self.instrument_menu.add_radiobutton(label=&#34;Raspberry Shake&#34;, variable=self.instrument_var, value=&#34;Raspberry Shake&#34;)
        self.instrument_menu.add_radiobutton(label=&#34;Nodes&#34;, variable=self.instrument_var, value=&#34;Nodes&#34;)
        self.instrument_menu.add_radiobutton(label=&#34;Other&#34;, variable=self.instrument_var, value=&#34;Other&#34;)
        self.settings_menu.add_cascade(label=&#34;Instrument&#34;, menu=self.instrument_menu)
        self.settings_menu.add_command(label=&#34;Processing Settings&#34;, command=lambda: self.tab_control.select(self.settings_tab))

        self.menubar.add_cascade(label=&#34;SPRIT&#34;, menu=self.sprit_menu)
        self.menubar.add_cascade(label=&#34;Settings&#34;, menu=self.settings_menu)
    
    def create_tabs(self):
        self.style = ttk.Style(self.master)

        self.tab_control = ttk.Notebook(self.master)

        # INPUT TAB
        self.input_tab = ttk.Frame(self.tab_control)

        # Configure the row and column of the input_tab to have a non-zero weight
        hvsrFrame = ttk.LabelFrame(self.input_tab, text=&#34;Input Parameters&#34;)
        #hvsrFrame.rowconfigure(0, weight=1)
        hvsrFrame.columnconfigure(1, weight=1)

        # Logo and Site Name
        # Replace &#34;logo.png&#34; with the path to your logo image
        #self.logo = tk.PhotoImage(file=&#34;logo.png&#34;)
        #self.logo_label = ttk.Label(hvsrFrame, image=self.logo)
        #self.logo_label.grid(row=0, column=0)
        self.processingData = False

        
        def update_input_labels(hvsr_data):
            #Update labels for data preview tab
            self.input_data_label.configure(text=self.data_filepath_entry.get() + &#39;\n&#39; + str(hvsr_data[&#39;stream&#39;]))
            
            self.obspySreamLabel_settings.configure(text=str(hvsr_data[&#39;stream&#39;]))

            self.sensitivityLabelZ_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;Z&#39;][&#39;sensitivity&#39;])
            self.gainLabelZ_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;Z&#39;][&#39;gain&#39;])
            self.polesLabelZ_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;Z&#39;][&#39;poles&#39;])
            self.zerosLabelZ_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;Z&#39;][&#39;zeros&#39;])
            
            self.sensitivityLabelN_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;N&#39;][&#39;sensitivity&#39;])
            self.gainLabelN_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;N&#39;][&#39;gain&#39;])
            self.polesLabelN_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;N&#39;][&#39;poles&#39;])
            self.zerosLabelN_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;N&#39;][&#39;zeros&#39;])

            self.sensitivityLabelE_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;E&#39;][&#39;sensitivity&#39;])
            self.gainLabelE_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;E&#39;][&#39;gain&#39;])
            self.polesLabelE_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;E&#39;][&#39;poles&#39;])
            self.zerosLabelE_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;E&#39;][&#39;zeros&#39;])
            return
        
        #FUNCTION TO READ DATA
        @catch_errors
        def read_data():
            self.starttime, self.endtime = get_times()


            if self.file_source.get() == &#39;batch&#39;:
                if isinstance(self.fpath, str):
                    pass
                elif len(self.fpath) &gt; 1:
                    self.fpath = list(self.fpath)
                    batchType = &#39;filelist&#39;
                else:
                    self.fpath = self.fpath[0]
                    batchType = &#39;table&#39;

                self.params = sprit_hvsr.batch_data_read(input_data=self.fpath, batch_type=batchType)
                self.hvsr_data = self.params
                firstSite = self.hvsr_data[list(self.hvsr_data.keys())[0]]
                update_input_labels(firstSite)

                #Plot data in data preview tab
                self.fig_pre, self.ax_pre = sprit_hvsr.plot_stream(stream=firstSite[&#39;stream&#39;], params=firstSite, fig=self.fig_pre, axes=self.ax_pre, return_fig=True)

                #Plot data in noise preview tab
                self.fig_noise, self.ax_noise = sprit_hvsr._plot_specgram_stream(stream=firstSite[&#39;stream&#39;], params=firstSite, fig=self.fig_noise, ax=self.ax_noise, fill_gaps=0, component=&#39;Z&#39;, stack_type=&#39;linear&#39;, detrend=&#39;mean&#39;, dbscale=True, return_fig=True, cmap_per=[0.1,0.9])
                select_windows(event=None, initialize=True)
                plot_noise_windows(firstSite)

            else:
                if isinstance(self.fpath, str):
                    pass
                elif len(self.fpath) &gt; 1:
                    self.fpath = list(self.fpath)
                else:
                    self.fpath = self.fpath[0]

                self.params = sprit_hvsr.input_params( datapath=self.fpath,
                                    metapath = self.meta_path.get(),
                                    site=self.site_name.get(),
                                    network=self.network.get(), 
                                    station=self.station.get(), 
                                    loc=self.location.get(), 
                                    channels=[self.z_channel.get(), self.n_channel.get(), self.e_channel.get()],
                                    acq_date = self.starttime.date(),
                                    starttime = self.starttime,
                                    endtime = self.endtime,
                                    tzone = &#39;UTC&#39;, #Will always be converted to UTC before we get to this point when using gui
                                    xcoord = self.x.get(),
                                    ycoord =  self.y.get(),
                                    elevation = self.z.get(),
                                    input_crs= self.input_crs.get(),
                                    output_crs= self.output_crs.get(),
                                    elev_unit= self.elev_unit.get(),
                                    instrument = self.instrumentSel.get(),
                                    hvsr_band = [self.hvsrBand_min.get(), self.hvsrBand_max.get()] )

                if self.trim_dir.get()==&#39;&#39;:
                    trimDir=None
                else:
                    trimDir=self.trim_dir.get()

                self.hvsr_data = sprit_hvsr.fetch_data(params=self.params,
                                            source=self.file_source.get(), 
                                            trim_dir=trimDir, 
                                            export_format=self.export_format.get(), 
                                            detrend=self.detrend.get(), 
                                            detrend_order=self.detrend_order.get())
                
                update_input_labels(self.hvsr_data)


                #Plot data in data preview tab
                self.fig_pre, self.ax_pre = sprit_hvsr.plot_stream(stream=self.hvsr_data[&#39;stream&#39;], params=self.hvsr_data, fig=self.fig_pre, axes=self.ax_pre, return_fig=True)

                #Plot data in noise preview tab
                self.fig_noise, self.ax_noise = sprit_hvsr._plot_specgram_stream(stream=self.hvsr_data[&#39;stream&#39;], params=self.hvsr_data, fig=self.fig_noise, ax=self.ax_noise, fill_gaps=0, component=&#39;Z&#39;, stack_type=&#39;linear&#39;, detrend=&#39;mean&#39;, dbscale=True, return_fig=True, cmap_per=[0.1,0.9])
                select_windows(event=None, initialize=True)
                plot_noise_windows(self.hvsr_data)

            self.data_read = True
            if not self.processingData:
                self.tab_control.select(self.preview_data_tab)

        #FUNCTION TO PROCESS DATA
        @catch_errors
        def process_data():
            self.processingData = True #Set to true while data processing algorithm is being run
            
            if self.data_read == False:
                read_data()
            
            self.hvsr_data = plot_noise_windows(self.hvsr_data)
   
            self.hvsr_data = sprit_hvsr.generate_ppsds(params=self.hvsr_data, 
                                               ppsd_length=self.ppsd_length.get(), 
                                               overlap=self.overlap.get(), 
                                               period_step_octaves=self.perStepOct.get(), 
                                               remove_outliers=self.remove_outliers.get(), 
                                               outlier_std=self.outlier_std.get(),
                                               skip_on_gaps=self.skip_on_gaps.get(),
                                               db_bins=self.db_bins,
                                               period_limits=self.period_limits,
                                               period_smoothing_width_octaves=self.perSmoothWidthOct.get(),
                                               special_handling=special_handling
                                               )
            
            self.hvsr_results = sprit_hvsr.process_hvsr(params=self.hvsr_data, 
                                                   method=self.method_ind,
                                                   smooth=self.hvsmooth_param,
                                                   freq_smooth=self.freq_smooth.get(),
                                                   f_smooth_width=self.fSmoothWidth.get(), 
                                                   resample=self.hvresample_int, 
                                                   remove_outlier_curves=self.outlierRembool.get(), 
                                                   outlier_curve_std=self.outlierRemStDev.get())
            
            self.hvsr_results = sprit_hvsr.check_peaks(hvsr_data=self.hvsr_results, 
                                                  hvsr_band = [self.hvsrBand_min.get(), self.hvsrBand_max.get()],
                                                  peak_water_level=self.peak_water_level)

            curveTest1ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Lw&#39;][:-1])
            curveTest1Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Lw&#39;][-1])

            curveTest2ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Nc&#39;][:-1])
            curveTest2Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Nc&#39;][-1])

            curveTest3ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;σ_A(f)&#39;][:-1])
            curveTest3Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;σ_A(f)&#39;][-1])

            curvePass = (self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Window Length Freq.&#39;] +
                                self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Significant Cycles&#39;]+
                                self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Low Curve StDev. over time&#39;]) &gt; 2
            if curvePass:
                totalCurveResult.configure(text=sprit_utils.check_mark(), font=(&#34;TkDefaultFont&#34;, 16, &#34;bold&#34;), foreground=&#39;green&#39;)
            else:
                totalCurveResult.configure(text=sprit_utils.x_mark(), font=(&#34;TkDefaultFont&#34;, 16, &#34;bold&#34;), foreground=&#39;red&#39;)

            peakTest1ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;A(f-)&#39;][:-1])
            peakTest1Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;A(f-)&#39;][-1])
            
            peakTest2ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;A(f+)&#39;][:-1])
            peakTest2Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;A(f+)&#39;][-1])
            
            peakTest3ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;A0&#39;][:-1])
            peakTest3Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;A0&#39;][-1])

            peakTest4ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;P-&#39;][:5] + &#39; and &#39; +self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;P+&#39;][:-1])
            if self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Freq. Stability&#39;]:
                peakTest4Result.configure(text=&#39;✔&#39;)
            else:
                peakTest4Result.configure(text=&#39;✘&#39;)

            peakTest5ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Sf&#39;][:-1])
            peakTest5Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Sf&#39;][-1])
            
            peakTest6ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Sa&#39;][:-1])
            peakTest6Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Sa&#39;][-1])

            peakPass = (self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Peak Freq. Clarity Below&#39;] +
                    self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Peak Freq. Clarity Above&#39;]+
                    self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Peak Amp. Clarity&#39;]+
                    self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Freq. Stability&#39;]+
                    self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Peak Stability (freq. std)&#39;]+
                    self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Peak Stability (amp. std)&#39;]) &gt;= 5
            if peakPass:
                totalPeakResult.configure(text=&#39;✔&#39;, font=(&#34;TkDefaultFont&#34;, 16, &#34;bold&#34;), foreground=&#39;green&#39;)
            else:
                totalPeakResult.configure(text=&#39;✘&#39;, font=(&#34;TkDefaultFont&#34;, 16, &#34;bold&#34;), foreground=&#39;red&#39;)

            if curvePass and peakPass:
                totalResult.configure(text=&#39;Pass ✔&#39;, font=(&#34;TkDefaultFont&#34;, 22, &#34;bold&#34;), foreground=&#39;green&#39;)
            else:
                totalResult.configure(text=&#39;Fail ✘&#39;, font=(&#34;TkDefaultFont&#34;, 22, &#34;bold&#34;), foreground=&#39;red&#39;)

            sprit_hvsr.hvplot(self.hvsr_results, plot_type=get_kindstr(), fig=self.fig_results, ax=self.ax_results, use_subplots=True, clear_fig=False)

            self.processingData = False
            self.tab_control.select(self.results_tab)

        
        def update_input_params_call():
            self.input_params_call.configure(text=&#34;input_params( datapath=&#39;{}&#39;, metapath={}, site=&#39;{}&#39;, instrument=&#39;{}&#39;,\n\tnetwork=&#39;{}&#39;, station=&#39;{}&#39;, loc=&#39;{}&#39;, channels=[{}, {}, {}], \n\tacq_date=&#39;{}&#39;, starttime=&#39;{}&#39;, endttime=&#39;{}&#39;, tzone=&#39;{}&#39;, \n\txcoord={}, ycoord={}, elevation={}, input_crs=&#39;{}&#39;, output_crs=&#39;{}&#39;, elev_unit=&#39;{}&#39;,  hvsr_band=[{}, {}])&#34;.format(
                                            self.data_path.get(), self.meta_path.get(), self.site_name.get(), self.instrumentSel.get(),
                                            self.network.get(), self.station.get(), self.location.get(),
                                            self.z_channel.get(), self.e_channel.get(), self.n_channel.get(),
                                            self.acq_date, self.starttime.time(), self.endtime.time(), self.tz,
                                            self.x.get(), self.y.get(), self.z.get(), 
                                            self.input_crs.get(), self.output_crs.get(), self.elev_unit.get(), 
                                            self.hvsrBand_min.get(), self.hvsrBand_max.get()))
        #Specify site name        
        siteLabel = ttk.Label(hvsrFrame, text=&#34;Site Name&#34;)
        siteLabel.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5)
        self.site_name = tk.StringVar()
        self.site_name.set(&#39;HVSR Site&#39;)
        self.site_name_entry = ttk.Entry(hvsrFrame, textvariable=self.site_name, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.site_name_entry.grid(row=0, column=1, columnspan=1, sticky=&#39;ew&#39;, padx=5)

        # source=file
        
        def on_source_select():
            try:
                str(self.file_source.get())
                sourceLabel.configure(text=&#34;source=&#39;{}&#39;&#34;.format(self.file_source.get()))
                update_fetch_call()

                if self.file_source.get() == &#39;raw&#39; or self.file_source.get() == &#39;dir&#39;:
                    self.browse_data_filepath_button.configure(text=&#39;Browse Folder&#39;)
                    self.batch_options_frame.grid_forget()
                elif self.file_source.get() == &#39;batch&#39;:
                    self.batch_options_frame.grid(row=11, column=0, columnspan=7, sticky=&#39;ew&#39;)
                else:
                    self.browse_data_filepath_button.configure(text=&#39;Browse File(s)&#39;)
                    self.batch_options_frame.grid_forget()
                return True
            except ValueError:
                return False

        sourceLabel = ttk.Label(master=hvsrFrame, text=&#34;source=&#39;file&#39;&#34;)

        ttk.Label(master=hvsrFrame, text=&#39;Data Source Type [str]&#39;).grid(row=0, column=3, sticky=&#39;e&#39;, padx=5)
        sourcFrame= ttk.Frame(hvsrFrame)
        sourcFrame.grid(row=0, column=4, sticky=&#39;w&#39;, columnspan=3)
        self.file_source = tk.StringVar()
        self.file_source.set(&#39;file&#39;)
        ttk.Radiobutton(master=sourcFrame, text=&#39;File&#39;, variable=self.file_source, value=&#39;file&#39;, command=on_source_select).grid(row=0, column=0, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=sourcFrame, text=&#39;Raw&#39;, variable=self.file_source, value=&#39;raw&#39;, command=on_source_select).grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=sourcFrame, text=&#39;Batch&#39;, variable=self.file_source, value=&#39;batch&#39;, command=on_source_select).grid(row=0, column=2, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=sourcFrame, text=&#39;Directory&#39;, variable=self.file_source, value=&#39;dir&#39;, command=on_source_select).grid(row=0, column=3, sticky=&#39;w&#39;, padx=(5, 10))

        #Instrument select
        ttk.Label(hvsrFrame, text=&#34;Instrument&#34;).grid(row=0, column=6, sticky=&#39;e&#39;, padx=5)
        inst_options = [&#34;Raspberry Shake&#34;, &#34;Nodes&#34;, &#34;Other&#34;]

        
        def on_option_select(self, inst):
            update_input_params_call()
            if inst == &#34;Raspberry Shake&#34;:
                self.network_entry.configure(state=&#39;normal&#39;)
                self.station_entry.configure(state=&#39;normal&#39;)
                self.location_entry.configure(state=&#39;normal&#39;)
                
                self.z_channel_entry.delete(0, &#39;end&#39;)
                self.e_channel_entry.delete(0, &#39;end&#39;)
                self.n_channel_entry.delete(0, &#39;end&#39;)
                
                self.z_channel_entry.insert(0,&#34;EHZ&#34;)
                self.e_channel_entry.insert(0,&#34;EHE&#34;)
                self.n_channel_entry.insert(0,&#34;EHN&#34;)

                self.network_entry.delete(0, &#39;end&#39;)
                self.network_entry.insert(0,&#34;AM&#34;)

                self.station_entry.delete(0, &#39;end&#39;)
                self.station_entry.insert(0,&#34;RAC84&#34;)

                self.location_entry.delete(0, &#39;end&#39;)
                self.location_entry.insert(0,&#34;00&#34;)
            else:
                self.network_entry.configure(state=&#39;disabled&#39;)
                self.station_entry.configure(state=&#39;disabled&#39;)
                self.location_entry.configure(state=&#39;disabled&#39;)

        self.instrumentSel = tk.StringVar(value=inst_options[0])
        self.instrument_dropdown = ttk.OptionMenu(hvsrFrame, self.instrumentSel, inst_options[0], *inst_options, command=on_option_select)
        self.instrument_dropdown.config(width=20)
        self.instrument_dropdown.grid(row=0, column=7, columnspan=1, sticky=&#39;ew&#39;)

        # Data Filepath
        dataLabel= ttk.Label(hvsrFrame, text=&#34;Data Filepath&#34;)
        dataLabel.grid(row=1, column=0, sticky=&#39;e&#39;, padx=5, pady=(5,2.55))
    
        #Function to set self.data_read False whenever the data_path is updated
        
        def on_data_path_change(data_path, index, trace_mode):
            #If our data path changes, data is registered as not having been read
            #This is primarily so that if just the Run button is pushed, it will know to first read the data
            self.data_read = False
        
        
        def filepath_update():
            self.fpath = self.data_path.get()
            self.data_read = False
            update_input_params_call()

        self.data_path = tk.StringVar()
        self.data_path.trace(&#39;w&#39;, on_data_path_change)
        self.data_filepath_entry = ttk.Entry(hvsrFrame, textvariable=self.data_path, validate=&#39;focusout&#39;, validatecommand=filepath_update)
        self.data_filepath_entry.grid(row=1, column=1, columnspan=6, sticky=&#39;ew&#39;, padx=5, pady=(5,2.55))

        
        def browse_data_filepath():
            if self.file_source.get() == &#39;raw&#39; or self.file_source.get() == &#39;dir&#39;:
                self.fpath = filedialog.askdirectory()
                if self.fpath:
                    self.data_filepath_entry.delete(0, &#39;end&#39;)
                    self.data_filepath_entry.insert(0, self.fpath)
            else:
                self.fpath = filedialog.askopenfilenames()
                
                #fpath will always be tuple
                self.no_data_files = len(self.fpath)
                    
                if self.fpath:
                    self.data_filepath_entry.delete(0, &#39;end&#39;)
                    for f in self.fpath:
                        self.data_filepath_entry.insert(&#39;end&#39;, self.fpath)
                
            update_input_params_call()


        buttonFrame = ttk.Frame(hvsrFrame)
        buttonFrame.grid(row=1, column=7, sticky=&#39;ew&#39;)

        self.browse_data_filepath_button = ttk.Button(buttonFrame, text=&#34;Browse File(s)&#34;, command=browse_data_filepath)

        #self.browse_data_filepath_button.grid(row=1, column=6, sticky=&#39;ew&#39;)
        self.browse_data_filepath_button.pack(side=&#34;left&#34;, fill=&#34;x&#34;, expand=True, padx=(0,2), pady=(5,2.55))

        # Metadata Filepath
        ttk.Label(hvsrFrame, text=&#34;Metadata Filepath&#34;).grid(row=2, column=0, sticky=&#39;e&#39;, padx=5, pady=(2.5,5))
        self.meta_path = tk.StringVar()
        self.metadata_filepath_entry = ttk.Entry(hvsrFrame, textvariable=self.meta_path, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.metadata_filepath_entry.grid(row=2, column=1, columnspan=6, sticky=&#39;ew&#39;, padx=5, pady=(2.5,5))
        
        
        def browse_metadata_filepath():
            filepath = filedialog.askopenfilename()
            if filepath:
                self.metadata_filepath_entry.delete(0, &#39;end&#39;)
                self.metadata_filepath_entry.insert(0, filepath)
            update_input_params_call()

        self.browse_metadata_filepath_button = ttk.Button(hvsrFrame, text=&#34;Browse&#34;, command=browse_metadata_filepath)
        self.browse_metadata_filepath_button.grid(row=2, column=7, sticky=&#39;ew&#39;, padx=0, pady=(2.5,5))

        
        def update_acq_date(event):
            aMonth = self.acq_month.get()
            if str(aMonth)[0]==&#39;0&#39;:
                aMonth = str(aMonth)[-1]

            aDay = self.acq_day.get()
            if str(aDay)[0]==&#39;0&#39;:
                aDay = str(aDay)[-1]

            self.acq_date = datetime.date(year=self.acq_year.get(), month=aMonth, day=aDay)#self.date_entry.get_date()
            self.day_of_year = self.acq_date.timetuple().tm_yday
            self.doy_label.configure(text=str(self.day_of_year))
            update_input_params_call()

        # Date and Time
        dateFrame = ttk.Frame(hvsrFrame)
        dateFrame.grid(row=3, column=1, columnspan=2, sticky=&#39;e&#39;, padx=5)
        ttk.Label(dateFrame, text=&#34;Date&#34;).grid(row=1, column=1, sticky=&#39;e&#39;, padx=5)

        self.acq_year = tk.IntVar()
        self.acq_year.set(int(datetime.datetime.today().year))
        self.acq_year_entry = ttk.Spinbox(dateFrame, from_=0, to=10000, width=7, textvariable=self.acq_year, validate=&#39;focusout&#39;, validatecommand=update_acq_date) 
        self.acq_year_entry.grid(row=1, column=2, sticky=&#39;ew&#39;, padx=1)

        self.acq_month = tk.IntVar()
        self.acq_month.set(int(datetime.datetime.today().month))
        self.acq_month_entry = ttk.Spinbox(dateFrame, from_=0, to=12, width=3, textvariable=self.acq_month, validate=&#39;focusout&#39;, validatecommand=update_acq_date) 
        self.acq_month_entry.grid(row=1, column=3, sticky=&#39;ew&#39;, padx=1)

        self.acq_day = tk.IntVar()
        self.acq_day.set(int(datetime.datetime.today().day))
        self.acq_day_entry = ttk.Spinbox(dateFrame, from_=0, to=31, width=3, textvariable=self.acq_day, validate=&#39;focusout&#39;, validatecommand=update_acq_date) 
        self.acq_day_entry.grid(row=1, column=4, sticky=&#39;ew&#39;, padx=1)

        self.acq_date = datetime.date.today()
        #self.date_entry = DateEntry(hvsrFrame, date_pattern=&#39;y-mm-dd&#39;, textvariable=self.acq_date, validate=&#39;focusout&#39;)#update_input_params_call)
        #self.date_entry.grid(row=3, column=2, sticky=&#39;w&#39;, padx=5)
        #self.date_entry.bind(&#34;&lt;&lt;DateEntrySelected&gt;&gt;&#34;, update_acq_date)
        
        sTimeFrame = ttk.Frame(hvsrFrame)
        sTimeFrame.grid(row=3, column=4, sticky=&#39;ew&#39;)

        def get_times():
            #Format starttime as datetime object (in timezone as originally entered)
            self.acq_date = datetime.date(year=self.acq_year.get(), month=self.acq_month.get(), day=self.acq_day.get())#self.date_entry.get_date()

            sHour = self.start_hour.get()
            if str(sHour)[0] == &#39;0&#39;:
                sHour = int(str(sHour)[-1])

            sMin = self.start_minute.get()
            if str(sMin)[0] == &#39;0&#39;:
                sMin = int(str(sMin)[-1])

            self.starttime = datetime.datetime(year = self.acq_date.year, 
                                          month = self.acq_date.month,
                                          day = self.acq_date.day,
                                          hour = sHour,
                                          minute = sMin,
                                          tzinfo=self.tz)
            
            #Get duration, as originally entered
            hour_dur = self.end_hour.get() - self.start_hour.get()
            if hour_dur &lt; 0:
                hour_dur = self.end_hour.get() + 24 - self.start_hour.get()
            min_dur = self.end_minute.get() - self.start_minute.get()

            #Convert starttime to utc
            #self.starttime = self.tz.normalize(self.tz.localize(self.starttime)).astimezone(pytz.utc)
            self.starttime  = self.starttime.astimezone(datetime.timezone.utc)

            #Get endttime based on utc starttime and original duration
            self.endtime = self.starttime + datetime.timedelta(hours=hour_dur, minutes=min_dur)

            return self.starttime, self.endtime

        self.tz = datetime.timezone.utc

        
        def any_time_change():
            self.acq_date = self.date_entry.get_date()
            self.starttime, self.endtime = get_times()
            update_input_params_call()

        ttk.Label(hvsrFrame, text=&#34;Start Time&#34;).grid(row=3, column=3, sticky=&#39;e&#39;, padx=5) 
        colonLabel= ttk.Label(sTimeFrame, text=&#34;:&#34;)#.grid(row=3, column=4, padx=(20,0), sticky=&#39;w&#39;)
        self.start_hour = tk.IntVar()
        self.start_hour.set(00)
        self.start_time_hour_entry = ttk.Spinbox(sTimeFrame, from_=0, to=23, width=5, textvariable=self.start_hour, validate=&#39;focusout&#39;, validatecommand=any_time_change) 
        self.start_time_hour_entry#.grid(row=3, column=4, sticky=&#39;w&#39;) 
        self.start_minute = tk.DoubleVar()
        self.start_minute.set(00)
        self.start_time_min_entry = ttk.Spinbox(sTimeFrame, from_=0, to=59, width=5, textvariable=self.start_minute, validate=&#39;focusout&#39;, validatecommand=any_time_change)
        self.start_time_min_entry#.grid(row=3, column=4, padx=80, sticky=&#39;w&#39;) 
        
        #sTLabel.pack(side=&#34;left&#34;, fill=&#34;x&#34;, expand=True)
        self.start_time_hour_entry.pack(side=&#39;left&#39;, expand=True)
        colonLabel.pack(side=&#34;left&#34;, fill=&#34;x&#34;)
        self.start_time_min_entry.pack(side=&#39;right&#39;, expand=True)
        
        eTimeFrame = ttk.Frame(hvsrFrame)
        eTimeFrame.grid(row=3, column=6, sticky=&#39;ew&#39;)
        ttk.Label(hvsrFrame, text=&#34;End Time&#34;).grid(row=3, column=5, sticky=&#39;e&#39;, padx=5) 
        colonLabel = ttk.Label(eTimeFrame, text=&#34;:&#34;)#.grid(row=3, column=6, padx=(20,0), sticky=&#39;w&#39;)  
        self.end_hour = tk.IntVar()
        self.end_hour.set(23)
        self.end_time_hour_entry = ttk.Spinbox(eTimeFrame, from_=0, to=23, width=5, textvariable=self.end_hour, validate=&#39;focusout&#39;, validatecommand=any_time_change) 
        self.end_time_hour_entry#.grid(row=3, column=+, sticky=&#39;w&#39;) 
        self.end_minute = tk.DoubleVar()
        self.end_minute.set(59)
        self.end_time_min_entry = ttk.Spinbox(eTimeFrame, from_=0, to=59, width=5, textvariable=self.end_minute, validate=&#39;focusout&#39;, validatecommand=any_time_change)
        self.end_time_min_entry#.grid(row=3, column=+, padx=80, sticky=&#39;w&#39;) 

        #eTLabel.pack(side=&#34;left&#34;, fill=&#34;x&#34;, expand=True)
        self.end_time_hour_entry.pack(side=&#39;left&#39;, expand=True)
        colonLabel.pack(side=&#34;left&#34;, fill=&#34;x&#34;)
        self.end_time_min_entry.pack(side=&#39;right&#39;, expand=True)

        self.acq_date = datetime.date(year=self.acq_year.get(), month=self.acq_month.get(), day=self.acq_day.get())#self.date_entry.get_date()
        self.starttime, self.endtime = get_times()

        
        def onTimezoneSelect(event):
            #Listbox &#34;loses&#34; selection and triggers an event sometimes, so need to check if that is just what happened
            if self.timezone_listbox.curselection():
                #If it was an actual selection, update timezone
                self.tz = zoneinfo.ZoneInfo(self.timezone_listbox.get(self.timezone_listbox.curselection()))
            else:
                #If it was just the listbox losing the selection, don&#39;t change anything
                pass
            update_input_params_call()

        self.timezone_listbox = tk.Listbox(hvsrFrame, selectmode=&#39;browse&#39;, height=25)

        self.timezone_listbox.insert(&#39;end&#39;, &#39;UTC&#39;)
        self.timezone_listbox.insert(&#39;end&#39;, &#39;US/Central&#39;)

        for tz in zoneinfo.available_timezones():# pytz.all_timezones:
            if tz !=&#39;UTC&#39;:
                self.timezone_listbox.insert(&#39;end&#39;, tz)
        self.timezone_listbox.selection_set(0)
        self.timezone_listbox.bind(&#39;&lt;&lt;ListboxSelect&gt;&gt;&#39;, onTimezoneSelect)

        ttk.Label(hvsrFrame,text=&#34;Timezone&#34;).grid(row=3,column=7, sticky=&#39;w&#39;, padx=5)
        self.timezone_listbox.grid(row=4,column=7, rowspan=26, sticky=&#39;nsew&#39;, padx=5)

        #ttk.Label(hvsrFrame, text=&#34;Timezone&#34;).grid(row=3, column=7)
        #self.timezone_var = tk.StringVar(value=&#34;UTC&#34;)
        #self.timezone_listbox = ttk.OptionMenu(hvsrFrame, self.timezone_var, &#34;UTC&#34;, *pytz.all_timezones)
        #self.timezone_listbox.grid(row=3,column=7)

        # DOY
        self.day_of_year = self.acq_date.timetuple().tm_yday
        
        ttk.Label(hvsrFrame,text=&#34;Day of Year:&#34;).grid(row=4,column=1, sticky=&#39;e&#39;, padx=5, pady=10)
        self.doy_label = ttk.Label(hvsrFrame,text=str(self.day_of_year))
        self.doy_label.grid(row=4, column=2, sticky=&#39;w&#39;)

        # UTC Time Output
        ttk.Label(hvsrFrame,text=&#34;UTC Time:&#34;).grid(row=4, column=3, sticky=&#39;e&#39;, padx=5, pady=10)
        self.utc_time_output_label = ttk.Label(hvsrFrame,text=&#34;&#34;)
        self.utc_time_output_label.grid(row=4,column=4)

        #Initialize as UTC
        self.tz = datetime.timezone.utc
        #self.tz = pytz.timezone(self.timezone_listbox.get(self.timezone_listbox.curselection()))
        #input_params() call

        self.starttime, self.endtime = get_times()

        # X Y Z CRS Depth
        ttk.Label(hvsrFrame,text=&#34;X&#34;).grid(row=5,column=1, sticky=&#39;e&#39;, padx=5, pady=10)
        self.x = tk.DoubleVar()
        self.x.set(0)
        self.x_entry = ttk.Entry(hvsrFrame, textvariable=self.x, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.x_entry.grid(row=5,column=2, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;Y&#34;).grid(row=5,column=3, sticky=&#39;e&#39;, padx=5, pady=10)
        self.y = tk.DoubleVar()
        self.y.set(0)
        self.y_entry = ttk.Entry(hvsrFrame, textvariable=self.y, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.y_entry.grid(row=5, column=4, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;Z&#34;).grid(row=5,column=5, sticky=&#39;e&#39;, padx=5, pady=10)
        self.z = tk.DoubleVar()
        self.z.set(0)
        self.z_entry = ttk.Entry(hvsrFrame, textvariable=self.z, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.z_entry.grid(row=5,column=6, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;Input CRS&#34;).grid(row=6,column=1, sticky=&#39;e&#39;, padx=5, pady=10)
        self.input_crs = tk.StringVar()
        self.input_crs.set(&#39;EPSG:4236&#39;)
        self.input_crs_entry = ttk.Entry(hvsrFrame, textvariable=self.input_crs, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.input_crs_entry.grid(row=6,column=2, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;Output CRS&#34;).grid(row=6,column=3, sticky=&#39;e&#39;, padx=5, pady=10)
        self.output_crs = tk.StringVar()
        self.output_crs.set(&#39;EPSG:4236&#39;)
        self.output_crs_entry = ttk.Entry(hvsrFrame, textvariable=self.output_crs, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.output_crs_entry.grid(row=6, column=4, sticky=&#39;w&#39;, padx=0)

        ttk.Label(master=hvsrFrame, text=&#39;Elevation Unit&#39;).grid(row=6, column=5, sticky=&#39;e&#39;, padx=5, pady=10)
        elevUnitFrame= ttk.Frame(hvsrFrame)
        elevUnitFrame.grid(row=6, column=6, sticky=&#39;w&#39;, columnspan=3)
        self.elev_unit = tk.StringVar()
        self.elev_unit.set(&#39;meters&#39;)
        ttk.Radiobutton(master=elevUnitFrame, text=&#39;Meters&#39;, variable=self.elev_unit, value=&#39;meters&#39;, command=update_input_params_call).grid(row=0, column=0, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=elevUnitFrame, text=&#39;Feet&#39;, variable=self.elev_unit, value=&#39;feet&#39;, command=update_input_params_call).grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))

        # Network Station Location
        ttk.Label(hvsrFrame,text=&#34;Network&#34;).grid(row=7,column=1, sticky=&#39;e&#39;, padx=5, pady=10)
        self.network = tk.StringVar()
        self.network.set(&#39;AM&#39;)
        self.network_entry = ttk.Entry(hvsrFrame, textvariable=self.network, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.network_entry.grid(row=7,column=2, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;Station&#34;).grid(row=7,column=3, sticky=&#39;e&#39;, padx=5, pady=10)
        self.station = tk.StringVar()
        self.station.set(&#39;RAC84&#39;)
        self.station_entry = ttk.Entry(hvsrFrame, textvariable=self.station, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.station_entry.grid(row=7,column=4, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;Location&#34;).grid(row=7,column=5, sticky=&#39;e&#39;, padx=5, pady=10)
        self.location = tk.StringVar()
        self.location.set(&#39;00&#39;)
        self.location_entry = ttk.Entry(hvsrFrame, textvariable=self.location, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.location_entry.grid(row=7,column=6, sticky=&#39;w&#39;, padx=0)

        # Z N E Channels
        ttk.Label(hvsrFrame,text=&#34;Z Channel&#34;).grid(row=8,column=1, sticky=&#39;e&#39;, padx=5, pady=10)
        self.z_channel = tk.StringVar()
        self.z_channel.set(&#39;EHZ&#39;)
        self.z_channel_entry = ttk.Entry(hvsrFrame, textvariable=self.z_channel, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.z_channel_entry.grid(row=8,column=2, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;N Channel&#34;).grid(row=8,column=3, sticky=&#39;e&#39;, padx=5, pady=10)
        self.n_channel = tk.StringVar()
        self.n_channel.set(&#39;EHN&#39;)
        self.n_channel_entry = ttk.Entry(hvsrFrame, textvariable=self.n_channel, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.n_channel_entry.grid(row=8,column=4, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;E Channel&#34;).grid(row=8,column=5, sticky=&#39;e&#39;, padx=5, pady=10)
        self.e_channel = tk.StringVar()
        self.e_channel.set(&#39;EHE&#39;)
        self.e_channel_entry = ttk.Entry(hvsrFrame, textvariable=self.e_channel, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.e_channel_entry.grid(row=8,column=6, sticky=&#39;w&#39;, padx=0)

        # HVSR Band
        def on_hvsrband_update():
            try:
                float(self.hvsrBand_min.get())
                float(self.hvsrBand_max.get())

                hvsrBandLabel.configure(text=&#39;hvsr_band=[{}, {}]&#39;.format(self.hvsrBand_min.get(), self.hvsrBand_max.get()))                
                update_check_peaks_call(self.checkPeaks_Call)
                update_input_params_call()
                return True
            except ValueError:
                return False      
        
        ttk.Label(hvsrFrame,text=&#34;HVSR Band&#34;).grid(row=9,column=1, sticky=&#39;e&#39;, padx=10, pady=10)
        hvsrbandframe= ttk.Frame(hvsrFrame)
        hvsrbandframe.grid(row=9, column=2,sticky=&#39;w&#39;)
        self.hvsrBand_min = tk.DoubleVar()
        self.hvsrBand_min.set(0.4)
        hvsr_band_min_entry = ttk.Entry(hvsrbandframe, width=9, textvariable=self.hvsrBand_min, validate=&#39;focusout&#39;, validatecommand=on_hvsrband_update)
        hvsr_band_min_entry.grid(row=0, column=0, sticky=&#39;ew&#39;, padx=(0,2))

        self.hvsrBand_max = tk.DoubleVar()
        self.hvsrBand_max.set(40)
        hvsr_band_max_entry = ttk.Entry(hvsrbandframe, width=9,textvariable=self.hvsrBand_max, validate=&#39;focusout&#39;, validatecommand=on_hvsrband_update)
        hvsr_band_max_entry.grid(row=0,column=1, sticky=&#39;ew&#39;, padx=(2,0))

        #BATCH Section
        
        def update_batch_data_read_call():
            self.batch_read_data_call.configure(text=&#34;batch_data_read(input_data, batch_type=&#39;{}&#39;, param_col={}, batch_params={})&#34;.format(
                                                                                        self.batch_type.get(), self.param_col.get(), self.batch_params.get()))
            return

        
        def on_batch_type_select():
            update_batch_data_read_call()
            return

        self.batch_options_frame = ttk.LabelFrame(hvsrFrame, text=&#39;Batch Options&#39;)
        ttk.Label(self.batch_options_frame, text=&#34;Batch Type&#34;).grid(row=0,column=0, sticky=&#39;e&#39;, padx=10, pady=10)
        batchTypeFrame= ttk.Frame(self.batch_options_frame)
        batchTypeFrame.grid(row=0, column=1, sticky=&#39;w&#39;, columnspan=3)
        self.batch_type = tk.StringVar()
        self.batch_type.set(&#39;table&#39;)
        ttk.Radiobutton(master=batchTypeFrame, text=&#39;Table&#39;, variable=self.batch_type, value=&#39;table&#39;, command=on_batch_type_select).grid(row=0, column=0, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=batchTypeFrame, text=&#39;File list&#39;, variable=self.batch_type, value=&#39;filelist&#39;, command=on_batch_type_select).grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))

        ttk.Label(self.batch_options_frame,text=&#34;Parameter column name&#34;).grid(row=0,column=4, sticky=&#39;e&#39;, padx=5)
        self.param_col = tk.StringVar()
        self.param_col.set(None)
        self.param_col_entry = ttk.Entry(self.batch_options_frame, textvariable=self.param_col, validate=&#39;focusout&#39;, validatecommand=update_batch_data_read_call)
        self.param_col_entry.grid(row=0, column=5, sticky=&#39;w&#39;, padx=0)
        ttk.Label(self.batch_options_frame,text=&#34;For batch_type=&#39;table&#39; with single parameter column only&#34;).grid(row=1,column=4, columnspan=2, sticky=&#39;w&#39;, padx=5)

        ttk.Label(self.batch_options_frame,text=&#34;Batch parameters&#34;).grid(row=0,column=6, sticky=&#39;e&#39;, padx=5)
        self.batch_params = tk.StringVar()
        self.batch_params.set(None)
        self.batch_params_entry = ttk.Entry(self.batch_options_frame, textvariable=self.batch_params, validate=&#39;focusout&#39;, validatecommand=update_batch_data_read_call, width=75)
        self.batch_params_entry.grid(row=0, column=7, columnspan=3, sticky=&#39;ew&#39;, padx=0)
        ttk.Label(self.batch_options_frame,text=&#34;To specify parameters used for reading in data&#34;).grid(row=1,column=6, columnspan=2, sticky=&#39;w&#39;, padx=5)

        self.batch_read_data_call = ttk.Label(self.batch_options_frame, text=&#34;batch_data_read(input_data, batch_type={}, param_col={}, batch_params={})&#34;.format(
                                                                                        self.batch_type.get(), self.param_col.get(), self.batch_params.get() ))
        self.batch_read_data_call.grid(row=2,column=0, columnspan=10, sticky=&#39;w&#39;, padx=10, pady=10)

        self.batch_options_frame.grid(row=11, column=0, columnspan=7, sticky=&#39;ew&#39;)
        self.batch_options_frame.grid_forget()
        
        separator = ttk.Separator(hvsrFrame, orient=&#39;horizontal&#39;)
        separator.grid(row=12, column=0, columnspan=7, sticky=&#39;ew&#39;, padx=10)

        
        def update_fetch_call():
            if self.trim_dir.get()==&#39;&#39;:
                trim_dir = None
            else:
                trim_dir = self.trim_dir.get()

            self.fetch_data_call.configure(text=&#34;fetch_data(params, source=&#39;{}&#39;, trim_dir={}, export_format=&#39;{}&#39;, detrend=&#39;{}&#39;, detrend_order={})&#34;
                                            .format(self.file_source.get(), trim_dir, self.export_format.get(), self.detrend.get(), self.detrend_order.get()))

        #export_format=&#39;.mseed&#39;
        
        def on_obspyFormatSelect(self):
            update_fetch_call()
        ttk.Label(hvsrFrame, text=&#34;Data Format&#34;).grid(row=13, column=1, sticky=&#39;e&#39;, padx=5)
        obspyformats =  [&#39;AH&#39;, &#39;ALSEP_PSE&#39;, &#39;ALSEP_WTH&#39;, &#39;ALSEP_WTN&#39;, &#39;CSS&#39;, &#39;DMX&#39;, &#39;GCF&#39;, &#39;GSE1&#39;, &#39;GSE2&#39;, &#39;KINEMETRICS_EVT&#39;, &#39;KNET&#39;, &#39;MSEED&#39;, &#39;NNSA_KB_CORE&#39;, &#39;PDAS&#39;, &#39;PICKLE&#39;, &#39;Q&#39;, &#39;REFTEK130&#39;, &#39;RG16&#39;, &#39;SAC&#39;, &#39;SACXY&#39;, &#39;SEG2&#39;, &#39;SEGY&#39;, &#39;SEISAN&#39;, &#39;SH_ASC&#39;, &#39;SLIST&#39;, &#39;SU&#39;, &#39;TSPAIR&#39;, &#39;WAV&#39;, &#39;WIN&#39;, &#39;Y&#39;]

        self.export_format = tk.StringVar(value=obspyformats[11])
        self.data_format_dropdown = ttk.OptionMenu(hvsrFrame, self.export_format, obspyformats[11], *obspyformats, command=on_obspyFormatSelect)
        self.data_format_dropdown.grid(row=13, column=2, columnspan=3, sticky=&#39;ew&#39;)

        #detrend=&#39;spline&#39;
        
        def on_detrend_select():
            try:
                str(self.detrend.get())
                update_fetch_call()
                return True
            except ValueError:
                return False

        sourceLabel = ttk.Label(master=hvsrFrame, text=&#34;source=&#39;raw&#39;&#34;)

        ttk.Label(master=hvsrFrame, text=&#39;Detrend type [str]&#39;).grid(row=14, column=1, sticky=&#39;e&#39;, padx=5)
        detrendFrame= ttk.Frame(hvsrFrame)
        detrendFrame.grid(row=14, column=2, sticky=&#39;w&#39;, columnspan=3)
        self.detrend = tk.StringVar()
        self.detrend.set(&#39;spline&#39;)
        ttk.Radiobutton(master=detrendFrame, text=&#39;Spline&#39;, variable=self.detrend, value=&#39;spline&#39;, command=on_detrend_select).grid(row=0, column=0, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=detrendFrame, text=&#39;Polynomial&#39;, variable=self.detrend, value=&#39;polynomial&#39;, command=on_detrend_select).grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=detrendFrame, text=&#39;None&#39;, variable=self.detrend, value=&#39;none&#39;, command=on_detrend_select).grid(row=0, column=2, sticky=&#39;w&#39;, padx=(5, 10))

        #detrend_order=2
        
        def on_detrend_order():
            try:
                int(self.detrend_order.get())
                update_fetch_call()
                return True
            except ValueError:
                return False
                     
        ttk.Label(hvsrFrame,text=&#34;Detrend Order [int]&#34;).grid(row=14,column=5, sticky=&#39;e&#39;, padx=5, pady=10)
        self.detrend_order = tk.IntVar()
        self.detrend_order.set(2)
        self.detrend_order_entry = ttk.Entry(hvsrFrame, textvariable=self.detrend_order, validate=&#39;focusout&#39;, validatecommand=on_detrend_order)
        self.detrend_order_entry.grid(row=14,column=6, sticky=&#39;w&#39;, padx=0)
        
        #trim_dir=False
        def on_trim_dir():
            try:
                str(self.trim_dir.get())
                update_fetch_call()
                return True
            except ValueError:
                return False
            
        ttk.Label(hvsrFrame, text=&#34;Output Directory (trimmed data)&#34;).grid(row=15, column=0, sticky=&#39;e&#39;, padx=5, pady=(2.5,5))
        self.trim_dir = tk.StringVar()
        self.trim_dir_entry = ttk.Entry(hvsrFrame, textvariable=self.trim_dir, validate=&#39;focusout&#39;, validatecommand=on_trim_dir)
        self.trim_dir_entry.grid(row=15, column=1, columnspan=5, sticky=&#39;ew&#39;, padx=5, pady=(2.5,5))
        
        
        def browse_trim_dir_filepath():
            filepath = filedialog.askdirectory()
            if filepath:
                self.trim_dir_entry.delete(0, &#39;end&#39;)
                self.trim_dir_entry.insert(0, filepath)
        
        self.trim_dir_filepath_button = ttk.Button(hvsrFrame, text=&#34;Browse&#34;, command=browse_trim_dir_filepath)
        self.trim_dir_filepath_button.grid(row=15, column=6, sticky=&#39;ew&#39;, padx=0, pady=(2.5,5))

        #self.starttime, self.endtime = get_times()
        input_params_LF = ttk.LabelFrame(master=self.input_tab, text=&#39;input_params() call&#39;)
        self.input_params_call = ttk.Label(master=input_params_LF, text=&#34;input_params( datapath=&#39;{}&#39;, metapath={}, site=&#39;{}&#39;, instrument=&#39;{}&#39;,\n\tnetwork=&#39;{}&#39;, station=&#39;{}&#39;, loc=&#39;{}&#39;, channels=[{}, {}, {}], \n\tacq_date=&#39;{}&#39;, starttime=&#39;{}&#39;, endttime=&#39;{}&#39;, tzone=&#39;{}&#39;, \n\txcoord={}, ycoord={}, elevation={}, input_crs=&#39;{}&#39;, output_crs=&#39;{}&#39;, elev_unit=&#39;{}&#39;,  hvsr_band=[{}, {}])&#34;.format(
                                            self.data_path.get(), self.meta_path.get(), self.site_name.get(), self.instrumentSel.get(),
                                            self.network.get(), self.station.get(), self.location.get(),
                                            self.z_channel.get(), self.e_channel.get(), self.n_channel.get(),
                                            self.acq_date, self.starttime.time(), self.endtime.time(), self.tz,
                                            self.x.get(), self.y.get(), self.z.get(), 
                                            self.input_crs.get(), self.output_crs.get(), self.elev_unit.get(), 
                                            self.hvsrBand_min.get(), self.hvsrBand_max.get()))
        self.input_params_call.pack(anchor=&#39;w&#39;, expand=True, padx=20)

        #fetch_data() call
        fetch_data_LF = ttk.LabelFrame(master=self.input_tab, text=&#39;fetch_data() call&#39;)
        self.fetch_data_call = ttk.Label(master=fetch_data_LF, text=&#34;fetch_data(params, source={}, trim_dir={}, export_format={}, detrend={}, detrend_order={})&#34;
                                                                .format(self.file_source.get(), None, self.export_format.get(), self.detrend.get(), self.detrend_order.get()))
        self.fetch_data_call.pack(anchor=&#39;w&#39;, expand=True, padx=20)

        #Set up frame for reading and running
        runFrame_hvsr = ttk.Frame(self.input_tab)

        self.style.configure(style=&#39;Custom.TButton&#39;, background=&#39;#d49949&#39;)
        self.read_button = ttk.Button(runFrame_hvsr, text=&#34;Read Data&#34;, command=read_data, width=30, style=&#39;Custom.TButton&#39;)

        self.style.configure(&#39;Run.TButton&#39;, background=&#39;#8b9685&#39;, width=10, height=3)
        self.run_button = ttk.Button(runFrame_hvsr, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)        
        self.run_button.pack(side=&#39;right&#39;, anchor=&#39;se&#39;, padx=(10,0))
        self.read_button.pack(side=&#39;right&#39;, anchor=&#39;se&#39;)

        hvsrFrame.pack(fill=&#39;both&#39;, expand=True, side=&#39;top&#39;)#.grid(row=0, sticky=&#34;nsew&#34;)
        runFrame_hvsr.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;)
        fetch_data_LF.pack(fill=&#39;x&#39;, side=&#39;bottom&#39;)
        input_params_LF.pack(fill=&#39;x&#39;, side=&#39;bottom&#39;)
        self.input_tab.pack(fill=&#39;both&#39;, expand=True)
        self.tab_control.add(self.input_tab, text=&#34;Input Params&#34;)

        #Data Preview Tab
        self.preview_data_tab = ttk.Frame(self.tab_control)

        # Configure the row and column of the input_tab to have a non-zero weight
        self.preview_data_tab.pack(expand=1)

        self.inputdataFrame = ttk.LabelFrame(self.preview_data_tab, text=&#34;Input Data Viewer&#34;)
        self.inputdataFrame.pack(expand=True, fill=&#39;both&#39;)
            
        self.inputInfoFrame = ttk.LabelFrame(self.inputdataFrame, text=&#34;Input Data Info&#34;)
        self.input_data_label = ttk.Label(self.inputInfoFrame, text=self.data_filepath_entry.get())
        self.input_data_label.pack(anchor=&#39;w&#39;, fill=&#39;both&#39;, expand=True, padx=15)                
        self.inputInfoFrame.pack(expand=True, fill=&#39;both&#39;, side=&#39;top&#39;)
        
        self.inputDataViewFrame = ttk.LabelFrame(self.inputdataFrame, text=&#34;Input Data Plot&#34;)
                    
        ttk.Label(master=self.inputInfoFrame, text=self.data_filepath_entry.get()).pack()#.grid(row=0, column=0)

        #Set up plot
        #self.fig_pre, self.ax_pre = plt.subplot_mosaic([[&#39;Z&#39;],[&#39;N&#39;],[&#39;E&#39;]], sharex=True, sharey=False)
        #self.canvas_pre = FigureCanvasTkAgg(self.fig_pre, master=self.inputDataViewFrame)
        #self.canvas_pre.draw()
        #self.canvasPreWidget = self.canvas_pre.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
        #self.canvasPreWidget.pack(expand=True, fill=&#39;both&#39;)#.grid(row=1)

        #Reset axes, figure, and canvas widget
        self.fig_pre = plt.figure()

        prev_mosaic = [[&#39;Z&#39;],[&#39;N&#39;],[&#39;E&#39;]]
        self.ax_pre = self.fig_pre.subplot_mosaic(prev_mosaic, sharex=True)  

        self.canvas_pre = FigureCanvasTkAgg(self.fig_pre, master=self.inputDataViewFrame)  # A tk.DrawingArea.
        self.canvas_pre.draw()
        self.canvasPreWidget = self.canvas_pre.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
        self.preview_toolbar = NavigationToolbar2Tk(self.canvas_pre, self.inputDataViewFrame, pack_toolbar=False)
        self.preview_toolbar.update()
    
        #self.canvas_pre.mpl_connect(&#34;button_release_event&#34;, select_windows)


        #Save preview figure
        savePrevFigFrame = ttk.Frame(master=self.inputDataViewFrame)
        
        ttk.Label(savePrevFigFrame, text=&#34;Export Figure&#34;).grid(row=0, column=0, sticky=&#39;ew&#39;, padx=5)
        self.previewFig_dir = tk.StringVar()
        self.previewFig_dir_entry = ttk.Entry(savePrevFigFrame, textvariable=self.previewFig_dir)
        self.previewFig_dir_entry.grid(row=0, column=1, columnspan=5, sticky=&#39;ew&#39;)
        
        
        def filepath_preview_fig():
            filepath = filedialog.asksaveasfilename(defaultextension=&#39;.png&#39;, initialdir=pathlib.Path(self.data_path.get()).parent)
            if filepath:
                self.previewFig_dir_entry.delete(0, &#39;end&#39;)
                self.previewFig_dir_entry.insert(0, filepath)
        
        
        def save_preview_fig():
            self.fig_pre.savefig(self.previewFig_dir.get())
        
        self.browsePreviewFig = ttk.Button(savePrevFigFrame, text=&#34;Browse&#34;,command=filepath_preview_fig)
        self.browsePreviewFig.grid(row=0, column=7, sticky=&#39;ew&#39;, padx=2.5)
        
        self.savePreviewFig = ttk.Button(savePrevFigFrame, text=&#34;Save&#34;,command=save_preview_fig)
        self.savePreviewFig.grid(row=0, column=8, columnspan=2, sticky=&#39;ew&#39;, padx=2.5)

        savePrevFigFrame.columnconfigure(1, weight=1)

        savePrevFigFrame.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, expand=False)
        self.preview_toolbar.pack(side=tk.BOTTOM, fill=tk.X)            
        self.canvasPreWidget.pack(fill=&#39;both&#39;, expand=True)#.grid(row=0, column=0, sticky=&#39;nsew&#39;)

        self.inputDataViewFrame.pack(expand=True, fill=&#39;both&#39;, side=&#39;bottom&#39;)
        
        #preview-Run button
        runFrame_dataPrev = ttk.Frame(self.preview_data_tab)
        self.run_button = ttk.Button(runFrame_dataPrev, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)
        self.run_button.pack(side=&#39;bottom&#39;, anchor=&#39;e&#39;)#.grid(row=2, column=9, columnspan=20, sticky=&#39;e&#39;)
        runFrame_dataPrev.pack(side=&#39;bottom&#39;, anchor=&#39;e&#39;)#grid(row=1, sticky=&#39;e&#39;)

        self.tab_control.add(self.preview_data_tab, text=&#34;Data Preview&#34;)

        # Noise tab
        self.noise_tab = ttk.Frame(self.tab_control)
        self.canvasFrame_noise = ttk.LabelFrame(self.noise_tab, text=&#39;Noise Viewer&#39;)

        #Helper function for updating the canvas and drawing/deleted the boxes
        
        def __draw_windows(event, pathlist, ax_key, windowDrawn, winArtist, xWindows, fig, ax):
            &#34;&#34;&#34;Helper function for updating the canvas and drawing/deleted the boxes&#34;&#34;&#34;
            for i, pa in enumerate(pathlist):
                for j, p in enumerate(pa): 
                    if windowDrawn[i][j]:
                        pass
                    else:
                        patch = matplotlib.patches.PathPatch(p, facecolor=&#39;k&#39;, alpha=0.75)                            
                        winArt = ax[ax_key].add_patch(patch)
                        windowDrawn[i][j] = True
                        winArtist[i][j] = winArt

            if event.button is MouseButton.RIGHT:
                fig.canvas.draw()

        #Helper function for manual window selection 
        
        def __draw_boxes(event, clickNo, xWindows, pathList, windowDrawn, winArtist, lineArtist, x0, fig, ax):
            &#34;&#34;&#34;Helper function for manual window selection to draw boxes to show where windows have been selected for removal&#34;&#34;&#34;
            #Create an axis dictionary if it does not already exist so all functions are the same

            if isinstance(ax, np.ndarray) or isinstance(ax, dict):
                ax = ax
            else:
                ax = {&#39;a&#39;:ax}

            
            if len(ax) &gt; 1:
                if type(ax) is not dict:
                    axDict = {}
                    for i, a in enumerate(ax):
                        axDict[str(i)] = a
                    ax = axDict
            #else:
            #    ax = {&#39;a&#39;:ax}
            
            #if event.inaxes!=ax: return
            #y0, y1 = ax.get_ylim()
            y0 = []
            y1 = []
            kList = []
            for k in ax.keys():
                kList.append(k)
                y0.append(ax[k].get_ylim()[0])
                y1.append(ax[k].get_ylim()[1])
            #else:
            #    y0 = [ax.get_ylim()[0]]
            #    y1 = [ax.get_ylim()[1]]

            if self.clickNo == 0:
                #y = np.linspace(ax.get_ylim()[0], ax.get_ylim()[1], 2)
                self.x0 = event.xdata
                self.clickNo = 1   
                self.lineArtist.append([])
                winNums = len(self.xWindows)
                for i, k in enumerate(ax.keys()):
                    linArt = ax[k].axvline(self.x0, 0, 1, color=&#39;k&#39;, linewidth=1, zorder=100)
                    self.lineArtist[winNums].append([linArt, linArt])
                #else:
                #    linArt = plt.axvline(self.x0, y0[i], y1[i], color=&#39;k&#39;, linewidth=1, zorder=100)
                #    self.lineArtist.append([linArt, linArt])
            else:
                x1 = event.xdata
                self.clickNo = 0

                windowDrawn.append([])
                winArtist.append([])  
                pathList.append([])
                winNums = len(self.xWindows)
                for i, key in enumerate(kList):
                    path_data = [
                        (matplotlib.path.Path.MOVETO, (self.x0, y0[i])),
                        (matplotlib.path.Path.LINETO, (x1, y0[i])),
                        (matplotlib.path.Path.LINETO, (x1, y1[i])),
                        (matplotlib.path.Path.LINETO, (self.x0, y1[i])),
                        (matplotlib.path.Path.LINETO, (self.x0, y0[i])),
                        (matplotlib.path.Path.CLOSEPOLY, (self.x0, y0[i])),
                    ]
                    codes, verts = zip(*path_data)
                    path = matplotlib.path.Path(verts, codes)

                    windowDrawn[winNums].append(False)
                    winArtist[winNums].append(None)

                    pathList[winNums].append(path)
                    __draw_windows(event=event, pathlist=pathList, ax_key=key, windowDrawn=windowDrawn, winArtist=winArtist, xWindows=self.xWindows, fig=fig, ax=ax)
                    linArt = ax[key].axvline(x1, 0, 1, color=&#39;k&#39;, linewidth=0.5, zorder=100)

                    [self.lineArtist[winNums][i].pop(-1)]
                    self.lineArtist[winNums][i].append(linArt)
                x_win = [self.x0, x1]
                x_win.sort() #Make sure they are in the right order
                self.xWindows.append(x_win)
            fig.canvas.draw()
            return self.clickNo, self.x0

        #Helper function for manual window selection to draw boxes to deslect windows for removal
        
        def __remove_on_right(event, xWindows, pathList, windowDrawn, winArtist,  lineArtist, fig, ax):
            &#34;&#34;&#34;Helper function for manual window selection to draw boxes to deslect windows for removal&#34;&#34;&#34;

            if self.xWindows is not None:
                for i, xWins in enumerate(self.xWindows):
                    if event.xdata &gt; xWins[0] and event.xdata &lt; xWins[1]:
                        linArtists = self.lineArtist[i]
                        pathList.pop(i)
                        for j, a in enumerate(linArtists):
                            winArtist[i][j].remove()#.pop(i)
                            self.lineArtist[i][j][0].remove()#.pop(i)#[i].pop(j)
                            self.lineArtist[i][j][1].remove()
                        windowDrawn.pop(i)
                        self.lineArtist.pop(i)#[i].pop(j)
                        winArtist.pop(i)#[i].pop(j)
                        self.xWindows.pop(i)
            fig.canvas.draw() 
               
        
        def select_windows(event, input=None, initialize=False):
            import obspy
            &#34;&#34;&#34;Function to manually select windows for exclusion from data.

            Parameters
            ----------
            input : dict
                Dictionary containing all the hvsr information.

            Returns
            -------
            self.xWindows : list
                List of two-item lists containing start and end times of windows to be removed.
            &#34;&#34;&#34;
            from matplotlib.backend_bases import MouseButton
            import matplotlib.pyplot as plt
            import matplotlib
            import time
            
            #self.fig_noise, self.ax_noise = sprit_hvsr._plot_specgram_stream(stream=input[&#39;stream&#39;], params=input, fig=self.fig_noise, ax=self.ax_noise, component=&#39;Z&#39;, stack_type=&#39;linear&#39;, detrend=&#39;mean&#39;, fill_gaps=0, dbscale=True, return_fig=True, cmap_per=[0.1,0.9])
            #self.fig_noise.canvas.draw()
            
            #if &#39;stream&#39; in input.keys():
            #    self.fig_noise, self.ax_noise = sprit_hvsr._plot_specgram_stream(stream=self.params[&#39;stream&#39;], params=self.params, fig=self.fig_noise, ax=self.ax_noise, component=&#39;Z&#39;, stack_type=&#39;linear&#39;, detrend=&#39;mean&#39;, fill_gaps=0, dbscale=True, return_fig=True, cmap_per=[0.1,0.9])
            #else:
            #    params = input.copy()
            #    input = input[&#39;stream&#39;]
            
            #if isinstance(input, obspy.core.stream.Stream):
            #    fig, ax = sprit_hvsr._plot_specgram_stream(input, component=[&#39;Z&#39;])
            #elif isinstance(input, obspy.core.trace.Trace):
            #    fig, ax = sprit_hvsr._plot_specgram_stream(input)
            if initialize:
                self.lineArtist = []
                self.winArtist = []
                self.windowDrawn = []
                self.pathList = []
                self.xWindows = []
                self.x0 = 0
                self.clickNo = 0
            
            if not initialize:
                __on_click(event)
                self.hvsr_data[&#39;xwindows_out&#39;] = self.xWindows


                #self.fig_closed
                #fig_closed = False
                #while fig_closed is False:
                #    #fig.canvas.mpl_connect(&#39;button_press_event&#39;, __on_click)#(self.clickNo, self.xWindows, pathList, windowDrawn, winArtist, lineArtist, self.x0, fig, ax))
                #    fig.canvas.mpl_connect(&#39;close_event&#39;, _on_fig_close)#(self.clickNo, self.xWindows, pathList, windowDrawn, winArtist, lineArtist, self.x0, fig, ax))
                #    plt.pause(0.5)
                
                #output[&#39;xwindows_out&#39;] = self.xWindows
                #output[&#39;fig&#39;] = fig
                #output[&#39;ax&#39;] = ax
                noEvent = True
            return self.hvsr_data

        #Support function to help select_windows run properly
        
        def _on_fig_close(event):
            self.fig_closed
            fig_closed = True
            return

        
        def __on_click(event):

            if event.button is MouseButton.RIGHT:
                __remove_on_right(event, self.xWindows, self.pathList, self.windowDrawn, self.winArtist, self.lineArtist, self.fig_noise, self.ax_noise)

            if event.button is MouseButton.LEFT:            
                self.clickNo, self.x0 = __draw_boxes(event, self.clickNo, self.xWindows, self.pathList, self.windowDrawn, self.winArtist, self.lineArtist, self.x0, self.fig_noise, self.ax_noise)    

        
        def plot_noise_windows(hvsr_data, initial_setup=False):
            if isinstance(hvsr_data, sprit_hvsr.HVSRBatch):
                batch_data = hvsr_data.copy()
                hvsr_data = hvsr_data[list(hvsr_data.keys())[0]]
            else:
                batch_data = None

            if initial_setup:
                self.xWindows=[]
            else:
                #Clear everything
                for key in self.ax_noise:
                    self.ax_noise[key].clear()
                self.fig_noise.clear()

                #Really make sure it&#39;s out of memory
                self.fig_noise = []
                self.ax_noise = []
                try:
                    self.fig_noise.get_children()
                except:
                    pass
                try:
                    self.ax_noise.get_children()
                except:
                    pass

            #Reset axes, figure, and canvas widget
            self.fig_noise = plt.figure()
    
            noise_mosaic = [[&#39;spec&#39;],[&#39;spec&#39;],[&#39;spec&#39;],
                    [&#39;spec&#39;],[&#39;spec&#39;],[&#39;spec&#39;],
                    [&#39;signalz&#39;],[&#39;signalz&#39;], [&#39;signaln&#39;], [&#39;signale&#39;]]
            self.ax_noise = self.fig_noise.subplot_mosaic(noise_mosaic, sharex=True)  

            if not initial_setup:
                self.noise_canvasWidget.destroy()
                self.noise_toolbar.destroy()
                self.fig_noise, self.ax_noise = sprit_hvsr._plot_specgram_stream(stream=hvsr_data[&#39;stream&#39;], params=hvsr_data, fig=self.fig_noise, ax=self.ax_noise, component=&#39;Z&#39;, stack_type=&#39;linear&#39;, detrend=&#39;mean&#39;, fill_gaps=0, dbscale=True, return_fig=True, cmap_per=[0.1,0.9])

            self.noise_canvas = FigureCanvasTkAgg(self.fig_noise, master=self.canvasFrame_noise)  # A tk.DrawingArea.
            self.noise_canvas.draw()
            #self.noise_canvasWidget = self.noise_canvas.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
            # pack_toolbar=False will make it easier to use a layout manager later on.
            self.noise_toolbar = NavigationToolbar2Tk(self.noise_canvas, self.canvasFrame_noise, pack_toolbar=False)
            self.noise_toolbar.update()
        
            self.noise_canvasWidget = self.noise_canvas.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
            self.noise_canvas.mpl_connect(&#34;button_release_event&#34;, select_windows)

            self.noise_toolbar.pack(side=tk.BOTTOM, fill=tk.X)            
            self.noise_canvasWidget.pack(fill=&#39;both&#39;)#.grid(row=0, column=0, sticky=&#39;nsew&#39;)

            if not initial_setup:
                if batch_data is None:
                    batch_data = {&#39;SITENAME&#39;:hvsr_data}

                for i, (k, hv_data) in enumerate(batch_data.items()):
                    #Reset edited data every time plot_noise_windows is run
                    hv_data[&#39;stream_edited&#39;] = hv_data[&#39;stream&#39;].copy()
                    
                    #Set initial input
                    input = hv_data[&#39;stream&#39;]

                    #print(input[0].stats.starttime)
                    if self.do_stalta.get():
                        hv_data[&#39;stream_edited&#39;] = sprit_hvsr.remove_noise(input=input, kind=&#39;stalta&#39;, sta=self.sta.get(), lta=self.lta.get(), stalta_thresh=[self.stalta_thresh_low.get(), self.stalta_thresh_hi.get()])
                        input = hv_data[&#39;stream_edited&#39;]

                    if self.do_pctThresh.get():
                        hv_data[&#39;stream_edited&#39;] = sprit_hvsr.remove_noise(input=input, kind=&#39;saturation&#39;,  sat_percent=self.pct.get(), min_win_size=self.win_size_sat.get())
                        input = hv_data[&#39;stream_edited&#39;]

                    if self.do_noiseWin.get():
                        hv_data[&#39;stream_edited&#39;] = sprit_hvsr.remove_noise(input=input, kind=&#39;noise&#39;, noise_percent=self.noise_amp_pct.get(), lta=self.lta_noise.get(), min_win_size=self.win_size_thresh.get())
                        input = hv_data[&#39;stream_edited&#39;]
                
                    if self.do_warmup.get():
                        hv_data[&#39;stream_edited&#39;] = sprit_hvsr.remove_noise(input=input, kind=&#39;warmup&#39;, warmup_time=self.warmup_time.get(), cooldown_time=self.cooldown_time.get())

                    if i==0:
                        self.fig_noise, self.ax_noise, self.noise_windows_line_artists, self.noise_windows_window_artists = sprit_hvsr._get_removed_windows(input=hvsr_data, fig=self.fig_noise, ax=self.ax_noise, existing_xWindows=self.xWindows, time_type=&#39;matplotlib&#39;)
                        self.fig_noise.canvas.draw()
                return hvsr_data
            
            self.fig_noise.canvas.draw()
            return

        plot_noise_windows(None, initial_setup=True)
        self.canvasFrame_noise.pack(fill=&#39;both&#39;)#.grid(row=0, column=0, sticky=&#34;nsew&#34;)

        #noise_mosaic = [[&#39;spec&#39;],[&#39;spec&#39;],[&#39;spec&#39;],
        #        [&#39;spec&#39;],[&#39;spec&#39;],[&#39;spec&#39;],
        #        [&#39;signalz&#39;],[&#39;signalz&#39;], [&#39;signaln&#39;], [&#39;signale&#39;]]
        #self.fig_noise, self.ax_noise = plt.subplot_mosaic(noise_mosaic, sharex=True)  
        #self.canvasFrame_noise = ttk.LabelFrame(self.noise_tab, text=&#39;Noise Viewer&#39;)
        #self.canvasFrame_noise.pack(fill=&#39;both&#39;)#.grid(row=0, column=0, sticky=&#34;nsew&#34;)

        #self.noise_canvas = FigureCanvasTkAgg(self.fig_noise, master=self.canvasFrame_noise)
        #self.noise_canvas.draw()
        #self.noise_canvasWidget = self.noise_canvas.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
        #self.noise_canvasWidget.pack(fill=&#39;both&#39;)#.grid(row=0, column=0, sticky=&#39;nsew&#39;)

        #Run button frame
        runFrame_noise = ttk.Frame(self.noise_tab)
        
        #Run area
        #Update Noise Windows button
        self.style.configure(style=&#39;Noise.TButton&#39;, background=&#39;#86a5ba&#39;)
        self.noise_button = ttk.Button(runFrame_noise, text=&#34;Update Noise Windows&#34;, command=plot_noise_windows, width=30, style=&#39;Noise.TButton&#39;)

        self.noise_windows_line_artists = []
        self.noise_windows_window_artists = []

        self.style.configure(&#39;Run.TButton&#39;, background=&#39;#8b9685&#39;, width=10, height=3)
        self.run_button = ttk.Button(runFrame_noise, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)        
        self.run_button.pack(side=&#39;right&#39;, anchor=&#39;se&#39;, padx=(10,0))
        self.noise_button.pack(side=&#39;right&#39;, anchor=&#39;se&#39;)

        runFrame_noise.pack(fill=&#39;both&#39;,side=&#39;bottom&#39;, anchor=&#39;e&#39;)    

        #Plot adjustment Frame
        pltAdjustFrame = ttk.LabelFrame(self.noise_tab, text=&#39;Adjust Plot&#39;)
        pltAdjustFrame.pack(fill=&#39;both&#39;, side=&#39;right&#39;)#.grid(row=0, column=1, sticky=&#39;nsew&#39;)

        ttk.Label(master=pltAdjustFrame, text=&#39;Adjustment Parameters (in progress)&#39;).grid(row=0, column=0)

        noiseFrame = ttk.LabelFrame(self.noise_tab, text=&#39;Noise Removal&#39;)
        noiseFrame.pack(fill=&#39;both&#39;)#.grid(row=1, columnspan=2, sticky=&#39;nsew&#39;)
        
        #Options for manually removing windows
        windowremoveFrame = ttk.LabelFrame(noiseFrame, text=&#39;Manual Window Removal&#39;)
        windowremoveFrame.grid(row=0, column=1, columnspan=1, sticky=&#39;nsew&#39;)
        self.do_window = tk.BooleanVar() # create a BooleanVar to store the state of the Checkbutton
        manualBool = ttk.Checkbutton(master=windowremoveFrame, text=&#34;&#34;, variable=self.do_window) # create the Checkbutton widget
        manualBool.grid(row=0, column=0, sticky=&#39;ew&#39;)
        
        
        def remove_windows_manually():
            #Placeholderfunction
            print(&#39;Ok, this button may not need to do anything&#39;)
            #Plot data in noise preview tab

        self.select_windows = ttk.Button(master=windowremoveFrame, text=&#34;Remove Windows&#34;, command=remove_windows_manually) # create the Checkbutton widget
        self.select_windows.grid(row=0, column=1, sticky=&#39;e&#39;)

        #Options for doing stalta antitrigger for noise removal
        stltaremoveFrame = ttk.LabelFrame(noiseFrame, text=&#39;STA/LTA Antitrigger&#39;)
        stltaremoveFrame.grid(row=0, column=0, columnspan=1, sticky=&#39;nsew&#39;)
        
        self.do_stalta = tk.BooleanVar()
        staltaBool = ttk.Checkbutton(master=stltaremoveFrame, text=&#34;&#34;, variable=self.do_stalta) # create the Checkbutton widget
        staltaBool.grid(row=0, column=0, sticky=&#39;ew&#39;)
        
        ttk.Label(master=stltaremoveFrame, text=&#34;STA [s]&#34;).grid(row=0, column=1)
        self.sta = tk.DoubleVar()
        self.sta.set(5)
        staEntry = ttk.Entry(master=stltaremoveFrame, textvariable=self.sta, width=5) # create the Entry widget
        staEntry.grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5,10))

        ttk.Label(master=stltaremoveFrame, text=&#34;LTA [s]&#34;).grid(row=0, column=3)
        self.lta = tk.DoubleVar()
        self.lta.set(30)
        ltaEntry = ttk.Entry(master=stltaremoveFrame, textvariable=self.lta, width=5) # create the Entry widget
        ltaEntry.grid(row=0, column=4, sticky=&#39;ew&#39;, padx=(5,10))

        ttk.Label(master=stltaremoveFrame, text=&#34;STA/LTA Thresholds (Low, High)&#34;).grid(row=0, column=5)
        self.stalta_thresh_low = tk.DoubleVar()
        self.stalta_thresh_low.set(0.5)
        staltaLowEntry = ttk.Entry(master=stltaremoveFrame, textvariable=self.stalta_thresh_low, width=5) # create the Entry widget
        staltaLowEntry.grid(row=0, column=6, sticky=&#39;ew&#39;, padx=(5,0))
        
        self.stalta_thresh_hi = tk.DoubleVar()
        self.stalta_thresh_hi.set(5)
        staltaHiEntry = ttk.Entry(master=stltaremoveFrame, textvariable=self.stalta_thresh_hi, width=5) # create the Entry widget
        staltaHiEntry.grid(row=0, column=7, sticky=&#39;ew&#39;)
        
        #Options for Percentage threshold removal
        pctThresFrame = ttk.LabelFrame(noiseFrame, text=&#39;Percentage Threshold&#39;)
        pctThresFrame.grid(row=1, column=0, sticky=&#39;nsew&#39;)

        self.do_pctThresh= tk.BooleanVar()
        pctBool = ttk.Checkbutton(master=pctThresFrame, text=&#34;&#34;, variable=self.do_pctThresh) # create the Checkbutton widget
        pctBool.grid(row=0, column=0, sticky=&#39;ew&#39;)
 
        ttk.Label(master=pctThresFrame, text=&#34;Max Instantaneous %&#34;).grid(row=0, column=1)
        self.pct = tk.DoubleVar()
        self.pct.set(0.995)
        pctEntry = ttk.Entry(master=pctThresFrame, textvariable=self.pct, width=10) # create the Entry widget
        pctEntry.grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5,10))

        ttk.Label(master=pctThresFrame, text=&#34;&#34;, width=27).grid(row=0, column=3, columnspan=2)

        ttk.Label(master=pctThresFrame, text=&#34;Min. Window Size [sec]&#34;).grid(row=0, column=5, sticky=&#39;e&#39;)
        self.win_size_sat = tk.DoubleVar()
        self.win_size_sat.set(0)
        win_size_Entry = ttk.Entry(master=pctThresFrame, textvariable=self.win_size_sat, width=10) # create the Entry widget
        win_size_Entry.grid(row=0, column=6, sticky=&#39;e&#39;, padx=(5,10))

        #Options for noisy window
        noisyWindowFrame = ttk.LabelFrame(noiseFrame, text=&#39;Noisy Windows&#39;)
        noisyWindowFrame.grid(row=2, column=0, sticky=&#39;nsew&#39;)

        self.do_noiseWin = tk.BooleanVar()
        winNoiseBool = ttk.Checkbutton(master=noisyWindowFrame, text=&#34;&#34;, variable=self.do_noiseWin) # create the Checkbutton widget
        winNoiseBool.grid(row=0, column=0, sticky=&#39;ew&#39;)
 
        ttk.Label(master=noisyWindowFrame, text=&#34;Max Window %&#34;).grid(row=0, column=1)
        self.noise_amp_pct = tk.DoubleVar()
        self.noise_amp_pct.set(0.80)
        winamppctEntry = ttk.Entry(master=noisyWindowFrame, textvariable=self.noise_amp_pct, width=10) # create the Entry widget
        winamppctEntry.grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5,10))

        ttk.Label(master=noisyWindowFrame, text=&#34;Window Length [sec]&#34;).grid(row=0, column=3)
        self.lta_noise = tk.DoubleVar()
        self.lta_noise.set(30)
        winamppctEntry = ttk.Entry(master=noisyWindowFrame, textvariable=self.lta_noise, width=10) # create the Entry widget
        winamppctEntry.grid(row=0, column=4, sticky=&#39;ew&#39;, padx=(5,10))

        ttk.Label(master=noisyWindowFrame, text=&#34;Min. Window Size [sec]&#34;).grid(row=0, column=5)
        self.win_size_thresh = tk.DoubleVar()
        self.win_size_thresh.set(0)
        win_size_Entry = ttk.Entry(master=noisyWindowFrame, textvariable=self.win_size_thresh, width=10) # create the Entry widget
        win_size_Entry.grid(row=0, column=6, sticky=&#39;e&#39;, padx=(5,10))

        #Options for warmup
        warmupFrame = ttk.LabelFrame(noiseFrame, text=&#39;Warmup &amp; Cooldown Time&#39;)
        warmupFrame.grid(row=3, column=0, sticky=&#39;nsew&#39;)

        self.do_warmup= tk.BooleanVar()
        warmupBool = ttk.Checkbutton(master=warmupFrame, text=&#34;&#34;, variable=self.do_warmup) # create the Checkbutton widget
        warmupBool.grid(row=0, column=0, sticky=&#39;ew&#39;)
 
        ttk.Label(master=warmupFrame, text=&#34;Warmup time [s]&#34;).grid(row=0, column=1)
        self.warmup_time = tk.DoubleVar()
        warmupEntry = ttk.Entry(master=warmupFrame, textvariable=self.warmup_time, width=10) # create the Entry widget
        warmupEntry.grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5,10))
        warmupEntry.delete(0, &#39;end&#39;)
        warmupEntry.insert(0, &#39;0&#39;)
 
        ttk.Label(master=warmupFrame, text=&#34;Cooldown Time [s]&#34;).grid(row=0, column=3)
        self.cooldown_time = tk.DoubleVar()
        cooldownEntry = ttk.Entry(master=warmupFrame, textvariable=self.cooldown_time, width=10) # create the Entry widget
        cooldownEntry.grid(row=0, column=5, sticky=&#39;ew&#39;, padx=(5,10))
        cooldownEntry.delete(0, &#39;end&#39;)
        cooldownEntry.insert(0, &#39;0&#39;)

        #Options for doing stdev noise removal
        stdremoveFrame = ttk.LabelFrame(noiseFrame, text=&#39;Standard Deviation Antitrigger (not yet implemented)&#39;)
        stdremoveFrame.grid(row=1, column=1, columnspan=1, sticky=&#39;nsew&#39;)
        
        self.do_stdev = tk.BooleanVar()
        stdBool = ttk.Checkbutton(master=stdremoveFrame, text=&#34;&#34;, variable=self.do_stdev, state=&#39;disabled&#39;) # create the Checkbutton widget
        stdBool.grid(row=0, column=0, sticky=&#39;ew&#39;)
        
        ttk.Label(master=stdremoveFrame, text=&#34;Std Deviation Ratio (moving stdev/total stdev)&#34;).grid(row=0, column=1)
        self.stdRatio = tk.DoubleVar()
        stdRatEntry = ttk.Entry(master=stdremoveFrame, textvariable=self.stdRatio, width=5, state=&#39;disabled&#39;) # create the Entry widget
        stdRatEntry.grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5,10))
        stdRatEntry.delete(0, &#39;end&#39;)
        stdRatEntry.insert(0, &#39;1&#39;)
        
        ttk.Label(master=stdremoveFrame, text=&#34;Window Length [s]&#34;).grid(row=0, column=3)
        self.stdWinLen = tk.DoubleVar()
        stdWinLenEntry = ttk.Entry(master=stdremoveFrame, textvariable=self.stdWinLen, width=5, state=&#39;disabled&#39;) # create the Entry widget
        stdWinLenEntry.grid(row=0, column=4, sticky=&#39;ew&#39;, padx=(5,10))
        stdWinLenEntry.delete(0, &#39;end&#39;)
        stdWinLenEntry.insert(0, &#39;5&#39;)

        #Quick set the auto 
        autoFrame = ttk.LabelFrame(noiseFrame, text=&#39;Auto Run&#39;)
        autoFrame.grid(row=2, column=1, columnspan=1, sticky=&#39;nsew&#39;)

        
        def set_auto():
            if self.do_auto.get():
                self.do_stalta.set(True)
                self.do_stdev.set(True)
                self.do_warmup.set(True)
                self.do_noiseWin.set(True)
                self.do_pctThresh.set(True)
            else:
                pass

        self.do_auto= tk.BooleanVar()
        autoBool = ttk.Checkbutton(master=autoFrame, text=&#34;&#34;, variable=self.do_auto, command=set_auto) # create the Checkbutton widget
        autoBool.grid(row=0, column=0, sticky=&#39;ew&#39;)   

        #Export noise windows
        ttk.Label(noiseFrame, text=&#34;Export Figure&#34;).grid(row=4, column=0, sticky=&#39;ew&#39;, padx=5)
        self.results_noise_dir = tk.StringVar()
        self.results_noise_dir_entry = ttk.Entry(noiseFrame, textvariable=self.results_noise_dir)
        self.results_noise_dir_entry.grid(row=4, column=0, columnspan=5, sticky=&#39;ew&#39;, padx=(100,5))
        
        
        def filepath_noise_fig():
            filepath = filedialog.asksaveasfilename(defaultextension=&#39;png&#39;, initialdir=pathlib.Path(self.data_path.get()).parent, initialfile=self.params[&#39;site&#39;]+&#39;_noisewindows.png&#39;)
            if filepath:
                self.results_noise_dir_entry.delete(4, &#39;end&#39;)
                self.results_noise_dir_entry.insert(4, filepath)
        
        
        def save_noise_fig():
            self.fig_noise.savefig(self.results_noise_dir.get())
        
        self.browse_noise_fig = ttk.Button(noiseFrame, text=&#34;Browse&#34;,command=filepath_noise_fig)
        self.browse_noise_fig.grid(row=4, column=7, sticky=&#39;ew&#39;, padx=2.5)
        
        self.save_noise_fig = ttk.Button(noiseFrame, text=&#34;Save&#34;,command=save_noise_fig)
        self.save_noise_fig.grid(row=4, column=8, columnspan=2, sticky=&#39;ew&#39;, padx=2.5)

        self.noise_tab.pack(expand=1)
        self.tab_control.add(self.noise_tab, text=&#34;Noise&#34;)

        # SETTINGS TAB
        self.settings_tab = ttk.Frame(self.tab_control)
        
        self.tab_control.add(self.settings_tab, text=&#34;Settings&#34;)
        
        # Create a new Notebook widget within the Settings tab
        settings_notebook = ttk.Notebook(self.settings_tab)

        # Create the tabs within the Settings tab
        #PPSD SETTINGS SUBTAB
        ppsd_settings_tab = ttk.Frame(settings_notebook)
        ppsdSettingsFrame = ttk.LabelFrame(ppsd_settings_tab, text=&#39;Input Settings&#39;)#.pack(fill=&#39;both&#39;)
        ppsdParamsFrame = ttk.LabelFrame(ppsd_settings_tab, text=&#39;PPSD Parameters&#39;)#.pack(fill=&#39;both&#39;)

        # ppsd_length=30.0
        
        def on_ppsd_length():
            try:
                float(self.ppsd_length.get())
                ppsdLenLabel.configure(text=&#39;ppsd_length={}&#39;.format(self.ppsd_length.get()))
                update_ppsd_call(self.ppsd_call)
                return True
            except ValueError:
                return False
        ppsdLenLabel = ttk.Label(master=ppsdParamsFrame, text=&#39;ppsd_length=30.0 &#39;)#.grid(row=0, column=0)
        ppsdLenLabel.grid(row=0, column=0, sticky=&#39;w&#39;, pady=(6,6), padx=5)
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;PPSD Length (in seconds) [float]&#39;).grid(row=0, column=0, sticky=&#39;w&#39;, padx=5)
        self.ppsd_length = tk.DoubleVar()
        self.ppsd_length.set(30)
        ppsdLenEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=self.ppsd_length, width=10, validate=&#39;focusout&#39;, validatecommand=on_ppsd_length)
        ppsdLenEntry.grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))

        # overlap=0.5, 
        
        def on_overlap():
            try:
                overlap = float(self.overlap.get())
                if overlap &gt; 1:
                    self.overlap.set(overlap/100)
                overlapLabel.configure(text=&#39;overlap={}&#39;.format(self.overlap.get()))
                update_ppsd_call(self.ppsd_call)
                return True
            except ValueError:
                return False
        overlapLabel = ttk.Label(master=ppsdParamsFrame, text=&#39;overlap=0.5 &#39;)#.grid(row=0, column=0)
        overlapLabel.grid(row=1, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Overlap % (0-1) [float]&#39;).grid(row=1, column=0, sticky=&#39;w&#39;, padx=5)
        self.overlap = tk.DoubleVar()
        self.overlap.set(0.5)
        overlapEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=self.overlap, width=10, validate=&#39;focusout&#39;, validatecommand=on_overlap)
        overlapEntry.grid(row=1, column=1, sticky=&#39;w&#39;, padx=(5, 10))

        # period_step_octaves=0.0625, 
        
        def on_per_step_oct():
            try:
                float(self.perStepOct.get())
                
                pStepOctLabel.configure(text=&#39;period_step_octaves={}&#39;.format(self.perStepOct.get()))
                update_ppsd_call(self.ppsd_call)            
                return True
            except ValueError:
                return False
        pStepOctLabel = ttk.Label(master=ppsdParamsFrame, text=&#39;period_step_octaves=0.0625&#39;)#.grid(row=0, column=0)
        pStepOctLabel.grid(row=2, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Period Step Octave [float]&#39;).grid(row=2, column=0, sticky=&#39;w&#39;, padx=5)
        self.perStepOct = tk.DoubleVar()
        self.perStepOct.set(0.0625)
        pStepOctEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=self.perStepOct, width=10, validate=&#39;focusout&#39;, validatecommand=on_per_step_oct)
        pStepOctEntry.grid(row=2, column=1, sticky=&#39;w&#39;, padx=(5, 10))

        #skip_on_gaps
        
        def show_sog():
            if self.skip_on_gaps.get():
                sogLabel.configure(text =&#39;skip_on_gaps=True&#39;)
            else:
                sogLabel.configure(text =&#39;skip_on_gaps=False&#39;)
            update_ppsd_call(self.ppsd_call)
            
        self.skip_on_gaps = tk.BooleanVar()
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Skip on Gaps [bool]: &#39;, justify=&#39;left&#39;).grid(row=3, column=0, sticky=&#39;w&#39;, padx=5)
        sogCheckButton = ttk.Checkbutton(master=ppsdSettingsFrame, text=&#39;&#39;, variable=self.skip_on_gaps, command=show_sog) # create the Entry widget
        sogCheckButton.grid(row=3, column=1, sticky=&#39;ew&#39;, padx=(5,10))
        sogLabel = ttk.Label(master=ppsdParamsFrame, text=&#39;skip_on_gaps=False&#39;)
        sogLabel.grid(row=3, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

        # db_bins=(-200, -50, 1.0), 
        
        def show_dbbins():
            try:
                float(minDB.get())
                float(maxDB.get())
                float(dB_step.get())
                dbbinsLabel.configure(text=&#39;db_bins=({}, {}, {})&#39;.format(
                    minDB.get(), maxDB.get(), dB_step.get()))
                self.db_bins = (minDB.get(), maxDB.get(), dB_step.get())
                update_ppsd_call(self.ppsd_call)
                return True
            except ValueError:
                return False

        dbbinsLabel = ttk.Label(master=ppsdParamsFrame,
                                text=&#39;db_bins=(-200, -50, 1.0)&#39;)
        dbbinsLabel.grid(row=4, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
        ttk.Label(master=ppsdSettingsFrame, text=&#39;dB Bins (Y Axis) [tuple]&#39;, justify=&#39;left&#39;).grid(row=4, column=0, sticky=&#39;w&#39;, padx=5)
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Min. dB&#39;).grid(row=4, column=1, sticky=&#39;e&#39;, padx=5)
        minDB = tk.DoubleVar()
        minDB.set(-200)
        minDBEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=minDB,
                            validate=&#34;focusout&#34;, validatecommand=show_dbbins, width=10)
        minDBEntry.grid(row=4, column=2, sticky=&#39;w&#39;, padx=(5, 10))
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Max. dB&#39;).grid(row=4, column=3, sticky=&#39;e&#39;, padx=5)
        maxDB = tk.DoubleVar()
        maxDB.set(-50)
        maxDBEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=maxDB,
                            validate=&#34;focusout&#34;, validatecommand=show_dbbins, width=10)
        maxDBEntry.grid(row=4, column=4, sticky=&#39;w&#39;, padx=(5, 10))

        ttk.Label(master=ppsdSettingsFrame, text=&#39;dB Step&#39;).grid(row=4, column=5, sticky=&#39;e&#39;, padx=5)
        dB_step = tk.DoubleVar()
        dB_step.set(1.0)
        stepEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=dB_step,
                            validate=&#34;focusout&#34;, validatecommand=(show_dbbins), width=10)
        stepEntry.grid(row=4, column=6, sticky=&#39;w&#39;, padx=(5, 10))
        self.db_bins = (minDB.get(), maxDB.get(), dB_step.get())

        # period_limits=None,
        
        def show_per_lims():
            try:
                if minPerLim.get() == &#39;None&#39;:
                    pass
                else:
                    float(minPerLim.get())
                    
                if maxPerLim.get() == &#39;None&#39;:
                    pass
                else:
                    float(maxPerLim.get())
                    
                if minPerLim.get() == &#39;None&#39; or maxPerLim.get() == &#39;None&#39;:
                    perLimsLabel.configure(text=&#39;period_limits=None&#39;)
                else:
                    perLimsLabel.configure(text=&#39;period_limits=[{}, {}]&#39;.format(minPerLim.get(), maxPerLim.get()))
                    self.period_limits = [float(minPerLim.get()), float(maxPerLim.get())]
                update_ppsd_call(self.ppsd_call)
                return True
            except ValueError:
                return False

        perLimsLabel = ttk.Label(master=ppsdParamsFrame,
                                text=&#39;period_limits=None&#39;)
        perLimsLabel.grid(row=5, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Period Limits [list of floats or None]&#39;, justify=&#39;left&#39;).grid(row=5, column=0, sticky=&#39;w&#39;, padx=5)
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Min. Period Limit&#39;).grid(row=5, column=1, sticky=&#39;e&#39;, padx=5)
        minPerLim = tk.StringVar()
        minPerLim.set(None)
        minPerLimEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=minPerLim,
                            validate=&#34;focusout&#34;, validatecommand=(show_per_lims), width=10)
        minPerLimEntry.grid(row=5, column=2, sticky=&#39;w&#39;, padx=(5, 10))
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Max. Period Limit&#39;).grid(row=5, column=3, sticky=&#39;e&#39;, padx=5)
        maxPerLim = tk.StringVar()
        maxPerLim.set(None)
        maxPerLimEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=maxPerLim,
                            validate=&#34;focusout&#34;, validatecommand=(show_per_lims), width=10)
        maxPerLimEntry.grid(row=5, column=4, sticky=&#39;w&#39;, padx=(5, 10))

        if minPerLim.get() == &#39;None&#39; or maxPerLim.get() == &#39;None&#39;:
            self.period_limits=None
        else:
            self.period_limits = [float(minPerLim.get()), float(maxPerLim.get())]

        # period_smoothing_width_octaves=1.0,
        
        def on_per_smoothwidth_oct():
            try:
                float(self.perSmoothWidthOct.get())
                
                pSmoothWidthLabel.configure(text=&#39;period_smoothing_width_octaves={}&#39;.format(self.perSmoothWidthOct.get()))
                update_ppsd_call(self.ppsd_call)
                return True
            except ValueError:
                return False
        pSmoothWidthLabel = ttk.Label(master=ppsdParamsFrame, text=&#39;period_smoothing_width_octaves=1.0&#39;)#.grid(row=0, column=0)
        pSmoothWidthLabel.grid(row=6, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Period Smoothing Width (octaves) [float]&#39;).grid(row=6, column=0, sticky=&#39;w&#39;, padx=5)
        self.perSmoothWidthOct = tk.DoubleVar()
        self.perSmoothWidthOct.set(1.0)
        pSmoothWidthEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=self.perSmoothWidthOct, width=10, validate=&#39;focusout&#39;, validatecommand=on_per_smoothwidth_oct)
        pSmoothWidthEntry.grid(row=6, column=1, sticky=&#39;w&#39;, padx=(5, 10))
        
        # special_handling=None, 
        
        def on_special_handling():
            try:
                str(self.special_handling.get())
                if self.special_handling.get() == &#39;None&#39;:
                    specialHandlingLabel.configure(text=&#34;special_handling={}&#34;.format(self.special_handling.get()))
                    special_handling = None
                else:
                    specialHandlingLabel.configure(text=&#34;special_handling=&#39;{}&#39;&#34;.format(self.special_handling.get()))
                    special_handling = self.special_handling.get()
                update_ppsd_call(self.ppsd_call)
                return True
            except ValueError:
                return False

        specialHandlingLabel = ttk.Label(master=ppsdParamsFrame, text=&#34;special_handling=None&#34;)
        specialHandlingLabel.grid(row=7, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

        ttk.Label(master=ppsdSettingsFrame, text=&#39;Special Handling [str]&#39;).grid(row=7, column=0, sticky=&#39;w&#39;, padx=5)

        self.special_handling = tk.StringVar()
        self.special_handling.set(&#39;None&#39;)
        ttk.Radiobutton(master=ppsdSettingsFrame, text=&#39;None&#39;, variable=self.special_handling, value=&#39;None&#39;, command=on_special_handling).grid(row=7, column=1, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=ppsdSettingsFrame, text=&#39;Ringlaser&#39;, variable=self.special_handling, value=&#39;ringlaser&#39;, command=on_special_handling).grid(row=7, column=2, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=ppsdSettingsFrame, text=&#39;Hydrophone&#39;, variable=self.special_handling, value=&#39;hydrophone&#39;, command=on_special_handling).grid(row=7, column=3, sticky=&#39;w&#39;, padx=(5, 10))

        if self.special_handling.get()==&#39;None&#39;:
            special_handling = None
        else:
            special_handling = self.special_handling.get()

        separator = ttk.Separator(ppsdSettingsFrame, orient=&#39;horizontal&#39;)
        separator.grid(row=8, columnspan=8, sticky=&#39;ew&#39;, pady=10, padx=5)

        separator = ttk.Separator(ppsdParamsFrame, orient=&#39;horizontal&#39;)
        separator.grid(row=8, sticky=&#39;ew&#39;, pady=10, padx=5)

        #remove_outliers
        
        def show_rem_outliers():
            if self.remove_outliers.get():
                rem_outliers_Label.configure(text =&#39;remove_outliers=True&#39;)
            else:
                rem_outliers_Label.configure(text =&#39;remove_outliers=False&#39;)
            update_ppsd_call(self.ppsd_call)
            
        self.remove_outliers = tk.BooleanVar()
        self.remove_outliers.set(True)
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Remove outlier curves [bool]: &#39;, justify=&#39;left&#39;).grid(row=9, column=0, sticky=&#39;w&#39;, padx=5)
        rem_outliers_CheckButton = ttk.Checkbutton(master=ppsdSettingsFrame, text=&#39;&#39;, variable=self.remove_outliers, command=show_rem_outliers) # create the Entry widget
        rem_outliers_CheckButton.grid(row=9, column=1, sticky=&#39;ew&#39;, padx=(5,10))
        rem_outliers_Label = ttk.Label(master=ppsdParamsFrame, text=&#39;remove_outliers=True&#39;)
        rem_outliers_Label.grid(row=9, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

        # outlier_std=1.5, 
        
        def on_outlier_std():
            try:
                float(self.outlier_std.get())
                outlier_std_Label.configure(text=&#39;outlier_std={}&#39;.format(self.outlier_std.get()))
                update_ppsd_call(self.ppsd_call)            
                return True
            except ValueError:
                return False
        outlier_std_Label = ttk.Label(master=ppsdParamsFrame, text=&#39;outlier_std=1.5&#39;)#.grid(row=0, column=0)
        outlier_std_Label.grid(row=10, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;St. Dev. for Outliers [float]&#39;).grid(row=10, column=0, sticky=&#39;w&#39;, padx=5)
        self.outlier_std = tk.DoubleVar()
        self.outlier_std.set(1.5)
        outlier_std_Entry = ttk.Entry(master=ppsdSettingsFrame, textvariable=self.outlier_std, width=10, validate=&#39;focusout&#39;, validatecommand=on_outlier_std)
        outlier_std_Entry.grid(row=10, column=1, sticky=&#39;w&#39;, padx=(5, 10))


        #PPSD Function Call
        ppsdCallFrame = ttk.LabelFrame(ppsd_settings_tab, text=&#39;sprit_hvsr.generate_ppsds() and obspy PPSD() call&#39;)#.pack(fill=&#39;both&#39;) 
       
        self.ppsd_call = ttk.Label(master=ppsdCallFrame, text=&#39;obspy...PPSD({}, {}, {}, {}, {}, {}, \n\t{}, {}, {}, {})&#39;
                  .format(&#39;stats&#39;, &#39;metadata&#39;, ppsdLenLabel.cget(&#39;text&#39;), overlapLabel.cget(&#39;text&#39;), pStepOctLabel.cget(&#39;text&#39;), sogLabel.cget(&#39;text&#39;), 
                          dbbinsLabel.cget(&#39;text&#39;), perLimsLabel.cget(&#39;text&#39;), pSmoothWidthLabel.cget(&#39;text&#39;), specialHandlingLabel.cget(&#39;text&#39;)))
        self.ppsd_call.pack(side=&#39;bottom&#39;, anchor=&#39;w&#39;, padx=(25,0), pady=(10,10))

        self.generate_ppsd_call = ttk.Label(master=ppsdCallFrame, text=&#39;generate_ppsds({}, remove_outliers={}, outlier_std={},...\n\t{}, {}, {}, {}, {}, \n\t{}, {}, {})&#39;
                  .format(&#39;params&#39;, self.remove_outliers.get(), self.outlier_std.get(), 
                          ppsdLenLabel.cget(&#39;text&#39;), overlapLabel.cget(&#39;text&#39;), pStepOctLabel.cget(&#39;text&#39;), sogLabel.cget(&#39;text&#39;), 
                          dbbinsLabel.cget(&#39;text&#39;), perLimsLabel.cget(&#39;text&#39;), pSmoothWidthLabel.cget(&#39;text&#39;), specialHandlingLabel.cget(&#39;text&#39;)))
        self.generate_ppsd_call.pack(side=&#39;bottom&#39;, anchor=&#39;w&#39;, padx=(25,0), pady=(10,10))
        
        
        def update_ppsd_call(ppsd_call):
            ppsd_call.configure(text=&#39;obspy...PPSD({}, {}, {}, {}, {}, {}, \n\t{}, {}, {}, {})&#39;.format(&#39;stats&#39;, &#39;metadata&#39;, ppsdLenLabel.cget(&#39;text&#39;), 
                                                                                                    overlapLabel.cget(&#39;text&#39;), pStepOctLabel.cget(&#39;text&#39;), sogLabel.cget(&#39;text&#39;), 
                          dbbinsLabel.cget(&#39;text&#39;), perLimsLabel.cget(&#39;text&#39;), pSmoothWidthLabel.cget(&#39;text&#39;), specialHandlingLabel.cget(&#39;text&#39;)))

            self.generate_ppsd_call.configure(text=&#39;generate_ppsds({}, remove_outliers={}, outlier_std={},...\n\t{}, {}, {}, {}, {}, \n\t{}, {}, {})&#39;
                            .format(&#39;params&#39;, self.remove_outliers.get(), self.outlier_std.get(), 
                                    ppsdLenLabel.cget(&#39;text&#39;), overlapLabel.cget(&#39;text&#39;), pStepOctLabel.cget(&#39;text&#39;), sogLabel.cget(&#39;text&#39;), 
                                    dbbinsLabel.cget(&#39;text&#39;), perLimsLabel.cget(&#39;text&#39;), pSmoothWidthLabel.cget(&#39;text&#39;), specialHandlingLabel.cget(&#39;text&#39;)))
                    

        #Stats from trace(s)
        obspyStatsFrame = ttk.LabelFrame(ppsd_settings_tab, text=&#39;Data Trace Stats&#39;)#.pack(fill=&#39;both&#39;)
        self.obspySreamLabel_settings = ttk.Label(obspyStatsFrame, text=&#39;Stats&#39;)
        self.obspySreamLabel_settings.pack(anchor=&#39;nw&#39;, padx=5)

        #Metadata (PAZ)
        obspyMetadataFrame = ttk.LabelFrame(ppsd_settings_tab, text=&#39;Metadata Poles and Zeros&#39;)#.pack(fill=&#39;both&#39;)

        self.metadataZ_settings = ttk.Label(obspyMetadataFrame, text=&#39;Z: &#39;)
        self.metadataZ_settings.grid(row=1, column=0, padx=5)
        self.metadataZ_settings.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))
        self.sensitivityLabelZ_settings = ttk.Label(obspyMetadataFrame, text=&#39;Sensitivity_Z&#39;)
        self.sensitivityLabelZ_settings.grid(row=1, column=1, padx=5)
        self.gainLabelZ_settings = ttk.Label(obspyMetadataFrame, text=&#39;Gain_Z&#39;)
        self.gainLabelZ_settings.grid(row=1, column=2, padx=5)
        self.polesLabelZ_settings = ttk.Label(obspyMetadataFrame, text=&#39;Poles_Z&#39;)
        self.polesLabelZ_settings.grid(row=1, column=3, padx=5)
        self.zerosLabelZ_settings = ttk.Label(obspyMetadataFrame, text=&#39;Zeros_Z&#39;)
        self.zerosLabelZ_settings.grid(row=1, column=4, padx=5)
 
        self.metadataN_settings = ttk.Label(obspyMetadataFrame, text=&#39;N: &#39;)
        self.metadataN_settings.grid(row=2, column=0, padx=5)
        self.metadataN_settings.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))
        self.sensitivityLabelN_settings = ttk.Label(obspyMetadataFrame, text=&#39;Sensitivity_N&#39;)
        self.sensitivityLabelN_settings.grid(row=2, column=1, padx=5)
        self.gainLabelN_settings = ttk.Label(obspyMetadataFrame, text=&#39;Gain_N&#39;)
        self.gainLabelN_settings.grid(row=2, column=2, padx=5)
        self.polesLabelN_settings = ttk.Label(obspyMetadataFrame, text=&#39;Poles_N&#39;)
        self.polesLabelN_settings.grid(row=2, column=3, padx=5)
        self.zerosLabelN_settings = ttk.Label(obspyMetadataFrame, text=&#39;Zeros_N&#39;)
        self.zerosLabelN_settings.grid(row=2, column=4, padx=5)
 
        self.metadataE_settings = ttk.Label(obspyMetadataFrame, text=&#39;E: &#39;)
        self.metadataE_settings.grid(row=3, column=0, padx=5)
        self.metadataE_settings.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))
        self.sensitivityLabelE_settings = ttk.Label(obspyMetadataFrame, text=&#39;Sensitivity_E&#39;)
        self.sensitivityLabelE_settings.grid(row=3, column=1)
        self.gainLabelE_settings = ttk.Label(obspyMetadataFrame, text=&#39;Gain_E&#39;)
        self.gainLabelE_settings.grid(row=3, column=2, padx=5)
        self.polesLabelE_settings = ttk.Label(obspyMetadataFrame, text=&#39;Poles_E&#39;)
        self.polesLabelE_settings.grid(row=3, column=3, padx=5)
        self.zerosLabelE_settings = ttk.Label(obspyMetadataFrame, text=&#39;Zeros_E&#39;)
        self.zerosLabelE_settings.grid(row=3, column=4, padx=5)

        self.metadata_sensitivity = ttk.Label(obspyMetadataFrame, text=&#39;Sensitivity&#39;)
        self.metadata_sensitivity.grid(row=0, column=1, padx=5)
        self.metadata_sensitivity.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))

        self.metadata_gain = ttk.Label(obspyMetadataFrame, text=&#39;Gain&#39;)
        self.metadata_gain.grid(row=0, column=2, padx=5)
        self.metadata_gain.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))

        self.metadata_poles = ttk.Label(obspyMetadataFrame, text=&#39;Poles&#39;)
        self.metadata_poles.grid(row=0, column=3, padx=5)
        self.metadata_poles.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))

        self.metadata_zeros = ttk.Label(obspyMetadataFrame, text=&#39;Zeros&#39;)
        self.metadata_zeros.grid(row=0, column=4, padx=5)
        self.metadata_zeros.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))

        #Run button frame
        runFrame_set_ppsd = ttk.Frame(ppsd_settings_tab)
        self.run_button = ttk.Button(runFrame_set_ppsd, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)
        self.run_button.pack(side=&#39;bottom&#39;, anchor=&#39;e&#39;)
        
        runFrame_set_ppsd.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;, anchor=&#39;e&#39;)            
        obspyMetadataFrame.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;,expand=True)#.grid(row=7, column=0, columnspan=6, sticky=&#39;nsew&#39;)#.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
        obspyStatsFrame.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;,expand=True)#.grid(row=6, column=0, columnspan=6, sticky=&#39;nsew&#39;)#.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
        ppsdCallFrame.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;,expand=True)#row=5, column=0, columnspan=6, sticky=&#39;nsew&#39;)#.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
        ppsdParamsFrame.pack(fill=&#39;both&#39;, side=&#39;right&#39;)#.grid(row=0, column=5, rowspan=4, sticky=&#39;nsew&#39;)#.pack(side=&#39;right&#39;,fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
        ppsdSettingsFrame.pack(fill=&#39;both&#39;, expand=True, side=&#39;top&#39;, anchor=&#39;w&#39;)#.grid(row=0, column=0, columnspan=4, rowspan=4, sticky=&#39;nsew&#39;)#.pack(side=&#39;left&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
    
        ppsd_settings_tab.pack(fill=&#39;both&#39;, expand=True)
        settings_notebook.add(ppsd_settings_tab, text=&#34;PPSD&#34;)

        #HVSR SETTINGS TAB
        hvsr_settings_tab = ttk.Frame(settings_notebook)
        
        hvsrSettingsFrame = ttk.LabelFrame(hvsr_settings_tab, text=&#39;H/V Processing Settings&#39;)#.pack(fill=&#39;both&#39;)
        
        hvsrParamsFrame = ttk.LabelFrame(hvsr_settings_tab, text=&#39;Process HVSR Parameters&#39;)#.pack(fill=&#39;both&#39;)
        
        #Method selection, method=4
        ttk.Label(hvsrSettingsFrame, text=&#34;Horizontal Combine Method [int]&#34;).grid(row=0, column=0, padx=(5,0), sticky=&#39;w&#39;)
        method_options = [&#39;&#39;, #Empty to make intuitive and match sprit_hvsr.py
                          &#34;1.Diffuse Field Assumption (not currently implemented)&#34;, 
                          &#34;2. Arithmetic Mean H ≡ (N + E)/2&#34;,
                          &#34;3. Geometric Mean: H ≡ √(N · E) (recommended by SESEAME Project (2004))&#34;,
                          &#34;4. Vector Summation: H ≡ √(N^2 + E^2)&#34;,
                          &#34;5. Quadratic Mean: H ≡ √(N^2 + E^2)/2&#34;,
                          &#34;6. Maximum Horizontal Value: H ≡ max(N, E)&#34;
                          ]

        
        def on_method_select(meth, meth_opts=method_options):
            self.method_ind = meth_opts.index(meth)

            try:
                int(self.method_ind)
                hCombMethodLabel.configure(text=&#34;method={}&#34;.format(self.method_ind))
                update_procHVSR_call(self.procHVSR_call)
                return True
            except ValueError:
                return False

        defaultMeth=3
        hCombMethodLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;method={}&#34;.format(defaultMeth), width=30)
        hCombMethodLabel.grid(row=0, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

        self.method_sel = tk.StringVar(value=method_options[defaultMeth])
        self.method_ind = method_options.index(self.method_sel.get())       
        self.method_dropdown = ttk.OptionMenu(hvsrSettingsFrame, self.method_sel, method_options[defaultMeth], *method_options, command=on_method_select)
        self.method_dropdown.config(width=50)
        self.method_dropdown.grid(row=0, column=1, columnspan=8, sticky=&#39;ew&#39;)
        
        #smooth=True, 
        
        def curve_smooth():
            try:
                int(self.hvsmooth.get())
                bool(self.hvsmoothbool.get())
                if not self.hvsmoothbool.get():
                    hvSmoothLabel.configure(text=&#39;smooth={}&#39;.format(self.hvsmoothbool.get()))
                    self.hvsmooth_param = False
                else:
                    hvSmoothLabel.configure(text=&#39;smooth={}&#39;.format(self.hvsmooth.get()))
                    self.hvsmooth_param = self.hvsmooth.get()              
                update_procHVSR_call(self.procHVSR_call)
                return True
            except ValueError:
                return False
            
        hvSmoothLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;smooth=True&#34;, width=30)
        hvSmoothLabel.grid(row=1, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

        ttk.Label(master=hvsrSettingsFrame, text=&#39;Smooth H/V Curve [bool]&#39;).grid(row=1, column=0, padx=(5,0), sticky=&#39;w&#39;)

        self.hvsmoothbool = tk.BooleanVar()
        self.hvsmoothbool.set(True)
        self.hvsmooth_param=True
        smoothCurveBool = ttk.Checkbutton(master=hvsrSettingsFrame, text=&#34;&#34;, compound=&#39;left&#39;, variable=self.hvsmoothbool, command=curve_smooth) # create the Checkbutton widget
        smoothCurveBool.grid(row=1, column=1, sticky=&#39;w&#39;)

        self.hvsmooth = tk.IntVar()
        self.hvsmooth.set(51)
        smoothCurveSamples = ttk.Entry(master=hvsrSettingsFrame, textvariable=self.hvsmooth, width=10, validate=&#39;focusout&#39;, validatecommand=curve_smooth)
        smoothCurveSamples.grid(row=1, column=2, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Label(master=hvsrSettingsFrame, text=&#39;[int] # pts in smoothing window (default=51)&#39;).grid(row=1, column=3, padx=(0,0))
        
        #freq_smooth=&#39;konno ohmachi&#39;, 
        freqSmoothLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;freq_smooth=&#39;konno ohmachi&#39;&#34;, width=30)
        freqSmoothLabel.grid(row=2, column=0, sticky=&#39;w&#39;, pady=(16,16), padx=5)

        
        def on_freq_smooth():
            try:
                str(self.freq_smooth.get())
                freqSmoothLabel.configure(text=&#34;freq_smooth={}&#34;.format(self.freq_smooth.get()))
                update_procHVSR_call(self.procHVSR_call)
                return True
            except ValueError:
                return False

        self.freq_smooth = tk.StringVar()
        self.freq_smooth.set(&#39;konno ohmachi&#39;)
        ttk.Label(master=hvsrSettingsFrame, text=&#39;Frequency Smoothing [str]&#39;).grid(row=2, column=0, padx=(5,0), sticky=&#39;w&#39;)
        fsmoothOptFrame = ttk.LabelFrame(master=hvsrSettingsFrame, text=&#39;Frequency Smoothing Operations&#39;)
        fsmoothOptFrame.grid(row=2, column=1, columnspan=7, padx=5, sticky=&#39;nsew&#39;)
        ttk.Radiobutton(master=fsmoothOptFrame, text=&#39;Konno-Ohmachi&#39;, variable=self.freq_smooth, value=&#39;konno ohmachi&#39;, command=on_freq_smooth).grid(row=0, column=0, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=fsmoothOptFrame, text=&#39;Constant&#39;, variable=self.freq_smooth, value=&#39;constant&#39;, command=on_freq_smooth).grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=fsmoothOptFrame, text=&#39;Proportional&#39;, variable=self.freq_smooth, value=&#39;proportional&#39;, command=on_freq_smooth).grid(row=0, column=2, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=fsmoothOptFrame, text=&#39;None&#39;, variable=self.freq_smooth, value=&#39;None&#39;, command=on_freq_smooth).grid(row=0, column=3, sticky=&#39;w&#39;, padx=(5, 10))

        #f_smooth_width=40, 
        fSmoothWidthlabel = ttk.Label(master=hvsrParamsFrame, text=&#34;f_smooth_width=40&#34;, width=30)
        fSmoothWidthlabel.grid(row=3, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

        
        def on_smooth_width():
            try:
                int(self.fSmoothWidth.get())
                fSmoothWidthlabel.configure(text=&#39;f_smooth_width={}&#39;.format(self.fSmoothWidth.get()))                
                update_procHVSR_call(self.procHVSR_call)
                return True
            except ValueError:
                return False
            
        ttk.Label(master=hvsrSettingsFrame, text=&#39;Bandwidth of freq. smoothing [int]&#39;).grid(row=3, column=0, padx=(5,0), sticky=&#39;w&#39;)
        self.fSmoothWidth = tk.IntVar()
        self.fSmoothWidth.set(40)
        fSmoothWidthEntry = ttk.Entry(master=hvsrSettingsFrame, justify=&#39;left&#39;, textvariable=self.fSmoothWidth, validate=&#39;focusout&#39;, validatecommand=on_smooth_width, width=10)
        fSmoothWidthEntry.grid(row=3, column=1, sticky=&#39;w&#39;, padx=(5, 10))
        
        #resample=True, 
        resampleLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;resample=True&#34;, width=30)
        resampleLabel.grid(row=4, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
        
        def on_curve_resample():
            try:
                if not self.resamplebool.get():
                    resampleLabel.configure(text=&#39;resample={}&#39;.format(self.resamplebool.get()))
                    self.hvresample_int=self.hvresample.get()
                else:
                    resampleLabel.configure(text=&#39;resample={}&#39;.format(self.hvresample.get()))
                    self.hvresample_int=self.hvresample.get()    
                update_procHVSR_call(self.procHVSR_call)
                return True
            except ValueError:
                return False
            
        self.resamplebool = tk.BooleanVar()
        self.resamplebool.set(True)
        ttk.Label(master=hvsrSettingsFrame, text=&#39;Resample H/V Curve [bool]&#39;).grid(row=4, column=0, padx=(5,0), sticky=&#39;w&#39;)
        resampleCurveBool = ttk.Checkbutton(master=hvsrSettingsFrame, text=&#34;&#34;, compound=&#39;left&#39;, variable=self.resamplebool, command=on_curve_resample) # create the Checkbutton widget
        resampleCurveBool.grid(row=4, column=1, sticky=&#39;w&#39;)

        self.hvresample = tk.IntVar()
        self.hvresample.set(1000)
        self.hvresample_int = self.hvresample.get()
        resampleCurveSamples = ttk.Entry(master=hvsrSettingsFrame, textvariable=self.hvresample, width=10, validate=&#39;focusout&#39;, validatecommand=on_curve_resample)
        resampleCurveSamples.grid(row=4, column=2, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Label(master=hvsrSettingsFrame, text=&#39;[int] # pts in resampled curve (default=1000)&#39;).grid(row=4, column=3, padx=(0,0), sticky=&#39;w&#39;)
                        
        #remove_outlier_curves=True, 
        outlierRemLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;remove_outlier_curves=True&#34;, width=30)
        outlierRemLabel.grid(row=5, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

        
        def on_remove_outlier_curves():
            try:
                bool(self.outlierRembool.get())
                outlierRemLabel.configure(text=&#39;remove_outlier_curves={}&#39;.format(self.outlierRembool.get()))
                #if self.outlierRembool.get():
                #    outlierRemStDev.state([&#39;active&#39;])
                #else:
                #    outlierRemStDev.state([&#39;disabled&#39;])

                update_procHVSR_call(self.procHVSR_call)
                return True
            except ValueError:
                return False
            
        self.outlierRembool = tk.BooleanVar()
        self.outlierRembool.set(True)
        ttk.Label(master=hvsrSettingsFrame, text=&#39;Remove Outlier H/V Curves [bool]&#39;).grid(row=5, column=0, padx=(5,0), sticky=&#39;w&#39;)
        resampleCurveBool = ttk.Checkbutton(master=hvsrSettingsFrame, text=&#34;&#34;, compound=&#39;left&#39;, variable=self.outlierRembool, command=on_remove_outlier_curves) # create the Checkbutton widget
        resampleCurveBool.grid(row=5, column=1, sticky=&#39;w&#39;)

        #outlier_curve_std=1.75
        outlierValLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;outlier_curve_std=1.75&#34;, width=30)
        outlierValLabel.grid(row=6, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)        

        
        def on_outlier_std():
            try:
                float(self.outlierRemStDev.get())
                outlierValLabel.configure(text=&#39;resample={}&#39;.format(self.outlierRemStDev.get()))                
                update_procHVSR_call(self.procHVSR_call)
                return True
            except ValueError:
                return False
            
        ttk.Label(master=hvsrSettingsFrame, text=&#39;Outlier St. Dev. [float]&#39;).grid(row=6, column=0, columnspan=2, padx=(5,0), sticky=&#39;w&#39;)
        self.outlierRemStDev = tk.DoubleVar()
        self.outlierRemStDev.set(1.75)
        outlierRemStDev = ttk.Entry(master=hvsrSettingsFrame, textvariable=self.outlierRemStDev, width=10, validate=&#39;focusout&#39;, validatecommand=on_outlier_std)
        outlierRemStDev.grid(row=6, column=1, sticky=&#39;w&#39;, padx=(5, 10))

        separator = ttk.Separator(hvsrSettingsFrame, orient=&#39;horizontal&#39;)
        separator.grid(row=7, columnspan=7, sticky=&#39;ew&#39;, pady=10)

        #hvsr_band=[0.4, 40]
        hvsrBandLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;hvsr_band=[0.4,40]&#34;, width=30)
        hvsrBandLabel.grid(row=7, column=0, sticky=&#39;w&#39;, pady=(20,6), padx=5)

        ttk.Label(hvsrSettingsFrame,text=&#34;HVSR Band [Hz]&#34;).grid(row=8,column=0, sticky=&#39;w&#39;, padx=(5,0))

        hvsr_band_min_settingsEntry = ttk.Entry(hvsrSettingsFrame, width=10, textvariable=self.hvsrBand_min, validate=&#39;focusout&#39;, validatecommand=on_hvsrband_update)
        hvsr_band_min_settingsEntry.grid(row=8,column=1, sticky=&#39;ew&#39;)

        hvsr_band_max_settingsEntry = ttk.Entry(hvsrSettingsFrame, width=10, textvariable=self.hvsrBand_max, validate=&#39;focusout&#39;, validatecommand=on_hvsrband_update)
        hvsr_band_max_settingsEntry.grid(row=8,column=2, sticky=&#39;ew&#39;)
   
        #peak_water_level=1.8
        pwaterLevLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;peak_water_level=1.8&#34;, width=30)
        pwaterLevLabel.grid(row=8, column=0, sticky=&#39;w&#39;, pady=(6,6), padx=5)        

        
        def on_pwaterlevel_update():
            try:
                float(self.peak_water_level.get())

                pwaterLevLabel.configure(text=&#39;peak_water_level={}&#39;.format(self.peak_water_level.get()))                
                update_check_peaks_call(self.checkPeaks_Call)
                return True
            except ValueError:
                return False      
                
        ttk.Label(hvsrSettingsFrame,text=&#34;Peak Water Level&#34;).grid(row=9, column=0, sticky=&#39;w&#39;, padx=5)

        self.peak_water_level = tk.DoubleVar()
        self.peak_water_level.set(1.8)
        pWaterLevelEntry = ttk.Entry(hvsrSettingsFrame, width=10, textvariable=self.peak_water_level, validate=&#39;focusout&#39;, validatecommand=on_pwaterlevel_update)
        pWaterLevelEntry.grid(row=9, column=1, sticky=&#39;w&#39;)

        #Process HVSR Function Call
        hvsrCallFrame = ttk.LabelFrame(hvsr_settings_tab, text=&#39;sprit_hvsr.process_hvsr() Call&#39;)#.pack(fill=&#39;both&#39;)
        
        self.procHVSR_call = ttk.Label(master=hvsrCallFrame, text=&#39;process_hvsr({}, {}, {}, {}, {}, \n\t{}, {}, {}, {}, {})&#39;
                  .format(&#39;params&#39;, hCombMethodLabel.cget(&#39;text&#39;), hvSmoothLabel.cget(&#39;text&#39;), freqSmoothLabel.cget(&#39;text&#39;), fSmoothWidthlabel.cget(&#39;text&#39;), resampleLabel.cget(&#39;text&#39;), 
                          outlierRemLabel.cget(&#39;text&#39;), outlierValLabel.cget(&#39;text&#39;), hvsrBandLabel.cget(&#39;text&#39;), pwaterLevLabel.cget(&#39;text&#39;)))
        self.procHVSR_call.pack(anchor=&#39;w&#39;, padx=(25,0), pady=(10,10))

        
        def update_procHVSR_call(procHVSR_call):
            procHVSR_call.configure(text=&#39;process_hvsr({}, {}, {}, {}, {}, \n\t{}, {}, {}, {}, {})&#39;
                  .format(&#39;params&#39;, hCombMethodLabel.cget(&#39;text&#39;), hvSmoothLabel.cget(&#39;text&#39;), freqSmoothLabel.cget(&#39;text&#39;), fSmoothWidthlabel.cget(&#39;text&#39;), resampleLabel.cget(&#39;text&#39;), 
                          outlierRemLabel.cget(&#39;text&#39;), outlierValLabel.cget(&#39;text&#39;), hvsrBandLabel.cget(&#39;text&#39;), pwaterLevLabel.cget(&#39;text&#39;)))
        
        #Check Peaks Function Call
        checkPeaksCallFrame = ttk.LabelFrame(hvsr_settings_tab, text=&#39;sprit_hvsr.check_peaks() Call&#39;)#.pack(fill=&#39;both&#39;)

        self.checkPeaks_Call = ttk.Label(master=checkPeaksCallFrame, text=&#39;check_peaks({}, {}, {})&#39;
                  .format(&#39;hvsr_data&#39;, hvsrBandLabel.cget(&#39;text&#39;), pwaterLevLabel.cget(&#39;text&#39;)))
        self.checkPeaks_Call.pack(anchor=&#39;w&#39;, padx=(25,0), pady=(10,10))

        #check_peaks(hvsr_dict, hvsr_band=[0.4, 40], peak_water_level=1.8)
        
        def update_check_peaks_call(checkPeaks_Call):
            checkPeaks_Call.configure(text=&#39;check_peaks({}, {}, {})&#39;
                  .format(&#39;hvsr_data&#39;, hvsrBandLabel.cget(&#39;text&#39;), pwaterLevLabel.cget(&#39;text&#39;)))


        #Run button frame
        runFrame_set_hvsr = ttk.Frame(hvsr_settings_tab)
        self.run_button = ttk.Button(runFrame_set_hvsr, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)
        self.run_button.pack(side=&#39;bottom&#39;, anchor=&#39;e&#39;)

        #Pack tab
        runFrame_set_hvsr.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;, anchor=&#39;e&#39;)    
        checkPeaksCallFrame.pack(fill=&#39;both&#39;, expand=True, side=&#39;bottom&#39;)#.grid(row=10, column=0, columnspan=6, sticky=&#39;nsew&#39;)#.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
        hvsrCallFrame.pack(fill=&#39;both&#39;, expand=True, side=&#39;bottom&#39;)#.grid(row=9, column=0, columnspan=6, sticky=&#39;nsew&#39;)#.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
        hvsrParamsFrame.pack(fill=&#39;both&#39;, side=&#39;right&#39;)#.grid(row=0, column=6, rowspan=4, sticky=&#39;nsew&#39;)#.pack(side=&#39;right&#39;,fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
        hvsrSettingsFrame.pack(fill=&#39;both&#39;, expand=True, side=&#39;top&#39;)#.grid(row=0, column=0, columnspan=6, rowspan=4, sticky=&#39;nsew&#39;)#.pack(fill=&#39;both&#39;, expand=True)
        
        hvsr_settings_tab.pack(fill=&#39;both&#39;, expand=True)           
        settings_notebook.add(hvsr_settings_tab, text=&#34;HVSR Settings&#34;)

        #PLOT SETTINGS TAB
        plot_settings_tab = ttk.Frame(settings_notebook)

        # Create the Plot Options LabelFrame
        plot_options_frame = ttk.LabelFrame(plot_settings_tab, text=&#34;Plot Options&#34;)

        
        def update_hvplot_call():
            kindstr = get_kindstr()
            hvplot_label.configure(text=&#34;hvplot({}, kind={}, xtype=&#39;{}&#39;, {}, {})&#34;.format(&#39;hvsr_data&#39;, kindstr, self.x_type.get(), &#39;[...]&#39;, &#39;kwargs&#39;))

        # Create the Checkbuttons for the plot options
        ttk.Label(plot_options_frame, text=&#39;HVSR Plot&#39;, justify=&#39;center&#39;).grid(row=0, column=1, sticky=&#39;ew&#39;, padx=(5, 5))
        ttk.Label(plot_options_frame, text=&#39;Components H/V Plot&#39;, justify=&#39;center&#39;).grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5, 5))
        ttk.Label(plot_options_frame, text=&#39;Spectrogram Plot&#39;, justify=&#39;center&#39;).grid(row=0, column=3, sticky=&#39;ew&#39;, padx=(5, 5))

        self.hvsr_chart_bool = tk.BooleanVar()
        self.hvsr_chart_bool.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#39;&#39;, variable=self.hvsr_chart_bool, command=update_hvplot_call).grid(row=1, column=1, sticky=&#39;nsew&#39;, padx=15, pady=(5, 20))
        self.ind_comp_chart_bool = tk.BooleanVar()
        self.ind_comp_chart_bool.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#39;&#39;, variable=self.ind_comp_chart_bool, command=update_hvplot_call).grid(row=1, column=2, sticky=&#39;nsew&#39;, padx=50, pady=(5, 20))
        self.spec_chart_bool = tk.BooleanVar()
        self.spec_chart_bool.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#39;&#39;, variable=self.spec_chart_bool, command=update_hvplot_call).grid(row=1, column=3, sticky=&#39;nsew&#39;, padx=25, pady=(5, 20))
        
        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=2, columnspan=5, sticky=&#39;ew&#39;, pady=5)
        
        #Separate component chart: c+
        ttk.Label(plot_options_frame, text=&#39;Show Components on same chart as H/V Curve:&#39;).grid(row=3, column=0, sticky=&#39;w&#39;, padx=5)
        
        
        def disable_comp_buttons():
            if self.show_comp_with_hv.get():
                self.annotate_best_peak_comp.set(False)
                self.show_best_peak_comp.set(False)
                bestPeakCompButton.config(state=&#34;disabled&#34;) 
                bestPeakCompAnnButton.config(state=&#39;disabled&#39;)
            else:
                bestPeakCompButton.config(state=&#34;normal&#34;) 
                bestPeakCompAnnButton.config(state=&#39;normal&#39;)
            update_hvplot_call()

        self.show_comp_with_hv = tk.BooleanVar()
        self.show_comp_with_hv.set(False)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_comp_with_hv, 
                        command=disable_comp_buttons).grid(row=3, column=2, sticky=&#34;ew&#34;, padx=50)

        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=4, columnspan=5, sticky=&#39;ew&#39;, pady=5)

        #Show Best Peak: p
        ttk.Label(plot_options_frame, text=&#39;Show Best Peak:&#39;).grid(row=5, column=0, sticky=&#39;w&#39;, padx=5)

        self.show_best_peak_hv = tk.BooleanVar()
        self.show_best_peak_hv.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_best_peak_hv, command=update_hvplot_call).grid(row=5, column=1, sticky=&#34;ew&#34;, padx=15)

        self.show_best_peak_comp = tk.BooleanVar()
        self.show_best_peak_comp.set(True)
        bestPeakCompButton=ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_best_peak_comp, command=update_hvplot_call)
        bestPeakCompButton.grid(row=5, column=2, sticky=&#34;ew&#34;, padx=50)

        self.show_best_peak_spec = tk.BooleanVar()
        self.show_best_peak_spec.set(False)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_best_peak_spec, command=update_hvplot_call).grid(row=5, column=3, sticky=&#34;ew&#34;, padx=25)

        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=6, columnspan=5, sticky=&#39;ew&#39;)

        #Annotate Best Peak: ann
        ttk.Label(plot_options_frame, text=&#39;Annotate Best Peak:&#39;).grid(row=7, column=0, sticky=&#39;w&#39;, padx=5)

        self.annotate_best_peak_hv = tk.BooleanVar()
        self.annotate_best_peak_hv.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.annotate_best_peak_hv, command=update_hvplot_call).grid(row=7, column=1, sticky=&#34;ew&#34;, padx=15)

        self.annotate_best_peak_comp = tk.BooleanVar()
        self.annotate_best_peak_comp.set(True)
        bestPeakCompAnnButton=ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.annotate_best_peak_comp, command=update_hvplot_call)
        bestPeakCompAnnButton.grid(row=7, column=2, sticky=&#34;ew&#34;, padx=50)

        self.annotate_best_peak_spec = tk.BooleanVar()
        self.annotate_best_peak_spec.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.annotate_best_peak_spec, command=update_hvplot_call).grid(row=7, column=3, sticky=&#34;ew&#34;, padx=25)

        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=8, columnspan=5, sticky=&#39;ew&#39;)


        #Show all peaks (main H/V curve): all
        ttk.Label(plot_options_frame, text=&#39;Show All Peaks (H/V Curve):&#39;).grid(row=9, column=0, sticky=&#39;w&#39;, padx=5)

        self.show_all_peaks_hv = tk.BooleanVar()
        self.show_all_peaks_hv.set(False)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_all_peaks_hv, command=update_hvplot_call).grid(row=9, column=1, sticky=&#34;ew&#34;, padx=15)

        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=10, columnspan=5, sticky=&#39;ew&#39;)

        #Show all curves: t
        ttk.Label(plot_options_frame, text=&#39;Show All H/V Curves:&#39;).grid(row=11, column=0, sticky=&#39;w&#39;, padx=5)

        self.show_ind_curves = tk.BooleanVar()
        self.show_ind_curves.set(False)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_ind_curves, command=update_hvplot_call).grid(row=11, column=1, sticky=&#34;ew&#34;, padx=15)

        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=12, columnspan=5, sticky=&#39;ew&#39;)

        #Show individual peaks (tp): tp
        ttk.Label(plot_options_frame, text=&#39;Show Individual Peaks:&#39;).grid(row=13, column=0, sticky=&#39;w&#39;, padx=5)

        self.show_ind_peaks = tk.BooleanVar()
        self.show_ind_peaks.set(False)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_ind_peaks, command=update_hvplot_call).grid(row=13, column=1, sticky=&#34;ew&#34;, padx=15)

        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=14, columnspan=5, sticky=&#39;ew&#39;)

        #Show individual peaks (tp): tp
        ttk.Label(plot_options_frame, text=&#39;Show Standard Deviation:&#39;).grid(row=15, column=0, sticky=&#39;w&#39;, padx=5)

        self.show_stDev_hv = tk.BooleanVar()
        self.show_stDev_hv.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_stDev_hv, command=update_hvplot_call).grid(row=15, column=1, sticky=&#34;ew&#34;, padx=15)

        self.show_stDev_comp = tk.BooleanVar()
        self.show_stDev_comp.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_stDev_comp, command=update_hvplot_call).grid(row=15, column=2, sticky=&#34;ew&#34;, padx=50)

        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=16, columnspan=5, sticky=&#39;ew&#39;)

        #Specify X-Type
        ttk.Label(plot_options_frame, text=&#39;X Type:&#39;).grid(row=17, column=0, sticky=&#39;w&#39;, padx=5, pady=10)

        self.x_type = tk.StringVar()
        self.x_type.set(&#39;freq&#39;)
        ttk.Radiobutton(master=plot_options_frame, text=&#39;Frequency&#39;, variable=self.x_type, value=&#39;freq&#39;, command=update_hvplot_call).grid(row=17, column=1, sticky=&#39;w&#39;, padx=(5, 10), pady=10)
        ttk.Radiobutton(master=plot_options_frame, text=&#39;Period&#39;, variable=self.x_type, value=&#39;period&#39;, command=update_hvplot_call).grid(row=17, column=2, sticky=&#39;w&#39;, padx=(5, 10), pady=10)

        #kwargs
        ttk.Label(plot_options_frame, text=&#39;Matplotlib Keyword Arguments (not implemented):&#39;).grid(row=18, column=0, sticky=&#39;w&#39;, padx=5, pady=10)

        self.plot_kwargs = tk.StringVar()
        self.plot_kwargs.set(&#34;cmap=&#39;turbo&#39;&#34;)
        ttk.Entry(plot_options_frame, textvariable=self.plot_kwargs).grid(row=18, column=1, columnspan=3, sticky=&#34;ew&#34;, pady=10)

        plot_options_frame.pack(fill=&#39;both&#39;, expand=True)#.grid(row=1, column=0, padx=10, pady=10, sticky=&#34;nsew&#34;)

        # Create the hvplot Call LabelFrame
        hvplot_call_frame = ttk.LabelFrame(plot_settings_tab, text=&#34;hvplot() Call&#34;)

        #HVSR
        
        def get_kindstr():
            if self.hvsr_chart_bool.get():
                kindstr_hv = &#39;HVSR&#39;
                if self.show_best_peak_hv.get():
                    kindstr_hv = kindstr_hv + &#39; p&#39;
                if self.annotate_best_peak_hv.get():
                    kindstr_hv = kindstr_hv + &#39; ann&#39;
                if self.show_all_peaks_hv.get():
                    kindstr_hv = kindstr_hv + &#39; all&#39;
                if self.show_ind_curves.get():
                    kindstr_hv = kindstr_hv + &#39; t&#39;
                if self.show_ind_peaks.get():
                    kindstr_hv = kindstr_hv + &#39;p&#39;
                if not self.show_stDev_hv.get():
                    kindstr_hv = kindstr_hv + &#39; -s&#39;
            else:
                kindstr_hv = &#39;&#39;

            #Comp
            if self.ind_comp_chart_bool.get():
                kindstr_c = &#39;c&#39;

                if not self.show_comp_with_hv.get():
                    kindstr_c = kindstr_c + &#39;+&#39;

                    if self.show_best_peak_comp.get():
                        kindstr_c = kindstr_c + &#39; p&#39;
                    if self.annotate_best_peak_comp.get():
                        kindstr_c = kindstr_c + &#39; ann&#39;
                if not self.show_stDev_comp.get():
                    kindstr_c = kindstr_c + &#39; -s&#39;
            else:
                kindstr_c = &#39;&#39;

            #Specgram
            if self.spec_chart_bool.get():
                kindstr_spec = &#39;Spec&#39;

                if self.show_best_peak_spec.get():
                    kindstr_spec = kindstr_spec + &#39; p&#39;
                if self.annotate_best_peak_spec.get():
                    kindstr_spec = kindstr_spec + &#39; ann&#39;
            else:
                kindstr_spec = &#39;&#39;
            kindstr = kindstr_hv + &#39; &#39; +  kindstr_c + &#39; &#39; + kindstr_spec
            return kindstr
        

        # Add a Label widget to the hvplot Call Label section
        hvplot_label = ttk.Label(hvplot_call_frame, text=&#34;hvplot({}, kind=&#39;{}&#39;, xtype=&#39;{}&#39;, {}, {})&#34;.format(&#39;hvsr_data&#39;, get_kindstr(), self.x_type.get(), &#39;[...]&#39;, &#39;kwargs&#39;))

        #Run button frame
        runFrame_set_plot = ttk.Frame(plot_settings_tab)

        self.run_button = ttk.Button(runFrame_set_plot, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)

        
        def update_results_plot():
            self.tab_control.select(self.results_tab)
            sprit_hvsr.hvplot(self.hvsr_results, plot_type=get_kindstr(), fig=self.fig_results, ax=self.ax_results, use_subplots=True, clear_fig=False)

        self.update_results_plot_button = ttk.Button(runFrame_set_plot, text=&#34;Update Plot&#34;, style=&#39;Noise.TButton&#39;, command=update_results_plot, width=30)
        
        self.run_button.pack(side=&#39;right&#39;, anchor=&#39;se&#39;, padx=(10,0))
        self.update_results_plot_button.pack(side=&#39;right&#39;, anchor=&#39;se&#39;)

        runFrame_set_plot.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;, anchor=&#39;e&#39;)
        hvplot_label.pack(fill=&#39;both&#39;, expand=True, padx=(10,0))#.grid(column=0, row=0, padx=10, pady=10, sticky=&#34;w&#34;)
        hvplot_call_frame.pack(fill=&#39;both&#39;, expand=True)#.grid(row=2, column=0, padx=10, pady=10, sticky=&#34;nsew&#34;)

        plot_settings_tab.pack(fill=&#39;both&#39;, expand=True)
        settings_notebook.add(plot_settings_tab, text=&#34;Plot Settings&#34;)

        # Pack the settings Notebook widget
        settings_notebook.pack(expand=True, fill=&#39;both&#39;)
        self.tab_control.add(self.settings_tab, text=&#34;Settings&#34;)

        # RESULTS TAB
        self.results_tab = ttk.Frame(self.tab_control)

        # Create the Batch Site selection LabelFrame
        self.results_siteSelectFrame = ttk.LabelFrame(self.results_tab, text=&#34;HVSR Results&#34;)
        self.results_siteSelectLabel = ttk.Label(self.results_siteSelectFrame, text=&#39;Select Site to display&#39;)


        # Create the hvplot Call LabelFrame
        self.results_chartFrame = ttk.LabelFrame(self.results_tab, text=&#34;Data Plots&#34;)

        #Set up plot     
        #results_mosaic = [[&#39;hvsr&#39;],[&#39;comp&#39;],[&#39;spec&#39;]]
        #self.fig_results, self.ax_results = plt.subplot_mosaic(results_mosaic)  
        #self.results_canvas = FigureCanvasTkAgg(self.fig_results, master=self.results_chartFrame)
        #self.results_canvas.draw()
        #self.results_canvasWidget = self.results_canvas.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)

        self.fig_results = plt.figure()
        results_mosaic = [[&#39;hvsr&#39;],[&#39;comp&#39;],[&#39;spec&#39;]]
        self.ax_results = self.fig_results.subplot_mosaic(results_mosaic)

        self.results_canvas = FigureCanvasTkAgg(self.fig_results, master=self.results_chartFrame)  # A tk.DrawingArea.
        self.results_canvas.draw()
        self.results_canvasWidget = self.results_canvas.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
        self.results_toolbar = NavigationToolbar2Tk(self.results_canvas, self.results_chartFrame, pack_toolbar=False)
        self.results_toolbar.update()
        self.results_toolbar.pack(fill=tk.X, side=tk.BOTTOM, expand=False)
        self.results_canvasWidget.pack(fill=&#39;both&#39;, expand=True)#.grid(row=0, column=0, sticky=&#39;nsew&#39;)

        #Peak report
        results_peakInfoFrame = ttk.LabelFrame(self.results_tab, text=&#34;Peak Report&#34;)
        curveTitleLabel = ttk.Label(results_peakInfoFrame, text=&#39;Criteria for Reliable H/V Curve (all 3 must pass)&#39;)
        curveTest1Label = ttk.Label(results_peakInfoFrame, text=&#39;Window Length for Frequency&#39;)
        curveTest1ResultFrame = ttk.Frame(results_peakInfoFrame)
        curveTest1ResultText = ttk.Label(curveTest1ResultFrame, text=&#39;&#39;)
        curveTest1Result = ttk.Label(curveTest1ResultFrame, text=&#39;&#39;)

        curveTest2Label = ttk.Label(results_peakInfoFrame, text=&#39;Number of Significant Cycles&#39;)
        curveTest2ResultFrame = ttk.Frame(results_peakInfoFrame)
        curveTest2ResultText = ttk.Label(curveTest2ResultFrame, text=&#39;&#39;)
        curveTest2Result = ttk.Label(curveTest2ResultFrame, text=&#39;&#39;)

        curveTest3Label = ttk.Label(results_peakInfoFrame, text=&#39;Low Curve Standard Deviation for Frequencies Near Peak Over Time&#39;)
        curveTest3ResultFrame = ttk.Frame(results_peakInfoFrame)
        curveTest3ResultText = ttk.Label(curveTest3ResultFrame, text=&#39;&#39;)
        curveTest3Result = ttk.Label(curveTest3ResultFrame, text=&#39;&#39;)

        totalCurveResult = ttk.Label(results_peakInfoFrame, text=&#39;&#39;)

        peakTitleLabel = ttk.Label(results_peakInfoFrame, text=&#39;Criteria for a Clear H/V Peak (5/6 must pass)&#39;)
        peakTest1Label = ttk.Label(results_peakInfoFrame, text=&#39;H/V Amplitude is low Below Peak Frequency&#39;)
        peakTest1ResultFrame = ttk.Frame(results_peakInfoFrame)
        peakTest1ResultText = ttk.Label(peakTest1ResultFrame, text=&#39;&#39;)
        peakTest1Result = ttk.Label(peakTest1ResultFrame, text=&#39;&#39;)
        
        peakTest2Label = ttk.Label(results_peakInfoFrame, text=&#39;H/V Amplitude is low Above Peak Frequency&#39;)
        peakTest2ResultFrame = ttk.Frame(results_peakInfoFrame)
        peakTest2ResultText = ttk.Label(peakTest2ResultFrame, text=&#39;&#39;)
        peakTest2Result = ttk.Label(peakTest2ResultFrame, text=&#39;&#39;)
        
        peakTest3Label = ttk.Label(results_peakInfoFrame, text=&#39;Peak is Prominent&#39;)
        peakTest3ResultFrame = ttk.Frame(results_peakInfoFrame)
        peakTest3ResultText = ttk.Label(peakTest3ResultFrame, text=&#39;&#39;)
        peakTest3Result = ttk.Label(peakTest3ResultFrame, text=&#39;&#39;)
        
        peakTest4Label = ttk.Label(results_peakInfoFrame, text=&#39;Frequency of Peak is Stationary Over Time&#39;)
        peakTest4ResultFrame = ttk.Frame(results_peakInfoFrame)
        peakTest4ResultText = ttk.Label(peakTest4ResultFrame, text=&#39;&#39;)
        peakTest4Result = ttk.Label(peakTest4ResultFrame, text=&#39;&#39;)
        
        peakTest5Label = ttk.Label(results_peakInfoFrame, text=&#39;Standard Deviation of Peak Frequency is low &#39;)
        peakTest5ResultFrame = ttk.Frame(results_peakInfoFrame)
        peakTest5ResultText = ttk.Label(peakTest5ResultFrame, text=&#39;&#39;)
        peakTest5Result = ttk.Label(peakTest5ResultFrame, text=&#39;&#39;)
        
        peakTest6Label = ttk.Label(results_peakInfoFrame, text=&#39;Standard Deviation of Peak Amplitude is low&#39;)
        peakTest6ResultFrame = ttk.Frame(results_peakInfoFrame)
        peakTest6ResultText = ttk.Label(peakTest6ResultFrame, text=&#39;&#39;)
        peakTest6Result = ttk.Label(peakTest6ResultFrame, text=&#39;&#39;)

        totalPeakResult = ttk.Label(results_peakInfoFrame, text=&#39;&#39;)

        totalResult = ttk.Label(results_peakInfoFrame, text=&#39;&#39;)

        curveTitleLabel.grid(row=0, sticky=&#39;w&#39;, padx=5, pady=2.5)
        curveTitleLabel.configure(font=(&#34;TkDefaultFont&#34;, 12, &#39;underline&#39;, &#39;bold&#39;))
        curveTest1Label.grid(row=1, sticky=&#39;w&#39;, padx=5, pady=2.5)
        curveTest1ResultFrame.grid(row=2, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        curveTest1ResultFrame.columnconfigure(0, weight=1)
        curveTest1ResultFrame.columnconfigure(1, weight=6)
        curveTest1ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        curveTest1Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        curveTest2Label.grid(row=3, sticky=&#39;w&#39;, padx=5, pady=2.5)
        curveTest2ResultFrame.grid(row=4, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        curveTest2ResultFrame.columnconfigure(0, weight=1)
        curveTest2ResultFrame.columnconfigure(1, weight=6)
        curveTest2ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        curveTest2Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        curveTest3Label.grid(row=5, sticky=&#39;w&#39;, padx=5, pady=2.5)
        curveTest3ResultFrame.grid(row=6, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        curveTest3ResultFrame.columnconfigure(0, weight=1)
        curveTest3ResultFrame.columnconfigure(1, weight=6)
        curveTest3ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        curveTest3Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        totalCurveResult.grid(row=7, sticky=&#39;e&#39;, padx=5, pady=10 )

        ttk.Separator(results_peakInfoFrame).grid(row=8, sticky=&#39;ew&#39;, pady=5)
        
        peakTitleLabel.grid(row=9, sticky=&#39;w&#39;, padx=5, pady=2.5)
        peakTitleLabel.configure(font=(&#34;TkDefaultFont&#34;, 12, &#39;underline&#39;, &#39;bold&#39;))
        
        peakTest1Label.grid(row=11, sticky=&#39;w&#39;, padx=5, pady=2.5)
        peakTest1ResultFrame.grid(row=12, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        peakTest1ResultFrame.columnconfigure(0, weight=1)
        peakTest1ResultFrame.columnconfigure(1, weight=6)
        peakTest1ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        peakTest1Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        peakTest2Label.grid(row=13, sticky=&#39;w&#39;, padx=5, pady=2.5)
        peakTest2ResultFrame.grid(row=14, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        peakTest2ResultFrame.columnconfigure(0, weight=1)
        peakTest2ResultFrame.columnconfigure(1, weight=6)
        peakTest2ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        peakTest2Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        peakTest3Label.grid(row=15, sticky=&#39;w&#39;, padx=5, pady=2.5)
        peakTest3ResultFrame.grid(row=16, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        peakTest3ResultFrame.columnconfigure(0, weight=1)
        peakTest3ResultFrame.columnconfigure(1, weight=6)
        peakTest3ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        peakTest3Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        peakTest4Label.grid(row=17, sticky=&#39;w&#39;, padx=5, pady=2.5)
        peakTest4ResultFrame.grid(row=18, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        peakTest4ResultFrame.columnconfigure(0, weight=1)
        peakTest4ResultFrame.columnconfigure(1, weight=6)
        peakTest4ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        peakTest4Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        peakTest5Label.grid(row=19, sticky=&#39;w&#39;, padx=5, pady=2.5)
        peakTest5ResultFrame.grid(row=20, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        peakTest5ResultFrame.columnconfigure(0, weight=1)
        peakTest5ResultFrame.columnconfigure(1, weight=6)
        peakTest5ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        peakTest5Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        peakTest6Label.grid(row=21, sticky=&#39;w&#39;, padx=5, pady=2.5)
        peakTest6ResultFrame.grid(row=22, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        peakTest6ResultFrame.columnconfigure(0, weight=1)
        peakTest6ResultFrame.columnconfigure(1, weight=6)
        peakTest6ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        peakTest6Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        totalPeakResult.grid(row=23, sticky=&#39;e&#39;, padx=5, pady=10 )

        ttk.Separator(results_peakInfoFrame).grid(row=24, sticky=&#39;ew&#39;, pady=5)

        totalResult.grid(row=25, sticky=&#39;e&#39;, padx=5, pady=10 )

        #Export results
        results_export_Frame = ttk.LabelFrame(self.results_tab, text=&#34;Export Results&#34;)
        
        ttk.Label(results_export_Frame, text=&#34;Export Figure&#34;).grid(row=0, column=0, sticky=&#39;ew&#39;, padx=5)
        self.results_fig_dir = tk.StringVar()
        self.results_fig_dir_entry = ttk.Entry(results_export_Frame, textvariable=self.results_fig_dir)
        self.results_fig_dir_entry.grid(row=0, column=1, columnspan=5, sticky=&#39;ew&#39;)
        
        
        def filepath_results_fig():
            filepath = filedialog.asksaveasfilename(defaultextension=&#39;png&#39;, initialdir=pathlib.Path(self.data_path.get()).parent, initialfile=self.params[&#39;site&#39;]+&#39;_results.png&#39;)
            if filepath:
                self.results_fig_dir_entry.delete(0, &#39;end&#39;)
                self.results_fig_dir_entry.insert(0, filepath)
        
        
        def save_results_fig():
            if not self.save_ind_subplots.get():
                self.fig_results.savefig(self.results_fig_dir.get())
            else:
                print(&#39;working on individual subplots&#39;)
                for key in self.ax_results.keys():
                    extent = self.ax_results[key].get_tightbbox(self.fig_results.canvas.renderer).transformed(self.fig_results.dpi_scale_trans.inverted())
                    self.fig_results.savefig(pathlib.Path(self.results_fig_dir.get()).parent.as_posix()+&#39;/Subplot&#39;+key+&#39;.png&#39;,  bbox_inches=extent)
        

        self.browse_results_fig = ttk.Button(results_export_Frame, text=&#34;Browse&#34;,command=filepath_results_fig)
        self.browse_results_fig.grid(row=0, column=7, sticky=&#39;ew&#39;, padx=2.5)
        
        self.save_results_fig = ttk.Button(results_export_Frame, text=&#34;Save&#34;,command=save_results_fig)
        self.save_results_fig.grid(row=0, column=8, columnspan=2, sticky=&#39;ew&#39;, padx=2.5)

        #Save subplots individually
        self.save_ind_subplots = tk.BooleanVar()
        self.save_ind_subplots.set(False)
        ttk.Checkbutton(results_export_Frame, text=&#34;Save ind. subplots&#34;, variable=self.save_ind_subplots).grid(row=0, column=10, sticky=&#34;ew&#34;, padx=5)

        self.browse_results_fig = ttk.Button(results_export_Frame, text=&#34;Update Plot&#34;,command=update_results_plot)
        self.browse_results_fig.grid(row=1, column=10, sticky=&#39;ew&#39;, padx=(7.5, 2.5))


        results_export_Frame.columnconfigure(1, weight=1)
        results_export_Frame.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;)

        #Export Peak Report        
        ttk.Label(results_export_Frame, text=&#34;Export Peak Report&#34;).grid(row=1, column=0, sticky=&#39;ew&#39;, padx=5)
        self.results_report_dir = tk.StringVar()
        self.results_report_dir_entry = ttk.Entry(results_export_Frame, textvariable=self.results_report_dir)
        self.results_report_dir_entry.grid(row=1, column=1, columnspan=5, sticky=&#39;ew&#39;)
        
        
        def filepath_report_fig():
            filepath = filedialog.asksaveasfilename(defaultextension=&#39;csv&#39;, initialdir=pathlib.Path(self.data_path.get()).parent, initialfile=self.params[&#39;site&#39;]+&#39;_peakReport.csv&#39;)
            if filepath:
                self.results_report_dir_entry.delete(0, &#39;end&#39;)
                self.results_report_dir_entry.insert(0, filepath)
        
        
        def save_report_fig():
            sprit_hvsr.get_report(self.hvsr_results, format=&#39;plot&#39;,  export=self.results_report_dir.get())

        self.browse_results_fig = ttk.Button(results_export_Frame, text=&#34;Browse&#34;,command=filepath_report_fig)
        self.browse_results_fig.grid(row=1, column=7, sticky=&#39;ew&#39;, padx=2.5)
        
        self.save_results_fig = ttk.Button(results_export_Frame, text=&#34;Save&#34;,command=save_report_fig)
        self.save_results_fig.grid(row=1, column=8, columnspan=2, sticky=&#39;ew&#39;, padx=2.5)

        results_peakInfoFrame.pack(side=&#39;right&#39;, fill=&#39;both&#39;)
        self.results_chartFrame.pack(side=&#39;top&#39;, expand=True, fill=&#39;both&#39;)
        results_export_Frame.pack(side=&#39;bottom&#39;, fill=&#39;x&#39;)
        
        # Add tabs to tab control
        self.tab_control.add(self.results_tab, text=&#34;Results&#34;)

        # Pack tab control
        self.tab_control.pack(expand=True, fill=&#34;both&#34;)

def on_closing():
    plt.close(&#39;all&#39;)
    root.destroy()
    exit()

if __name__ == &#34;__main__&#34;:
    root = tk.Tk()
    icon_path = pathlib.Path(pkg_resources.resource_filename(__name__, &#39;resources/icon/sprit_icon_alpha.ico&#39;))
    root.iconbitmap(icon_path)

    app = SPRIT_App(root)

    root.protocol(&#34;WM_DELETE_WINDOW&#34;, on_closing)
    root.mainloop()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sprit.sprit_gui.catch_errors"><code class="name flex">
<span>def <span class="ident">catch_errors</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def catch_errors(func):
    #Define a local function to get a list of warnings that we&#39;ll use in the output
    def get_warning_msg_list(w):
        messageList = []
        #Collect warnings that happened before we got to the error
        if w:
            hasWarnings = True
            for warning in w:
                warning_category = type(warning.message).__name__.title().replace(&#39;warning&#39;,&#39;Warning&#39;)
                warning_message = str(warning.message)
                # append the warning category and message to messageList so we get all warnings
                messageList.append(f&#39;{warning_category}: {warning_message}&#39;)
        return messageList
    
    # use functools.wraps to preserve the original function&#39;s metadata
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        result = None
        # use the global keyword to access the error_message and error_category variables
        global error_message
        global error_category

        messageList = []
        hasWarnings = False
        # use a try-except block to catch any exceptions
        try:
            # use a context manager to catch any warnings
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter(&#39;always&#39;)
                # call the original function with the given arguments
                result = func(*args, **kwargs)
                
                #Get message list, [] if no messages, doesn&#39;t run at all if Error/exception in func
                messageList = get_warning_msg_list(w)
                if messageList == []:
                    return result
                else:
                    warningMessage = &#34;WARNING:&#34;
                    for msg in messageList:
                        warningMessage = &#34;\n {}&#34;.format(msg)

                    messagebox.showwarning(title=&#39;WARNINGS&#39;, message=warningMessage)
                    
        except Exception as e:
            messageList = get_warning_msg_list(w)
            
            error_category = type(e).__name__.title().replace(&#39;error&#39;, &#39;Error&#39;)
            error_message = str(e)

            #Print the linenumber where error occured to terminal
            #print(traceback.extract_tb(sys.exc_info()[2])[-1].lineno)
            #Print the function name where the error occured
            #print(func.__name__)

            #Get message list, [] if no messages, doesn&#39;t run at all if Error/exception in func
            warningMessageList = get_warning_msg_list(w)
            
            fullErrorMessage = f&#39;PRIMARY ERROR ({error_category}): {error_message}&#39;
            if messageList == []:
                pass
            else:
                
                fullErrorMessage = fullErrorMessage+&#34;\n\n  Additional Warnings along the way:&#34;
                for addMsg in warningMessageList:
                    fullErrorMessage = &#34;\n{}\n   {}&#34;.format(fullErrorMessage, addMsg)

            messagebox.showerror(title=f&#39;ERROR ({error_category})&#39;,
                                    message=fullErrorMessage)
                
        # return the result of the function or the error/warning messages and categories
        return result
    # return the wrapper function
    return wrapper</code></pre>
</details>
</dd>
<dt id="sprit.sprit_gui.on_closing"><code class="name flex">
<span>def <span class="ident">on_closing</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_closing():
    plt.close(&#39;all&#39;)
    root.destroy()
    exit()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sprit.sprit_gui.SPRIT_App"><code class="flex name class">
<span>class <span class="ident">SPRIT_App</span></span>
<span>(</span><span>master)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SPRIT_App:
    def __init__(self, master):
        self.master = master
        self.master.title(&#34;SPRIT&#34;)
        self.params = sprit_hvsr.HVSRData({&#39;site&#39;:&#39;&#39;})

        # Set the theme
        self.darkthemepath = pathlib.Path(pkg_resources.resource_filename(__name__, &#34;resources/themes/forest-dark.tcl&#34;))
        self.lightthemepath = pathlib.Path(pkg_resources.resource_filename(__name__, &#34;resources/themes/forest-light.tcl&#34;))
        
        # Create the style object
        self.style = ttk.Style(master)
        self.master.tk.call(&#39;source&#39;, self.lightthemepath)
        #self.style.theme_use(&#39;default&#39;)
        self.style.theme_use(&#39;forest-light&#39;)

        self.create_menubar()
        self.create_tabs()

        self.master.rowconfigure(0, weight=1)
        self.master.columnconfigure(0, weight=1)        

        # Create the dark theme
        #self.style.theme_create(&#34;dark&#34;, parent=&#34;alt&#34;, settings={
        #    &#34;TLabel&#34;: {&#34;configure&#34;: {&#34;background&#34;: &#34;black&#34;, &#34;foreground&#34;: &#34;white&#34;}},
        #    &#34;TButton&#34;: {&#34;configure&#34;: {&#34;background&#34;: &#34;black&#34;, &#34;foreground&#34;: &#34;white&#34;}},
        #    # Add more options here to style other widgets
        #})
        
        # Create the light theme
        #self.style.theme_create(&#34;light&#34;, parent=&#34;alt&#34;, settings={
        #    &#34;TLabel&#34;: {&#34;configure&#34;: {&#34;background&#34;: &#34;white&#34;, &#34;foreground&#34;: &#34;black&#34;}},
        #    &#34;TButton&#34;: {&#34;configure&#34;: {&#34;background&#34;: &#34;white&#34;, &#34;foreground&#34;: &#34;black&#34;}},
        #    # Add more options here to style other widgets
        #})
        
    #Not currently working
    def manual_label_update(self):
        for notebook in self.master.winfo_children():
            if isinstance(notebook, ttk.Notebook):
                for tab_id in notebook.tabs():
                    tab_frame = notebook.nametowidget(tab_id)
                    #print(type(tab_frame))
                    for frame in tab_frame.winfo_children():
                        if isinstance(frame, ttk.LabelFrame):
                            for widget in frame.winfo_children():
                                if isinstance(widget, ttk.Label):
                                    # apply the updated style to the label
                                    
                                    self.style.layout(&#39;CustTLabel&#39;, [(&#39;Label.border&#39;, {&#39;sticky&#39;: &#39;nswe&#39;, &#39;border&#39;: &#39;1&#39;, &#39;children&#39;: [(&#39;Label.padding&#39;, {&#39;sticky&#39;: &#39;nswe&#39;, &#39;children&#39;: [(&#39;Label.text&#39;, {&#39;sticky&#39;: &#39;nswe&#39;})]})]})])
                                    self.style.configure(&#39;CustTLabel&#39;, background=self.style.lookup(&#39;style&#39;, &#39;background&#39;), foreground=self.style.lookup(&#39;style&#39;, &#39;background&#39;))
                                    self.style.map(&#39;CustTLabel&#39;, {&#39;priority&#39;:[(&#39;CustTLabel&#39;,1)]})
                                    widget.configure(style=&#39;CustTLabel&#39;)

    def create_menubar(self):
        self.menubar = tk.Menu(self.master)
        self.master.config(menu=self.menubar)
        
        self.sprit_menu = tk.Menu(self.menubar, tearoff=0)

        def on_theme_select():
            # Set the theme based on the selected value
            self.style = ttk.Style()
            
            &#34;&#34;&#34;An attempt to get the backgrounds right
            def apply_to_all_children(widget, func):
                Recursively apply a function to all child widgets of a given widget
                children = widget.winfo_children()
                for child in children:
                    func(child)
                    apply_to_all_children(child, func)
                return

            def change_background_color(widget):
                if isinstance(widget, tk.Label):
                    widget.option_clear()
                    widget.configure(background=None, foreground=None)
                return
            
            apply_to_all_children(self.master, change_background_color)
            &#34;&#34;&#34;
            if &#39;forest&#39; in self.theme_var.get():
                if self.theme_var.get()==&#39;forest-dark&#39; and &#39;forest-dark&#39; not in self.style.theme_names():
                    self.master.tk.call(&#39;source&#39;, self.darkthemepath)
                elif self.theme_var.get()==&#39;forest-light&#39; and &#39;forest-light&#39; not in self.style.theme_names():
                    self.master.tk.call(&#39;source&#39;, self.lightthemepath)            
            self.master.tk.call(&#34;ttk::style&#34;, &#34;theme&#34;, &#34;use&#34;, self.theme_var.get())
            #self.master.tk.call(&#34;ttk::setTheme&#34;, self.theme_var.get())

            #self.style.theme_use(self.theme_var.get())
            #self.master.tk.call(&#39;source&#39;, self.lightthemepath)
            #self.style.theme_use(self.theme_var.get())
            #self.style.configure(&#34;TLabel&#34;, background=self.style.lookup(&#39;TLabel&#39;, &#39;background&#39;), foreground=self.style.lookup(&#39;TLabel&#39;, &#39;background&#39;))

        def import_parameters(self):
            filepath = filedialog.askopenfilename()
        
        
        def export_parameters(self):
            filepath = filedialog.asksaveasfilename()

        self.theme_menu = tk.Menu(self.menubar, tearoff=0)
        self.theme_var = tk.StringVar(value=&#34;Default&#34;)
        self.theme_menu.add_radiobutton(label=&#34;Default&#34;, variable=self.theme_var, value=&#34;default&#34;, command=on_theme_select)
        self.theme_menu.add_radiobutton(label=&#34;Clam&#34;, variable=self.theme_var, value=&#34;clam&#34;, command=on_theme_select)
        self.theme_menu.add_radiobutton(label=&#34;Alt&#34;, variable=self.theme_var, value=&#34;alt&#34;, command=on_theme_select)
        self.theme_menu.add_radiobutton(label=&#34;Forest Light (buggy)&#34;, variable=self.theme_var, value=&#34;forest-light&#34;, command=on_theme_select)
        self.theme_menu.add_radiobutton(label=&#34;Forest Dark (buggy)&#34;, variable=self.theme_var, value=&#34;forest-dark&#34;, command=on_theme_select)

        self.sprit_menu.add_cascade(label=&#34;Theme&#34;, menu=self.theme_menu)
        self.sprit_menu.add_command(label=&#34;Import Parameters&#34;, command=import_parameters)
        self.sprit_menu.add_command(label=&#34;Export Parameters&#34;, command=export_parameters)
        self.sprit_menu.add_separator()
        self.sprit_menu.add_command(label=&#34;Exit&#34;, command=self.master.quit)
        self.settings_menu = tk.Menu(self.menubar, tearoff=0)
        self.instrument_menu = tk.Menu(self.settings_menu, tearoff=0)
        self.instrument_var = tk.StringVar(value=&#34;Raspberry Shake&#34;)
        self.instrument_menu.add_radiobutton(label=&#34;Raspberry Shake&#34;, variable=self.instrument_var, value=&#34;Raspberry Shake&#34;)
        self.instrument_menu.add_radiobutton(label=&#34;Nodes&#34;, variable=self.instrument_var, value=&#34;Nodes&#34;)
        self.instrument_menu.add_radiobutton(label=&#34;Other&#34;, variable=self.instrument_var, value=&#34;Other&#34;)
        self.settings_menu.add_cascade(label=&#34;Instrument&#34;, menu=self.instrument_menu)
        self.settings_menu.add_command(label=&#34;Processing Settings&#34;, command=lambda: self.tab_control.select(self.settings_tab))

        self.menubar.add_cascade(label=&#34;SPRIT&#34;, menu=self.sprit_menu)
        self.menubar.add_cascade(label=&#34;Settings&#34;, menu=self.settings_menu)
    
    def create_tabs(self):
        self.style = ttk.Style(self.master)

        self.tab_control = ttk.Notebook(self.master)

        # INPUT TAB
        self.input_tab = ttk.Frame(self.tab_control)

        # Configure the row and column of the input_tab to have a non-zero weight
        hvsrFrame = ttk.LabelFrame(self.input_tab, text=&#34;Input Parameters&#34;)
        #hvsrFrame.rowconfigure(0, weight=1)
        hvsrFrame.columnconfigure(1, weight=1)

        # Logo and Site Name
        # Replace &#34;logo.png&#34; with the path to your logo image
        #self.logo = tk.PhotoImage(file=&#34;logo.png&#34;)
        #self.logo_label = ttk.Label(hvsrFrame, image=self.logo)
        #self.logo_label.grid(row=0, column=0)
        self.processingData = False

        
        def update_input_labels(hvsr_data):
            #Update labels for data preview tab
            self.input_data_label.configure(text=self.data_filepath_entry.get() + &#39;\n&#39; + str(hvsr_data[&#39;stream&#39;]))
            
            self.obspySreamLabel_settings.configure(text=str(hvsr_data[&#39;stream&#39;]))

            self.sensitivityLabelZ_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;Z&#39;][&#39;sensitivity&#39;])
            self.gainLabelZ_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;Z&#39;][&#39;gain&#39;])
            self.polesLabelZ_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;Z&#39;][&#39;poles&#39;])
            self.zerosLabelZ_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;Z&#39;][&#39;zeros&#39;])
            
            self.sensitivityLabelN_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;N&#39;][&#39;sensitivity&#39;])
            self.gainLabelN_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;N&#39;][&#39;gain&#39;])
            self.polesLabelN_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;N&#39;][&#39;poles&#39;])
            self.zerosLabelN_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;N&#39;][&#39;zeros&#39;])

            self.sensitivityLabelE_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;E&#39;][&#39;sensitivity&#39;])
            self.gainLabelE_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;E&#39;][&#39;gain&#39;])
            self.polesLabelE_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;E&#39;][&#39;poles&#39;])
            self.zerosLabelE_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;E&#39;][&#39;zeros&#39;])
            return
        
        #FUNCTION TO READ DATA
        @catch_errors
        def read_data():
            self.starttime, self.endtime = get_times()


            if self.file_source.get() == &#39;batch&#39;:
                if isinstance(self.fpath, str):
                    pass
                elif len(self.fpath) &gt; 1:
                    self.fpath = list(self.fpath)
                    batchType = &#39;filelist&#39;
                else:
                    self.fpath = self.fpath[0]
                    batchType = &#39;table&#39;

                self.params = sprit_hvsr.batch_data_read(input_data=self.fpath, batch_type=batchType)
                self.hvsr_data = self.params
                firstSite = self.hvsr_data[list(self.hvsr_data.keys())[0]]
                update_input_labels(firstSite)

                #Plot data in data preview tab
                self.fig_pre, self.ax_pre = sprit_hvsr.plot_stream(stream=firstSite[&#39;stream&#39;], params=firstSite, fig=self.fig_pre, axes=self.ax_pre, return_fig=True)

                #Plot data in noise preview tab
                self.fig_noise, self.ax_noise = sprit_hvsr._plot_specgram_stream(stream=firstSite[&#39;stream&#39;], params=firstSite, fig=self.fig_noise, ax=self.ax_noise, fill_gaps=0, component=&#39;Z&#39;, stack_type=&#39;linear&#39;, detrend=&#39;mean&#39;, dbscale=True, return_fig=True, cmap_per=[0.1,0.9])
                select_windows(event=None, initialize=True)
                plot_noise_windows(firstSite)

            else:
                if isinstance(self.fpath, str):
                    pass
                elif len(self.fpath) &gt; 1:
                    self.fpath = list(self.fpath)
                else:
                    self.fpath = self.fpath[0]

                self.params = sprit_hvsr.input_params( datapath=self.fpath,
                                    metapath = self.meta_path.get(),
                                    site=self.site_name.get(),
                                    network=self.network.get(), 
                                    station=self.station.get(), 
                                    loc=self.location.get(), 
                                    channels=[self.z_channel.get(), self.n_channel.get(), self.e_channel.get()],
                                    acq_date = self.starttime.date(),
                                    starttime = self.starttime,
                                    endtime = self.endtime,
                                    tzone = &#39;UTC&#39;, #Will always be converted to UTC before we get to this point when using gui
                                    xcoord = self.x.get(),
                                    ycoord =  self.y.get(),
                                    elevation = self.z.get(),
                                    input_crs= self.input_crs.get(),
                                    output_crs= self.output_crs.get(),
                                    elev_unit= self.elev_unit.get(),
                                    instrument = self.instrumentSel.get(),
                                    hvsr_band = [self.hvsrBand_min.get(), self.hvsrBand_max.get()] )

                if self.trim_dir.get()==&#39;&#39;:
                    trimDir=None
                else:
                    trimDir=self.trim_dir.get()

                self.hvsr_data = sprit_hvsr.fetch_data(params=self.params,
                                            source=self.file_source.get(), 
                                            trim_dir=trimDir, 
                                            export_format=self.export_format.get(), 
                                            detrend=self.detrend.get(), 
                                            detrend_order=self.detrend_order.get())
                
                update_input_labels(self.hvsr_data)


                #Plot data in data preview tab
                self.fig_pre, self.ax_pre = sprit_hvsr.plot_stream(stream=self.hvsr_data[&#39;stream&#39;], params=self.hvsr_data, fig=self.fig_pre, axes=self.ax_pre, return_fig=True)

                #Plot data in noise preview tab
                self.fig_noise, self.ax_noise = sprit_hvsr._plot_specgram_stream(stream=self.hvsr_data[&#39;stream&#39;], params=self.hvsr_data, fig=self.fig_noise, ax=self.ax_noise, fill_gaps=0, component=&#39;Z&#39;, stack_type=&#39;linear&#39;, detrend=&#39;mean&#39;, dbscale=True, return_fig=True, cmap_per=[0.1,0.9])
                select_windows(event=None, initialize=True)
                plot_noise_windows(self.hvsr_data)

            self.data_read = True
            if not self.processingData:
                self.tab_control.select(self.preview_data_tab)

        #FUNCTION TO PROCESS DATA
        @catch_errors
        def process_data():
            self.processingData = True #Set to true while data processing algorithm is being run
            
            if self.data_read == False:
                read_data()
            
            self.hvsr_data = plot_noise_windows(self.hvsr_data)
   
            self.hvsr_data = sprit_hvsr.generate_ppsds(params=self.hvsr_data, 
                                               ppsd_length=self.ppsd_length.get(), 
                                               overlap=self.overlap.get(), 
                                               period_step_octaves=self.perStepOct.get(), 
                                               remove_outliers=self.remove_outliers.get(), 
                                               outlier_std=self.outlier_std.get(),
                                               skip_on_gaps=self.skip_on_gaps.get(),
                                               db_bins=self.db_bins,
                                               period_limits=self.period_limits,
                                               period_smoothing_width_octaves=self.perSmoothWidthOct.get(),
                                               special_handling=special_handling
                                               )
            
            self.hvsr_results = sprit_hvsr.process_hvsr(params=self.hvsr_data, 
                                                   method=self.method_ind,
                                                   smooth=self.hvsmooth_param,
                                                   freq_smooth=self.freq_smooth.get(),
                                                   f_smooth_width=self.fSmoothWidth.get(), 
                                                   resample=self.hvresample_int, 
                                                   remove_outlier_curves=self.outlierRembool.get(), 
                                                   outlier_curve_std=self.outlierRemStDev.get())
            
            self.hvsr_results = sprit_hvsr.check_peaks(hvsr_data=self.hvsr_results, 
                                                  hvsr_band = [self.hvsrBand_min.get(), self.hvsrBand_max.get()],
                                                  peak_water_level=self.peak_water_level)

            curveTest1ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Lw&#39;][:-1])
            curveTest1Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Lw&#39;][-1])

            curveTest2ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Nc&#39;][:-1])
            curveTest2Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Nc&#39;][-1])

            curveTest3ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;σ_A(f)&#39;][:-1])
            curveTest3Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;σ_A(f)&#39;][-1])

            curvePass = (self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Window Length Freq.&#39;] +
                                self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Significant Cycles&#39;]+
                                self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Low Curve StDev. over time&#39;]) &gt; 2
            if curvePass:
                totalCurveResult.configure(text=sprit_utils.check_mark(), font=(&#34;TkDefaultFont&#34;, 16, &#34;bold&#34;), foreground=&#39;green&#39;)
            else:
                totalCurveResult.configure(text=sprit_utils.x_mark(), font=(&#34;TkDefaultFont&#34;, 16, &#34;bold&#34;), foreground=&#39;red&#39;)

            peakTest1ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;A(f-)&#39;][:-1])
            peakTest1Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;A(f-)&#39;][-1])
            
            peakTest2ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;A(f+)&#39;][:-1])
            peakTest2Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;A(f+)&#39;][-1])
            
            peakTest3ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;A0&#39;][:-1])
            peakTest3Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;A0&#39;][-1])

            peakTest4ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;P-&#39;][:5] + &#39; and &#39; +self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;P+&#39;][:-1])
            if self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Freq. Stability&#39;]:
                peakTest4Result.configure(text=&#39;✔&#39;)
            else:
                peakTest4Result.configure(text=&#39;✘&#39;)

            peakTest5ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Sf&#39;][:-1])
            peakTest5Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Sf&#39;][-1])
            
            peakTest6ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Sa&#39;][:-1])
            peakTest6Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Sa&#39;][-1])

            peakPass = (self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Peak Freq. Clarity Below&#39;] +
                    self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Peak Freq. Clarity Above&#39;]+
                    self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Peak Amp. Clarity&#39;]+
                    self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Freq. Stability&#39;]+
                    self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Peak Stability (freq. std)&#39;]+
                    self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Peak Stability (amp. std)&#39;]) &gt;= 5
            if peakPass:
                totalPeakResult.configure(text=&#39;✔&#39;, font=(&#34;TkDefaultFont&#34;, 16, &#34;bold&#34;), foreground=&#39;green&#39;)
            else:
                totalPeakResult.configure(text=&#39;✘&#39;, font=(&#34;TkDefaultFont&#34;, 16, &#34;bold&#34;), foreground=&#39;red&#39;)

            if curvePass and peakPass:
                totalResult.configure(text=&#39;Pass ✔&#39;, font=(&#34;TkDefaultFont&#34;, 22, &#34;bold&#34;), foreground=&#39;green&#39;)
            else:
                totalResult.configure(text=&#39;Fail ✘&#39;, font=(&#34;TkDefaultFont&#34;, 22, &#34;bold&#34;), foreground=&#39;red&#39;)

            sprit_hvsr.hvplot(self.hvsr_results, plot_type=get_kindstr(), fig=self.fig_results, ax=self.ax_results, use_subplots=True, clear_fig=False)

            self.processingData = False
            self.tab_control.select(self.results_tab)

        
        def update_input_params_call():
            self.input_params_call.configure(text=&#34;input_params( datapath=&#39;{}&#39;, metapath={}, site=&#39;{}&#39;, instrument=&#39;{}&#39;,\n\tnetwork=&#39;{}&#39;, station=&#39;{}&#39;, loc=&#39;{}&#39;, channels=[{}, {}, {}], \n\tacq_date=&#39;{}&#39;, starttime=&#39;{}&#39;, endttime=&#39;{}&#39;, tzone=&#39;{}&#39;, \n\txcoord={}, ycoord={}, elevation={}, input_crs=&#39;{}&#39;, output_crs=&#39;{}&#39;, elev_unit=&#39;{}&#39;,  hvsr_band=[{}, {}])&#34;.format(
                                            self.data_path.get(), self.meta_path.get(), self.site_name.get(), self.instrumentSel.get(),
                                            self.network.get(), self.station.get(), self.location.get(),
                                            self.z_channel.get(), self.e_channel.get(), self.n_channel.get(),
                                            self.acq_date, self.starttime.time(), self.endtime.time(), self.tz,
                                            self.x.get(), self.y.get(), self.z.get(), 
                                            self.input_crs.get(), self.output_crs.get(), self.elev_unit.get(), 
                                            self.hvsrBand_min.get(), self.hvsrBand_max.get()))
        #Specify site name        
        siteLabel = ttk.Label(hvsrFrame, text=&#34;Site Name&#34;)
        siteLabel.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5)
        self.site_name = tk.StringVar()
        self.site_name.set(&#39;HVSR Site&#39;)
        self.site_name_entry = ttk.Entry(hvsrFrame, textvariable=self.site_name, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.site_name_entry.grid(row=0, column=1, columnspan=1, sticky=&#39;ew&#39;, padx=5)

        # source=file
        
        def on_source_select():
            try:
                str(self.file_source.get())
                sourceLabel.configure(text=&#34;source=&#39;{}&#39;&#34;.format(self.file_source.get()))
                update_fetch_call()

                if self.file_source.get() == &#39;raw&#39; or self.file_source.get() == &#39;dir&#39;:
                    self.browse_data_filepath_button.configure(text=&#39;Browse Folder&#39;)
                    self.batch_options_frame.grid_forget()
                elif self.file_source.get() == &#39;batch&#39;:
                    self.batch_options_frame.grid(row=11, column=0, columnspan=7, sticky=&#39;ew&#39;)
                else:
                    self.browse_data_filepath_button.configure(text=&#39;Browse File(s)&#39;)
                    self.batch_options_frame.grid_forget()
                return True
            except ValueError:
                return False

        sourceLabel = ttk.Label(master=hvsrFrame, text=&#34;source=&#39;file&#39;&#34;)

        ttk.Label(master=hvsrFrame, text=&#39;Data Source Type [str]&#39;).grid(row=0, column=3, sticky=&#39;e&#39;, padx=5)
        sourcFrame= ttk.Frame(hvsrFrame)
        sourcFrame.grid(row=0, column=4, sticky=&#39;w&#39;, columnspan=3)
        self.file_source = tk.StringVar()
        self.file_source.set(&#39;file&#39;)
        ttk.Radiobutton(master=sourcFrame, text=&#39;File&#39;, variable=self.file_source, value=&#39;file&#39;, command=on_source_select).grid(row=0, column=0, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=sourcFrame, text=&#39;Raw&#39;, variable=self.file_source, value=&#39;raw&#39;, command=on_source_select).grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=sourcFrame, text=&#39;Batch&#39;, variable=self.file_source, value=&#39;batch&#39;, command=on_source_select).grid(row=0, column=2, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=sourcFrame, text=&#39;Directory&#39;, variable=self.file_source, value=&#39;dir&#39;, command=on_source_select).grid(row=0, column=3, sticky=&#39;w&#39;, padx=(5, 10))

        #Instrument select
        ttk.Label(hvsrFrame, text=&#34;Instrument&#34;).grid(row=0, column=6, sticky=&#39;e&#39;, padx=5)
        inst_options = [&#34;Raspberry Shake&#34;, &#34;Nodes&#34;, &#34;Other&#34;]

        
        def on_option_select(self, inst):
            update_input_params_call()
            if inst == &#34;Raspberry Shake&#34;:
                self.network_entry.configure(state=&#39;normal&#39;)
                self.station_entry.configure(state=&#39;normal&#39;)
                self.location_entry.configure(state=&#39;normal&#39;)
                
                self.z_channel_entry.delete(0, &#39;end&#39;)
                self.e_channel_entry.delete(0, &#39;end&#39;)
                self.n_channel_entry.delete(0, &#39;end&#39;)
                
                self.z_channel_entry.insert(0,&#34;EHZ&#34;)
                self.e_channel_entry.insert(0,&#34;EHE&#34;)
                self.n_channel_entry.insert(0,&#34;EHN&#34;)

                self.network_entry.delete(0, &#39;end&#39;)
                self.network_entry.insert(0,&#34;AM&#34;)

                self.station_entry.delete(0, &#39;end&#39;)
                self.station_entry.insert(0,&#34;RAC84&#34;)

                self.location_entry.delete(0, &#39;end&#39;)
                self.location_entry.insert(0,&#34;00&#34;)
            else:
                self.network_entry.configure(state=&#39;disabled&#39;)
                self.station_entry.configure(state=&#39;disabled&#39;)
                self.location_entry.configure(state=&#39;disabled&#39;)

        self.instrumentSel = tk.StringVar(value=inst_options[0])
        self.instrument_dropdown = ttk.OptionMenu(hvsrFrame, self.instrumentSel, inst_options[0], *inst_options, command=on_option_select)
        self.instrument_dropdown.config(width=20)
        self.instrument_dropdown.grid(row=0, column=7, columnspan=1, sticky=&#39;ew&#39;)

        # Data Filepath
        dataLabel= ttk.Label(hvsrFrame, text=&#34;Data Filepath&#34;)
        dataLabel.grid(row=1, column=0, sticky=&#39;e&#39;, padx=5, pady=(5,2.55))
    
        #Function to set self.data_read False whenever the data_path is updated
        
        def on_data_path_change(data_path, index, trace_mode):
            #If our data path changes, data is registered as not having been read
            #This is primarily so that if just the Run button is pushed, it will know to first read the data
            self.data_read = False
        
        
        def filepath_update():
            self.fpath = self.data_path.get()
            self.data_read = False
            update_input_params_call()

        self.data_path = tk.StringVar()
        self.data_path.trace(&#39;w&#39;, on_data_path_change)
        self.data_filepath_entry = ttk.Entry(hvsrFrame, textvariable=self.data_path, validate=&#39;focusout&#39;, validatecommand=filepath_update)
        self.data_filepath_entry.grid(row=1, column=1, columnspan=6, sticky=&#39;ew&#39;, padx=5, pady=(5,2.55))

        
        def browse_data_filepath():
            if self.file_source.get() == &#39;raw&#39; or self.file_source.get() == &#39;dir&#39;:
                self.fpath = filedialog.askdirectory()
                if self.fpath:
                    self.data_filepath_entry.delete(0, &#39;end&#39;)
                    self.data_filepath_entry.insert(0, self.fpath)
            else:
                self.fpath = filedialog.askopenfilenames()
                
                #fpath will always be tuple
                self.no_data_files = len(self.fpath)
                    
                if self.fpath:
                    self.data_filepath_entry.delete(0, &#39;end&#39;)
                    for f in self.fpath:
                        self.data_filepath_entry.insert(&#39;end&#39;, self.fpath)
                
            update_input_params_call()


        buttonFrame = ttk.Frame(hvsrFrame)
        buttonFrame.grid(row=1, column=7, sticky=&#39;ew&#39;)

        self.browse_data_filepath_button = ttk.Button(buttonFrame, text=&#34;Browse File(s)&#34;, command=browse_data_filepath)

        #self.browse_data_filepath_button.grid(row=1, column=6, sticky=&#39;ew&#39;)
        self.browse_data_filepath_button.pack(side=&#34;left&#34;, fill=&#34;x&#34;, expand=True, padx=(0,2), pady=(5,2.55))

        # Metadata Filepath
        ttk.Label(hvsrFrame, text=&#34;Metadata Filepath&#34;).grid(row=2, column=0, sticky=&#39;e&#39;, padx=5, pady=(2.5,5))
        self.meta_path = tk.StringVar()
        self.metadata_filepath_entry = ttk.Entry(hvsrFrame, textvariable=self.meta_path, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.metadata_filepath_entry.grid(row=2, column=1, columnspan=6, sticky=&#39;ew&#39;, padx=5, pady=(2.5,5))
        
        
        def browse_metadata_filepath():
            filepath = filedialog.askopenfilename()
            if filepath:
                self.metadata_filepath_entry.delete(0, &#39;end&#39;)
                self.metadata_filepath_entry.insert(0, filepath)
            update_input_params_call()

        self.browse_metadata_filepath_button = ttk.Button(hvsrFrame, text=&#34;Browse&#34;, command=browse_metadata_filepath)
        self.browse_metadata_filepath_button.grid(row=2, column=7, sticky=&#39;ew&#39;, padx=0, pady=(2.5,5))

        
        def update_acq_date(event):
            aMonth = self.acq_month.get()
            if str(aMonth)[0]==&#39;0&#39;:
                aMonth = str(aMonth)[-1]

            aDay = self.acq_day.get()
            if str(aDay)[0]==&#39;0&#39;:
                aDay = str(aDay)[-1]

            self.acq_date = datetime.date(year=self.acq_year.get(), month=aMonth, day=aDay)#self.date_entry.get_date()
            self.day_of_year = self.acq_date.timetuple().tm_yday
            self.doy_label.configure(text=str(self.day_of_year))
            update_input_params_call()

        # Date and Time
        dateFrame = ttk.Frame(hvsrFrame)
        dateFrame.grid(row=3, column=1, columnspan=2, sticky=&#39;e&#39;, padx=5)
        ttk.Label(dateFrame, text=&#34;Date&#34;).grid(row=1, column=1, sticky=&#39;e&#39;, padx=5)

        self.acq_year = tk.IntVar()
        self.acq_year.set(int(datetime.datetime.today().year))
        self.acq_year_entry = ttk.Spinbox(dateFrame, from_=0, to=10000, width=7, textvariable=self.acq_year, validate=&#39;focusout&#39;, validatecommand=update_acq_date) 
        self.acq_year_entry.grid(row=1, column=2, sticky=&#39;ew&#39;, padx=1)

        self.acq_month = tk.IntVar()
        self.acq_month.set(int(datetime.datetime.today().month))
        self.acq_month_entry = ttk.Spinbox(dateFrame, from_=0, to=12, width=3, textvariable=self.acq_month, validate=&#39;focusout&#39;, validatecommand=update_acq_date) 
        self.acq_month_entry.grid(row=1, column=3, sticky=&#39;ew&#39;, padx=1)

        self.acq_day = tk.IntVar()
        self.acq_day.set(int(datetime.datetime.today().day))
        self.acq_day_entry = ttk.Spinbox(dateFrame, from_=0, to=31, width=3, textvariable=self.acq_day, validate=&#39;focusout&#39;, validatecommand=update_acq_date) 
        self.acq_day_entry.grid(row=1, column=4, sticky=&#39;ew&#39;, padx=1)

        self.acq_date = datetime.date.today()
        #self.date_entry = DateEntry(hvsrFrame, date_pattern=&#39;y-mm-dd&#39;, textvariable=self.acq_date, validate=&#39;focusout&#39;)#update_input_params_call)
        #self.date_entry.grid(row=3, column=2, sticky=&#39;w&#39;, padx=5)
        #self.date_entry.bind(&#34;&lt;&lt;DateEntrySelected&gt;&gt;&#34;, update_acq_date)
        
        sTimeFrame = ttk.Frame(hvsrFrame)
        sTimeFrame.grid(row=3, column=4, sticky=&#39;ew&#39;)

        def get_times():
            #Format starttime as datetime object (in timezone as originally entered)
            self.acq_date = datetime.date(year=self.acq_year.get(), month=self.acq_month.get(), day=self.acq_day.get())#self.date_entry.get_date()

            sHour = self.start_hour.get()
            if str(sHour)[0] == &#39;0&#39;:
                sHour = int(str(sHour)[-1])

            sMin = self.start_minute.get()
            if str(sMin)[0] == &#39;0&#39;:
                sMin = int(str(sMin)[-1])

            self.starttime = datetime.datetime(year = self.acq_date.year, 
                                          month = self.acq_date.month,
                                          day = self.acq_date.day,
                                          hour = sHour,
                                          minute = sMin,
                                          tzinfo=self.tz)
            
            #Get duration, as originally entered
            hour_dur = self.end_hour.get() - self.start_hour.get()
            if hour_dur &lt; 0:
                hour_dur = self.end_hour.get() + 24 - self.start_hour.get()
            min_dur = self.end_minute.get() - self.start_minute.get()

            #Convert starttime to utc
            #self.starttime = self.tz.normalize(self.tz.localize(self.starttime)).astimezone(pytz.utc)
            self.starttime  = self.starttime.astimezone(datetime.timezone.utc)

            #Get endttime based on utc starttime and original duration
            self.endtime = self.starttime + datetime.timedelta(hours=hour_dur, minutes=min_dur)

            return self.starttime, self.endtime

        self.tz = datetime.timezone.utc

        
        def any_time_change():
            self.acq_date = self.date_entry.get_date()
            self.starttime, self.endtime = get_times()
            update_input_params_call()

        ttk.Label(hvsrFrame, text=&#34;Start Time&#34;).grid(row=3, column=3, sticky=&#39;e&#39;, padx=5) 
        colonLabel= ttk.Label(sTimeFrame, text=&#34;:&#34;)#.grid(row=3, column=4, padx=(20,0), sticky=&#39;w&#39;)
        self.start_hour = tk.IntVar()
        self.start_hour.set(00)
        self.start_time_hour_entry = ttk.Spinbox(sTimeFrame, from_=0, to=23, width=5, textvariable=self.start_hour, validate=&#39;focusout&#39;, validatecommand=any_time_change) 
        self.start_time_hour_entry#.grid(row=3, column=4, sticky=&#39;w&#39;) 
        self.start_minute = tk.DoubleVar()
        self.start_minute.set(00)
        self.start_time_min_entry = ttk.Spinbox(sTimeFrame, from_=0, to=59, width=5, textvariable=self.start_minute, validate=&#39;focusout&#39;, validatecommand=any_time_change)
        self.start_time_min_entry#.grid(row=3, column=4, padx=80, sticky=&#39;w&#39;) 
        
        #sTLabel.pack(side=&#34;left&#34;, fill=&#34;x&#34;, expand=True)
        self.start_time_hour_entry.pack(side=&#39;left&#39;, expand=True)
        colonLabel.pack(side=&#34;left&#34;, fill=&#34;x&#34;)
        self.start_time_min_entry.pack(side=&#39;right&#39;, expand=True)
        
        eTimeFrame = ttk.Frame(hvsrFrame)
        eTimeFrame.grid(row=3, column=6, sticky=&#39;ew&#39;)
        ttk.Label(hvsrFrame, text=&#34;End Time&#34;).grid(row=3, column=5, sticky=&#39;e&#39;, padx=5) 
        colonLabel = ttk.Label(eTimeFrame, text=&#34;:&#34;)#.grid(row=3, column=6, padx=(20,0), sticky=&#39;w&#39;)  
        self.end_hour = tk.IntVar()
        self.end_hour.set(23)
        self.end_time_hour_entry = ttk.Spinbox(eTimeFrame, from_=0, to=23, width=5, textvariable=self.end_hour, validate=&#39;focusout&#39;, validatecommand=any_time_change) 
        self.end_time_hour_entry#.grid(row=3, column=+, sticky=&#39;w&#39;) 
        self.end_minute = tk.DoubleVar()
        self.end_minute.set(59)
        self.end_time_min_entry = ttk.Spinbox(eTimeFrame, from_=0, to=59, width=5, textvariable=self.end_minute, validate=&#39;focusout&#39;, validatecommand=any_time_change)
        self.end_time_min_entry#.grid(row=3, column=+, padx=80, sticky=&#39;w&#39;) 

        #eTLabel.pack(side=&#34;left&#34;, fill=&#34;x&#34;, expand=True)
        self.end_time_hour_entry.pack(side=&#39;left&#39;, expand=True)
        colonLabel.pack(side=&#34;left&#34;, fill=&#34;x&#34;)
        self.end_time_min_entry.pack(side=&#39;right&#39;, expand=True)

        self.acq_date = datetime.date(year=self.acq_year.get(), month=self.acq_month.get(), day=self.acq_day.get())#self.date_entry.get_date()
        self.starttime, self.endtime = get_times()

        
        def onTimezoneSelect(event):
            #Listbox &#34;loses&#34; selection and triggers an event sometimes, so need to check if that is just what happened
            if self.timezone_listbox.curselection():
                #If it was an actual selection, update timezone
                self.tz = zoneinfo.ZoneInfo(self.timezone_listbox.get(self.timezone_listbox.curselection()))
            else:
                #If it was just the listbox losing the selection, don&#39;t change anything
                pass
            update_input_params_call()

        self.timezone_listbox = tk.Listbox(hvsrFrame, selectmode=&#39;browse&#39;, height=25)

        self.timezone_listbox.insert(&#39;end&#39;, &#39;UTC&#39;)
        self.timezone_listbox.insert(&#39;end&#39;, &#39;US/Central&#39;)

        for tz in zoneinfo.available_timezones():# pytz.all_timezones:
            if tz !=&#39;UTC&#39;:
                self.timezone_listbox.insert(&#39;end&#39;, tz)
        self.timezone_listbox.selection_set(0)
        self.timezone_listbox.bind(&#39;&lt;&lt;ListboxSelect&gt;&gt;&#39;, onTimezoneSelect)

        ttk.Label(hvsrFrame,text=&#34;Timezone&#34;).grid(row=3,column=7, sticky=&#39;w&#39;, padx=5)
        self.timezone_listbox.grid(row=4,column=7, rowspan=26, sticky=&#39;nsew&#39;, padx=5)

        #ttk.Label(hvsrFrame, text=&#34;Timezone&#34;).grid(row=3, column=7)
        #self.timezone_var = tk.StringVar(value=&#34;UTC&#34;)
        #self.timezone_listbox = ttk.OptionMenu(hvsrFrame, self.timezone_var, &#34;UTC&#34;, *pytz.all_timezones)
        #self.timezone_listbox.grid(row=3,column=7)

        # DOY
        self.day_of_year = self.acq_date.timetuple().tm_yday
        
        ttk.Label(hvsrFrame,text=&#34;Day of Year:&#34;).grid(row=4,column=1, sticky=&#39;e&#39;, padx=5, pady=10)
        self.doy_label = ttk.Label(hvsrFrame,text=str(self.day_of_year))
        self.doy_label.grid(row=4, column=2, sticky=&#39;w&#39;)

        # UTC Time Output
        ttk.Label(hvsrFrame,text=&#34;UTC Time:&#34;).grid(row=4, column=3, sticky=&#39;e&#39;, padx=5, pady=10)
        self.utc_time_output_label = ttk.Label(hvsrFrame,text=&#34;&#34;)
        self.utc_time_output_label.grid(row=4,column=4)

        #Initialize as UTC
        self.tz = datetime.timezone.utc
        #self.tz = pytz.timezone(self.timezone_listbox.get(self.timezone_listbox.curselection()))
        #input_params() call

        self.starttime, self.endtime = get_times()

        # X Y Z CRS Depth
        ttk.Label(hvsrFrame,text=&#34;X&#34;).grid(row=5,column=1, sticky=&#39;e&#39;, padx=5, pady=10)
        self.x = tk.DoubleVar()
        self.x.set(0)
        self.x_entry = ttk.Entry(hvsrFrame, textvariable=self.x, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.x_entry.grid(row=5,column=2, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;Y&#34;).grid(row=5,column=3, sticky=&#39;e&#39;, padx=5, pady=10)
        self.y = tk.DoubleVar()
        self.y.set(0)
        self.y_entry = ttk.Entry(hvsrFrame, textvariable=self.y, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.y_entry.grid(row=5, column=4, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;Z&#34;).grid(row=5,column=5, sticky=&#39;e&#39;, padx=5, pady=10)
        self.z = tk.DoubleVar()
        self.z.set(0)
        self.z_entry = ttk.Entry(hvsrFrame, textvariable=self.z, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.z_entry.grid(row=5,column=6, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;Input CRS&#34;).grid(row=6,column=1, sticky=&#39;e&#39;, padx=5, pady=10)
        self.input_crs = tk.StringVar()
        self.input_crs.set(&#39;EPSG:4236&#39;)
        self.input_crs_entry = ttk.Entry(hvsrFrame, textvariable=self.input_crs, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.input_crs_entry.grid(row=6,column=2, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;Output CRS&#34;).grid(row=6,column=3, sticky=&#39;e&#39;, padx=5, pady=10)
        self.output_crs = tk.StringVar()
        self.output_crs.set(&#39;EPSG:4236&#39;)
        self.output_crs_entry = ttk.Entry(hvsrFrame, textvariable=self.output_crs, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.output_crs_entry.grid(row=6, column=4, sticky=&#39;w&#39;, padx=0)

        ttk.Label(master=hvsrFrame, text=&#39;Elevation Unit&#39;).grid(row=6, column=5, sticky=&#39;e&#39;, padx=5, pady=10)
        elevUnitFrame= ttk.Frame(hvsrFrame)
        elevUnitFrame.grid(row=6, column=6, sticky=&#39;w&#39;, columnspan=3)
        self.elev_unit = tk.StringVar()
        self.elev_unit.set(&#39;meters&#39;)
        ttk.Radiobutton(master=elevUnitFrame, text=&#39;Meters&#39;, variable=self.elev_unit, value=&#39;meters&#39;, command=update_input_params_call).grid(row=0, column=0, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=elevUnitFrame, text=&#39;Feet&#39;, variable=self.elev_unit, value=&#39;feet&#39;, command=update_input_params_call).grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))

        # Network Station Location
        ttk.Label(hvsrFrame,text=&#34;Network&#34;).grid(row=7,column=1, sticky=&#39;e&#39;, padx=5, pady=10)
        self.network = tk.StringVar()
        self.network.set(&#39;AM&#39;)
        self.network_entry = ttk.Entry(hvsrFrame, textvariable=self.network, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.network_entry.grid(row=7,column=2, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;Station&#34;).grid(row=7,column=3, sticky=&#39;e&#39;, padx=5, pady=10)
        self.station = tk.StringVar()
        self.station.set(&#39;RAC84&#39;)
        self.station_entry = ttk.Entry(hvsrFrame, textvariable=self.station, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.station_entry.grid(row=7,column=4, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;Location&#34;).grid(row=7,column=5, sticky=&#39;e&#39;, padx=5, pady=10)
        self.location = tk.StringVar()
        self.location.set(&#39;00&#39;)
        self.location_entry = ttk.Entry(hvsrFrame, textvariable=self.location, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.location_entry.grid(row=7,column=6, sticky=&#39;w&#39;, padx=0)

        # Z N E Channels
        ttk.Label(hvsrFrame,text=&#34;Z Channel&#34;).grid(row=8,column=1, sticky=&#39;e&#39;, padx=5, pady=10)
        self.z_channel = tk.StringVar()
        self.z_channel.set(&#39;EHZ&#39;)
        self.z_channel_entry = ttk.Entry(hvsrFrame, textvariable=self.z_channel, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.z_channel_entry.grid(row=8,column=2, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;N Channel&#34;).grid(row=8,column=3, sticky=&#39;e&#39;, padx=5, pady=10)
        self.n_channel = tk.StringVar()
        self.n_channel.set(&#39;EHN&#39;)
        self.n_channel_entry = ttk.Entry(hvsrFrame, textvariable=self.n_channel, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.n_channel_entry.grid(row=8,column=4, sticky=&#39;w&#39;, padx=0)

        ttk.Label(hvsrFrame,text=&#34;E Channel&#34;).grid(row=8,column=5, sticky=&#39;e&#39;, padx=5, pady=10)
        self.e_channel = tk.StringVar()
        self.e_channel.set(&#39;EHE&#39;)
        self.e_channel_entry = ttk.Entry(hvsrFrame, textvariable=self.e_channel, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
        self.e_channel_entry.grid(row=8,column=6, sticky=&#39;w&#39;, padx=0)

        # HVSR Band
        def on_hvsrband_update():
            try:
                float(self.hvsrBand_min.get())
                float(self.hvsrBand_max.get())

                hvsrBandLabel.configure(text=&#39;hvsr_band=[{}, {}]&#39;.format(self.hvsrBand_min.get(), self.hvsrBand_max.get()))                
                update_check_peaks_call(self.checkPeaks_Call)
                update_input_params_call()
                return True
            except ValueError:
                return False      
        
        ttk.Label(hvsrFrame,text=&#34;HVSR Band&#34;).grid(row=9,column=1, sticky=&#39;e&#39;, padx=10, pady=10)
        hvsrbandframe= ttk.Frame(hvsrFrame)
        hvsrbandframe.grid(row=9, column=2,sticky=&#39;w&#39;)
        self.hvsrBand_min = tk.DoubleVar()
        self.hvsrBand_min.set(0.4)
        hvsr_band_min_entry = ttk.Entry(hvsrbandframe, width=9, textvariable=self.hvsrBand_min, validate=&#39;focusout&#39;, validatecommand=on_hvsrband_update)
        hvsr_band_min_entry.grid(row=0, column=0, sticky=&#39;ew&#39;, padx=(0,2))

        self.hvsrBand_max = tk.DoubleVar()
        self.hvsrBand_max.set(40)
        hvsr_band_max_entry = ttk.Entry(hvsrbandframe, width=9,textvariable=self.hvsrBand_max, validate=&#39;focusout&#39;, validatecommand=on_hvsrband_update)
        hvsr_band_max_entry.grid(row=0,column=1, sticky=&#39;ew&#39;, padx=(2,0))

        #BATCH Section
        
        def update_batch_data_read_call():
            self.batch_read_data_call.configure(text=&#34;batch_data_read(input_data, batch_type=&#39;{}&#39;, param_col={}, batch_params={})&#34;.format(
                                                                                        self.batch_type.get(), self.param_col.get(), self.batch_params.get()))
            return

        
        def on_batch_type_select():
            update_batch_data_read_call()
            return

        self.batch_options_frame = ttk.LabelFrame(hvsrFrame, text=&#39;Batch Options&#39;)
        ttk.Label(self.batch_options_frame, text=&#34;Batch Type&#34;).grid(row=0,column=0, sticky=&#39;e&#39;, padx=10, pady=10)
        batchTypeFrame= ttk.Frame(self.batch_options_frame)
        batchTypeFrame.grid(row=0, column=1, sticky=&#39;w&#39;, columnspan=3)
        self.batch_type = tk.StringVar()
        self.batch_type.set(&#39;table&#39;)
        ttk.Radiobutton(master=batchTypeFrame, text=&#39;Table&#39;, variable=self.batch_type, value=&#39;table&#39;, command=on_batch_type_select).grid(row=0, column=0, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=batchTypeFrame, text=&#39;File list&#39;, variable=self.batch_type, value=&#39;filelist&#39;, command=on_batch_type_select).grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))

        ttk.Label(self.batch_options_frame,text=&#34;Parameter column name&#34;).grid(row=0,column=4, sticky=&#39;e&#39;, padx=5)
        self.param_col = tk.StringVar()
        self.param_col.set(None)
        self.param_col_entry = ttk.Entry(self.batch_options_frame, textvariable=self.param_col, validate=&#39;focusout&#39;, validatecommand=update_batch_data_read_call)
        self.param_col_entry.grid(row=0, column=5, sticky=&#39;w&#39;, padx=0)
        ttk.Label(self.batch_options_frame,text=&#34;For batch_type=&#39;table&#39; with single parameter column only&#34;).grid(row=1,column=4, columnspan=2, sticky=&#39;w&#39;, padx=5)

        ttk.Label(self.batch_options_frame,text=&#34;Batch parameters&#34;).grid(row=0,column=6, sticky=&#39;e&#39;, padx=5)
        self.batch_params = tk.StringVar()
        self.batch_params.set(None)
        self.batch_params_entry = ttk.Entry(self.batch_options_frame, textvariable=self.batch_params, validate=&#39;focusout&#39;, validatecommand=update_batch_data_read_call, width=75)
        self.batch_params_entry.grid(row=0, column=7, columnspan=3, sticky=&#39;ew&#39;, padx=0)
        ttk.Label(self.batch_options_frame,text=&#34;To specify parameters used for reading in data&#34;).grid(row=1,column=6, columnspan=2, sticky=&#39;w&#39;, padx=5)

        self.batch_read_data_call = ttk.Label(self.batch_options_frame, text=&#34;batch_data_read(input_data, batch_type={}, param_col={}, batch_params={})&#34;.format(
                                                                                        self.batch_type.get(), self.param_col.get(), self.batch_params.get() ))
        self.batch_read_data_call.grid(row=2,column=0, columnspan=10, sticky=&#39;w&#39;, padx=10, pady=10)

        self.batch_options_frame.grid(row=11, column=0, columnspan=7, sticky=&#39;ew&#39;)
        self.batch_options_frame.grid_forget()
        
        separator = ttk.Separator(hvsrFrame, orient=&#39;horizontal&#39;)
        separator.grid(row=12, column=0, columnspan=7, sticky=&#39;ew&#39;, padx=10)

        
        def update_fetch_call():
            if self.trim_dir.get()==&#39;&#39;:
                trim_dir = None
            else:
                trim_dir = self.trim_dir.get()

            self.fetch_data_call.configure(text=&#34;fetch_data(params, source=&#39;{}&#39;, trim_dir={}, export_format=&#39;{}&#39;, detrend=&#39;{}&#39;, detrend_order={})&#34;
                                            .format(self.file_source.get(), trim_dir, self.export_format.get(), self.detrend.get(), self.detrend_order.get()))

        #export_format=&#39;.mseed&#39;
        
        def on_obspyFormatSelect(self):
            update_fetch_call()
        ttk.Label(hvsrFrame, text=&#34;Data Format&#34;).grid(row=13, column=1, sticky=&#39;e&#39;, padx=5)
        obspyformats =  [&#39;AH&#39;, &#39;ALSEP_PSE&#39;, &#39;ALSEP_WTH&#39;, &#39;ALSEP_WTN&#39;, &#39;CSS&#39;, &#39;DMX&#39;, &#39;GCF&#39;, &#39;GSE1&#39;, &#39;GSE2&#39;, &#39;KINEMETRICS_EVT&#39;, &#39;KNET&#39;, &#39;MSEED&#39;, &#39;NNSA_KB_CORE&#39;, &#39;PDAS&#39;, &#39;PICKLE&#39;, &#39;Q&#39;, &#39;REFTEK130&#39;, &#39;RG16&#39;, &#39;SAC&#39;, &#39;SACXY&#39;, &#39;SEG2&#39;, &#39;SEGY&#39;, &#39;SEISAN&#39;, &#39;SH_ASC&#39;, &#39;SLIST&#39;, &#39;SU&#39;, &#39;TSPAIR&#39;, &#39;WAV&#39;, &#39;WIN&#39;, &#39;Y&#39;]

        self.export_format = tk.StringVar(value=obspyformats[11])
        self.data_format_dropdown = ttk.OptionMenu(hvsrFrame, self.export_format, obspyformats[11], *obspyformats, command=on_obspyFormatSelect)
        self.data_format_dropdown.grid(row=13, column=2, columnspan=3, sticky=&#39;ew&#39;)

        #detrend=&#39;spline&#39;
        
        def on_detrend_select():
            try:
                str(self.detrend.get())
                update_fetch_call()
                return True
            except ValueError:
                return False

        sourceLabel = ttk.Label(master=hvsrFrame, text=&#34;source=&#39;raw&#39;&#34;)

        ttk.Label(master=hvsrFrame, text=&#39;Detrend type [str]&#39;).grid(row=14, column=1, sticky=&#39;e&#39;, padx=5)
        detrendFrame= ttk.Frame(hvsrFrame)
        detrendFrame.grid(row=14, column=2, sticky=&#39;w&#39;, columnspan=3)
        self.detrend = tk.StringVar()
        self.detrend.set(&#39;spline&#39;)
        ttk.Radiobutton(master=detrendFrame, text=&#39;Spline&#39;, variable=self.detrend, value=&#39;spline&#39;, command=on_detrend_select).grid(row=0, column=0, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=detrendFrame, text=&#39;Polynomial&#39;, variable=self.detrend, value=&#39;polynomial&#39;, command=on_detrend_select).grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=detrendFrame, text=&#39;None&#39;, variable=self.detrend, value=&#39;none&#39;, command=on_detrend_select).grid(row=0, column=2, sticky=&#39;w&#39;, padx=(5, 10))

        #detrend_order=2
        
        def on_detrend_order():
            try:
                int(self.detrend_order.get())
                update_fetch_call()
                return True
            except ValueError:
                return False
                     
        ttk.Label(hvsrFrame,text=&#34;Detrend Order [int]&#34;).grid(row=14,column=5, sticky=&#39;e&#39;, padx=5, pady=10)
        self.detrend_order = tk.IntVar()
        self.detrend_order.set(2)
        self.detrend_order_entry = ttk.Entry(hvsrFrame, textvariable=self.detrend_order, validate=&#39;focusout&#39;, validatecommand=on_detrend_order)
        self.detrend_order_entry.grid(row=14,column=6, sticky=&#39;w&#39;, padx=0)
        
        #trim_dir=False
        def on_trim_dir():
            try:
                str(self.trim_dir.get())
                update_fetch_call()
                return True
            except ValueError:
                return False
            
        ttk.Label(hvsrFrame, text=&#34;Output Directory (trimmed data)&#34;).grid(row=15, column=0, sticky=&#39;e&#39;, padx=5, pady=(2.5,5))
        self.trim_dir = tk.StringVar()
        self.trim_dir_entry = ttk.Entry(hvsrFrame, textvariable=self.trim_dir, validate=&#39;focusout&#39;, validatecommand=on_trim_dir)
        self.trim_dir_entry.grid(row=15, column=1, columnspan=5, sticky=&#39;ew&#39;, padx=5, pady=(2.5,5))
        
        
        def browse_trim_dir_filepath():
            filepath = filedialog.askdirectory()
            if filepath:
                self.trim_dir_entry.delete(0, &#39;end&#39;)
                self.trim_dir_entry.insert(0, filepath)
        
        self.trim_dir_filepath_button = ttk.Button(hvsrFrame, text=&#34;Browse&#34;, command=browse_trim_dir_filepath)
        self.trim_dir_filepath_button.grid(row=15, column=6, sticky=&#39;ew&#39;, padx=0, pady=(2.5,5))

        #self.starttime, self.endtime = get_times()
        input_params_LF = ttk.LabelFrame(master=self.input_tab, text=&#39;input_params() call&#39;)
        self.input_params_call = ttk.Label(master=input_params_LF, text=&#34;input_params( datapath=&#39;{}&#39;, metapath={}, site=&#39;{}&#39;, instrument=&#39;{}&#39;,\n\tnetwork=&#39;{}&#39;, station=&#39;{}&#39;, loc=&#39;{}&#39;, channels=[{}, {}, {}], \n\tacq_date=&#39;{}&#39;, starttime=&#39;{}&#39;, endttime=&#39;{}&#39;, tzone=&#39;{}&#39;, \n\txcoord={}, ycoord={}, elevation={}, input_crs=&#39;{}&#39;, output_crs=&#39;{}&#39;, elev_unit=&#39;{}&#39;,  hvsr_band=[{}, {}])&#34;.format(
                                            self.data_path.get(), self.meta_path.get(), self.site_name.get(), self.instrumentSel.get(),
                                            self.network.get(), self.station.get(), self.location.get(),
                                            self.z_channel.get(), self.e_channel.get(), self.n_channel.get(),
                                            self.acq_date, self.starttime.time(), self.endtime.time(), self.tz,
                                            self.x.get(), self.y.get(), self.z.get(), 
                                            self.input_crs.get(), self.output_crs.get(), self.elev_unit.get(), 
                                            self.hvsrBand_min.get(), self.hvsrBand_max.get()))
        self.input_params_call.pack(anchor=&#39;w&#39;, expand=True, padx=20)

        #fetch_data() call
        fetch_data_LF = ttk.LabelFrame(master=self.input_tab, text=&#39;fetch_data() call&#39;)
        self.fetch_data_call = ttk.Label(master=fetch_data_LF, text=&#34;fetch_data(params, source={}, trim_dir={}, export_format={}, detrend={}, detrend_order={})&#34;
                                                                .format(self.file_source.get(), None, self.export_format.get(), self.detrend.get(), self.detrend_order.get()))
        self.fetch_data_call.pack(anchor=&#39;w&#39;, expand=True, padx=20)

        #Set up frame for reading and running
        runFrame_hvsr = ttk.Frame(self.input_tab)

        self.style.configure(style=&#39;Custom.TButton&#39;, background=&#39;#d49949&#39;)
        self.read_button = ttk.Button(runFrame_hvsr, text=&#34;Read Data&#34;, command=read_data, width=30, style=&#39;Custom.TButton&#39;)

        self.style.configure(&#39;Run.TButton&#39;, background=&#39;#8b9685&#39;, width=10, height=3)
        self.run_button = ttk.Button(runFrame_hvsr, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)        
        self.run_button.pack(side=&#39;right&#39;, anchor=&#39;se&#39;, padx=(10,0))
        self.read_button.pack(side=&#39;right&#39;, anchor=&#39;se&#39;)

        hvsrFrame.pack(fill=&#39;both&#39;, expand=True, side=&#39;top&#39;)#.grid(row=0, sticky=&#34;nsew&#34;)
        runFrame_hvsr.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;)
        fetch_data_LF.pack(fill=&#39;x&#39;, side=&#39;bottom&#39;)
        input_params_LF.pack(fill=&#39;x&#39;, side=&#39;bottom&#39;)
        self.input_tab.pack(fill=&#39;both&#39;, expand=True)
        self.tab_control.add(self.input_tab, text=&#34;Input Params&#34;)

        #Data Preview Tab
        self.preview_data_tab = ttk.Frame(self.tab_control)

        # Configure the row and column of the input_tab to have a non-zero weight
        self.preview_data_tab.pack(expand=1)

        self.inputdataFrame = ttk.LabelFrame(self.preview_data_tab, text=&#34;Input Data Viewer&#34;)
        self.inputdataFrame.pack(expand=True, fill=&#39;both&#39;)
            
        self.inputInfoFrame = ttk.LabelFrame(self.inputdataFrame, text=&#34;Input Data Info&#34;)
        self.input_data_label = ttk.Label(self.inputInfoFrame, text=self.data_filepath_entry.get())
        self.input_data_label.pack(anchor=&#39;w&#39;, fill=&#39;both&#39;, expand=True, padx=15)                
        self.inputInfoFrame.pack(expand=True, fill=&#39;both&#39;, side=&#39;top&#39;)
        
        self.inputDataViewFrame = ttk.LabelFrame(self.inputdataFrame, text=&#34;Input Data Plot&#34;)
                    
        ttk.Label(master=self.inputInfoFrame, text=self.data_filepath_entry.get()).pack()#.grid(row=0, column=0)

        #Set up plot
        #self.fig_pre, self.ax_pre = plt.subplot_mosaic([[&#39;Z&#39;],[&#39;N&#39;],[&#39;E&#39;]], sharex=True, sharey=False)
        #self.canvas_pre = FigureCanvasTkAgg(self.fig_pre, master=self.inputDataViewFrame)
        #self.canvas_pre.draw()
        #self.canvasPreWidget = self.canvas_pre.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
        #self.canvasPreWidget.pack(expand=True, fill=&#39;both&#39;)#.grid(row=1)

        #Reset axes, figure, and canvas widget
        self.fig_pre = plt.figure()

        prev_mosaic = [[&#39;Z&#39;],[&#39;N&#39;],[&#39;E&#39;]]
        self.ax_pre = self.fig_pre.subplot_mosaic(prev_mosaic, sharex=True)  

        self.canvas_pre = FigureCanvasTkAgg(self.fig_pre, master=self.inputDataViewFrame)  # A tk.DrawingArea.
        self.canvas_pre.draw()
        self.canvasPreWidget = self.canvas_pre.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
        self.preview_toolbar = NavigationToolbar2Tk(self.canvas_pre, self.inputDataViewFrame, pack_toolbar=False)
        self.preview_toolbar.update()
    
        #self.canvas_pre.mpl_connect(&#34;button_release_event&#34;, select_windows)


        #Save preview figure
        savePrevFigFrame = ttk.Frame(master=self.inputDataViewFrame)
        
        ttk.Label(savePrevFigFrame, text=&#34;Export Figure&#34;).grid(row=0, column=0, sticky=&#39;ew&#39;, padx=5)
        self.previewFig_dir = tk.StringVar()
        self.previewFig_dir_entry = ttk.Entry(savePrevFigFrame, textvariable=self.previewFig_dir)
        self.previewFig_dir_entry.grid(row=0, column=1, columnspan=5, sticky=&#39;ew&#39;)
        
        
        def filepath_preview_fig():
            filepath = filedialog.asksaveasfilename(defaultextension=&#39;.png&#39;, initialdir=pathlib.Path(self.data_path.get()).parent)
            if filepath:
                self.previewFig_dir_entry.delete(0, &#39;end&#39;)
                self.previewFig_dir_entry.insert(0, filepath)
        
        
        def save_preview_fig():
            self.fig_pre.savefig(self.previewFig_dir.get())
        
        self.browsePreviewFig = ttk.Button(savePrevFigFrame, text=&#34;Browse&#34;,command=filepath_preview_fig)
        self.browsePreviewFig.grid(row=0, column=7, sticky=&#39;ew&#39;, padx=2.5)
        
        self.savePreviewFig = ttk.Button(savePrevFigFrame, text=&#34;Save&#34;,command=save_preview_fig)
        self.savePreviewFig.grid(row=0, column=8, columnspan=2, sticky=&#39;ew&#39;, padx=2.5)

        savePrevFigFrame.columnconfigure(1, weight=1)

        savePrevFigFrame.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, expand=False)
        self.preview_toolbar.pack(side=tk.BOTTOM, fill=tk.X)            
        self.canvasPreWidget.pack(fill=&#39;both&#39;, expand=True)#.grid(row=0, column=0, sticky=&#39;nsew&#39;)

        self.inputDataViewFrame.pack(expand=True, fill=&#39;both&#39;, side=&#39;bottom&#39;)
        
        #preview-Run button
        runFrame_dataPrev = ttk.Frame(self.preview_data_tab)
        self.run_button = ttk.Button(runFrame_dataPrev, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)
        self.run_button.pack(side=&#39;bottom&#39;, anchor=&#39;e&#39;)#.grid(row=2, column=9, columnspan=20, sticky=&#39;e&#39;)
        runFrame_dataPrev.pack(side=&#39;bottom&#39;, anchor=&#39;e&#39;)#grid(row=1, sticky=&#39;e&#39;)

        self.tab_control.add(self.preview_data_tab, text=&#34;Data Preview&#34;)

        # Noise tab
        self.noise_tab = ttk.Frame(self.tab_control)
        self.canvasFrame_noise = ttk.LabelFrame(self.noise_tab, text=&#39;Noise Viewer&#39;)

        #Helper function for updating the canvas and drawing/deleted the boxes
        
        def __draw_windows(event, pathlist, ax_key, windowDrawn, winArtist, xWindows, fig, ax):
            &#34;&#34;&#34;Helper function for updating the canvas and drawing/deleted the boxes&#34;&#34;&#34;
            for i, pa in enumerate(pathlist):
                for j, p in enumerate(pa): 
                    if windowDrawn[i][j]:
                        pass
                    else:
                        patch = matplotlib.patches.PathPatch(p, facecolor=&#39;k&#39;, alpha=0.75)                            
                        winArt = ax[ax_key].add_patch(patch)
                        windowDrawn[i][j] = True
                        winArtist[i][j] = winArt

            if event.button is MouseButton.RIGHT:
                fig.canvas.draw()

        #Helper function for manual window selection 
        
        def __draw_boxes(event, clickNo, xWindows, pathList, windowDrawn, winArtist, lineArtist, x0, fig, ax):
            &#34;&#34;&#34;Helper function for manual window selection to draw boxes to show where windows have been selected for removal&#34;&#34;&#34;
            #Create an axis dictionary if it does not already exist so all functions are the same

            if isinstance(ax, np.ndarray) or isinstance(ax, dict):
                ax = ax
            else:
                ax = {&#39;a&#39;:ax}

            
            if len(ax) &gt; 1:
                if type(ax) is not dict:
                    axDict = {}
                    for i, a in enumerate(ax):
                        axDict[str(i)] = a
                    ax = axDict
            #else:
            #    ax = {&#39;a&#39;:ax}
            
            #if event.inaxes!=ax: return
            #y0, y1 = ax.get_ylim()
            y0 = []
            y1 = []
            kList = []
            for k in ax.keys():
                kList.append(k)
                y0.append(ax[k].get_ylim()[0])
                y1.append(ax[k].get_ylim()[1])
            #else:
            #    y0 = [ax.get_ylim()[0]]
            #    y1 = [ax.get_ylim()[1]]

            if self.clickNo == 0:
                #y = np.linspace(ax.get_ylim()[0], ax.get_ylim()[1], 2)
                self.x0 = event.xdata
                self.clickNo = 1   
                self.lineArtist.append([])
                winNums = len(self.xWindows)
                for i, k in enumerate(ax.keys()):
                    linArt = ax[k].axvline(self.x0, 0, 1, color=&#39;k&#39;, linewidth=1, zorder=100)
                    self.lineArtist[winNums].append([linArt, linArt])
                #else:
                #    linArt = plt.axvline(self.x0, y0[i], y1[i], color=&#39;k&#39;, linewidth=1, zorder=100)
                #    self.lineArtist.append([linArt, linArt])
            else:
                x1 = event.xdata
                self.clickNo = 0

                windowDrawn.append([])
                winArtist.append([])  
                pathList.append([])
                winNums = len(self.xWindows)
                for i, key in enumerate(kList):
                    path_data = [
                        (matplotlib.path.Path.MOVETO, (self.x0, y0[i])),
                        (matplotlib.path.Path.LINETO, (x1, y0[i])),
                        (matplotlib.path.Path.LINETO, (x1, y1[i])),
                        (matplotlib.path.Path.LINETO, (self.x0, y1[i])),
                        (matplotlib.path.Path.LINETO, (self.x0, y0[i])),
                        (matplotlib.path.Path.CLOSEPOLY, (self.x0, y0[i])),
                    ]
                    codes, verts = zip(*path_data)
                    path = matplotlib.path.Path(verts, codes)

                    windowDrawn[winNums].append(False)
                    winArtist[winNums].append(None)

                    pathList[winNums].append(path)
                    __draw_windows(event=event, pathlist=pathList, ax_key=key, windowDrawn=windowDrawn, winArtist=winArtist, xWindows=self.xWindows, fig=fig, ax=ax)
                    linArt = ax[key].axvline(x1, 0, 1, color=&#39;k&#39;, linewidth=0.5, zorder=100)

                    [self.lineArtist[winNums][i].pop(-1)]
                    self.lineArtist[winNums][i].append(linArt)
                x_win = [self.x0, x1]
                x_win.sort() #Make sure they are in the right order
                self.xWindows.append(x_win)
            fig.canvas.draw()
            return self.clickNo, self.x0

        #Helper function for manual window selection to draw boxes to deslect windows for removal
        
        def __remove_on_right(event, xWindows, pathList, windowDrawn, winArtist,  lineArtist, fig, ax):
            &#34;&#34;&#34;Helper function for manual window selection to draw boxes to deslect windows for removal&#34;&#34;&#34;

            if self.xWindows is not None:
                for i, xWins in enumerate(self.xWindows):
                    if event.xdata &gt; xWins[0] and event.xdata &lt; xWins[1]:
                        linArtists = self.lineArtist[i]
                        pathList.pop(i)
                        for j, a in enumerate(linArtists):
                            winArtist[i][j].remove()#.pop(i)
                            self.lineArtist[i][j][0].remove()#.pop(i)#[i].pop(j)
                            self.lineArtist[i][j][1].remove()
                        windowDrawn.pop(i)
                        self.lineArtist.pop(i)#[i].pop(j)
                        winArtist.pop(i)#[i].pop(j)
                        self.xWindows.pop(i)
            fig.canvas.draw() 
               
        
        def select_windows(event, input=None, initialize=False):
            import obspy
            &#34;&#34;&#34;Function to manually select windows for exclusion from data.

            Parameters
            ----------
            input : dict
                Dictionary containing all the hvsr information.

            Returns
            -------
            self.xWindows : list
                List of two-item lists containing start and end times of windows to be removed.
            &#34;&#34;&#34;
            from matplotlib.backend_bases import MouseButton
            import matplotlib.pyplot as plt
            import matplotlib
            import time
            
            #self.fig_noise, self.ax_noise = sprit_hvsr._plot_specgram_stream(stream=input[&#39;stream&#39;], params=input, fig=self.fig_noise, ax=self.ax_noise, component=&#39;Z&#39;, stack_type=&#39;linear&#39;, detrend=&#39;mean&#39;, fill_gaps=0, dbscale=True, return_fig=True, cmap_per=[0.1,0.9])
            #self.fig_noise.canvas.draw()
            
            #if &#39;stream&#39; in input.keys():
            #    self.fig_noise, self.ax_noise = sprit_hvsr._plot_specgram_stream(stream=self.params[&#39;stream&#39;], params=self.params, fig=self.fig_noise, ax=self.ax_noise, component=&#39;Z&#39;, stack_type=&#39;linear&#39;, detrend=&#39;mean&#39;, fill_gaps=0, dbscale=True, return_fig=True, cmap_per=[0.1,0.9])
            #else:
            #    params = input.copy()
            #    input = input[&#39;stream&#39;]
            
            #if isinstance(input, obspy.core.stream.Stream):
            #    fig, ax = sprit_hvsr._plot_specgram_stream(input, component=[&#39;Z&#39;])
            #elif isinstance(input, obspy.core.trace.Trace):
            #    fig, ax = sprit_hvsr._plot_specgram_stream(input)
            if initialize:
                self.lineArtist = []
                self.winArtist = []
                self.windowDrawn = []
                self.pathList = []
                self.xWindows = []
                self.x0 = 0
                self.clickNo = 0
            
            if not initialize:
                __on_click(event)
                self.hvsr_data[&#39;xwindows_out&#39;] = self.xWindows


                #self.fig_closed
                #fig_closed = False
                #while fig_closed is False:
                #    #fig.canvas.mpl_connect(&#39;button_press_event&#39;, __on_click)#(self.clickNo, self.xWindows, pathList, windowDrawn, winArtist, lineArtist, self.x0, fig, ax))
                #    fig.canvas.mpl_connect(&#39;close_event&#39;, _on_fig_close)#(self.clickNo, self.xWindows, pathList, windowDrawn, winArtist, lineArtist, self.x0, fig, ax))
                #    plt.pause(0.5)
                
                #output[&#39;xwindows_out&#39;] = self.xWindows
                #output[&#39;fig&#39;] = fig
                #output[&#39;ax&#39;] = ax
                noEvent = True
            return self.hvsr_data

        #Support function to help select_windows run properly
        
        def _on_fig_close(event):
            self.fig_closed
            fig_closed = True
            return

        
        def __on_click(event):

            if event.button is MouseButton.RIGHT:
                __remove_on_right(event, self.xWindows, self.pathList, self.windowDrawn, self.winArtist, self.lineArtist, self.fig_noise, self.ax_noise)

            if event.button is MouseButton.LEFT:            
                self.clickNo, self.x0 = __draw_boxes(event, self.clickNo, self.xWindows, self.pathList, self.windowDrawn, self.winArtist, self.lineArtist, self.x0, self.fig_noise, self.ax_noise)    

        
        def plot_noise_windows(hvsr_data, initial_setup=False):
            if isinstance(hvsr_data, sprit_hvsr.HVSRBatch):
                batch_data = hvsr_data.copy()
                hvsr_data = hvsr_data[list(hvsr_data.keys())[0]]
            else:
                batch_data = None

            if initial_setup:
                self.xWindows=[]
            else:
                #Clear everything
                for key in self.ax_noise:
                    self.ax_noise[key].clear()
                self.fig_noise.clear()

                #Really make sure it&#39;s out of memory
                self.fig_noise = []
                self.ax_noise = []
                try:
                    self.fig_noise.get_children()
                except:
                    pass
                try:
                    self.ax_noise.get_children()
                except:
                    pass

            #Reset axes, figure, and canvas widget
            self.fig_noise = plt.figure()
    
            noise_mosaic = [[&#39;spec&#39;],[&#39;spec&#39;],[&#39;spec&#39;],
                    [&#39;spec&#39;],[&#39;spec&#39;],[&#39;spec&#39;],
                    [&#39;signalz&#39;],[&#39;signalz&#39;], [&#39;signaln&#39;], [&#39;signale&#39;]]
            self.ax_noise = self.fig_noise.subplot_mosaic(noise_mosaic, sharex=True)  

            if not initial_setup:
                self.noise_canvasWidget.destroy()
                self.noise_toolbar.destroy()
                self.fig_noise, self.ax_noise = sprit_hvsr._plot_specgram_stream(stream=hvsr_data[&#39;stream&#39;], params=hvsr_data, fig=self.fig_noise, ax=self.ax_noise, component=&#39;Z&#39;, stack_type=&#39;linear&#39;, detrend=&#39;mean&#39;, fill_gaps=0, dbscale=True, return_fig=True, cmap_per=[0.1,0.9])

            self.noise_canvas = FigureCanvasTkAgg(self.fig_noise, master=self.canvasFrame_noise)  # A tk.DrawingArea.
            self.noise_canvas.draw()
            #self.noise_canvasWidget = self.noise_canvas.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
            # pack_toolbar=False will make it easier to use a layout manager later on.
            self.noise_toolbar = NavigationToolbar2Tk(self.noise_canvas, self.canvasFrame_noise, pack_toolbar=False)
            self.noise_toolbar.update()
        
            self.noise_canvasWidget = self.noise_canvas.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
            self.noise_canvas.mpl_connect(&#34;button_release_event&#34;, select_windows)

            self.noise_toolbar.pack(side=tk.BOTTOM, fill=tk.X)            
            self.noise_canvasWidget.pack(fill=&#39;both&#39;)#.grid(row=0, column=0, sticky=&#39;nsew&#39;)

            if not initial_setup:
                if batch_data is None:
                    batch_data = {&#39;SITENAME&#39;:hvsr_data}

                for i, (k, hv_data) in enumerate(batch_data.items()):
                    #Reset edited data every time plot_noise_windows is run
                    hv_data[&#39;stream_edited&#39;] = hv_data[&#39;stream&#39;].copy()
                    
                    #Set initial input
                    input = hv_data[&#39;stream&#39;]

                    #print(input[0].stats.starttime)
                    if self.do_stalta.get():
                        hv_data[&#39;stream_edited&#39;] = sprit_hvsr.remove_noise(input=input, kind=&#39;stalta&#39;, sta=self.sta.get(), lta=self.lta.get(), stalta_thresh=[self.stalta_thresh_low.get(), self.stalta_thresh_hi.get()])
                        input = hv_data[&#39;stream_edited&#39;]

                    if self.do_pctThresh.get():
                        hv_data[&#39;stream_edited&#39;] = sprit_hvsr.remove_noise(input=input, kind=&#39;saturation&#39;,  sat_percent=self.pct.get(), min_win_size=self.win_size_sat.get())
                        input = hv_data[&#39;stream_edited&#39;]

                    if self.do_noiseWin.get():
                        hv_data[&#39;stream_edited&#39;] = sprit_hvsr.remove_noise(input=input, kind=&#39;noise&#39;, noise_percent=self.noise_amp_pct.get(), lta=self.lta_noise.get(), min_win_size=self.win_size_thresh.get())
                        input = hv_data[&#39;stream_edited&#39;]
                
                    if self.do_warmup.get():
                        hv_data[&#39;stream_edited&#39;] = sprit_hvsr.remove_noise(input=input, kind=&#39;warmup&#39;, warmup_time=self.warmup_time.get(), cooldown_time=self.cooldown_time.get())

                    if i==0:
                        self.fig_noise, self.ax_noise, self.noise_windows_line_artists, self.noise_windows_window_artists = sprit_hvsr._get_removed_windows(input=hvsr_data, fig=self.fig_noise, ax=self.ax_noise, existing_xWindows=self.xWindows, time_type=&#39;matplotlib&#39;)
                        self.fig_noise.canvas.draw()
                return hvsr_data
            
            self.fig_noise.canvas.draw()
            return

        plot_noise_windows(None, initial_setup=True)
        self.canvasFrame_noise.pack(fill=&#39;both&#39;)#.grid(row=0, column=0, sticky=&#34;nsew&#34;)

        #noise_mosaic = [[&#39;spec&#39;],[&#39;spec&#39;],[&#39;spec&#39;],
        #        [&#39;spec&#39;],[&#39;spec&#39;],[&#39;spec&#39;],
        #        [&#39;signalz&#39;],[&#39;signalz&#39;], [&#39;signaln&#39;], [&#39;signale&#39;]]
        #self.fig_noise, self.ax_noise = plt.subplot_mosaic(noise_mosaic, sharex=True)  
        #self.canvasFrame_noise = ttk.LabelFrame(self.noise_tab, text=&#39;Noise Viewer&#39;)
        #self.canvasFrame_noise.pack(fill=&#39;both&#39;)#.grid(row=0, column=0, sticky=&#34;nsew&#34;)

        #self.noise_canvas = FigureCanvasTkAgg(self.fig_noise, master=self.canvasFrame_noise)
        #self.noise_canvas.draw()
        #self.noise_canvasWidget = self.noise_canvas.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
        #self.noise_canvasWidget.pack(fill=&#39;both&#39;)#.grid(row=0, column=0, sticky=&#39;nsew&#39;)

        #Run button frame
        runFrame_noise = ttk.Frame(self.noise_tab)
        
        #Run area
        #Update Noise Windows button
        self.style.configure(style=&#39;Noise.TButton&#39;, background=&#39;#86a5ba&#39;)
        self.noise_button = ttk.Button(runFrame_noise, text=&#34;Update Noise Windows&#34;, command=plot_noise_windows, width=30, style=&#39;Noise.TButton&#39;)

        self.noise_windows_line_artists = []
        self.noise_windows_window_artists = []

        self.style.configure(&#39;Run.TButton&#39;, background=&#39;#8b9685&#39;, width=10, height=3)
        self.run_button = ttk.Button(runFrame_noise, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)        
        self.run_button.pack(side=&#39;right&#39;, anchor=&#39;se&#39;, padx=(10,0))
        self.noise_button.pack(side=&#39;right&#39;, anchor=&#39;se&#39;)

        runFrame_noise.pack(fill=&#39;both&#39;,side=&#39;bottom&#39;, anchor=&#39;e&#39;)    

        #Plot adjustment Frame
        pltAdjustFrame = ttk.LabelFrame(self.noise_tab, text=&#39;Adjust Plot&#39;)
        pltAdjustFrame.pack(fill=&#39;both&#39;, side=&#39;right&#39;)#.grid(row=0, column=1, sticky=&#39;nsew&#39;)

        ttk.Label(master=pltAdjustFrame, text=&#39;Adjustment Parameters (in progress)&#39;).grid(row=0, column=0)

        noiseFrame = ttk.LabelFrame(self.noise_tab, text=&#39;Noise Removal&#39;)
        noiseFrame.pack(fill=&#39;both&#39;)#.grid(row=1, columnspan=2, sticky=&#39;nsew&#39;)
        
        #Options for manually removing windows
        windowremoveFrame = ttk.LabelFrame(noiseFrame, text=&#39;Manual Window Removal&#39;)
        windowremoveFrame.grid(row=0, column=1, columnspan=1, sticky=&#39;nsew&#39;)
        self.do_window = tk.BooleanVar() # create a BooleanVar to store the state of the Checkbutton
        manualBool = ttk.Checkbutton(master=windowremoveFrame, text=&#34;&#34;, variable=self.do_window) # create the Checkbutton widget
        manualBool.grid(row=0, column=0, sticky=&#39;ew&#39;)
        
        
        def remove_windows_manually():
            #Placeholderfunction
            print(&#39;Ok, this button may not need to do anything&#39;)
            #Plot data in noise preview tab

        self.select_windows = ttk.Button(master=windowremoveFrame, text=&#34;Remove Windows&#34;, command=remove_windows_manually) # create the Checkbutton widget
        self.select_windows.grid(row=0, column=1, sticky=&#39;e&#39;)

        #Options for doing stalta antitrigger for noise removal
        stltaremoveFrame = ttk.LabelFrame(noiseFrame, text=&#39;STA/LTA Antitrigger&#39;)
        stltaremoveFrame.grid(row=0, column=0, columnspan=1, sticky=&#39;nsew&#39;)
        
        self.do_stalta = tk.BooleanVar()
        staltaBool = ttk.Checkbutton(master=stltaremoveFrame, text=&#34;&#34;, variable=self.do_stalta) # create the Checkbutton widget
        staltaBool.grid(row=0, column=0, sticky=&#39;ew&#39;)
        
        ttk.Label(master=stltaremoveFrame, text=&#34;STA [s]&#34;).grid(row=0, column=1)
        self.sta = tk.DoubleVar()
        self.sta.set(5)
        staEntry = ttk.Entry(master=stltaremoveFrame, textvariable=self.sta, width=5) # create the Entry widget
        staEntry.grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5,10))

        ttk.Label(master=stltaremoveFrame, text=&#34;LTA [s]&#34;).grid(row=0, column=3)
        self.lta = tk.DoubleVar()
        self.lta.set(30)
        ltaEntry = ttk.Entry(master=stltaremoveFrame, textvariable=self.lta, width=5) # create the Entry widget
        ltaEntry.grid(row=0, column=4, sticky=&#39;ew&#39;, padx=(5,10))

        ttk.Label(master=stltaremoveFrame, text=&#34;STA/LTA Thresholds (Low, High)&#34;).grid(row=0, column=5)
        self.stalta_thresh_low = tk.DoubleVar()
        self.stalta_thresh_low.set(0.5)
        staltaLowEntry = ttk.Entry(master=stltaremoveFrame, textvariable=self.stalta_thresh_low, width=5) # create the Entry widget
        staltaLowEntry.grid(row=0, column=6, sticky=&#39;ew&#39;, padx=(5,0))
        
        self.stalta_thresh_hi = tk.DoubleVar()
        self.stalta_thresh_hi.set(5)
        staltaHiEntry = ttk.Entry(master=stltaremoveFrame, textvariable=self.stalta_thresh_hi, width=5) # create the Entry widget
        staltaHiEntry.grid(row=0, column=7, sticky=&#39;ew&#39;)
        
        #Options for Percentage threshold removal
        pctThresFrame = ttk.LabelFrame(noiseFrame, text=&#39;Percentage Threshold&#39;)
        pctThresFrame.grid(row=1, column=0, sticky=&#39;nsew&#39;)

        self.do_pctThresh= tk.BooleanVar()
        pctBool = ttk.Checkbutton(master=pctThresFrame, text=&#34;&#34;, variable=self.do_pctThresh) # create the Checkbutton widget
        pctBool.grid(row=0, column=0, sticky=&#39;ew&#39;)
 
        ttk.Label(master=pctThresFrame, text=&#34;Max Instantaneous %&#34;).grid(row=0, column=1)
        self.pct = tk.DoubleVar()
        self.pct.set(0.995)
        pctEntry = ttk.Entry(master=pctThresFrame, textvariable=self.pct, width=10) # create the Entry widget
        pctEntry.grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5,10))

        ttk.Label(master=pctThresFrame, text=&#34;&#34;, width=27).grid(row=0, column=3, columnspan=2)

        ttk.Label(master=pctThresFrame, text=&#34;Min. Window Size [sec]&#34;).grid(row=0, column=5, sticky=&#39;e&#39;)
        self.win_size_sat = tk.DoubleVar()
        self.win_size_sat.set(0)
        win_size_Entry = ttk.Entry(master=pctThresFrame, textvariable=self.win_size_sat, width=10) # create the Entry widget
        win_size_Entry.grid(row=0, column=6, sticky=&#39;e&#39;, padx=(5,10))

        #Options for noisy window
        noisyWindowFrame = ttk.LabelFrame(noiseFrame, text=&#39;Noisy Windows&#39;)
        noisyWindowFrame.grid(row=2, column=0, sticky=&#39;nsew&#39;)

        self.do_noiseWin = tk.BooleanVar()
        winNoiseBool = ttk.Checkbutton(master=noisyWindowFrame, text=&#34;&#34;, variable=self.do_noiseWin) # create the Checkbutton widget
        winNoiseBool.grid(row=0, column=0, sticky=&#39;ew&#39;)
 
        ttk.Label(master=noisyWindowFrame, text=&#34;Max Window %&#34;).grid(row=0, column=1)
        self.noise_amp_pct = tk.DoubleVar()
        self.noise_amp_pct.set(0.80)
        winamppctEntry = ttk.Entry(master=noisyWindowFrame, textvariable=self.noise_amp_pct, width=10) # create the Entry widget
        winamppctEntry.grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5,10))

        ttk.Label(master=noisyWindowFrame, text=&#34;Window Length [sec]&#34;).grid(row=0, column=3)
        self.lta_noise = tk.DoubleVar()
        self.lta_noise.set(30)
        winamppctEntry = ttk.Entry(master=noisyWindowFrame, textvariable=self.lta_noise, width=10) # create the Entry widget
        winamppctEntry.grid(row=0, column=4, sticky=&#39;ew&#39;, padx=(5,10))

        ttk.Label(master=noisyWindowFrame, text=&#34;Min. Window Size [sec]&#34;).grid(row=0, column=5)
        self.win_size_thresh = tk.DoubleVar()
        self.win_size_thresh.set(0)
        win_size_Entry = ttk.Entry(master=noisyWindowFrame, textvariable=self.win_size_thresh, width=10) # create the Entry widget
        win_size_Entry.grid(row=0, column=6, sticky=&#39;e&#39;, padx=(5,10))

        #Options for warmup
        warmupFrame = ttk.LabelFrame(noiseFrame, text=&#39;Warmup &amp; Cooldown Time&#39;)
        warmupFrame.grid(row=3, column=0, sticky=&#39;nsew&#39;)

        self.do_warmup= tk.BooleanVar()
        warmupBool = ttk.Checkbutton(master=warmupFrame, text=&#34;&#34;, variable=self.do_warmup) # create the Checkbutton widget
        warmupBool.grid(row=0, column=0, sticky=&#39;ew&#39;)
 
        ttk.Label(master=warmupFrame, text=&#34;Warmup time [s]&#34;).grid(row=0, column=1)
        self.warmup_time = tk.DoubleVar()
        warmupEntry = ttk.Entry(master=warmupFrame, textvariable=self.warmup_time, width=10) # create the Entry widget
        warmupEntry.grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5,10))
        warmupEntry.delete(0, &#39;end&#39;)
        warmupEntry.insert(0, &#39;0&#39;)
 
        ttk.Label(master=warmupFrame, text=&#34;Cooldown Time [s]&#34;).grid(row=0, column=3)
        self.cooldown_time = tk.DoubleVar()
        cooldownEntry = ttk.Entry(master=warmupFrame, textvariable=self.cooldown_time, width=10) # create the Entry widget
        cooldownEntry.grid(row=0, column=5, sticky=&#39;ew&#39;, padx=(5,10))
        cooldownEntry.delete(0, &#39;end&#39;)
        cooldownEntry.insert(0, &#39;0&#39;)

        #Options for doing stdev noise removal
        stdremoveFrame = ttk.LabelFrame(noiseFrame, text=&#39;Standard Deviation Antitrigger (not yet implemented)&#39;)
        stdremoveFrame.grid(row=1, column=1, columnspan=1, sticky=&#39;nsew&#39;)
        
        self.do_stdev = tk.BooleanVar()
        stdBool = ttk.Checkbutton(master=stdremoveFrame, text=&#34;&#34;, variable=self.do_stdev, state=&#39;disabled&#39;) # create the Checkbutton widget
        stdBool.grid(row=0, column=0, sticky=&#39;ew&#39;)
        
        ttk.Label(master=stdremoveFrame, text=&#34;Std Deviation Ratio (moving stdev/total stdev)&#34;).grid(row=0, column=1)
        self.stdRatio = tk.DoubleVar()
        stdRatEntry = ttk.Entry(master=stdremoveFrame, textvariable=self.stdRatio, width=5, state=&#39;disabled&#39;) # create the Entry widget
        stdRatEntry.grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5,10))
        stdRatEntry.delete(0, &#39;end&#39;)
        stdRatEntry.insert(0, &#39;1&#39;)
        
        ttk.Label(master=stdremoveFrame, text=&#34;Window Length [s]&#34;).grid(row=0, column=3)
        self.stdWinLen = tk.DoubleVar()
        stdWinLenEntry = ttk.Entry(master=stdremoveFrame, textvariable=self.stdWinLen, width=5, state=&#39;disabled&#39;) # create the Entry widget
        stdWinLenEntry.grid(row=0, column=4, sticky=&#39;ew&#39;, padx=(5,10))
        stdWinLenEntry.delete(0, &#39;end&#39;)
        stdWinLenEntry.insert(0, &#39;5&#39;)

        #Quick set the auto 
        autoFrame = ttk.LabelFrame(noiseFrame, text=&#39;Auto Run&#39;)
        autoFrame.grid(row=2, column=1, columnspan=1, sticky=&#39;nsew&#39;)

        
        def set_auto():
            if self.do_auto.get():
                self.do_stalta.set(True)
                self.do_stdev.set(True)
                self.do_warmup.set(True)
                self.do_noiseWin.set(True)
                self.do_pctThresh.set(True)
            else:
                pass

        self.do_auto= tk.BooleanVar()
        autoBool = ttk.Checkbutton(master=autoFrame, text=&#34;&#34;, variable=self.do_auto, command=set_auto) # create the Checkbutton widget
        autoBool.grid(row=0, column=0, sticky=&#39;ew&#39;)   

        #Export noise windows
        ttk.Label(noiseFrame, text=&#34;Export Figure&#34;).grid(row=4, column=0, sticky=&#39;ew&#39;, padx=5)
        self.results_noise_dir = tk.StringVar()
        self.results_noise_dir_entry = ttk.Entry(noiseFrame, textvariable=self.results_noise_dir)
        self.results_noise_dir_entry.grid(row=4, column=0, columnspan=5, sticky=&#39;ew&#39;, padx=(100,5))
        
        
        def filepath_noise_fig():
            filepath = filedialog.asksaveasfilename(defaultextension=&#39;png&#39;, initialdir=pathlib.Path(self.data_path.get()).parent, initialfile=self.params[&#39;site&#39;]+&#39;_noisewindows.png&#39;)
            if filepath:
                self.results_noise_dir_entry.delete(4, &#39;end&#39;)
                self.results_noise_dir_entry.insert(4, filepath)
        
        
        def save_noise_fig():
            self.fig_noise.savefig(self.results_noise_dir.get())
        
        self.browse_noise_fig = ttk.Button(noiseFrame, text=&#34;Browse&#34;,command=filepath_noise_fig)
        self.browse_noise_fig.grid(row=4, column=7, sticky=&#39;ew&#39;, padx=2.5)
        
        self.save_noise_fig = ttk.Button(noiseFrame, text=&#34;Save&#34;,command=save_noise_fig)
        self.save_noise_fig.grid(row=4, column=8, columnspan=2, sticky=&#39;ew&#39;, padx=2.5)

        self.noise_tab.pack(expand=1)
        self.tab_control.add(self.noise_tab, text=&#34;Noise&#34;)

        # SETTINGS TAB
        self.settings_tab = ttk.Frame(self.tab_control)
        
        self.tab_control.add(self.settings_tab, text=&#34;Settings&#34;)
        
        # Create a new Notebook widget within the Settings tab
        settings_notebook = ttk.Notebook(self.settings_tab)

        # Create the tabs within the Settings tab
        #PPSD SETTINGS SUBTAB
        ppsd_settings_tab = ttk.Frame(settings_notebook)
        ppsdSettingsFrame = ttk.LabelFrame(ppsd_settings_tab, text=&#39;Input Settings&#39;)#.pack(fill=&#39;both&#39;)
        ppsdParamsFrame = ttk.LabelFrame(ppsd_settings_tab, text=&#39;PPSD Parameters&#39;)#.pack(fill=&#39;both&#39;)

        # ppsd_length=30.0
        
        def on_ppsd_length():
            try:
                float(self.ppsd_length.get())
                ppsdLenLabel.configure(text=&#39;ppsd_length={}&#39;.format(self.ppsd_length.get()))
                update_ppsd_call(self.ppsd_call)
                return True
            except ValueError:
                return False
        ppsdLenLabel = ttk.Label(master=ppsdParamsFrame, text=&#39;ppsd_length=30.0 &#39;)#.grid(row=0, column=0)
        ppsdLenLabel.grid(row=0, column=0, sticky=&#39;w&#39;, pady=(6,6), padx=5)
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;PPSD Length (in seconds) [float]&#39;).grid(row=0, column=0, sticky=&#39;w&#39;, padx=5)
        self.ppsd_length = tk.DoubleVar()
        self.ppsd_length.set(30)
        ppsdLenEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=self.ppsd_length, width=10, validate=&#39;focusout&#39;, validatecommand=on_ppsd_length)
        ppsdLenEntry.grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))

        # overlap=0.5, 
        
        def on_overlap():
            try:
                overlap = float(self.overlap.get())
                if overlap &gt; 1:
                    self.overlap.set(overlap/100)
                overlapLabel.configure(text=&#39;overlap={}&#39;.format(self.overlap.get()))
                update_ppsd_call(self.ppsd_call)
                return True
            except ValueError:
                return False
        overlapLabel = ttk.Label(master=ppsdParamsFrame, text=&#39;overlap=0.5 &#39;)#.grid(row=0, column=0)
        overlapLabel.grid(row=1, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Overlap % (0-1) [float]&#39;).grid(row=1, column=0, sticky=&#39;w&#39;, padx=5)
        self.overlap = tk.DoubleVar()
        self.overlap.set(0.5)
        overlapEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=self.overlap, width=10, validate=&#39;focusout&#39;, validatecommand=on_overlap)
        overlapEntry.grid(row=1, column=1, sticky=&#39;w&#39;, padx=(5, 10))

        # period_step_octaves=0.0625, 
        
        def on_per_step_oct():
            try:
                float(self.perStepOct.get())
                
                pStepOctLabel.configure(text=&#39;period_step_octaves={}&#39;.format(self.perStepOct.get()))
                update_ppsd_call(self.ppsd_call)            
                return True
            except ValueError:
                return False
        pStepOctLabel = ttk.Label(master=ppsdParamsFrame, text=&#39;period_step_octaves=0.0625&#39;)#.grid(row=0, column=0)
        pStepOctLabel.grid(row=2, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Period Step Octave [float]&#39;).grid(row=2, column=0, sticky=&#39;w&#39;, padx=5)
        self.perStepOct = tk.DoubleVar()
        self.perStepOct.set(0.0625)
        pStepOctEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=self.perStepOct, width=10, validate=&#39;focusout&#39;, validatecommand=on_per_step_oct)
        pStepOctEntry.grid(row=2, column=1, sticky=&#39;w&#39;, padx=(5, 10))

        #skip_on_gaps
        
        def show_sog():
            if self.skip_on_gaps.get():
                sogLabel.configure(text =&#39;skip_on_gaps=True&#39;)
            else:
                sogLabel.configure(text =&#39;skip_on_gaps=False&#39;)
            update_ppsd_call(self.ppsd_call)
            
        self.skip_on_gaps = tk.BooleanVar()
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Skip on Gaps [bool]: &#39;, justify=&#39;left&#39;).grid(row=3, column=0, sticky=&#39;w&#39;, padx=5)
        sogCheckButton = ttk.Checkbutton(master=ppsdSettingsFrame, text=&#39;&#39;, variable=self.skip_on_gaps, command=show_sog) # create the Entry widget
        sogCheckButton.grid(row=3, column=1, sticky=&#39;ew&#39;, padx=(5,10))
        sogLabel = ttk.Label(master=ppsdParamsFrame, text=&#39;skip_on_gaps=False&#39;)
        sogLabel.grid(row=3, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

        # db_bins=(-200, -50, 1.0), 
        
        def show_dbbins():
            try:
                float(minDB.get())
                float(maxDB.get())
                float(dB_step.get())
                dbbinsLabel.configure(text=&#39;db_bins=({}, {}, {})&#39;.format(
                    minDB.get(), maxDB.get(), dB_step.get()))
                self.db_bins = (minDB.get(), maxDB.get(), dB_step.get())
                update_ppsd_call(self.ppsd_call)
                return True
            except ValueError:
                return False

        dbbinsLabel = ttk.Label(master=ppsdParamsFrame,
                                text=&#39;db_bins=(-200, -50, 1.0)&#39;)
        dbbinsLabel.grid(row=4, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
        ttk.Label(master=ppsdSettingsFrame, text=&#39;dB Bins (Y Axis) [tuple]&#39;, justify=&#39;left&#39;).grid(row=4, column=0, sticky=&#39;w&#39;, padx=5)
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Min. dB&#39;).grid(row=4, column=1, sticky=&#39;e&#39;, padx=5)
        minDB = tk.DoubleVar()
        minDB.set(-200)
        minDBEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=minDB,
                            validate=&#34;focusout&#34;, validatecommand=show_dbbins, width=10)
        minDBEntry.grid(row=4, column=2, sticky=&#39;w&#39;, padx=(5, 10))
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Max. dB&#39;).grid(row=4, column=3, sticky=&#39;e&#39;, padx=5)
        maxDB = tk.DoubleVar()
        maxDB.set(-50)
        maxDBEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=maxDB,
                            validate=&#34;focusout&#34;, validatecommand=show_dbbins, width=10)
        maxDBEntry.grid(row=4, column=4, sticky=&#39;w&#39;, padx=(5, 10))

        ttk.Label(master=ppsdSettingsFrame, text=&#39;dB Step&#39;).grid(row=4, column=5, sticky=&#39;e&#39;, padx=5)
        dB_step = tk.DoubleVar()
        dB_step.set(1.0)
        stepEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=dB_step,
                            validate=&#34;focusout&#34;, validatecommand=(show_dbbins), width=10)
        stepEntry.grid(row=4, column=6, sticky=&#39;w&#39;, padx=(5, 10))
        self.db_bins = (minDB.get(), maxDB.get(), dB_step.get())

        # period_limits=None,
        
        def show_per_lims():
            try:
                if minPerLim.get() == &#39;None&#39;:
                    pass
                else:
                    float(minPerLim.get())
                    
                if maxPerLim.get() == &#39;None&#39;:
                    pass
                else:
                    float(maxPerLim.get())
                    
                if minPerLim.get() == &#39;None&#39; or maxPerLim.get() == &#39;None&#39;:
                    perLimsLabel.configure(text=&#39;period_limits=None&#39;)
                else:
                    perLimsLabel.configure(text=&#39;period_limits=[{}, {}]&#39;.format(minPerLim.get(), maxPerLim.get()))
                    self.period_limits = [float(minPerLim.get()), float(maxPerLim.get())]
                update_ppsd_call(self.ppsd_call)
                return True
            except ValueError:
                return False

        perLimsLabel = ttk.Label(master=ppsdParamsFrame,
                                text=&#39;period_limits=None&#39;)
        perLimsLabel.grid(row=5, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Period Limits [list of floats or None]&#39;, justify=&#39;left&#39;).grid(row=5, column=0, sticky=&#39;w&#39;, padx=5)
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Min. Period Limit&#39;).grid(row=5, column=1, sticky=&#39;e&#39;, padx=5)
        minPerLim = tk.StringVar()
        minPerLim.set(None)
        minPerLimEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=minPerLim,
                            validate=&#34;focusout&#34;, validatecommand=(show_per_lims), width=10)
        minPerLimEntry.grid(row=5, column=2, sticky=&#39;w&#39;, padx=(5, 10))
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Max. Period Limit&#39;).grid(row=5, column=3, sticky=&#39;e&#39;, padx=5)
        maxPerLim = tk.StringVar()
        maxPerLim.set(None)
        maxPerLimEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=maxPerLim,
                            validate=&#34;focusout&#34;, validatecommand=(show_per_lims), width=10)
        maxPerLimEntry.grid(row=5, column=4, sticky=&#39;w&#39;, padx=(5, 10))

        if minPerLim.get() == &#39;None&#39; or maxPerLim.get() == &#39;None&#39;:
            self.period_limits=None
        else:
            self.period_limits = [float(minPerLim.get()), float(maxPerLim.get())]

        # period_smoothing_width_octaves=1.0,
        
        def on_per_smoothwidth_oct():
            try:
                float(self.perSmoothWidthOct.get())
                
                pSmoothWidthLabel.configure(text=&#39;period_smoothing_width_octaves={}&#39;.format(self.perSmoothWidthOct.get()))
                update_ppsd_call(self.ppsd_call)
                return True
            except ValueError:
                return False
        pSmoothWidthLabel = ttk.Label(master=ppsdParamsFrame, text=&#39;period_smoothing_width_octaves=1.0&#39;)#.grid(row=0, column=0)
        pSmoothWidthLabel.grid(row=6, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Period Smoothing Width (octaves) [float]&#39;).grid(row=6, column=0, sticky=&#39;w&#39;, padx=5)
        self.perSmoothWidthOct = tk.DoubleVar()
        self.perSmoothWidthOct.set(1.0)
        pSmoothWidthEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=self.perSmoothWidthOct, width=10, validate=&#39;focusout&#39;, validatecommand=on_per_smoothwidth_oct)
        pSmoothWidthEntry.grid(row=6, column=1, sticky=&#39;w&#39;, padx=(5, 10))
        
        # special_handling=None, 
        
        def on_special_handling():
            try:
                str(self.special_handling.get())
                if self.special_handling.get() == &#39;None&#39;:
                    specialHandlingLabel.configure(text=&#34;special_handling={}&#34;.format(self.special_handling.get()))
                    special_handling = None
                else:
                    specialHandlingLabel.configure(text=&#34;special_handling=&#39;{}&#39;&#34;.format(self.special_handling.get()))
                    special_handling = self.special_handling.get()
                update_ppsd_call(self.ppsd_call)
                return True
            except ValueError:
                return False

        specialHandlingLabel = ttk.Label(master=ppsdParamsFrame, text=&#34;special_handling=None&#34;)
        specialHandlingLabel.grid(row=7, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

        ttk.Label(master=ppsdSettingsFrame, text=&#39;Special Handling [str]&#39;).grid(row=7, column=0, sticky=&#39;w&#39;, padx=5)

        self.special_handling = tk.StringVar()
        self.special_handling.set(&#39;None&#39;)
        ttk.Radiobutton(master=ppsdSettingsFrame, text=&#39;None&#39;, variable=self.special_handling, value=&#39;None&#39;, command=on_special_handling).grid(row=7, column=1, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=ppsdSettingsFrame, text=&#39;Ringlaser&#39;, variable=self.special_handling, value=&#39;ringlaser&#39;, command=on_special_handling).grid(row=7, column=2, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=ppsdSettingsFrame, text=&#39;Hydrophone&#39;, variable=self.special_handling, value=&#39;hydrophone&#39;, command=on_special_handling).grid(row=7, column=3, sticky=&#39;w&#39;, padx=(5, 10))

        if self.special_handling.get()==&#39;None&#39;:
            special_handling = None
        else:
            special_handling = self.special_handling.get()

        separator = ttk.Separator(ppsdSettingsFrame, orient=&#39;horizontal&#39;)
        separator.grid(row=8, columnspan=8, sticky=&#39;ew&#39;, pady=10, padx=5)

        separator = ttk.Separator(ppsdParamsFrame, orient=&#39;horizontal&#39;)
        separator.grid(row=8, sticky=&#39;ew&#39;, pady=10, padx=5)

        #remove_outliers
        
        def show_rem_outliers():
            if self.remove_outliers.get():
                rem_outliers_Label.configure(text =&#39;remove_outliers=True&#39;)
            else:
                rem_outliers_Label.configure(text =&#39;remove_outliers=False&#39;)
            update_ppsd_call(self.ppsd_call)
            
        self.remove_outliers = tk.BooleanVar()
        self.remove_outliers.set(True)
        ttk.Label(master=ppsdSettingsFrame, text=&#39;Remove outlier curves [bool]: &#39;, justify=&#39;left&#39;).grid(row=9, column=0, sticky=&#39;w&#39;, padx=5)
        rem_outliers_CheckButton = ttk.Checkbutton(master=ppsdSettingsFrame, text=&#39;&#39;, variable=self.remove_outliers, command=show_rem_outliers) # create the Entry widget
        rem_outliers_CheckButton.grid(row=9, column=1, sticky=&#39;ew&#39;, padx=(5,10))
        rem_outliers_Label = ttk.Label(master=ppsdParamsFrame, text=&#39;remove_outliers=True&#39;)
        rem_outliers_Label.grid(row=9, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

        # outlier_std=1.5, 
        
        def on_outlier_std():
            try:
                float(self.outlier_std.get())
                outlier_std_Label.configure(text=&#39;outlier_std={}&#39;.format(self.outlier_std.get()))
                update_ppsd_call(self.ppsd_call)            
                return True
            except ValueError:
                return False
        outlier_std_Label = ttk.Label(master=ppsdParamsFrame, text=&#39;outlier_std=1.5&#39;)#.grid(row=0, column=0)
        outlier_std_Label.grid(row=10, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
        
        ttk.Label(master=ppsdSettingsFrame, text=&#39;St. Dev. for Outliers [float]&#39;).grid(row=10, column=0, sticky=&#39;w&#39;, padx=5)
        self.outlier_std = tk.DoubleVar()
        self.outlier_std.set(1.5)
        outlier_std_Entry = ttk.Entry(master=ppsdSettingsFrame, textvariable=self.outlier_std, width=10, validate=&#39;focusout&#39;, validatecommand=on_outlier_std)
        outlier_std_Entry.grid(row=10, column=1, sticky=&#39;w&#39;, padx=(5, 10))


        #PPSD Function Call
        ppsdCallFrame = ttk.LabelFrame(ppsd_settings_tab, text=&#39;sprit_hvsr.generate_ppsds() and obspy PPSD() call&#39;)#.pack(fill=&#39;both&#39;) 
       
        self.ppsd_call = ttk.Label(master=ppsdCallFrame, text=&#39;obspy...PPSD({}, {}, {}, {}, {}, {}, \n\t{}, {}, {}, {})&#39;
                  .format(&#39;stats&#39;, &#39;metadata&#39;, ppsdLenLabel.cget(&#39;text&#39;), overlapLabel.cget(&#39;text&#39;), pStepOctLabel.cget(&#39;text&#39;), sogLabel.cget(&#39;text&#39;), 
                          dbbinsLabel.cget(&#39;text&#39;), perLimsLabel.cget(&#39;text&#39;), pSmoothWidthLabel.cget(&#39;text&#39;), specialHandlingLabel.cget(&#39;text&#39;)))
        self.ppsd_call.pack(side=&#39;bottom&#39;, anchor=&#39;w&#39;, padx=(25,0), pady=(10,10))

        self.generate_ppsd_call = ttk.Label(master=ppsdCallFrame, text=&#39;generate_ppsds({}, remove_outliers={}, outlier_std={},...\n\t{}, {}, {}, {}, {}, \n\t{}, {}, {})&#39;
                  .format(&#39;params&#39;, self.remove_outliers.get(), self.outlier_std.get(), 
                          ppsdLenLabel.cget(&#39;text&#39;), overlapLabel.cget(&#39;text&#39;), pStepOctLabel.cget(&#39;text&#39;), sogLabel.cget(&#39;text&#39;), 
                          dbbinsLabel.cget(&#39;text&#39;), perLimsLabel.cget(&#39;text&#39;), pSmoothWidthLabel.cget(&#39;text&#39;), specialHandlingLabel.cget(&#39;text&#39;)))
        self.generate_ppsd_call.pack(side=&#39;bottom&#39;, anchor=&#39;w&#39;, padx=(25,0), pady=(10,10))
        
        
        def update_ppsd_call(ppsd_call):
            ppsd_call.configure(text=&#39;obspy...PPSD({}, {}, {}, {}, {}, {}, \n\t{}, {}, {}, {})&#39;.format(&#39;stats&#39;, &#39;metadata&#39;, ppsdLenLabel.cget(&#39;text&#39;), 
                                                                                                    overlapLabel.cget(&#39;text&#39;), pStepOctLabel.cget(&#39;text&#39;), sogLabel.cget(&#39;text&#39;), 
                          dbbinsLabel.cget(&#39;text&#39;), perLimsLabel.cget(&#39;text&#39;), pSmoothWidthLabel.cget(&#39;text&#39;), specialHandlingLabel.cget(&#39;text&#39;)))

            self.generate_ppsd_call.configure(text=&#39;generate_ppsds({}, remove_outliers={}, outlier_std={},...\n\t{}, {}, {}, {}, {}, \n\t{}, {}, {})&#39;
                            .format(&#39;params&#39;, self.remove_outliers.get(), self.outlier_std.get(), 
                                    ppsdLenLabel.cget(&#39;text&#39;), overlapLabel.cget(&#39;text&#39;), pStepOctLabel.cget(&#39;text&#39;), sogLabel.cget(&#39;text&#39;), 
                                    dbbinsLabel.cget(&#39;text&#39;), perLimsLabel.cget(&#39;text&#39;), pSmoothWidthLabel.cget(&#39;text&#39;), specialHandlingLabel.cget(&#39;text&#39;)))
                    

        #Stats from trace(s)
        obspyStatsFrame = ttk.LabelFrame(ppsd_settings_tab, text=&#39;Data Trace Stats&#39;)#.pack(fill=&#39;both&#39;)
        self.obspySreamLabel_settings = ttk.Label(obspyStatsFrame, text=&#39;Stats&#39;)
        self.obspySreamLabel_settings.pack(anchor=&#39;nw&#39;, padx=5)

        #Metadata (PAZ)
        obspyMetadataFrame = ttk.LabelFrame(ppsd_settings_tab, text=&#39;Metadata Poles and Zeros&#39;)#.pack(fill=&#39;both&#39;)

        self.metadataZ_settings = ttk.Label(obspyMetadataFrame, text=&#39;Z: &#39;)
        self.metadataZ_settings.grid(row=1, column=0, padx=5)
        self.metadataZ_settings.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))
        self.sensitivityLabelZ_settings = ttk.Label(obspyMetadataFrame, text=&#39;Sensitivity_Z&#39;)
        self.sensitivityLabelZ_settings.grid(row=1, column=1, padx=5)
        self.gainLabelZ_settings = ttk.Label(obspyMetadataFrame, text=&#39;Gain_Z&#39;)
        self.gainLabelZ_settings.grid(row=1, column=2, padx=5)
        self.polesLabelZ_settings = ttk.Label(obspyMetadataFrame, text=&#39;Poles_Z&#39;)
        self.polesLabelZ_settings.grid(row=1, column=3, padx=5)
        self.zerosLabelZ_settings = ttk.Label(obspyMetadataFrame, text=&#39;Zeros_Z&#39;)
        self.zerosLabelZ_settings.grid(row=1, column=4, padx=5)
 
        self.metadataN_settings = ttk.Label(obspyMetadataFrame, text=&#39;N: &#39;)
        self.metadataN_settings.grid(row=2, column=0, padx=5)
        self.metadataN_settings.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))
        self.sensitivityLabelN_settings = ttk.Label(obspyMetadataFrame, text=&#39;Sensitivity_N&#39;)
        self.sensitivityLabelN_settings.grid(row=2, column=1, padx=5)
        self.gainLabelN_settings = ttk.Label(obspyMetadataFrame, text=&#39;Gain_N&#39;)
        self.gainLabelN_settings.grid(row=2, column=2, padx=5)
        self.polesLabelN_settings = ttk.Label(obspyMetadataFrame, text=&#39;Poles_N&#39;)
        self.polesLabelN_settings.grid(row=2, column=3, padx=5)
        self.zerosLabelN_settings = ttk.Label(obspyMetadataFrame, text=&#39;Zeros_N&#39;)
        self.zerosLabelN_settings.grid(row=2, column=4, padx=5)
 
        self.metadataE_settings = ttk.Label(obspyMetadataFrame, text=&#39;E: &#39;)
        self.metadataE_settings.grid(row=3, column=0, padx=5)
        self.metadataE_settings.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))
        self.sensitivityLabelE_settings = ttk.Label(obspyMetadataFrame, text=&#39;Sensitivity_E&#39;)
        self.sensitivityLabelE_settings.grid(row=3, column=1)
        self.gainLabelE_settings = ttk.Label(obspyMetadataFrame, text=&#39;Gain_E&#39;)
        self.gainLabelE_settings.grid(row=3, column=2, padx=5)
        self.polesLabelE_settings = ttk.Label(obspyMetadataFrame, text=&#39;Poles_E&#39;)
        self.polesLabelE_settings.grid(row=3, column=3, padx=5)
        self.zerosLabelE_settings = ttk.Label(obspyMetadataFrame, text=&#39;Zeros_E&#39;)
        self.zerosLabelE_settings.grid(row=3, column=4, padx=5)

        self.metadata_sensitivity = ttk.Label(obspyMetadataFrame, text=&#39;Sensitivity&#39;)
        self.metadata_sensitivity.grid(row=0, column=1, padx=5)
        self.metadata_sensitivity.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))

        self.metadata_gain = ttk.Label(obspyMetadataFrame, text=&#39;Gain&#39;)
        self.metadata_gain.grid(row=0, column=2, padx=5)
        self.metadata_gain.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))

        self.metadata_poles = ttk.Label(obspyMetadataFrame, text=&#39;Poles&#39;)
        self.metadata_poles.grid(row=0, column=3, padx=5)
        self.metadata_poles.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))

        self.metadata_zeros = ttk.Label(obspyMetadataFrame, text=&#39;Zeros&#39;)
        self.metadata_zeros.grid(row=0, column=4, padx=5)
        self.metadata_zeros.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))

        #Run button frame
        runFrame_set_ppsd = ttk.Frame(ppsd_settings_tab)
        self.run_button = ttk.Button(runFrame_set_ppsd, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)
        self.run_button.pack(side=&#39;bottom&#39;, anchor=&#39;e&#39;)
        
        runFrame_set_ppsd.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;, anchor=&#39;e&#39;)            
        obspyMetadataFrame.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;,expand=True)#.grid(row=7, column=0, columnspan=6, sticky=&#39;nsew&#39;)#.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
        obspyStatsFrame.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;,expand=True)#.grid(row=6, column=0, columnspan=6, sticky=&#39;nsew&#39;)#.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
        ppsdCallFrame.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;,expand=True)#row=5, column=0, columnspan=6, sticky=&#39;nsew&#39;)#.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
        ppsdParamsFrame.pack(fill=&#39;both&#39;, side=&#39;right&#39;)#.grid(row=0, column=5, rowspan=4, sticky=&#39;nsew&#39;)#.pack(side=&#39;right&#39;,fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
        ppsdSettingsFrame.pack(fill=&#39;both&#39;, expand=True, side=&#39;top&#39;, anchor=&#39;w&#39;)#.grid(row=0, column=0, columnspan=4, rowspan=4, sticky=&#39;nsew&#39;)#.pack(side=&#39;left&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
    
        ppsd_settings_tab.pack(fill=&#39;both&#39;, expand=True)
        settings_notebook.add(ppsd_settings_tab, text=&#34;PPSD&#34;)

        #HVSR SETTINGS TAB
        hvsr_settings_tab = ttk.Frame(settings_notebook)
        
        hvsrSettingsFrame = ttk.LabelFrame(hvsr_settings_tab, text=&#39;H/V Processing Settings&#39;)#.pack(fill=&#39;both&#39;)
        
        hvsrParamsFrame = ttk.LabelFrame(hvsr_settings_tab, text=&#39;Process HVSR Parameters&#39;)#.pack(fill=&#39;both&#39;)
        
        #Method selection, method=4
        ttk.Label(hvsrSettingsFrame, text=&#34;Horizontal Combine Method [int]&#34;).grid(row=0, column=0, padx=(5,0), sticky=&#39;w&#39;)
        method_options = [&#39;&#39;, #Empty to make intuitive and match sprit_hvsr.py
                          &#34;1.Diffuse Field Assumption (not currently implemented)&#34;, 
                          &#34;2. Arithmetic Mean H ≡ (N + E)/2&#34;,
                          &#34;3. Geometric Mean: H ≡ √(N · E) (recommended by SESEAME Project (2004))&#34;,
                          &#34;4. Vector Summation: H ≡ √(N^2 + E^2)&#34;,
                          &#34;5. Quadratic Mean: H ≡ √(N^2 + E^2)/2&#34;,
                          &#34;6. Maximum Horizontal Value: H ≡ max(N, E)&#34;
                          ]

        
        def on_method_select(meth, meth_opts=method_options):
            self.method_ind = meth_opts.index(meth)

            try:
                int(self.method_ind)
                hCombMethodLabel.configure(text=&#34;method={}&#34;.format(self.method_ind))
                update_procHVSR_call(self.procHVSR_call)
                return True
            except ValueError:
                return False

        defaultMeth=3
        hCombMethodLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;method={}&#34;.format(defaultMeth), width=30)
        hCombMethodLabel.grid(row=0, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

        self.method_sel = tk.StringVar(value=method_options[defaultMeth])
        self.method_ind = method_options.index(self.method_sel.get())       
        self.method_dropdown = ttk.OptionMenu(hvsrSettingsFrame, self.method_sel, method_options[defaultMeth], *method_options, command=on_method_select)
        self.method_dropdown.config(width=50)
        self.method_dropdown.grid(row=0, column=1, columnspan=8, sticky=&#39;ew&#39;)
        
        #smooth=True, 
        
        def curve_smooth():
            try:
                int(self.hvsmooth.get())
                bool(self.hvsmoothbool.get())
                if not self.hvsmoothbool.get():
                    hvSmoothLabel.configure(text=&#39;smooth={}&#39;.format(self.hvsmoothbool.get()))
                    self.hvsmooth_param = False
                else:
                    hvSmoothLabel.configure(text=&#39;smooth={}&#39;.format(self.hvsmooth.get()))
                    self.hvsmooth_param = self.hvsmooth.get()              
                update_procHVSR_call(self.procHVSR_call)
                return True
            except ValueError:
                return False
            
        hvSmoothLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;smooth=True&#34;, width=30)
        hvSmoothLabel.grid(row=1, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

        ttk.Label(master=hvsrSettingsFrame, text=&#39;Smooth H/V Curve [bool]&#39;).grid(row=1, column=0, padx=(5,0), sticky=&#39;w&#39;)

        self.hvsmoothbool = tk.BooleanVar()
        self.hvsmoothbool.set(True)
        self.hvsmooth_param=True
        smoothCurveBool = ttk.Checkbutton(master=hvsrSettingsFrame, text=&#34;&#34;, compound=&#39;left&#39;, variable=self.hvsmoothbool, command=curve_smooth) # create the Checkbutton widget
        smoothCurveBool.grid(row=1, column=1, sticky=&#39;w&#39;)

        self.hvsmooth = tk.IntVar()
        self.hvsmooth.set(51)
        smoothCurveSamples = ttk.Entry(master=hvsrSettingsFrame, textvariable=self.hvsmooth, width=10, validate=&#39;focusout&#39;, validatecommand=curve_smooth)
        smoothCurveSamples.grid(row=1, column=2, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Label(master=hvsrSettingsFrame, text=&#39;[int] # pts in smoothing window (default=51)&#39;).grid(row=1, column=3, padx=(0,0))
        
        #freq_smooth=&#39;konno ohmachi&#39;, 
        freqSmoothLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;freq_smooth=&#39;konno ohmachi&#39;&#34;, width=30)
        freqSmoothLabel.grid(row=2, column=0, sticky=&#39;w&#39;, pady=(16,16), padx=5)

        
        def on_freq_smooth():
            try:
                str(self.freq_smooth.get())
                freqSmoothLabel.configure(text=&#34;freq_smooth={}&#34;.format(self.freq_smooth.get()))
                update_procHVSR_call(self.procHVSR_call)
                return True
            except ValueError:
                return False

        self.freq_smooth = tk.StringVar()
        self.freq_smooth.set(&#39;konno ohmachi&#39;)
        ttk.Label(master=hvsrSettingsFrame, text=&#39;Frequency Smoothing [str]&#39;).grid(row=2, column=0, padx=(5,0), sticky=&#39;w&#39;)
        fsmoothOptFrame = ttk.LabelFrame(master=hvsrSettingsFrame, text=&#39;Frequency Smoothing Operations&#39;)
        fsmoothOptFrame.grid(row=2, column=1, columnspan=7, padx=5, sticky=&#39;nsew&#39;)
        ttk.Radiobutton(master=fsmoothOptFrame, text=&#39;Konno-Ohmachi&#39;, variable=self.freq_smooth, value=&#39;konno ohmachi&#39;, command=on_freq_smooth).grid(row=0, column=0, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=fsmoothOptFrame, text=&#39;Constant&#39;, variable=self.freq_smooth, value=&#39;constant&#39;, command=on_freq_smooth).grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=fsmoothOptFrame, text=&#39;Proportional&#39;, variable=self.freq_smooth, value=&#39;proportional&#39;, command=on_freq_smooth).grid(row=0, column=2, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Radiobutton(master=fsmoothOptFrame, text=&#39;None&#39;, variable=self.freq_smooth, value=&#39;None&#39;, command=on_freq_smooth).grid(row=0, column=3, sticky=&#39;w&#39;, padx=(5, 10))

        #f_smooth_width=40, 
        fSmoothWidthlabel = ttk.Label(master=hvsrParamsFrame, text=&#34;f_smooth_width=40&#34;, width=30)
        fSmoothWidthlabel.grid(row=3, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

        
        def on_smooth_width():
            try:
                int(self.fSmoothWidth.get())
                fSmoothWidthlabel.configure(text=&#39;f_smooth_width={}&#39;.format(self.fSmoothWidth.get()))                
                update_procHVSR_call(self.procHVSR_call)
                return True
            except ValueError:
                return False
            
        ttk.Label(master=hvsrSettingsFrame, text=&#39;Bandwidth of freq. smoothing [int]&#39;).grid(row=3, column=0, padx=(5,0), sticky=&#39;w&#39;)
        self.fSmoothWidth = tk.IntVar()
        self.fSmoothWidth.set(40)
        fSmoothWidthEntry = ttk.Entry(master=hvsrSettingsFrame, justify=&#39;left&#39;, textvariable=self.fSmoothWidth, validate=&#39;focusout&#39;, validatecommand=on_smooth_width, width=10)
        fSmoothWidthEntry.grid(row=3, column=1, sticky=&#39;w&#39;, padx=(5, 10))
        
        #resample=True, 
        resampleLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;resample=True&#34;, width=30)
        resampleLabel.grid(row=4, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
        
        def on_curve_resample():
            try:
                if not self.resamplebool.get():
                    resampleLabel.configure(text=&#39;resample={}&#39;.format(self.resamplebool.get()))
                    self.hvresample_int=self.hvresample.get()
                else:
                    resampleLabel.configure(text=&#39;resample={}&#39;.format(self.hvresample.get()))
                    self.hvresample_int=self.hvresample.get()    
                update_procHVSR_call(self.procHVSR_call)
                return True
            except ValueError:
                return False
            
        self.resamplebool = tk.BooleanVar()
        self.resamplebool.set(True)
        ttk.Label(master=hvsrSettingsFrame, text=&#39;Resample H/V Curve [bool]&#39;).grid(row=4, column=0, padx=(5,0), sticky=&#39;w&#39;)
        resampleCurveBool = ttk.Checkbutton(master=hvsrSettingsFrame, text=&#34;&#34;, compound=&#39;left&#39;, variable=self.resamplebool, command=on_curve_resample) # create the Checkbutton widget
        resampleCurveBool.grid(row=4, column=1, sticky=&#39;w&#39;)

        self.hvresample = tk.IntVar()
        self.hvresample.set(1000)
        self.hvresample_int = self.hvresample.get()
        resampleCurveSamples = ttk.Entry(master=hvsrSettingsFrame, textvariable=self.hvresample, width=10, validate=&#39;focusout&#39;, validatecommand=on_curve_resample)
        resampleCurveSamples.grid(row=4, column=2, sticky=&#39;w&#39;, padx=(5, 10))
        ttk.Label(master=hvsrSettingsFrame, text=&#39;[int] # pts in resampled curve (default=1000)&#39;).grid(row=4, column=3, padx=(0,0), sticky=&#39;w&#39;)
                        
        #remove_outlier_curves=True, 
        outlierRemLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;remove_outlier_curves=True&#34;, width=30)
        outlierRemLabel.grid(row=5, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

        
        def on_remove_outlier_curves():
            try:
                bool(self.outlierRembool.get())
                outlierRemLabel.configure(text=&#39;remove_outlier_curves={}&#39;.format(self.outlierRembool.get()))
                #if self.outlierRembool.get():
                #    outlierRemStDev.state([&#39;active&#39;])
                #else:
                #    outlierRemStDev.state([&#39;disabled&#39;])

                update_procHVSR_call(self.procHVSR_call)
                return True
            except ValueError:
                return False
            
        self.outlierRembool = tk.BooleanVar()
        self.outlierRembool.set(True)
        ttk.Label(master=hvsrSettingsFrame, text=&#39;Remove Outlier H/V Curves [bool]&#39;).grid(row=5, column=0, padx=(5,0), sticky=&#39;w&#39;)
        resampleCurveBool = ttk.Checkbutton(master=hvsrSettingsFrame, text=&#34;&#34;, compound=&#39;left&#39;, variable=self.outlierRembool, command=on_remove_outlier_curves) # create the Checkbutton widget
        resampleCurveBool.grid(row=5, column=1, sticky=&#39;w&#39;)

        #outlier_curve_std=1.75
        outlierValLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;outlier_curve_std=1.75&#34;, width=30)
        outlierValLabel.grid(row=6, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)        

        
        def on_outlier_std():
            try:
                float(self.outlierRemStDev.get())
                outlierValLabel.configure(text=&#39;resample={}&#39;.format(self.outlierRemStDev.get()))                
                update_procHVSR_call(self.procHVSR_call)
                return True
            except ValueError:
                return False
            
        ttk.Label(master=hvsrSettingsFrame, text=&#39;Outlier St. Dev. [float]&#39;).grid(row=6, column=0, columnspan=2, padx=(5,0), sticky=&#39;w&#39;)
        self.outlierRemStDev = tk.DoubleVar()
        self.outlierRemStDev.set(1.75)
        outlierRemStDev = ttk.Entry(master=hvsrSettingsFrame, textvariable=self.outlierRemStDev, width=10, validate=&#39;focusout&#39;, validatecommand=on_outlier_std)
        outlierRemStDev.grid(row=6, column=1, sticky=&#39;w&#39;, padx=(5, 10))

        separator = ttk.Separator(hvsrSettingsFrame, orient=&#39;horizontal&#39;)
        separator.grid(row=7, columnspan=7, sticky=&#39;ew&#39;, pady=10)

        #hvsr_band=[0.4, 40]
        hvsrBandLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;hvsr_band=[0.4,40]&#34;, width=30)
        hvsrBandLabel.grid(row=7, column=0, sticky=&#39;w&#39;, pady=(20,6), padx=5)

        ttk.Label(hvsrSettingsFrame,text=&#34;HVSR Band [Hz]&#34;).grid(row=8,column=0, sticky=&#39;w&#39;, padx=(5,0))

        hvsr_band_min_settingsEntry = ttk.Entry(hvsrSettingsFrame, width=10, textvariable=self.hvsrBand_min, validate=&#39;focusout&#39;, validatecommand=on_hvsrband_update)
        hvsr_band_min_settingsEntry.grid(row=8,column=1, sticky=&#39;ew&#39;)

        hvsr_band_max_settingsEntry = ttk.Entry(hvsrSettingsFrame, width=10, textvariable=self.hvsrBand_max, validate=&#39;focusout&#39;, validatecommand=on_hvsrband_update)
        hvsr_band_max_settingsEntry.grid(row=8,column=2, sticky=&#39;ew&#39;)
   
        #peak_water_level=1.8
        pwaterLevLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;peak_water_level=1.8&#34;, width=30)
        pwaterLevLabel.grid(row=8, column=0, sticky=&#39;w&#39;, pady=(6,6), padx=5)        

        
        def on_pwaterlevel_update():
            try:
                float(self.peak_water_level.get())

                pwaterLevLabel.configure(text=&#39;peak_water_level={}&#39;.format(self.peak_water_level.get()))                
                update_check_peaks_call(self.checkPeaks_Call)
                return True
            except ValueError:
                return False      
                
        ttk.Label(hvsrSettingsFrame,text=&#34;Peak Water Level&#34;).grid(row=9, column=0, sticky=&#39;w&#39;, padx=5)

        self.peak_water_level = tk.DoubleVar()
        self.peak_water_level.set(1.8)
        pWaterLevelEntry = ttk.Entry(hvsrSettingsFrame, width=10, textvariable=self.peak_water_level, validate=&#39;focusout&#39;, validatecommand=on_pwaterlevel_update)
        pWaterLevelEntry.grid(row=9, column=1, sticky=&#39;w&#39;)

        #Process HVSR Function Call
        hvsrCallFrame = ttk.LabelFrame(hvsr_settings_tab, text=&#39;sprit_hvsr.process_hvsr() Call&#39;)#.pack(fill=&#39;both&#39;)
        
        self.procHVSR_call = ttk.Label(master=hvsrCallFrame, text=&#39;process_hvsr({}, {}, {}, {}, {}, \n\t{}, {}, {}, {}, {})&#39;
                  .format(&#39;params&#39;, hCombMethodLabel.cget(&#39;text&#39;), hvSmoothLabel.cget(&#39;text&#39;), freqSmoothLabel.cget(&#39;text&#39;), fSmoothWidthlabel.cget(&#39;text&#39;), resampleLabel.cget(&#39;text&#39;), 
                          outlierRemLabel.cget(&#39;text&#39;), outlierValLabel.cget(&#39;text&#39;), hvsrBandLabel.cget(&#39;text&#39;), pwaterLevLabel.cget(&#39;text&#39;)))
        self.procHVSR_call.pack(anchor=&#39;w&#39;, padx=(25,0), pady=(10,10))

        
        def update_procHVSR_call(procHVSR_call):
            procHVSR_call.configure(text=&#39;process_hvsr({}, {}, {}, {}, {}, \n\t{}, {}, {}, {}, {})&#39;
                  .format(&#39;params&#39;, hCombMethodLabel.cget(&#39;text&#39;), hvSmoothLabel.cget(&#39;text&#39;), freqSmoothLabel.cget(&#39;text&#39;), fSmoothWidthlabel.cget(&#39;text&#39;), resampleLabel.cget(&#39;text&#39;), 
                          outlierRemLabel.cget(&#39;text&#39;), outlierValLabel.cget(&#39;text&#39;), hvsrBandLabel.cget(&#39;text&#39;), pwaterLevLabel.cget(&#39;text&#39;)))
        
        #Check Peaks Function Call
        checkPeaksCallFrame = ttk.LabelFrame(hvsr_settings_tab, text=&#39;sprit_hvsr.check_peaks() Call&#39;)#.pack(fill=&#39;both&#39;)

        self.checkPeaks_Call = ttk.Label(master=checkPeaksCallFrame, text=&#39;check_peaks({}, {}, {})&#39;
                  .format(&#39;hvsr_data&#39;, hvsrBandLabel.cget(&#39;text&#39;), pwaterLevLabel.cget(&#39;text&#39;)))
        self.checkPeaks_Call.pack(anchor=&#39;w&#39;, padx=(25,0), pady=(10,10))

        #check_peaks(hvsr_dict, hvsr_band=[0.4, 40], peak_water_level=1.8)
        
        def update_check_peaks_call(checkPeaks_Call):
            checkPeaks_Call.configure(text=&#39;check_peaks({}, {}, {})&#39;
                  .format(&#39;hvsr_data&#39;, hvsrBandLabel.cget(&#39;text&#39;), pwaterLevLabel.cget(&#39;text&#39;)))


        #Run button frame
        runFrame_set_hvsr = ttk.Frame(hvsr_settings_tab)
        self.run_button = ttk.Button(runFrame_set_hvsr, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)
        self.run_button.pack(side=&#39;bottom&#39;, anchor=&#39;e&#39;)

        #Pack tab
        runFrame_set_hvsr.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;, anchor=&#39;e&#39;)    
        checkPeaksCallFrame.pack(fill=&#39;both&#39;, expand=True, side=&#39;bottom&#39;)#.grid(row=10, column=0, columnspan=6, sticky=&#39;nsew&#39;)#.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
        hvsrCallFrame.pack(fill=&#39;both&#39;, expand=True, side=&#39;bottom&#39;)#.grid(row=9, column=0, columnspan=6, sticky=&#39;nsew&#39;)#.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
        hvsrParamsFrame.pack(fill=&#39;both&#39;, side=&#39;right&#39;)#.grid(row=0, column=6, rowspan=4, sticky=&#39;nsew&#39;)#.pack(side=&#39;right&#39;,fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
        hvsrSettingsFrame.pack(fill=&#39;both&#39;, expand=True, side=&#39;top&#39;)#.grid(row=0, column=0, columnspan=6, rowspan=4, sticky=&#39;nsew&#39;)#.pack(fill=&#39;both&#39;, expand=True)
        
        hvsr_settings_tab.pack(fill=&#39;both&#39;, expand=True)           
        settings_notebook.add(hvsr_settings_tab, text=&#34;HVSR Settings&#34;)

        #PLOT SETTINGS TAB
        plot_settings_tab = ttk.Frame(settings_notebook)

        # Create the Plot Options LabelFrame
        plot_options_frame = ttk.LabelFrame(plot_settings_tab, text=&#34;Plot Options&#34;)

        
        def update_hvplot_call():
            kindstr = get_kindstr()
            hvplot_label.configure(text=&#34;hvplot({}, kind={}, xtype=&#39;{}&#39;, {}, {})&#34;.format(&#39;hvsr_data&#39;, kindstr, self.x_type.get(), &#39;[...]&#39;, &#39;kwargs&#39;))

        # Create the Checkbuttons for the plot options
        ttk.Label(plot_options_frame, text=&#39;HVSR Plot&#39;, justify=&#39;center&#39;).grid(row=0, column=1, sticky=&#39;ew&#39;, padx=(5, 5))
        ttk.Label(plot_options_frame, text=&#39;Components H/V Plot&#39;, justify=&#39;center&#39;).grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5, 5))
        ttk.Label(plot_options_frame, text=&#39;Spectrogram Plot&#39;, justify=&#39;center&#39;).grid(row=0, column=3, sticky=&#39;ew&#39;, padx=(5, 5))

        self.hvsr_chart_bool = tk.BooleanVar()
        self.hvsr_chart_bool.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#39;&#39;, variable=self.hvsr_chart_bool, command=update_hvplot_call).grid(row=1, column=1, sticky=&#39;nsew&#39;, padx=15, pady=(5, 20))
        self.ind_comp_chart_bool = tk.BooleanVar()
        self.ind_comp_chart_bool.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#39;&#39;, variable=self.ind_comp_chart_bool, command=update_hvplot_call).grid(row=1, column=2, sticky=&#39;nsew&#39;, padx=50, pady=(5, 20))
        self.spec_chart_bool = tk.BooleanVar()
        self.spec_chart_bool.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#39;&#39;, variable=self.spec_chart_bool, command=update_hvplot_call).grid(row=1, column=3, sticky=&#39;nsew&#39;, padx=25, pady=(5, 20))
        
        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=2, columnspan=5, sticky=&#39;ew&#39;, pady=5)
        
        #Separate component chart: c+
        ttk.Label(plot_options_frame, text=&#39;Show Components on same chart as H/V Curve:&#39;).grid(row=3, column=0, sticky=&#39;w&#39;, padx=5)
        
        
        def disable_comp_buttons():
            if self.show_comp_with_hv.get():
                self.annotate_best_peak_comp.set(False)
                self.show_best_peak_comp.set(False)
                bestPeakCompButton.config(state=&#34;disabled&#34;) 
                bestPeakCompAnnButton.config(state=&#39;disabled&#39;)
            else:
                bestPeakCompButton.config(state=&#34;normal&#34;) 
                bestPeakCompAnnButton.config(state=&#39;normal&#39;)
            update_hvplot_call()

        self.show_comp_with_hv = tk.BooleanVar()
        self.show_comp_with_hv.set(False)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_comp_with_hv, 
                        command=disable_comp_buttons).grid(row=3, column=2, sticky=&#34;ew&#34;, padx=50)

        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=4, columnspan=5, sticky=&#39;ew&#39;, pady=5)

        #Show Best Peak: p
        ttk.Label(plot_options_frame, text=&#39;Show Best Peak:&#39;).grid(row=5, column=0, sticky=&#39;w&#39;, padx=5)

        self.show_best_peak_hv = tk.BooleanVar()
        self.show_best_peak_hv.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_best_peak_hv, command=update_hvplot_call).grid(row=5, column=1, sticky=&#34;ew&#34;, padx=15)

        self.show_best_peak_comp = tk.BooleanVar()
        self.show_best_peak_comp.set(True)
        bestPeakCompButton=ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_best_peak_comp, command=update_hvplot_call)
        bestPeakCompButton.grid(row=5, column=2, sticky=&#34;ew&#34;, padx=50)

        self.show_best_peak_spec = tk.BooleanVar()
        self.show_best_peak_spec.set(False)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_best_peak_spec, command=update_hvplot_call).grid(row=5, column=3, sticky=&#34;ew&#34;, padx=25)

        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=6, columnspan=5, sticky=&#39;ew&#39;)

        #Annotate Best Peak: ann
        ttk.Label(plot_options_frame, text=&#39;Annotate Best Peak:&#39;).grid(row=7, column=0, sticky=&#39;w&#39;, padx=5)

        self.annotate_best_peak_hv = tk.BooleanVar()
        self.annotate_best_peak_hv.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.annotate_best_peak_hv, command=update_hvplot_call).grid(row=7, column=1, sticky=&#34;ew&#34;, padx=15)

        self.annotate_best_peak_comp = tk.BooleanVar()
        self.annotate_best_peak_comp.set(True)
        bestPeakCompAnnButton=ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.annotate_best_peak_comp, command=update_hvplot_call)
        bestPeakCompAnnButton.grid(row=7, column=2, sticky=&#34;ew&#34;, padx=50)

        self.annotate_best_peak_spec = tk.BooleanVar()
        self.annotate_best_peak_spec.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.annotate_best_peak_spec, command=update_hvplot_call).grid(row=7, column=3, sticky=&#34;ew&#34;, padx=25)

        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=8, columnspan=5, sticky=&#39;ew&#39;)


        #Show all peaks (main H/V curve): all
        ttk.Label(plot_options_frame, text=&#39;Show All Peaks (H/V Curve):&#39;).grid(row=9, column=0, sticky=&#39;w&#39;, padx=5)

        self.show_all_peaks_hv = tk.BooleanVar()
        self.show_all_peaks_hv.set(False)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_all_peaks_hv, command=update_hvplot_call).grid(row=9, column=1, sticky=&#34;ew&#34;, padx=15)

        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=10, columnspan=5, sticky=&#39;ew&#39;)

        #Show all curves: t
        ttk.Label(plot_options_frame, text=&#39;Show All H/V Curves:&#39;).grid(row=11, column=0, sticky=&#39;w&#39;, padx=5)

        self.show_ind_curves = tk.BooleanVar()
        self.show_ind_curves.set(False)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_ind_curves, command=update_hvplot_call).grid(row=11, column=1, sticky=&#34;ew&#34;, padx=15)

        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=12, columnspan=5, sticky=&#39;ew&#39;)

        #Show individual peaks (tp): tp
        ttk.Label(plot_options_frame, text=&#39;Show Individual Peaks:&#39;).grid(row=13, column=0, sticky=&#39;w&#39;, padx=5)

        self.show_ind_peaks = tk.BooleanVar()
        self.show_ind_peaks.set(False)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_ind_peaks, command=update_hvplot_call).grid(row=13, column=1, sticky=&#34;ew&#34;, padx=15)

        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=14, columnspan=5, sticky=&#39;ew&#39;)

        #Show individual peaks (tp): tp
        ttk.Label(plot_options_frame, text=&#39;Show Standard Deviation:&#39;).grid(row=15, column=0, sticky=&#39;w&#39;, padx=5)

        self.show_stDev_hv = tk.BooleanVar()
        self.show_stDev_hv.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_stDev_hv, command=update_hvplot_call).grid(row=15, column=1, sticky=&#34;ew&#34;, padx=15)

        self.show_stDev_comp = tk.BooleanVar()
        self.show_stDev_comp.set(True)
        ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_stDev_comp, command=update_hvplot_call).grid(row=15, column=2, sticky=&#34;ew&#34;, padx=50)

        ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=16, columnspan=5, sticky=&#39;ew&#39;)

        #Specify X-Type
        ttk.Label(plot_options_frame, text=&#39;X Type:&#39;).grid(row=17, column=0, sticky=&#39;w&#39;, padx=5, pady=10)

        self.x_type = tk.StringVar()
        self.x_type.set(&#39;freq&#39;)
        ttk.Radiobutton(master=plot_options_frame, text=&#39;Frequency&#39;, variable=self.x_type, value=&#39;freq&#39;, command=update_hvplot_call).grid(row=17, column=1, sticky=&#39;w&#39;, padx=(5, 10), pady=10)
        ttk.Radiobutton(master=plot_options_frame, text=&#39;Period&#39;, variable=self.x_type, value=&#39;period&#39;, command=update_hvplot_call).grid(row=17, column=2, sticky=&#39;w&#39;, padx=(5, 10), pady=10)

        #kwargs
        ttk.Label(plot_options_frame, text=&#39;Matplotlib Keyword Arguments (not implemented):&#39;).grid(row=18, column=0, sticky=&#39;w&#39;, padx=5, pady=10)

        self.plot_kwargs = tk.StringVar()
        self.plot_kwargs.set(&#34;cmap=&#39;turbo&#39;&#34;)
        ttk.Entry(plot_options_frame, textvariable=self.plot_kwargs).grid(row=18, column=1, columnspan=3, sticky=&#34;ew&#34;, pady=10)

        plot_options_frame.pack(fill=&#39;both&#39;, expand=True)#.grid(row=1, column=0, padx=10, pady=10, sticky=&#34;nsew&#34;)

        # Create the hvplot Call LabelFrame
        hvplot_call_frame = ttk.LabelFrame(plot_settings_tab, text=&#34;hvplot() Call&#34;)

        #HVSR
        
        def get_kindstr():
            if self.hvsr_chart_bool.get():
                kindstr_hv = &#39;HVSR&#39;
                if self.show_best_peak_hv.get():
                    kindstr_hv = kindstr_hv + &#39; p&#39;
                if self.annotate_best_peak_hv.get():
                    kindstr_hv = kindstr_hv + &#39; ann&#39;
                if self.show_all_peaks_hv.get():
                    kindstr_hv = kindstr_hv + &#39; all&#39;
                if self.show_ind_curves.get():
                    kindstr_hv = kindstr_hv + &#39; t&#39;
                if self.show_ind_peaks.get():
                    kindstr_hv = kindstr_hv + &#39;p&#39;
                if not self.show_stDev_hv.get():
                    kindstr_hv = kindstr_hv + &#39; -s&#39;
            else:
                kindstr_hv = &#39;&#39;

            #Comp
            if self.ind_comp_chart_bool.get():
                kindstr_c = &#39;c&#39;

                if not self.show_comp_with_hv.get():
                    kindstr_c = kindstr_c + &#39;+&#39;

                    if self.show_best_peak_comp.get():
                        kindstr_c = kindstr_c + &#39; p&#39;
                    if self.annotate_best_peak_comp.get():
                        kindstr_c = kindstr_c + &#39; ann&#39;
                if not self.show_stDev_comp.get():
                    kindstr_c = kindstr_c + &#39; -s&#39;
            else:
                kindstr_c = &#39;&#39;

            #Specgram
            if self.spec_chart_bool.get():
                kindstr_spec = &#39;Spec&#39;

                if self.show_best_peak_spec.get():
                    kindstr_spec = kindstr_spec + &#39; p&#39;
                if self.annotate_best_peak_spec.get():
                    kindstr_spec = kindstr_spec + &#39; ann&#39;
            else:
                kindstr_spec = &#39;&#39;
            kindstr = kindstr_hv + &#39; &#39; +  kindstr_c + &#39; &#39; + kindstr_spec
            return kindstr
        

        # Add a Label widget to the hvplot Call Label section
        hvplot_label = ttk.Label(hvplot_call_frame, text=&#34;hvplot({}, kind=&#39;{}&#39;, xtype=&#39;{}&#39;, {}, {})&#34;.format(&#39;hvsr_data&#39;, get_kindstr(), self.x_type.get(), &#39;[...]&#39;, &#39;kwargs&#39;))

        #Run button frame
        runFrame_set_plot = ttk.Frame(plot_settings_tab)

        self.run_button = ttk.Button(runFrame_set_plot, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)

        
        def update_results_plot():
            self.tab_control.select(self.results_tab)
            sprit_hvsr.hvplot(self.hvsr_results, plot_type=get_kindstr(), fig=self.fig_results, ax=self.ax_results, use_subplots=True, clear_fig=False)

        self.update_results_plot_button = ttk.Button(runFrame_set_plot, text=&#34;Update Plot&#34;, style=&#39;Noise.TButton&#39;, command=update_results_plot, width=30)
        
        self.run_button.pack(side=&#39;right&#39;, anchor=&#39;se&#39;, padx=(10,0))
        self.update_results_plot_button.pack(side=&#39;right&#39;, anchor=&#39;se&#39;)

        runFrame_set_plot.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;, anchor=&#39;e&#39;)
        hvplot_label.pack(fill=&#39;both&#39;, expand=True, padx=(10,0))#.grid(column=0, row=0, padx=10, pady=10, sticky=&#34;w&#34;)
        hvplot_call_frame.pack(fill=&#39;both&#39;, expand=True)#.grid(row=2, column=0, padx=10, pady=10, sticky=&#34;nsew&#34;)

        plot_settings_tab.pack(fill=&#39;both&#39;, expand=True)
        settings_notebook.add(plot_settings_tab, text=&#34;Plot Settings&#34;)

        # Pack the settings Notebook widget
        settings_notebook.pack(expand=True, fill=&#39;both&#39;)
        self.tab_control.add(self.settings_tab, text=&#34;Settings&#34;)

        # RESULTS TAB
        self.results_tab = ttk.Frame(self.tab_control)

        # Create the Batch Site selection LabelFrame
        self.results_siteSelectFrame = ttk.LabelFrame(self.results_tab, text=&#34;HVSR Results&#34;)
        self.results_siteSelectLabel = ttk.Label(self.results_siteSelectFrame, text=&#39;Select Site to display&#39;)


        # Create the hvplot Call LabelFrame
        self.results_chartFrame = ttk.LabelFrame(self.results_tab, text=&#34;Data Plots&#34;)

        #Set up plot     
        #results_mosaic = [[&#39;hvsr&#39;],[&#39;comp&#39;],[&#39;spec&#39;]]
        #self.fig_results, self.ax_results = plt.subplot_mosaic(results_mosaic)  
        #self.results_canvas = FigureCanvasTkAgg(self.fig_results, master=self.results_chartFrame)
        #self.results_canvas.draw()
        #self.results_canvasWidget = self.results_canvas.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)

        self.fig_results = plt.figure()
        results_mosaic = [[&#39;hvsr&#39;],[&#39;comp&#39;],[&#39;spec&#39;]]
        self.ax_results = self.fig_results.subplot_mosaic(results_mosaic)

        self.results_canvas = FigureCanvasTkAgg(self.fig_results, master=self.results_chartFrame)  # A tk.DrawingArea.
        self.results_canvas.draw()
        self.results_canvasWidget = self.results_canvas.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
        self.results_toolbar = NavigationToolbar2Tk(self.results_canvas, self.results_chartFrame, pack_toolbar=False)
        self.results_toolbar.update()
        self.results_toolbar.pack(fill=tk.X, side=tk.BOTTOM, expand=False)
        self.results_canvasWidget.pack(fill=&#39;both&#39;, expand=True)#.grid(row=0, column=0, sticky=&#39;nsew&#39;)

        #Peak report
        results_peakInfoFrame = ttk.LabelFrame(self.results_tab, text=&#34;Peak Report&#34;)
        curveTitleLabel = ttk.Label(results_peakInfoFrame, text=&#39;Criteria for Reliable H/V Curve (all 3 must pass)&#39;)
        curveTest1Label = ttk.Label(results_peakInfoFrame, text=&#39;Window Length for Frequency&#39;)
        curveTest1ResultFrame = ttk.Frame(results_peakInfoFrame)
        curveTest1ResultText = ttk.Label(curveTest1ResultFrame, text=&#39;&#39;)
        curveTest1Result = ttk.Label(curveTest1ResultFrame, text=&#39;&#39;)

        curveTest2Label = ttk.Label(results_peakInfoFrame, text=&#39;Number of Significant Cycles&#39;)
        curveTest2ResultFrame = ttk.Frame(results_peakInfoFrame)
        curveTest2ResultText = ttk.Label(curveTest2ResultFrame, text=&#39;&#39;)
        curveTest2Result = ttk.Label(curveTest2ResultFrame, text=&#39;&#39;)

        curveTest3Label = ttk.Label(results_peakInfoFrame, text=&#39;Low Curve Standard Deviation for Frequencies Near Peak Over Time&#39;)
        curveTest3ResultFrame = ttk.Frame(results_peakInfoFrame)
        curveTest3ResultText = ttk.Label(curveTest3ResultFrame, text=&#39;&#39;)
        curveTest3Result = ttk.Label(curveTest3ResultFrame, text=&#39;&#39;)

        totalCurveResult = ttk.Label(results_peakInfoFrame, text=&#39;&#39;)

        peakTitleLabel = ttk.Label(results_peakInfoFrame, text=&#39;Criteria for a Clear H/V Peak (5/6 must pass)&#39;)
        peakTest1Label = ttk.Label(results_peakInfoFrame, text=&#39;H/V Amplitude is low Below Peak Frequency&#39;)
        peakTest1ResultFrame = ttk.Frame(results_peakInfoFrame)
        peakTest1ResultText = ttk.Label(peakTest1ResultFrame, text=&#39;&#39;)
        peakTest1Result = ttk.Label(peakTest1ResultFrame, text=&#39;&#39;)
        
        peakTest2Label = ttk.Label(results_peakInfoFrame, text=&#39;H/V Amplitude is low Above Peak Frequency&#39;)
        peakTest2ResultFrame = ttk.Frame(results_peakInfoFrame)
        peakTest2ResultText = ttk.Label(peakTest2ResultFrame, text=&#39;&#39;)
        peakTest2Result = ttk.Label(peakTest2ResultFrame, text=&#39;&#39;)
        
        peakTest3Label = ttk.Label(results_peakInfoFrame, text=&#39;Peak is Prominent&#39;)
        peakTest3ResultFrame = ttk.Frame(results_peakInfoFrame)
        peakTest3ResultText = ttk.Label(peakTest3ResultFrame, text=&#39;&#39;)
        peakTest3Result = ttk.Label(peakTest3ResultFrame, text=&#39;&#39;)
        
        peakTest4Label = ttk.Label(results_peakInfoFrame, text=&#39;Frequency of Peak is Stationary Over Time&#39;)
        peakTest4ResultFrame = ttk.Frame(results_peakInfoFrame)
        peakTest4ResultText = ttk.Label(peakTest4ResultFrame, text=&#39;&#39;)
        peakTest4Result = ttk.Label(peakTest4ResultFrame, text=&#39;&#39;)
        
        peakTest5Label = ttk.Label(results_peakInfoFrame, text=&#39;Standard Deviation of Peak Frequency is low &#39;)
        peakTest5ResultFrame = ttk.Frame(results_peakInfoFrame)
        peakTest5ResultText = ttk.Label(peakTest5ResultFrame, text=&#39;&#39;)
        peakTest5Result = ttk.Label(peakTest5ResultFrame, text=&#39;&#39;)
        
        peakTest6Label = ttk.Label(results_peakInfoFrame, text=&#39;Standard Deviation of Peak Amplitude is low&#39;)
        peakTest6ResultFrame = ttk.Frame(results_peakInfoFrame)
        peakTest6ResultText = ttk.Label(peakTest6ResultFrame, text=&#39;&#39;)
        peakTest6Result = ttk.Label(peakTest6ResultFrame, text=&#39;&#39;)

        totalPeakResult = ttk.Label(results_peakInfoFrame, text=&#39;&#39;)

        totalResult = ttk.Label(results_peakInfoFrame, text=&#39;&#39;)

        curveTitleLabel.grid(row=0, sticky=&#39;w&#39;, padx=5, pady=2.5)
        curveTitleLabel.configure(font=(&#34;TkDefaultFont&#34;, 12, &#39;underline&#39;, &#39;bold&#39;))
        curveTest1Label.grid(row=1, sticky=&#39;w&#39;, padx=5, pady=2.5)
        curveTest1ResultFrame.grid(row=2, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        curveTest1ResultFrame.columnconfigure(0, weight=1)
        curveTest1ResultFrame.columnconfigure(1, weight=6)
        curveTest1ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        curveTest1Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        curveTest2Label.grid(row=3, sticky=&#39;w&#39;, padx=5, pady=2.5)
        curveTest2ResultFrame.grid(row=4, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        curveTest2ResultFrame.columnconfigure(0, weight=1)
        curveTest2ResultFrame.columnconfigure(1, weight=6)
        curveTest2ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        curveTest2Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        curveTest3Label.grid(row=5, sticky=&#39;w&#39;, padx=5, pady=2.5)
        curveTest3ResultFrame.grid(row=6, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        curveTest3ResultFrame.columnconfigure(0, weight=1)
        curveTest3ResultFrame.columnconfigure(1, weight=6)
        curveTest3ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        curveTest3Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        totalCurveResult.grid(row=7, sticky=&#39;e&#39;, padx=5, pady=10 )

        ttk.Separator(results_peakInfoFrame).grid(row=8, sticky=&#39;ew&#39;, pady=5)
        
        peakTitleLabel.grid(row=9, sticky=&#39;w&#39;, padx=5, pady=2.5)
        peakTitleLabel.configure(font=(&#34;TkDefaultFont&#34;, 12, &#39;underline&#39;, &#39;bold&#39;))
        
        peakTest1Label.grid(row=11, sticky=&#39;w&#39;, padx=5, pady=2.5)
        peakTest1ResultFrame.grid(row=12, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        peakTest1ResultFrame.columnconfigure(0, weight=1)
        peakTest1ResultFrame.columnconfigure(1, weight=6)
        peakTest1ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        peakTest1Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        peakTest2Label.grid(row=13, sticky=&#39;w&#39;, padx=5, pady=2.5)
        peakTest2ResultFrame.grid(row=14, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        peakTest2ResultFrame.columnconfigure(0, weight=1)
        peakTest2ResultFrame.columnconfigure(1, weight=6)
        peakTest2ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        peakTest2Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        peakTest3Label.grid(row=15, sticky=&#39;w&#39;, padx=5, pady=2.5)
        peakTest3ResultFrame.grid(row=16, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        peakTest3ResultFrame.columnconfigure(0, weight=1)
        peakTest3ResultFrame.columnconfigure(1, weight=6)
        peakTest3ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        peakTest3Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        peakTest4Label.grid(row=17, sticky=&#39;w&#39;, padx=5, pady=2.5)
        peakTest4ResultFrame.grid(row=18, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        peakTest4ResultFrame.columnconfigure(0, weight=1)
        peakTest4ResultFrame.columnconfigure(1, weight=6)
        peakTest4ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        peakTest4Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        peakTest5Label.grid(row=19, sticky=&#39;w&#39;, padx=5, pady=2.5)
        peakTest5ResultFrame.grid(row=20, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        peakTest5ResultFrame.columnconfigure(0, weight=1)
        peakTest5ResultFrame.columnconfigure(1, weight=6)
        peakTest5ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        peakTest5Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        peakTest6Label.grid(row=21, sticky=&#39;w&#39;, padx=5, pady=2.5)
        peakTest6ResultFrame.grid(row=22, sticky=&#39;ew&#39;, padx=5, pady=2.5)
        peakTest6ResultFrame.columnconfigure(0, weight=1)
        peakTest6ResultFrame.columnconfigure(1, weight=6)
        peakTest6ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
        peakTest6Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

        totalPeakResult.grid(row=23, sticky=&#39;e&#39;, padx=5, pady=10 )

        ttk.Separator(results_peakInfoFrame).grid(row=24, sticky=&#39;ew&#39;, pady=5)

        totalResult.grid(row=25, sticky=&#39;e&#39;, padx=5, pady=10 )

        #Export results
        results_export_Frame = ttk.LabelFrame(self.results_tab, text=&#34;Export Results&#34;)
        
        ttk.Label(results_export_Frame, text=&#34;Export Figure&#34;).grid(row=0, column=0, sticky=&#39;ew&#39;, padx=5)
        self.results_fig_dir = tk.StringVar()
        self.results_fig_dir_entry = ttk.Entry(results_export_Frame, textvariable=self.results_fig_dir)
        self.results_fig_dir_entry.grid(row=0, column=1, columnspan=5, sticky=&#39;ew&#39;)
        
        
        def filepath_results_fig():
            filepath = filedialog.asksaveasfilename(defaultextension=&#39;png&#39;, initialdir=pathlib.Path(self.data_path.get()).parent, initialfile=self.params[&#39;site&#39;]+&#39;_results.png&#39;)
            if filepath:
                self.results_fig_dir_entry.delete(0, &#39;end&#39;)
                self.results_fig_dir_entry.insert(0, filepath)
        
        
        def save_results_fig():
            if not self.save_ind_subplots.get():
                self.fig_results.savefig(self.results_fig_dir.get())
            else:
                print(&#39;working on individual subplots&#39;)
                for key in self.ax_results.keys():
                    extent = self.ax_results[key].get_tightbbox(self.fig_results.canvas.renderer).transformed(self.fig_results.dpi_scale_trans.inverted())
                    self.fig_results.savefig(pathlib.Path(self.results_fig_dir.get()).parent.as_posix()+&#39;/Subplot&#39;+key+&#39;.png&#39;,  bbox_inches=extent)
        

        self.browse_results_fig = ttk.Button(results_export_Frame, text=&#34;Browse&#34;,command=filepath_results_fig)
        self.browse_results_fig.grid(row=0, column=7, sticky=&#39;ew&#39;, padx=2.5)
        
        self.save_results_fig = ttk.Button(results_export_Frame, text=&#34;Save&#34;,command=save_results_fig)
        self.save_results_fig.grid(row=0, column=8, columnspan=2, sticky=&#39;ew&#39;, padx=2.5)

        #Save subplots individually
        self.save_ind_subplots = tk.BooleanVar()
        self.save_ind_subplots.set(False)
        ttk.Checkbutton(results_export_Frame, text=&#34;Save ind. subplots&#34;, variable=self.save_ind_subplots).grid(row=0, column=10, sticky=&#34;ew&#34;, padx=5)

        self.browse_results_fig = ttk.Button(results_export_Frame, text=&#34;Update Plot&#34;,command=update_results_plot)
        self.browse_results_fig.grid(row=1, column=10, sticky=&#39;ew&#39;, padx=(7.5, 2.5))


        results_export_Frame.columnconfigure(1, weight=1)
        results_export_Frame.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;)

        #Export Peak Report        
        ttk.Label(results_export_Frame, text=&#34;Export Peak Report&#34;).grid(row=1, column=0, sticky=&#39;ew&#39;, padx=5)
        self.results_report_dir = tk.StringVar()
        self.results_report_dir_entry = ttk.Entry(results_export_Frame, textvariable=self.results_report_dir)
        self.results_report_dir_entry.grid(row=1, column=1, columnspan=5, sticky=&#39;ew&#39;)
        
        
        def filepath_report_fig():
            filepath = filedialog.asksaveasfilename(defaultextension=&#39;csv&#39;, initialdir=pathlib.Path(self.data_path.get()).parent, initialfile=self.params[&#39;site&#39;]+&#39;_peakReport.csv&#39;)
            if filepath:
                self.results_report_dir_entry.delete(0, &#39;end&#39;)
                self.results_report_dir_entry.insert(0, filepath)
        
        
        def save_report_fig():
            sprit_hvsr.get_report(self.hvsr_results, format=&#39;plot&#39;,  export=self.results_report_dir.get())

        self.browse_results_fig = ttk.Button(results_export_Frame, text=&#34;Browse&#34;,command=filepath_report_fig)
        self.browse_results_fig.grid(row=1, column=7, sticky=&#39;ew&#39;, padx=2.5)
        
        self.save_results_fig = ttk.Button(results_export_Frame, text=&#34;Save&#34;,command=save_report_fig)
        self.save_results_fig.grid(row=1, column=8, columnspan=2, sticky=&#39;ew&#39;, padx=2.5)

        results_peakInfoFrame.pack(side=&#39;right&#39;, fill=&#39;both&#39;)
        self.results_chartFrame.pack(side=&#39;top&#39;, expand=True, fill=&#39;both&#39;)
        results_export_Frame.pack(side=&#39;bottom&#39;, fill=&#39;x&#39;)
        
        # Add tabs to tab control
        self.tab_control.add(self.results_tab, text=&#34;Results&#34;)

        # Pack tab control
        self.tab_control.pack(expand=True, fill=&#34;both&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="sprit.sprit_gui.SPRIT_App.create_menubar"><code class="name flex">
<span>def <span class="ident">create_menubar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_menubar(self):
    self.menubar = tk.Menu(self.master)
    self.master.config(menu=self.menubar)
    
    self.sprit_menu = tk.Menu(self.menubar, tearoff=0)

    def on_theme_select():
        # Set the theme based on the selected value
        self.style = ttk.Style()
        
        &#34;&#34;&#34;An attempt to get the backgrounds right
        def apply_to_all_children(widget, func):
            Recursively apply a function to all child widgets of a given widget
            children = widget.winfo_children()
            for child in children:
                func(child)
                apply_to_all_children(child, func)
            return

        def change_background_color(widget):
            if isinstance(widget, tk.Label):
                widget.option_clear()
                widget.configure(background=None, foreground=None)
            return
        
        apply_to_all_children(self.master, change_background_color)
        &#34;&#34;&#34;
        if &#39;forest&#39; in self.theme_var.get():
            if self.theme_var.get()==&#39;forest-dark&#39; and &#39;forest-dark&#39; not in self.style.theme_names():
                self.master.tk.call(&#39;source&#39;, self.darkthemepath)
            elif self.theme_var.get()==&#39;forest-light&#39; and &#39;forest-light&#39; not in self.style.theme_names():
                self.master.tk.call(&#39;source&#39;, self.lightthemepath)            
        self.master.tk.call(&#34;ttk::style&#34;, &#34;theme&#34;, &#34;use&#34;, self.theme_var.get())
        #self.master.tk.call(&#34;ttk::setTheme&#34;, self.theme_var.get())

        #self.style.theme_use(self.theme_var.get())
        #self.master.tk.call(&#39;source&#39;, self.lightthemepath)
        #self.style.theme_use(self.theme_var.get())
        #self.style.configure(&#34;TLabel&#34;, background=self.style.lookup(&#39;TLabel&#39;, &#39;background&#39;), foreground=self.style.lookup(&#39;TLabel&#39;, &#39;background&#39;))

    def import_parameters(self):
        filepath = filedialog.askopenfilename()
    
    
    def export_parameters(self):
        filepath = filedialog.asksaveasfilename()

    self.theme_menu = tk.Menu(self.menubar, tearoff=0)
    self.theme_var = tk.StringVar(value=&#34;Default&#34;)
    self.theme_menu.add_radiobutton(label=&#34;Default&#34;, variable=self.theme_var, value=&#34;default&#34;, command=on_theme_select)
    self.theme_menu.add_radiobutton(label=&#34;Clam&#34;, variable=self.theme_var, value=&#34;clam&#34;, command=on_theme_select)
    self.theme_menu.add_radiobutton(label=&#34;Alt&#34;, variable=self.theme_var, value=&#34;alt&#34;, command=on_theme_select)
    self.theme_menu.add_radiobutton(label=&#34;Forest Light (buggy)&#34;, variable=self.theme_var, value=&#34;forest-light&#34;, command=on_theme_select)
    self.theme_menu.add_radiobutton(label=&#34;Forest Dark (buggy)&#34;, variable=self.theme_var, value=&#34;forest-dark&#34;, command=on_theme_select)

    self.sprit_menu.add_cascade(label=&#34;Theme&#34;, menu=self.theme_menu)
    self.sprit_menu.add_command(label=&#34;Import Parameters&#34;, command=import_parameters)
    self.sprit_menu.add_command(label=&#34;Export Parameters&#34;, command=export_parameters)
    self.sprit_menu.add_separator()
    self.sprit_menu.add_command(label=&#34;Exit&#34;, command=self.master.quit)
    self.settings_menu = tk.Menu(self.menubar, tearoff=0)
    self.instrument_menu = tk.Menu(self.settings_menu, tearoff=0)
    self.instrument_var = tk.StringVar(value=&#34;Raspberry Shake&#34;)
    self.instrument_menu.add_radiobutton(label=&#34;Raspberry Shake&#34;, variable=self.instrument_var, value=&#34;Raspberry Shake&#34;)
    self.instrument_menu.add_radiobutton(label=&#34;Nodes&#34;, variable=self.instrument_var, value=&#34;Nodes&#34;)
    self.instrument_menu.add_radiobutton(label=&#34;Other&#34;, variable=self.instrument_var, value=&#34;Other&#34;)
    self.settings_menu.add_cascade(label=&#34;Instrument&#34;, menu=self.instrument_menu)
    self.settings_menu.add_command(label=&#34;Processing Settings&#34;, command=lambda: self.tab_control.select(self.settings_tab))

    self.menubar.add_cascade(label=&#34;SPRIT&#34;, menu=self.sprit_menu)
    self.menubar.add_cascade(label=&#34;Settings&#34;, menu=self.settings_menu)</code></pre>
</details>
</dd>
<dt id="sprit.sprit_gui.SPRIT_App.create_tabs"><code class="name flex">
<span>def <span class="ident">create_tabs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_tabs(self):
    self.style = ttk.Style(self.master)

    self.tab_control = ttk.Notebook(self.master)

    # INPUT TAB
    self.input_tab = ttk.Frame(self.tab_control)

    # Configure the row and column of the input_tab to have a non-zero weight
    hvsrFrame = ttk.LabelFrame(self.input_tab, text=&#34;Input Parameters&#34;)
    #hvsrFrame.rowconfigure(0, weight=1)
    hvsrFrame.columnconfigure(1, weight=1)

    # Logo and Site Name
    # Replace &#34;logo.png&#34; with the path to your logo image
    #self.logo = tk.PhotoImage(file=&#34;logo.png&#34;)
    #self.logo_label = ttk.Label(hvsrFrame, image=self.logo)
    #self.logo_label.grid(row=0, column=0)
    self.processingData = False

    
    def update_input_labels(hvsr_data):
        #Update labels for data preview tab
        self.input_data_label.configure(text=self.data_filepath_entry.get() + &#39;\n&#39; + str(hvsr_data[&#39;stream&#39;]))
        
        self.obspySreamLabel_settings.configure(text=str(hvsr_data[&#39;stream&#39;]))

        self.sensitivityLabelZ_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;Z&#39;][&#39;sensitivity&#39;])
        self.gainLabelZ_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;Z&#39;][&#39;gain&#39;])
        self.polesLabelZ_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;Z&#39;][&#39;poles&#39;])
        self.zerosLabelZ_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;Z&#39;][&#39;zeros&#39;])
        
        self.sensitivityLabelN_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;N&#39;][&#39;sensitivity&#39;])
        self.gainLabelN_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;N&#39;][&#39;gain&#39;])
        self.polesLabelN_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;N&#39;][&#39;poles&#39;])
        self.zerosLabelN_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;N&#39;][&#39;zeros&#39;])

        self.sensitivityLabelE_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;E&#39;][&#39;sensitivity&#39;])
        self.gainLabelE_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;E&#39;][&#39;gain&#39;])
        self.polesLabelE_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;E&#39;][&#39;poles&#39;])
        self.zerosLabelE_settings.configure(text=hvsr_data[&#39;paz&#39;][&#39;E&#39;][&#39;zeros&#39;])
        return
    
    #FUNCTION TO READ DATA
    @catch_errors
    def read_data():
        self.starttime, self.endtime = get_times()


        if self.file_source.get() == &#39;batch&#39;:
            if isinstance(self.fpath, str):
                pass
            elif len(self.fpath) &gt; 1:
                self.fpath = list(self.fpath)
                batchType = &#39;filelist&#39;
            else:
                self.fpath = self.fpath[0]
                batchType = &#39;table&#39;

            self.params = sprit_hvsr.batch_data_read(input_data=self.fpath, batch_type=batchType)
            self.hvsr_data = self.params
            firstSite = self.hvsr_data[list(self.hvsr_data.keys())[0]]
            update_input_labels(firstSite)

            #Plot data in data preview tab
            self.fig_pre, self.ax_pre = sprit_hvsr.plot_stream(stream=firstSite[&#39;stream&#39;], params=firstSite, fig=self.fig_pre, axes=self.ax_pre, return_fig=True)

            #Plot data in noise preview tab
            self.fig_noise, self.ax_noise = sprit_hvsr._plot_specgram_stream(stream=firstSite[&#39;stream&#39;], params=firstSite, fig=self.fig_noise, ax=self.ax_noise, fill_gaps=0, component=&#39;Z&#39;, stack_type=&#39;linear&#39;, detrend=&#39;mean&#39;, dbscale=True, return_fig=True, cmap_per=[0.1,0.9])
            select_windows(event=None, initialize=True)
            plot_noise_windows(firstSite)

        else:
            if isinstance(self.fpath, str):
                pass
            elif len(self.fpath) &gt; 1:
                self.fpath = list(self.fpath)
            else:
                self.fpath = self.fpath[0]

            self.params = sprit_hvsr.input_params( datapath=self.fpath,
                                metapath = self.meta_path.get(),
                                site=self.site_name.get(),
                                network=self.network.get(), 
                                station=self.station.get(), 
                                loc=self.location.get(), 
                                channels=[self.z_channel.get(), self.n_channel.get(), self.e_channel.get()],
                                acq_date = self.starttime.date(),
                                starttime = self.starttime,
                                endtime = self.endtime,
                                tzone = &#39;UTC&#39;, #Will always be converted to UTC before we get to this point when using gui
                                xcoord = self.x.get(),
                                ycoord =  self.y.get(),
                                elevation = self.z.get(),
                                input_crs= self.input_crs.get(),
                                output_crs= self.output_crs.get(),
                                elev_unit= self.elev_unit.get(),
                                instrument = self.instrumentSel.get(),
                                hvsr_band = [self.hvsrBand_min.get(), self.hvsrBand_max.get()] )

            if self.trim_dir.get()==&#39;&#39;:
                trimDir=None
            else:
                trimDir=self.trim_dir.get()

            self.hvsr_data = sprit_hvsr.fetch_data(params=self.params,
                                        source=self.file_source.get(), 
                                        trim_dir=trimDir, 
                                        export_format=self.export_format.get(), 
                                        detrend=self.detrend.get(), 
                                        detrend_order=self.detrend_order.get())
            
            update_input_labels(self.hvsr_data)


            #Plot data in data preview tab
            self.fig_pre, self.ax_pre = sprit_hvsr.plot_stream(stream=self.hvsr_data[&#39;stream&#39;], params=self.hvsr_data, fig=self.fig_pre, axes=self.ax_pre, return_fig=True)

            #Plot data in noise preview tab
            self.fig_noise, self.ax_noise = sprit_hvsr._plot_specgram_stream(stream=self.hvsr_data[&#39;stream&#39;], params=self.hvsr_data, fig=self.fig_noise, ax=self.ax_noise, fill_gaps=0, component=&#39;Z&#39;, stack_type=&#39;linear&#39;, detrend=&#39;mean&#39;, dbscale=True, return_fig=True, cmap_per=[0.1,0.9])
            select_windows(event=None, initialize=True)
            plot_noise_windows(self.hvsr_data)

        self.data_read = True
        if not self.processingData:
            self.tab_control.select(self.preview_data_tab)

    #FUNCTION TO PROCESS DATA
    @catch_errors
    def process_data():
        self.processingData = True #Set to true while data processing algorithm is being run
        
        if self.data_read == False:
            read_data()
        
        self.hvsr_data = plot_noise_windows(self.hvsr_data)

        self.hvsr_data = sprit_hvsr.generate_ppsds(params=self.hvsr_data, 
                                           ppsd_length=self.ppsd_length.get(), 
                                           overlap=self.overlap.get(), 
                                           period_step_octaves=self.perStepOct.get(), 
                                           remove_outliers=self.remove_outliers.get(), 
                                           outlier_std=self.outlier_std.get(),
                                           skip_on_gaps=self.skip_on_gaps.get(),
                                           db_bins=self.db_bins,
                                           period_limits=self.period_limits,
                                           period_smoothing_width_octaves=self.perSmoothWidthOct.get(),
                                           special_handling=special_handling
                                           )
        
        self.hvsr_results = sprit_hvsr.process_hvsr(params=self.hvsr_data, 
                                               method=self.method_ind,
                                               smooth=self.hvsmooth_param,
                                               freq_smooth=self.freq_smooth.get(),
                                               f_smooth_width=self.fSmoothWidth.get(), 
                                               resample=self.hvresample_int, 
                                               remove_outlier_curves=self.outlierRembool.get(), 
                                               outlier_curve_std=self.outlierRemStDev.get())
        
        self.hvsr_results = sprit_hvsr.check_peaks(hvsr_data=self.hvsr_results, 
                                              hvsr_band = [self.hvsrBand_min.get(), self.hvsrBand_max.get()],
                                              peak_water_level=self.peak_water_level)

        curveTest1ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Lw&#39;][:-1])
        curveTest1Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Lw&#39;][-1])

        curveTest2ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Nc&#39;][:-1])
        curveTest2Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Nc&#39;][-1])

        curveTest3ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;σ_A(f)&#39;][:-1])
        curveTest3Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;σ_A(f)&#39;][-1])

        curvePass = (self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Window Length Freq.&#39;] +
                            self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Significant Cycles&#39;]+
                            self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Low Curve StDev. over time&#39;]) &gt; 2
        if curvePass:
            totalCurveResult.configure(text=sprit_utils.check_mark(), font=(&#34;TkDefaultFont&#34;, 16, &#34;bold&#34;), foreground=&#39;green&#39;)
        else:
            totalCurveResult.configure(text=sprit_utils.x_mark(), font=(&#34;TkDefaultFont&#34;, 16, &#34;bold&#34;), foreground=&#39;red&#39;)

        peakTest1ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;A(f-)&#39;][:-1])
        peakTest1Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;A(f-)&#39;][-1])
        
        peakTest2ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;A(f+)&#39;][:-1])
        peakTest2Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;A(f+)&#39;][-1])
        
        peakTest3ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;A0&#39;][:-1])
        peakTest3Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;A0&#39;][-1])

        peakTest4ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;P-&#39;][:5] + &#39; and &#39; +self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;P+&#39;][:-1])
        if self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Freq. Stability&#39;]:
            peakTest4Result.configure(text=&#39;✔&#39;)
        else:
            peakTest4Result.configure(text=&#39;✘&#39;)

        peakTest5ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Sf&#39;][:-1])
        peakTest5Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Sf&#39;][-1])
        
        peakTest6ResultText.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Sa&#39;][:-1])
        peakTest6Result.configure(text=self.hvsr_results[&#39;Best Peak&#39;][&#39;Report&#39;][&#39;Sa&#39;][-1])

        peakPass = (self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Peak Freq. Clarity Below&#39;] +
                self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Peak Freq. Clarity Above&#39;]+
                self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Peak Amp. Clarity&#39;]+
                self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Freq. Stability&#39;]+
                self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Peak Stability (freq. std)&#39;]+
                self.hvsr_results[&#39;Best Peak&#39;][&#39;Pass List&#39;][&#39;Peak Stability (amp. std)&#39;]) &gt;= 5
        if peakPass:
            totalPeakResult.configure(text=&#39;✔&#39;, font=(&#34;TkDefaultFont&#34;, 16, &#34;bold&#34;), foreground=&#39;green&#39;)
        else:
            totalPeakResult.configure(text=&#39;✘&#39;, font=(&#34;TkDefaultFont&#34;, 16, &#34;bold&#34;), foreground=&#39;red&#39;)

        if curvePass and peakPass:
            totalResult.configure(text=&#39;Pass ✔&#39;, font=(&#34;TkDefaultFont&#34;, 22, &#34;bold&#34;), foreground=&#39;green&#39;)
        else:
            totalResult.configure(text=&#39;Fail ✘&#39;, font=(&#34;TkDefaultFont&#34;, 22, &#34;bold&#34;), foreground=&#39;red&#39;)

        sprit_hvsr.hvplot(self.hvsr_results, plot_type=get_kindstr(), fig=self.fig_results, ax=self.ax_results, use_subplots=True, clear_fig=False)

        self.processingData = False
        self.tab_control.select(self.results_tab)

    
    def update_input_params_call():
        self.input_params_call.configure(text=&#34;input_params( datapath=&#39;{}&#39;, metapath={}, site=&#39;{}&#39;, instrument=&#39;{}&#39;,\n\tnetwork=&#39;{}&#39;, station=&#39;{}&#39;, loc=&#39;{}&#39;, channels=[{}, {}, {}], \n\tacq_date=&#39;{}&#39;, starttime=&#39;{}&#39;, endttime=&#39;{}&#39;, tzone=&#39;{}&#39;, \n\txcoord={}, ycoord={}, elevation={}, input_crs=&#39;{}&#39;, output_crs=&#39;{}&#39;, elev_unit=&#39;{}&#39;,  hvsr_band=[{}, {}])&#34;.format(
                                        self.data_path.get(), self.meta_path.get(), self.site_name.get(), self.instrumentSel.get(),
                                        self.network.get(), self.station.get(), self.location.get(),
                                        self.z_channel.get(), self.e_channel.get(), self.n_channel.get(),
                                        self.acq_date, self.starttime.time(), self.endtime.time(), self.tz,
                                        self.x.get(), self.y.get(), self.z.get(), 
                                        self.input_crs.get(), self.output_crs.get(), self.elev_unit.get(), 
                                        self.hvsrBand_min.get(), self.hvsrBand_max.get()))
    #Specify site name        
    siteLabel = ttk.Label(hvsrFrame, text=&#34;Site Name&#34;)
    siteLabel.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5)
    self.site_name = tk.StringVar()
    self.site_name.set(&#39;HVSR Site&#39;)
    self.site_name_entry = ttk.Entry(hvsrFrame, textvariable=self.site_name, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
    self.site_name_entry.grid(row=0, column=1, columnspan=1, sticky=&#39;ew&#39;, padx=5)

    # source=file
    
    def on_source_select():
        try:
            str(self.file_source.get())
            sourceLabel.configure(text=&#34;source=&#39;{}&#39;&#34;.format(self.file_source.get()))
            update_fetch_call()

            if self.file_source.get() == &#39;raw&#39; or self.file_source.get() == &#39;dir&#39;:
                self.browse_data_filepath_button.configure(text=&#39;Browse Folder&#39;)
                self.batch_options_frame.grid_forget()
            elif self.file_source.get() == &#39;batch&#39;:
                self.batch_options_frame.grid(row=11, column=0, columnspan=7, sticky=&#39;ew&#39;)
            else:
                self.browse_data_filepath_button.configure(text=&#39;Browse File(s)&#39;)
                self.batch_options_frame.grid_forget()
            return True
        except ValueError:
            return False

    sourceLabel = ttk.Label(master=hvsrFrame, text=&#34;source=&#39;file&#39;&#34;)

    ttk.Label(master=hvsrFrame, text=&#39;Data Source Type [str]&#39;).grid(row=0, column=3, sticky=&#39;e&#39;, padx=5)
    sourcFrame= ttk.Frame(hvsrFrame)
    sourcFrame.grid(row=0, column=4, sticky=&#39;w&#39;, columnspan=3)
    self.file_source = tk.StringVar()
    self.file_source.set(&#39;file&#39;)
    ttk.Radiobutton(master=sourcFrame, text=&#39;File&#39;, variable=self.file_source, value=&#39;file&#39;, command=on_source_select).grid(row=0, column=0, sticky=&#39;w&#39;, padx=(5, 10))
    ttk.Radiobutton(master=sourcFrame, text=&#39;Raw&#39;, variable=self.file_source, value=&#39;raw&#39;, command=on_source_select).grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))
    ttk.Radiobutton(master=sourcFrame, text=&#39;Batch&#39;, variable=self.file_source, value=&#39;batch&#39;, command=on_source_select).grid(row=0, column=2, sticky=&#39;w&#39;, padx=(5, 10))
    ttk.Radiobutton(master=sourcFrame, text=&#39;Directory&#39;, variable=self.file_source, value=&#39;dir&#39;, command=on_source_select).grid(row=0, column=3, sticky=&#39;w&#39;, padx=(5, 10))

    #Instrument select
    ttk.Label(hvsrFrame, text=&#34;Instrument&#34;).grid(row=0, column=6, sticky=&#39;e&#39;, padx=5)
    inst_options = [&#34;Raspberry Shake&#34;, &#34;Nodes&#34;, &#34;Other&#34;]

    
    def on_option_select(self, inst):
        update_input_params_call()
        if inst == &#34;Raspberry Shake&#34;:
            self.network_entry.configure(state=&#39;normal&#39;)
            self.station_entry.configure(state=&#39;normal&#39;)
            self.location_entry.configure(state=&#39;normal&#39;)
            
            self.z_channel_entry.delete(0, &#39;end&#39;)
            self.e_channel_entry.delete(0, &#39;end&#39;)
            self.n_channel_entry.delete(0, &#39;end&#39;)
            
            self.z_channel_entry.insert(0,&#34;EHZ&#34;)
            self.e_channel_entry.insert(0,&#34;EHE&#34;)
            self.n_channel_entry.insert(0,&#34;EHN&#34;)

            self.network_entry.delete(0, &#39;end&#39;)
            self.network_entry.insert(0,&#34;AM&#34;)

            self.station_entry.delete(0, &#39;end&#39;)
            self.station_entry.insert(0,&#34;RAC84&#34;)

            self.location_entry.delete(0, &#39;end&#39;)
            self.location_entry.insert(0,&#34;00&#34;)
        else:
            self.network_entry.configure(state=&#39;disabled&#39;)
            self.station_entry.configure(state=&#39;disabled&#39;)
            self.location_entry.configure(state=&#39;disabled&#39;)

    self.instrumentSel = tk.StringVar(value=inst_options[0])
    self.instrument_dropdown = ttk.OptionMenu(hvsrFrame, self.instrumentSel, inst_options[0], *inst_options, command=on_option_select)
    self.instrument_dropdown.config(width=20)
    self.instrument_dropdown.grid(row=0, column=7, columnspan=1, sticky=&#39;ew&#39;)

    # Data Filepath
    dataLabel= ttk.Label(hvsrFrame, text=&#34;Data Filepath&#34;)
    dataLabel.grid(row=1, column=0, sticky=&#39;e&#39;, padx=5, pady=(5,2.55))

    #Function to set self.data_read False whenever the data_path is updated
    
    def on_data_path_change(data_path, index, trace_mode):
        #If our data path changes, data is registered as not having been read
        #This is primarily so that if just the Run button is pushed, it will know to first read the data
        self.data_read = False
    
    
    def filepath_update():
        self.fpath = self.data_path.get()
        self.data_read = False
        update_input_params_call()

    self.data_path = tk.StringVar()
    self.data_path.trace(&#39;w&#39;, on_data_path_change)
    self.data_filepath_entry = ttk.Entry(hvsrFrame, textvariable=self.data_path, validate=&#39;focusout&#39;, validatecommand=filepath_update)
    self.data_filepath_entry.grid(row=1, column=1, columnspan=6, sticky=&#39;ew&#39;, padx=5, pady=(5,2.55))

    
    def browse_data_filepath():
        if self.file_source.get() == &#39;raw&#39; or self.file_source.get() == &#39;dir&#39;:
            self.fpath = filedialog.askdirectory()
            if self.fpath:
                self.data_filepath_entry.delete(0, &#39;end&#39;)
                self.data_filepath_entry.insert(0, self.fpath)
        else:
            self.fpath = filedialog.askopenfilenames()
            
            #fpath will always be tuple
            self.no_data_files = len(self.fpath)
                
            if self.fpath:
                self.data_filepath_entry.delete(0, &#39;end&#39;)
                for f in self.fpath:
                    self.data_filepath_entry.insert(&#39;end&#39;, self.fpath)
            
        update_input_params_call()


    buttonFrame = ttk.Frame(hvsrFrame)
    buttonFrame.grid(row=1, column=7, sticky=&#39;ew&#39;)

    self.browse_data_filepath_button = ttk.Button(buttonFrame, text=&#34;Browse File(s)&#34;, command=browse_data_filepath)

    #self.browse_data_filepath_button.grid(row=1, column=6, sticky=&#39;ew&#39;)
    self.browse_data_filepath_button.pack(side=&#34;left&#34;, fill=&#34;x&#34;, expand=True, padx=(0,2), pady=(5,2.55))

    # Metadata Filepath
    ttk.Label(hvsrFrame, text=&#34;Metadata Filepath&#34;).grid(row=2, column=0, sticky=&#39;e&#39;, padx=5, pady=(2.5,5))
    self.meta_path = tk.StringVar()
    self.metadata_filepath_entry = ttk.Entry(hvsrFrame, textvariable=self.meta_path, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
    self.metadata_filepath_entry.grid(row=2, column=1, columnspan=6, sticky=&#39;ew&#39;, padx=5, pady=(2.5,5))
    
    
    def browse_metadata_filepath():
        filepath = filedialog.askopenfilename()
        if filepath:
            self.metadata_filepath_entry.delete(0, &#39;end&#39;)
            self.metadata_filepath_entry.insert(0, filepath)
        update_input_params_call()

    self.browse_metadata_filepath_button = ttk.Button(hvsrFrame, text=&#34;Browse&#34;, command=browse_metadata_filepath)
    self.browse_metadata_filepath_button.grid(row=2, column=7, sticky=&#39;ew&#39;, padx=0, pady=(2.5,5))

    
    def update_acq_date(event):
        aMonth = self.acq_month.get()
        if str(aMonth)[0]==&#39;0&#39;:
            aMonth = str(aMonth)[-1]

        aDay = self.acq_day.get()
        if str(aDay)[0]==&#39;0&#39;:
            aDay = str(aDay)[-1]

        self.acq_date = datetime.date(year=self.acq_year.get(), month=aMonth, day=aDay)#self.date_entry.get_date()
        self.day_of_year = self.acq_date.timetuple().tm_yday
        self.doy_label.configure(text=str(self.day_of_year))
        update_input_params_call()

    # Date and Time
    dateFrame = ttk.Frame(hvsrFrame)
    dateFrame.grid(row=3, column=1, columnspan=2, sticky=&#39;e&#39;, padx=5)
    ttk.Label(dateFrame, text=&#34;Date&#34;).grid(row=1, column=1, sticky=&#39;e&#39;, padx=5)

    self.acq_year = tk.IntVar()
    self.acq_year.set(int(datetime.datetime.today().year))
    self.acq_year_entry = ttk.Spinbox(dateFrame, from_=0, to=10000, width=7, textvariable=self.acq_year, validate=&#39;focusout&#39;, validatecommand=update_acq_date) 
    self.acq_year_entry.grid(row=1, column=2, sticky=&#39;ew&#39;, padx=1)

    self.acq_month = tk.IntVar()
    self.acq_month.set(int(datetime.datetime.today().month))
    self.acq_month_entry = ttk.Spinbox(dateFrame, from_=0, to=12, width=3, textvariable=self.acq_month, validate=&#39;focusout&#39;, validatecommand=update_acq_date) 
    self.acq_month_entry.grid(row=1, column=3, sticky=&#39;ew&#39;, padx=1)

    self.acq_day = tk.IntVar()
    self.acq_day.set(int(datetime.datetime.today().day))
    self.acq_day_entry = ttk.Spinbox(dateFrame, from_=0, to=31, width=3, textvariable=self.acq_day, validate=&#39;focusout&#39;, validatecommand=update_acq_date) 
    self.acq_day_entry.grid(row=1, column=4, sticky=&#39;ew&#39;, padx=1)

    self.acq_date = datetime.date.today()
    #self.date_entry = DateEntry(hvsrFrame, date_pattern=&#39;y-mm-dd&#39;, textvariable=self.acq_date, validate=&#39;focusout&#39;)#update_input_params_call)
    #self.date_entry.grid(row=3, column=2, sticky=&#39;w&#39;, padx=5)
    #self.date_entry.bind(&#34;&lt;&lt;DateEntrySelected&gt;&gt;&#34;, update_acq_date)
    
    sTimeFrame = ttk.Frame(hvsrFrame)
    sTimeFrame.grid(row=3, column=4, sticky=&#39;ew&#39;)

    def get_times():
        #Format starttime as datetime object (in timezone as originally entered)
        self.acq_date = datetime.date(year=self.acq_year.get(), month=self.acq_month.get(), day=self.acq_day.get())#self.date_entry.get_date()

        sHour = self.start_hour.get()
        if str(sHour)[0] == &#39;0&#39;:
            sHour = int(str(sHour)[-1])

        sMin = self.start_minute.get()
        if str(sMin)[0] == &#39;0&#39;:
            sMin = int(str(sMin)[-1])

        self.starttime = datetime.datetime(year = self.acq_date.year, 
                                      month = self.acq_date.month,
                                      day = self.acq_date.day,
                                      hour = sHour,
                                      minute = sMin,
                                      tzinfo=self.tz)
        
        #Get duration, as originally entered
        hour_dur = self.end_hour.get() - self.start_hour.get()
        if hour_dur &lt; 0:
            hour_dur = self.end_hour.get() + 24 - self.start_hour.get()
        min_dur = self.end_minute.get() - self.start_minute.get()

        #Convert starttime to utc
        #self.starttime = self.tz.normalize(self.tz.localize(self.starttime)).astimezone(pytz.utc)
        self.starttime  = self.starttime.astimezone(datetime.timezone.utc)

        #Get endttime based on utc starttime and original duration
        self.endtime = self.starttime + datetime.timedelta(hours=hour_dur, minutes=min_dur)

        return self.starttime, self.endtime

    self.tz = datetime.timezone.utc

    
    def any_time_change():
        self.acq_date = self.date_entry.get_date()
        self.starttime, self.endtime = get_times()
        update_input_params_call()

    ttk.Label(hvsrFrame, text=&#34;Start Time&#34;).grid(row=3, column=3, sticky=&#39;e&#39;, padx=5) 
    colonLabel= ttk.Label(sTimeFrame, text=&#34;:&#34;)#.grid(row=3, column=4, padx=(20,0), sticky=&#39;w&#39;)
    self.start_hour = tk.IntVar()
    self.start_hour.set(00)
    self.start_time_hour_entry = ttk.Spinbox(sTimeFrame, from_=0, to=23, width=5, textvariable=self.start_hour, validate=&#39;focusout&#39;, validatecommand=any_time_change) 
    self.start_time_hour_entry#.grid(row=3, column=4, sticky=&#39;w&#39;) 
    self.start_minute = tk.DoubleVar()
    self.start_minute.set(00)
    self.start_time_min_entry = ttk.Spinbox(sTimeFrame, from_=0, to=59, width=5, textvariable=self.start_minute, validate=&#39;focusout&#39;, validatecommand=any_time_change)
    self.start_time_min_entry#.grid(row=3, column=4, padx=80, sticky=&#39;w&#39;) 
    
    #sTLabel.pack(side=&#34;left&#34;, fill=&#34;x&#34;, expand=True)
    self.start_time_hour_entry.pack(side=&#39;left&#39;, expand=True)
    colonLabel.pack(side=&#34;left&#34;, fill=&#34;x&#34;)
    self.start_time_min_entry.pack(side=&#39;right&#39;, expand=True)
    
    eTimeFrame = ttk.Frame(hvsrFrame)
    eTimeFrame.grid(row=3, column=6, sticky=&#39;ew&#39;)
    ttk.Label(hvsrFrame, text=&#34;End Time&#34;).grid(row=3, column=5, sticky=&#39;e&#39;, padx=5) 
    colonLabel = ttk.Label(eTimeFrame, text=&#34;:&#34;)#.grid(row=3, column=6, padx=(20,0), sticky=&#39;w&#39;)  
    self.end_hour = tk.IntVar()
    self.end_hour.set(23)
    self.end_time_hour_entry = ttk.Spinbox(eTimeFrame, from_=0, to=23, width=5, textvariable=self.end_hour, validate=&#39;focusout&#39;, validatecommand=any_time_change) 
    self.end_time_hour_entry#.grid(row=3, column=+, sticky=&#39;w&#39;) 
    self.end_minute = tk.DoubleVar()
    self.end_minute.set(59)
    self.end_time_min_entry = ttk.Spinbox(eTimeFrame, from_=0, to=59, width=5, textvariable=self.end_minute, validate=&#39;focusout&#39;, validatecommand=any_time_change)
    self.end_time_min_entry#.grid(row=3, column=+, padx=80, sticky=&#39;w&#39;) 

    #eTLabel.pack(side=&#34;left&#34;, fill=&#34;x&#34;, expand=True)
    self.end_time_hour_entry.pack(side=&#39;left&#39;, expand=True)
    colonLabel.pack(side=&#34;left&#34;, fill=&#34;x&#34;)
    self.end_time_min_entry.pack(side=&#39;right&#39;, expand=True)

    self.acq_date = datetime.date(year=self.acq_year.get(), month=self.acq_month.get(), day=self.acq_day.get())#self.date_entry.get_date()
    self.starttime, self.endtime = get_times()

    
    def onTimezoneSelect(event):
        #Listbox &#34;loses&#34; selection and triggers an event sometimes, so need to check if that is just what happened
        if self.timezone_listbox.curselection():
            #If it was an actual selection, update timezone
            self.tz = zoneinfo.ZoneInfo(self.timezone_listbox.get(self.timezone_listbox.curselection()))
        else:
            #If it was just the listbox losing the selection, don&#39;t change anything
            pass
        update_input_params_call()

    self.timezone_listbox = tk.Listbox(hvsrFrame, selectmode=&#39;browse&#39;, height=25)

    self.timezone_listbox.insert(&#39;end&#39;, &#39;UTC&#39;)
    self.timezone_listbox.insert(&#39;end&#39;, &#39;US/Central&#39;)

    for tz in zoneinfo.available_timezones():# pytz.all_timezones:
        if tz !=&#39;UTC&#39;:
            self.timezone_listbox.insert(&#39;end&#39;, tz)
    self.timezone_listbox.selection_set(0)
    self.timezone_listbox.bind(&#39;&lt;&lt;ListboxSelect&gt;&gt;&#39;, onTimezoneSelect)

    ttk.Label(hvsrFrame,text=&#34;Timezone&#34;).grid(row=3,column=7, sticky=&#39;w&#39;, padx=5)
    self.timezone_listbox.grid(row=4,column=7, rowspan=26, sticky=&#39;nsew&#39;, padx=5)

    #ttk.Label(hvsrFrame, text=&#34;Timezone&#34;).grid(row=3, column=7)
    #self.timezone_var = tk.StringVar(value=&#34;UTC&#34;)
    #self.timezone_listbox = ttk.OptionMenu(hvsrFrame, self.timezone_var, &#34;UTC&#34;, *pytz.all_timezones)
    #self.timezone_listbox.grid(row=3,column=7)

    # DOY
    self.day_of_year = self.acq_date.timetuple().tm_yday
    
    ttk.Label(hvsrFrame,text=&#34;Day of Year:&#34;).grid(row=4,column=1, sticky=&#39;e&#39;, padx=5, pady=10)
    self.doy_label = ttk.Label(hvsrFrame,text=str(self.day_of_year))
    self.doy_label.grid(row=4, column=2, sticky=&#39;w&#39;)

    # UTC Time Output
    ttk.Label(hvsrFrame,text=&#34;UTC Time:&#34;).grid(row=4, column=3, sticky=&#39;e&#39;, padx=5, pady=10)
    self.utc_time_output_label = ttk.Label(hvsrFrame,text=&#34;&#34;)
    self.utc_time_output_label.grid(row=4,column=4)

    #Initialize as UTC
    self.tz = datetime.timezone.utc
    #self.tz = pytz.timezone(self.timezone_listbox.get(self.timezone_listbox.curselection()))
    #input_params() call

    self.starttime, self.endtime = get_times()

    # X Y Z CRS Depth
    ttk.Label(hvsrFrame,text=&#34;X&#34;).grid(row=5,column=1, sticky=&#39;e&#39;, padx=5, pady=10)
    self.x = tk.DoubleVar()
    self.x.set(0)
    self.x_entry = ttk.Entry(hvsrFrame, textvariable=self.x, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
    self.x_entry.grid(row=5,column=2, sticky=&#39;w&#39;, padx=0)

    ttk.Label(hvsrFrame,text=&#34;Y&#34;).grid(row=5,column=3, sticky=&#39;e&#39;, padx=5, pady=10)
    self.y = tk.DoubleVar()
    self.y.set(0)
    self.y_entry = ttk.Entry(hvsrFrame, textvariable=self.y, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
    self.y_entry.grid(row=5, column=4, sticky=&#39;w&#39;, padx=0)

    ttk.Label(hvsrFrame,text=&#34;Z&#34;).grid(row=5,column=5, sticky=&#39;e&#39;, padx=5, pady=10)
    self.z = tk.DoubleVar()
    self.z.set(0)
    self.z_entry = ttk.Entry(hvsrFrame, textvariable=self.z, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
    self.z_entry.grid(row=5,column=6, sticky=&#39;w&#39;, padx=0)

    ttk.Label(hvsrFrame,text=&#34;Input CRS&#34;).grid(row=6,column=1, sticky=&#39;e&#39;, padx=5, pady=10)
    self.input_crs = tk.StringVar()
    self.input_crs.set(&#39;EPSG:4236&#39;)
    self.input_crs_entry = ttk.Entry(hvsrFrame, textvariable=self.input_crs, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
    self.input_crs_entry.grid(row=6,column=2, sticky=&#39;w&#39;, padx=0)

    ttk.Label(hvsrFrame,text=&#34;Output CRS&#34;).grid(row=6,column=3, sticky=&#39;e&#39;, padx=5, pady=10)
    self.output_crs = tk.StringVar()
    self.output_crs.set(&#39;EPSG:4236&#39;)
    self.output_crs_entry = ttk.Entry(hvsrFrame, textvariable=self.output_crs, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
    self.output_crs_entry.grid(row=6, column=4, sticky=&#39;w&#39;, padx=0)

    ttk.Label(master=hvsrFrame, text=&#39;Elevation Unit&#39;).grid(row=6, column=5, sticky=&#39;e&#39;, padx=5, pady=10)
    elevUnitFrame= ttk.Frame(hvsrFrame)
    elevUnitFrame.grid(row=6, column=6, sticky=&#39;w&#39;, columnspan=3)
    self.elev_unit = tk.StringVar()
    self.elev_unit.set(&#39;meters&#39;)
    ttk.Radiobutton(master=elevUnitFrame, text=&#39;Meters&#39;, variable=self.elev_unit, value=&#39;meters&#39;, command=update_input_params_call).grid(row=0, column=0, sticky=&#39;w&#39;, padx=(5, 10))
    ttk.Radiobutton(master=elevUnitFrame, text=&#39;Feet&#39;, variable=self.elev_unit, value=&#39;feet&#39;, command=update_input_params_call).grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))

    # Network Station Location
    ttk.Label(hvsrFrame,text=&#34;Network&#34;).grid(row=7,column=1, sticky=&#39;e&#39;, padx=5, pady=10)
    self.network = tk.StringVar()
    self.network.set(&#39;AM&#39;)
    self.network_entry = ttk.Entry(hvsrFrame, textvariable=self.network, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
    self.network_entry.grid(row=7,column=2, sticky=&#39;w&#39;, padx=0)

    ttk.Label(hvsrFrame,text=&#34;Station&#34;).grid(row=7,column=3, sticky=&#39;e&#39;, padx=5, pady=10)
    self.station = tk.StringVar()
    self.station.set(&#39;RAC84&#39;)
    self.station_entry = ttk.Entry(hvsrFrame, textvariable=self.station, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
    self.station_entry.grid(row=7,column=4, sticky=&#39;w&#39;, padx=0)

    ttk.Label(hvsrFrame,text=&#34;Location&#34;).grid(row=7,column=5, sticky=&#39;e&#39;, padx=5, pady=10)
    self.location = tk.StringVar()
    self.location.set(&#39;00&#39;)
    self.location_entry = ttk.Entry(hvsrFrame, textvariable=self.location, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
    self.location_entry.grid(row=7,column=6, sticky=&#39;w&#39;, padx=0)

    # Z N E Channels
    ttk.Label(hvsrFrame,text=&#34;Z Channel&#34;).grid(row=8,column=1, sticky=&#39;e&#39;, padx=5, pady=10)
    self.z_channel = tk.StringVar()
    self.z_channel.set(&#39;EHZ&#39;)
    self.z_channel_entry = ttk.Entry(hvsrFrame, textvariable=self.z_channel, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
    self.z_channel_entry.grid(row=8,column=2, sticky=&#39;w&#39;, padx=0)

    ttk.Label(hvsrFrame,text=&#34;N Channel&#34;).grid(row=8,column=3, sticky=&#39;e&#39;, padx=5, pady=10)
    self.n_channel = tk.StringVar()
    self.n_channel.set(&#39;EHN&#39;)
    self.n_channel_entry = ttk.Entry(hvsrFrame, textvariable=self.n_channel, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
    self.n_channel_entry.grid(row=8,column=4, sticky=&#39;w&#39;, padx=0)

    ttk.Label(hvsrFrame,text=&#34;E Channel&#34;).grid(row=8,column=5, sticky=&#39;e&#39;, padx=5, pady=10)
    self.e_channel = tk.StringVar()
    self.e_channel.set(&#39;EHE&#39;)
    self.e_channel_entry = ttk.Entry(hvsrFrame, textvariable=self.e_channel, validate=&#39;focusout&#39;, validatecommand=update_input_params_call)
    self.e_channel_entry.grid(row=8,column=6, sticky=&#39;w&#39;, padx=0)

    # HVSR Band
    def on_hvsrband_update():
        try:
            float(self.hvsrBand_min.get())
            float(self.hvsrBand_max.get())

            hvsrBandLabel.configure(text=&#39;hvsr_band=[{}, {}]&#39;.format(self.hvsrBand_min.get(), self.hvsrBand_max.get()))                
            update_check_peaks_call(self.checkPeaks_Call)
            update_input_params_call()
            return True
        except ValueError:
            return False      
    
    ttk.Label(hvsrFrame,text=&#34;HVSR Band&#34;).grid(row=9,column=1, sticky=&#39;e&#39;, padx=10, pady=10)
    hvsrbandframe= ttk.Frame(hvsrFrame)
    hvsrbandframe.grid(row=9, column=2,sticky=&#39;w&#39;)
    self.hvsrBand_min = tk.DoubleVar()
    self.hvsrBand_min.set(0.4)
    hvsr_band_min_entry = ttk.Entry(hvsrbandframe, width=9, textvariable=self.hvsrBand_min, validate=&#39;focusout&#39;, validatecommand=on_hvsrband_update)
    hvsr_band_min_entry.grid(row=0, column=0, sticky=&#39;ew&#39;, padx=(0,2))

    self.hvsrBand_max = tk.DoubleVar()
    self.hvsrBand_max.set(40)
    hvsr_band_max_entry = ttk.Entry(hvsrbandframe, width=9,textvariable=self.hvsrBand_max, validate=&#39;focusout&#39;, validatecommand=on_hvsrband_update)
    hvsr_band_max_entry.grid(row=0,column=1, sticky=&#39;ew&#39;, padx=(2,0))

    #BATCH Section
    
    def update_batch_data_read_call():
        self.batch_read_data_call.configure(text=&#34;batch_data_read(input_data, batch_type=&#39;{}&#39;, param_col={}, batch_params={})&#34;.format(
                                                                                    self.batch_type.get(), self.param_col.get(), self.batch_params.get()))
        return

    
    def on_batch_type_select():
        update_batch_data_read_call()
        return

    self.batch_options_frame = ttk.LabelFrame(hvsrFrame, text=&#39;Batch Options&#39;)
    ttk.Label(self.batch_options_frame, text=&#34;Batch Type&#34;).grid(row=0,column=0, sticky=&#39;e&#39;, padx=10, pady=10)
    batchTypeFrame= ttk.Frame(self.batch_options_frame)
    batchTypeFrame.grid(row=0, column=1, sticky=&#39;w&#39;, columnspan=3)
    self.batch_type = tk.StringVar()
    self.batch_type.set(&#39;table&#39;)
    ttk.Radiobutton(master=batchTypeFrame, text=&#39;Table&#39;, variable=self.batch_type, value=&#39;table&#39;, command=on_batch_type_select).grid(row=0, column=0, sticky=&#39;w&#39;, padx=(5, 10))
    ttk.Radiobutton(master=batchTypeFrame, text=&#39;File list&#39;, variable=self.batch_type, value=&#39;filelist&#39;, command=on_batch_type_select).grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))

    ttk.Label(self.batch_options_frame,text=&#34;Parameter column name&#34;).grid(row=0,column=4, sticky=&#39;e&#39;, padx=5)
    self.param_col = tk.StringVar()
    self.param_col.set(None)
    self.param_col_entry = ttk.Entry(self.batch_options_frame, textvariable=self.param_col, validate=&#39;focusout&#39;, validatecommand=update_batch_data_read_call)
    self.param_col_entry.grid(row=0, column=5, sticky=&#39;w&#39;, padx=0)
    ttk.Label(self.batch_options_frame,text=&#34;For batch_type=&#39;table&#39; with single parameter column only&#34;).grid(row=1,column=4, columnspan=2, sticky=&#39;w&#39;, padx=5)

    ttk.Label(self.batch_options_frame,text=&#34;Batch parameters&#34;).grid(row=0,column=6, sticky=&#39;e&#39;, padx=5)
    self.batch_params = tk.StringVar()
    self.batch_params.set(None)
    self.batch_params_entry = ttk.Entry(self.batch_options_frame, textvariable=self.batch_params, validate=&#39;focusout&#39;, validatecommand=update_batch_data_read_call, width=75)
    self.batch_params_entry.grid(row=0, column=7, columnspan=3, sticky=&#39;ew&#39;, padx=0)
    ttk.Label(self.batch_options_frame,text=&#34;To specify parameters used for reading in data&#34;).grid(row=1,column=6, columnspan=2, sticky=&#39;w&#39;, padx=5)

    self.batch_read_data_call = ttk.Label(self.batch_options_frame, text=&#34;batch_data_read(input_data, batch_type={}, param_col={}, batch_params={})&#34;.format(
                                                                                    self.batch_type.get(), self.param_col.get(), self.batch_params.get() ))
    self.batch_read_data_call.grid(row=2,column=0, columnspan=10, sticky=&#39;w&#39;, padx=10, pady=10)

    self.batch_options_frame.grid(row=11, column=0, columnspan=7, sticky=&#39;ew&#39;)
    self.batch_options_frame.grid_forget()
    
    separator = ttk.Separator(hvsrFrame, orient=&#39;horizontal&#39;)
    separator.grid(row=12, column=0, columnspan=7, sticky=&#39;ew&#39;, padx=10)

    
    def update_fetch_call():
        if self.trim_dir.get()==&#39;&#39;:
            trim_dir = None
        else:
            trim_dir = self.trim_dir.get()

        self.fetch_data_call.configure(text=&#34;fetch_data(params, source=&#39;{}&#39;, trim_dir={}, export_format=&#39;{}&#39;, detrend=&#39;{}&#39;, detrend_order={})&#34;
                                        .format(self.file_source.get(), trim_dir, self.export_format.get(), self.detrend.get(), self.detrend_order.get()))

    #export_format=&#39;.mseed&#39;
    
    def on_obspyFormatSelect(self):
        update_fetch_call()
    ttk.Label(hvsrFrame, text=&#34;Data Format&#34;).grid(row=13, column=1, sticky=&#39;e&#39;, padx=5)
    obspyformats =  [&#39;AH&#39;, &#39;ALSEP_PSE&#39;, &#39;ALSEP_WTH&#39;, &#39;ALSEP_WTN&#39;, &#39;CSS&#39;, &#39;DMX&#39;, &#39;GCF&#39;, &#39;GSE1&#39;, &#39;GSE2&#39;, &#39;KINEMETRICS_EVT&#39;, &#39;KNET&#39;, &#39;MSEED&#39;, &#39;NNSA_KB_CORE&#39;, &#39;PDAS&#39;, &#39;PICKLE&#39;, &#39;Q&#39;, &#39;REFTEK130&#39;, &#39;RG16&#39;, &#39;SAC&#39;, &#39;SACXY&#39;, &#39;SEG2&#39;, &#39;SEGY&#39;, &#39;SEISAN&#39;, &#39;SH_ASC&#39;, &#39;SLIST&#39;, &#39;SU&#39;, &#39;TSPAIR&#39;, &#39;WAV&#39;, &#39;WIN&#39;, &#39;Y&#39;]

    self.export_format = tk.StringVar(value=obspyformats[11])
    self.data_format_dropdown = ttk.OptionMenu(hvsrFrame, self.export_format, obspyformats[11], *obspyformats, command=on_obspyFormatSelect)
    self.data_format_dropdown.grid(row=13, column=2, columnspan=3, sticky=&#39;ew&#39;)

    #detrend=&#39;spline&#39;
    
    def on_detrend_select():
        try:
            str(self.detrend.get())
            update_fetch_call()
            return True
        except ValueError:
            return False

    sourceLabel = ttk.Label(master=hvsrFrame, text=&#34;source=&#39;raw&#39;&#34;)

    ttk.Label(master=hvsrFrame, text=&#39;Detrend type [str]&#39;).grid(row=14, column=1, sticky=&#39;e&#39;, padx=5)
    detrendFrame= ttk.Frame(hvsrFrame)
    detrendFrame.grid(row=14, column=2, sticky=&#39;w&#39;, columnspan=3)
    self.detrend = tk.StringVar()
    self.detrend.set(&#39;spline&#39;)
    ttk.Radiobutton(master=detrendFrame, text=&#39;Spline&#39;, variable=self.detrend, value=&#39;spline&#39;, command=on_detrend_select).grid(row=0, column=0, sticky=&#39;w&#39;, padx=(5, 10))
    ttk.Radiobutton(master=detrendFrame, text=&#39;Polynomial&#39;, variable=self.detrend, value=&#39;polynomial&#39;, command=on_detrend_select).grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))
    ttk.Radiobutton(master=detrendFrame, text=&#39;None&#39;, variable=self.detrend, value=&#39;none&#39;, command=on_detrend_select).grid(row=0, column=2, sticky=&#39;w&#39;, padx=(5, 10))

    #detrend_order=2
    
    def on_detrend_order():
        try:
            int(self.detrend_order.get())
            update_fetch_call()
            return True
        except ValueError:
            return False
                 
    ttk.Label(hvsrFrame,text=&#34;Detrend Order [int]&#34;).grid(row=14,column=5, sticky=&#39;e&#39;, padx=5, pady=10)
    self.detrend_order = tk.IntVar()
    self.detrend_order.set(2)
    self.detrend_order_entry = ttk.Entry(hvsrFrame, textvariable=self.detrend_order, validate=&#39;focusout&#39;, validatecommand=on_detrend_order)
    self.detrend_order_entry.grid(row=14,column=6, sticky=&#39;w&#39;, padx=0)
    
    #trim_dir=False
    def on_trim_dir():
        try:
            str(self.trim_dir.get())
            update_fetch_call()
            return True
        except ValueError:
            return False
        
    ttk.Label(hvsrFrame, text=&#34;Output Directory (trimmed data)&#34;).grid(row=15, column=0, sticky=&#39;e&#39;, padx=5, pady=(2.5,5))
    self.trim_dir = tk.StringVar()
    self.trim_dir_entry = ttk.Entry(hvsrFrame, textvariable=self.trim_dir, validate=&#39;focusout&#39;, validatecommand=on_trim_dir)
    self.trim_dir_entry.grid(row=15, column=1, columnspan=5, sticky=&#39;ew&#39;, padx=5, pady=(2.5,5))
    
    
    def browse_trim_dir_filepath():
        filepath = filedialog.askdirectory()
        if filepath:
            self.trim_dir_entry.delete(0, &#39;end&#39;)
            self.trim_dir_entry.insert(0, filepath)
    
    self.trim_dir_filepath_button = ttk.Button(hvsrFrame, text=&#34;Browse&#34;, command=browse_trim_dir_filepath)
    self.trim_dir_filepath_button.grid(row=15, column=6, sticky=&#39;ew&#39;, padx=0, pady=(2.5,5))

    #self.starttime, self.endtime = get_times()
    input_params_LF = ttk.LabelFrame(master=self.input_tab, text=&#39;input_params() call&#39;)
    self.input_params_call = ttk.Label(master=input_params_LF, text=&#34;input_params( datapath=&#39;{}&#39;, metapath={}, site=&#39;{}&#39;, instrument=&#39;{}&#39;,\n\tnetwork=&#39;{}&#39;, station=&#39;{}&#39;, loc=&#39;{}&#39;, channels=[{}, {}, {}], \n\tacq_date=&#39;{}&#39;, starttime=&#39;{}&#39;, endttime=&#39;{}&#39;, tzone=&#39;{}&#39;, \n\txcoord={}, ycoord={}, elevation={}, input_crs=&#39;{}&#39;, output_crs=&#39;{}&#39;, elev_unit=&#39;{}&#39;,  hvsr_band=[{}, {}])&#34;.format(
                                        self.data_path.get(), self.meta_path.get(), self.site_name.get(), self.instrumentSel.get(),
                                        self.network.get(), self.station.get(), self.location.get(),
                                        self.z_channel.get(), self.e_channel.get(), self.n_channel.get(),
                                        self.acq_date, self.starttime.time(), self.endtime.time(), self.tz,
                                        self.x.get(), self.y.get(), self.z.get(), 
                                        self.input_crs.get(), self.output_crs.get(), self.elev_unit.get(), 
                                        self.hvsrBand_min.get(), self.hvsrBand_max.get()))
    self.input_params_call.pack(anchor=&#39;w&#39;, expand=True, padx=20)

    #fetch_data() call
    fetch_data_LF = ttk.LabelFrame(master=self.input_tab, text=&#39;fetch_data() call&#39;)
    self.fetch_data_call = ttk.Label(master=fetch_data_LF, text=&#34;fetch_data(params, source={}, trim_dir={}, export_format={}, detrend={}, detrend_order={})&#34;
                                                            .format(self.file_source.get(), None, self.export_format.get(), self.detrend.get(), self.detrend_order.get()))
    self.fetch_data_call.pack(anchor=&#39;w&#39;, expand=True, padx=20)

    #Set up frame for reading and running
    runFrame_hvsr = ttk.Frame(self.input_tab)

    self.style.configure(style=&#39;Custom.TButton&#39;, background=&#39;#d49949&#39;)
    self.read_button = ttk.Button(runFrame_hvsr, text=&#34;Read Data&#34;, command=read_data, width=30, style=&#39;Custom.TButton&#39;)

    self.style.configure(&#39;Run.TButton&#39;, background=&#39;#8b9685&#39;, width=10, height=3)
    self.run_button = ttk.Button(runFrame_hvsr, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)        
    self.run_button.pack(side=&#39;right&#39;, anchor=&#39;se&#39;, padx=(10,0))
    self.read_button.pack(side=&#39;right&#39;, anchor=&#39;se&#39;)

    hvsrFrame.pack(fill=&#39;both&#39;, expand=True, side=&#39;top&#39;)#.grid(row=0, sticky=&#34;nsew&#34;)
    runFrame_hvsr.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;)
    fetch_data_LF.pack(fill=&#39;x&#39;, side=&#39;bottom&#39;)
    input_params_LF.pack(fill=&#39;x&#39;, side=&#39;bottom&#39;)
    self.input_tab.pack(fill=&#39;both&#39;, expand=True)
    self.tab_control.add(self.input_tab, text=&#34;Input Params&#34;)

    #Data Preview Tab
    self.preview_data_tab = ttk.Frame(self.tab_control)

    # Configure the row and column of the input_tab to have a non-zero weight
    self.preview_data_tab.pack(expand=1)

    self.inputdataFrame = ttk.LabelFrame(self.preview_data_tab, text=&#34;Input Data Viewer&#34;)
    self.inputdataFrame.pack(expand=True, fill=&#39;both&#39;)
        
    self.inputInfoFrame = ttk.LabelFrame(self.inputdataFrame, text=&#34;Input Data Info&#34;)
    self.input_data_label = ttk.Label(self.inputInfoFrame, text=self.data_filepath_entry.get())
    self.input_data_label.pack(anchor=&#39;w&#39;, fill=&#39;both&#39;, expand=True, padx=15)                
    self.inputInfoFrame.pack(expand=True, fill=&#39;both&#39;, side=&#39;top&#39;)
    
    self.inputDataViewFrame = ttk.LabelFrame(self.inputdataFrame, text=&#34;Input Data Plot&#34;)
                
    ttk.Label(master=self.inputInfoFrame, text=self.data_filepath_entry.get()).pack()#.grid(row=0, column=0)

    #Set up plot
    #self.fig_pre, self.ax_pre = plt.subplot_mosaic([[&#39;Z&#39;],[&#39;N&#39;],[&#39;E&#39;]], sharex=True, sharey=False)
    #self.canvas_pre = FigureCanvasTkAgg(self.fig_pre, master=self.inputDataViewFrame)
    #self.canvas_pre.draw()
    #self.canvasPreWidget = self.canvas_pre.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
    #self.canvasPreWidget.pack(expand=True, fill=&#39;both&#39;)#.grid(row=1)

    #Reset axes, figure, and canvas widget
    self.fig_pre = plt.figure()

    prev_mosaic = [[&#39;Z&#39;],[&#39;N&#39;],[&#39;E&#39;]]
    self.ax_pre = self.fig_pre.subplot_mosaic(prev_mosaic, sharex=True)  

    self.canvas_pre = FigureCanvasTkAgg(self.fig_pre, master=self.inputDataViewFrame)  # A tk.DrawingArea.
    self.canvas_pre.draw()
    self.canvasPreWidget = self.canvas_pre.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
    self.preview_toolbar = NavigationToolbar2Tk(self.canvas_pre, self.inputDataViewFrame, pack_toolbar=False)
    self.preview_toolbar.update()

    #self.canvas_pre.mpl_connect(&#34;button_release_event&#34;, select_windows)


    #Save preview figure
    savePrevFigFrame = ttk.Frame(master=self.inputDataViewFrame)
    
    ttk.Label(savePrevFigFrame, text=&#34;Export Figure&#34;).grid(row=0, column=0, sticky=&#39;ew&#39;, padx=5)
    self.previewFig_dir = tk.StringVar()
    self.previewFig_dir_entry = ttk.Entry(savePrevFigFrame, textvariable=self.previewFig_dir)
    self.previewFig_dir_entry.grid(row=0, column=1, columnspan=5, sticky=&#39;ew&#39;)
    
    
    def filepath_preview_fig():
        filepath = filedialog.asksaveasfilename(defaultextension=&#39;.png&#39;, initialdir=pathlib.Path(self.data_path.get()).parent)
        if filepath:
            self.previewFig_dir_entry.delete(0, &#39;end&#39;)
            self.previewFig_dir_entry.insert(0, filepath)
    
    
    def save_preview_fig():
        self.fig_pre.savefig(self.previewFig_dir.get())
    
    self.browsePreviewFig = ttk.Button(savePrevFigFrame, text=&#34;Browse&#34;,command=filepath_preview_fig)
    self.browsePreviewFig.grid(row=0, column=7, sticky=&#39;ew&#39;, padx=2.5)
    
    self.savePreviewFig = ttk.Button(savePrevFigFrame, text=&#34;Save&#34;,command=save_preview_fig)
    self.savePreviewFig.grid(row=0, column=8, columnspan=2, sticky=&#39;ew&#39;, padx=2.5)

    savePrevFigFrame.columnconfigure(1, weight=1)

    savePrevFigFrame.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, expand=False)
    self.preview_toolbar.pack(side=tk.BOTTOM, fill=tk.X)            
    self.canvasPreWidget.pack(fill=&#39;both&#39;, expand=True)#.grid(row=0, column=0, sticky=&#39;nsew&#39;)

    self.inputDataViewFrame.pack(expand=True, fill=&#39;both&#39;, side=&#39;bottom&#39;)
    
    #preview-Run button
    runFrame_dataPrev = ttk.Frame(self.preview_data_tab)
    self.run_button = ttk.Button(runFrame_dataPrev, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)
    self.run_button.pack(side=&#39;bottom&#39;, anchor=&#39;e&#39;)#.grid(row=2, column=9, columnspan=20, sticky=&#39;e&#39;)
    runFrame_dataPrev.pack(side=&#39;bottom&#39;, anchor=&#39;e&#39;)#grid(row=1, sticky=&#39;e&#39;)

    self.tab_control.add(self.preview_data_tab, text=&#34;Data Preview&#34;)

    # Noise tab
    self.noise_tab = ttk.Frame(self.tab_control)
    self.canvasFrame_noise = ttk.LabelFrame(self.noise_tab, text=&#39;Noise Viewer&#39;)

    #Helper function for updating the canvas and drawing/deleted the boxes
    
    def __draw_windows(event, pathlist, ax_key, windowDrawn, winArtist, xWindows, fig, ax):
        &#34;&#34;&#34;Helper function for updating the canvas and drawing/deleted the boxes&#34;&#34;&#34;
        for i, pa in enumerate(pathlist):
            for j, p in enumerate(pa): 
                if windowDrawn[i][j]:
                    pass
                else:
                    patch = matplotlib.patches.PathPatch(p, facecolor=&#39;k&#39;, alpha=0.75)                            
                    winArt = ax[ax_key].add_patch(patch)
                    windowDrawn[i][j] = True
                    winArtist[i][j] = winArt

        if event.button is MouseButton.RIGHT:
            fig.canvas.draw()

    #Helper function for manual window selection 
    
    def __draw_boxes(event, clickNo, xWindows, pathList, windowDrawn, winArtist, lineArtist, x0, fig, ax):
        &#34;&#34;&#34;Helper function for manual window selection to draw boxes to show where windows have been selected for removal&#34;&#34;&#34;
        #Create an axis dictionary if it does not already exist so all functions are the same

        if isinstance(ax, np.ndarray) or isinstance(ax, dict):
            ax = ax
        else:
            ax = {&#39;a&#39;:ax}

        
        if len(ax) &gt; 1:
            if type(ax) is not dict:
                axDict = {}
                for i, a in enumerate(ax):
                    axDict[str(i)] = a
                ax = axDict
        #else:
        #    ax = {&#39;a&#39;:ax}
        
        #if event.inaxes!=ax: return
        #y0, y1 = ax.get_ylim()
        y0 = []
        y1 = []
        kList = []
        for k in ax.keys():
            kList.append(k)
            y0.append(ax[k].get_ylim()[0])
            y1.append(ax[k].get_ylim()[1])
        #else:
        #    y0 = [ax.get_ylim()[0]]
        #    y1 = [ax.get_ylim()[1]]

        if self.clickNo == 0:
            #y = np.linspace(ax.get_ylim()[0], ax.get_ylim()[1], 2)
            self.x0 = event.xdata
            self.clickNo = 1   
            self.lineArtist.append([])
            winNums = len(self.xWindows)
            for i, k in enumerate(ax.keys()):
                linArt = ax[k].axvline(self.x0, 0, 1, color=&#39;k&#39;, linewidth=1, zorder=100)
                self.lineArtist[winNums].append([linArt, linArt])
            #else:
            #    linArt = plt.axvline(self.x0, y0[i], y1[i], color=&#39;k&#39;, linewidth=1, zorder=100)
            #    self.lineArtist.append([linArt, linArt])
        else:
            x1 = event.xdata
            self.clickNo = 0

            windowDrawn.append([])
            winArtist.append([])  
            pathList.append([])
            winNums = len(self.xWindows)
            for i, key in enumerate(kList):
                path_data = [
                    (matplotlib.path.Path.MOVETO, (self.x0, y0[i])),
                    (matplotlib.path.Path.LINETO, (x1, y0[i])),
                    (matplotlib.path.Path.LINETO, (x1, y1[i])),
                    (matplotlib.path.Path.LINETO, (self.x0, y1[i])),
                    (matplotlib.path.Path.LINETO, (self.x0, y0[i])),
                    (matplotlib.path.Path.CLOSEPOLY, (self.x0, y0[i])),
                ]
                codes, verts = zip(*path_data)
                path = matplotlib.path.Path(verts, codes)

                windowDrawn[winNums].append(False)
                winArtist[winNums].append(None)

                pathList[winNums].append(path)
                __draw_windows(event=event, pathlist=pathList, ax_key=key, windowDrawn=windowDrawn, winArtist=winArtist, xWindows=self.xWindows, fig=fig, ax=ax)
                linArt = ax[key].axvline(x1, 0, 1, color=&#39;k&#39;, linewidth=0.5, zorder=100)

                [self.lineArtist[winNums][i].pop(-1)]
                self.lineArtist[winNums][i].append(linArt)
            x_win = [self.x0, x1]
            x_win.sort() #Make sure they are in the right order
            self.xWindows.append(x_win)
        fig.canvas.draw()
        return self.clickNo, self.x0

    #Helper function for manual window selection to draw boxes to deslect windows for removal
    
    def __remove_on_right(event, xWindows, pathList, windowDrawn, winArtist,  lineArtist, fig, ax):
        &#34;&#34;&#34;Helper function for manual window selection to draw boxes to deslect windows for removal&#34;&#34;&#34;

        if self.xWindows is not None:
            for i, xWins in enumerate(self.xWindows):
                if event.xdata &gt; xWins[0] and event.xdata &lt; xWins[1]:
                    linArtists = self.lineArtist[i]
                    pathList.pop(i)
                    for j, a in enumerate(linArtists):
                        winArtist[i][j].remove()#.pop(i)
                        self.lineArtist[i][j][0].remove()#.pop(i)#[i].pop(j)
                        self.lineArtist[i][j][1].remove()
                    windowDrawn.pop(i)
                    self.lineArtist.pop(i)#[i].pop(j)
                    winArtist.pop(i)#[i].pop(j)
                    self.xWindows.pop(i)
        fig.canvas.draw() 
           
    
    def select_windows(event, input=None, initialize=False):
        import obspy
        &#34;&#34;&#34;Function to manually select windows for exclusion from data.

        Parameters
        ----------
        input : dict
            Dictionary containing all the hvsr information.

        Returns
        -------
        self.xWindows : list
            List of two-item lists containing start and end times of windows to be removed.
        &#34;&#34;&#34;
        from matplotlib.backend_bases import MouseButton
        import matplotlib.pyplot as plt
        import matplotlib
        import time
        
        #self.fig_noise, self.ax_noise = sprit_hvsr._plot_specgram_stream(stream=input[&#39;stream&#39;], params=input, fig=self.fig_noise, ax=self.ax_noise, component=&#39;Z&#39;, stack_type=&#39;linear&#39;, detrend=&#39;mean&#39;, fill_gaps=0, dbscale=True, return_fig=True, cmap_per=[0.1,0.9])
        #self.fig_noise.canvas.draw()
        
        #if &#39;stream&#39; in input.keys():
        #    self.fig_noise, self.ax_noise = sprit_hvsr._plot_specgram_stream(stream=self.params[&#39;stream&#39;], params=self.params, fig=self.fig_noise, ax=self.ax_noise, component=&#39;Z&#39;, stack_type=&#39;linear&#39;, detrend=&#39;mean&#39;, fill_gaps=0, dbscale=True, return_fig=True, cmap_per=[0.1,0.9])
        #else:
        #    params = input.copy()
        #    input = input[&#39;stream&#39;]
        
        #if isinstance(input, obspy.core.stream.Stream):
        #    fig, ax = sprit_hvsr._plot_specgram_stream(input, component=[&#39;Z&#39;])
        #elif isinstance(input, obspy.core.trace.Trace):
        #    fig, ax = sprit_hvsr._plot_specgram_stream(input)
        if initialize:
            self.lineArtist = []
            self.winArtist = []
            self.windowDrawn = []
            self.pathList = []
            self.xWindows = []
            self.x0 = 0
            self.clickNo = 0
        
        if not initialize:
            __on_click(event)
            self.hvsr_data[&#39;xwindows_out&#39;] = self.xWindows


            #self.fig_closed
            #fig_closed = False
            #while fig_closed is False:
            #    #fig.canvas.mpl_connect(&#39;button_press_event&#39;, __on_click)#(self.clickNo, self.xWindows, pathList, windowDrawn, winArtist, lineArtist, self.x0, fig, ax))
            #    fig.canvas.mpl_connect(&#39;close_event&#39;, _on_fig_close)#(self.clickNo, self.xWindows, pathList, windowDrawn, winArtist, lineArtist, self.x0, fig, ax))
            #    plt.pause(0.5)
            
            #output[&#39;xwindows_out&#39;] = self.xWindows
            #output[&#39;fig&#39;] = fig
            #output[&#39;ax&#39;] = ax
            noEvent = True
        return self.hvsr_data

    #Support function to help select_windows run properly
    
    def _on_fig_close(event):
        self.fig_closed
        fig_closed = True
        return

    
    def __on_click(event):

        if event.button is MouseButton.RIGHT:
            __remove_on_right(event, self.xWindows, self.pathList, self.windowDrawn, self.winArtist, self.lineArtist, self.fig_noise, self.ax_noise)

        if event.button is MouseButton.LEFT:            
            self.clickNo, self.x0 = __draw_boxes(event, self.clickNo, self.xWindows, self.pathList, self.windowDrawn, self.winArtist, self.lineArtist, self.x0, self.fig_noise, self.ax_noise)    

    
    def plot_noise_windows(hvsr_data, initial_setup=False):
        if isinstance(hvsr_data, sprit_hvsr.HVSRBatch):
            batch_data = hvsr_data.copy()
            hvsr_data = hvsr_data[list(hvsr_data.keys())[0]]
        else:
            batch_data = None

        if initial_setup:
            self.xWindows=[]
        else:
            #Clear everything
            for key in self.ax_noise:
                self.ax_noise[key].clear()
            self.fig_noise.clear()

            #Really make sure it&#39;s out of memory
            self.fig_noise = []
            self.ax_noise = []
            try:
                self.fig_noise.get_children()
            except:
                pass
            try:
                self.ax_noise.get_children()
            except:
                pass

        #Reset axes, figure, and canvas widget
        self.fig_noise = plt.figure()

        noise_mosaic = [[&#39;spec&#39;],[&#39;spec&#39;],[&#39;spec&#39;],
                [&#39;spec&#39;],[&#39;spec&#39;],[&#39;spec&#39;],
                [&#39;signalz&#39;],[&#39;signalz&#39;], [&#39;signaln&#39;], [&#39;signale&#39;]]
        self.ax_noise = self.fig_noise.subplot_mosaic(noise_mosaic, sharex=True)  

        if not initial_setup:
            self.noise_canvasWidget.destroy()
            self.noise_toolbar.destroy()
            self.fig_noise, self.ax_noise = sprit_hvsr._plot_specgram_stream(stream=hvsr_data[&#39;stream&#39;], params=hvsr_data, fig=self.fig_noise, ax=self.ax_noise, component=&#39;Z&#39;, stack_type=&#39;linear&#39;, detrend=&#39;mean&#39;, fill_gaps=0, dbscale=True, return_fig=True, cmap_per=[0.1,0.9])

        self.noise_canvas = FigureCanvasTkAgg(self.fig_noise, master=self.canvasFrame_noise)  # A tk.DrawingArea.
        self.noise_canvas.draw()
        #self.noise_canvasWidget = self.noise_canvas.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
        # pack_toolbar=False will make it easier to use a layout manager later on.
        self.noise_toolbar = NavigationToolbar2Tk(self.noise_canvas, self.canvasFrame_noise, pack_toolbar=False)
        self.noise_toolbar.update()
    
        self.noise_canvasWidget = self.noise_canvas.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
        self.noise_canvas.mpl_connect(&#34;button_release_event&#34;, select_windows)

        self.noise_toolbar.pack(side=tk.BOTTOM, fill=tk.X)            
        self.noise_canvasWidget.pack(fill=&#39;both&#39;)#.grid(row=0, column=0, sticky=&#39;nsew&#39;)

        if not initial_setup:
            if batch_data is None:
                batch_data = {&#39;SITENAME&#39;:hvsr_data}

            for i, (k, hv_data) in enumerate(batch_data.items()):
                #Reset edited data every time plot_noise_windows is run
                hv_data[&#39;stream_edited&#39;] = hv_data[&#39;stream&#39;].copy()
                
                #Set initial input
                input = hv_data[&#39;stream&#39;]

                #print(input[0].stats.starttime)
                if self.do_stalta.get():
                    hv_data[&#39;stream_edited&#39;] = sprit_hvsr.remove_noise(input=input, kind=&#39;stalta&#39;, sta=self.sta.get(), lta=self.lta.get(), stalta_thresh=[self.stalta_thresh_low.get(), self.stalta_thresh_hi.get()])
                    input = hv_data[&#39;stream_edited&#39;]

                if self.do_pctThresh.get():
                    hv_data[&#39;stream_edited&#39;] = sprit_hvsr.remove_noise(input=input, kind=&#39;saturation&#39;,  sat_percent=self.pct.get(), min_win_size=self.win_size_sat.get())
                    input = hv_data[&#39;stream_edited&#39;]

                if self.do_noiseWin.get():
                    hv_data[&#39;stream_edited&#39;] = sprit_hvsr.remove_noise(input=input, kind=&#39;noise&#39;, noise_percent=self.noise_amp_pct.get(), lta=self.lta_noise.get(), min_win_size=self.win_size_thresh.get())
                    input = hv_data[&#39;stream_edited&#39;]
            
                if self.do_warmup.get():
                    hv_data[&#39;stream_edited&#39;] = sprit_hvsr.remove_noise(input=input, kind=&#39;warmup&#39;, warmup_time=self.warmup_time.get(), cooldown_time=self.cooldown_time.get())

                if i==0:
                    self.fig_noise, self.ax_noise, self.noise_windows_line_artists, self.noise_windows_window_artists = sprit_hvsr._get_removed_windows(input=hvsr_data, fig=self.fig_noise, ax=self.ax_noise, existing_xWindows=self.xWindows, time_type=&#39;matplotlib&#39;)
                    self.fig_noise.canvas.draw()
            return hvsr_data
        
        self.fig_noise.canvas.draw()
        return

    plot_noise_windows(None, initial_setup=True)
    self.canvasFrame_noise.pack(fill=&#39;both&#39;)#.grid(row=0, column=0, sticky=&#34;nsew&#34;)

    #noise_mosaic = [[&#39;spec&#39;],[&#39;spec&#39;],[&#39;spec&#39;],
    #        [&#39;spec&#39;],[&#39;spec&#39;],[&#39;spec&#39;],
    #        [&#39;signalz&#39;],[&#39;signalz&#39;], [&#39;signaln&#39;], [&#39;signale&#39;]]
    #self.fig_noise, self.ax_noise = plt.subplot_mosaic(noise_mosaic, sharex=True)  
    #self.canvasFrame_noise = ttk.LabelFrame(self.noise_tab, text=&#39;Noise Viewer&#39;)
    #self.canvasFrame_noise.pack(fill=&#39;both&#39;)#.grid(row=0, column=0, sticky=&#34;nsew&#34;)

    #self.noise_canvas = FigureCanvasTkAgg(self.fig_noise, master=self.canvasFrame_noise)
    #self.noise_canvas.draw()
    #self.noise_canvasWidget = self.noise_canvas.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
    #self.noise_canvasWidget.pack(fill=&#39;both&#39;)#.grid(row=0, column=0, sticky=&#39;nsew&#39;)

    #Run button frame
    runFrame_noise = ttk.Frame(self.noise_tab)
    
    #Run area
    #Update Noise Windows button
    self.style.configure(style=&#39;Noise.TButton&#39;, background=&#39;#86a5ba&#39;)
    self.noise_button = ttk.Button(runFrame_noise, text=&#34;Update Noise Windows&#34;, command=plot_noise_windows, width=30, style=&#39;Noise.TButton&#39;)

    self.noise_windows_line_artists = []
    self.noise_windows_window_artists = []

    self.style.configure(&#39;Run.TButton&#39;, background=&#39;#8b9685&#39;, width=10, height=3)
    self.run_button = ttk.Button(runFrame_noise, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)        
    self.run_button.pack(side=&#39;right&#39;, anchor=&#39;se&#39;, padx=(10,0))
    self.noise_button.pack(side=&#39;right&#39;, anchor=&#39;se&#39;)

    runFrame_noise.pack(fill=&#39;both&#39;,side=&#39;bottom&#39;, anchor=&#39;e&#39;)    

    #Plot adjustment Frame
    pltAdjustFrame = ttk.LabelFrame(self.noise_tab, text=&#39;Adjust Plot&#39;)
    pltAdjustFrame.pack(fill=&#39;both&#39;, side=&#39;right&#39;)#.grid(row=0, column=1, sticky=&#39;nsew&#39;)

    ttk.Label(master=pltAdjustFrame, text=&#39;Adjustment Parameters (in progress)&#39;).grid(row=0, column=0)

    noiseFrame = ttk.LabelFrame(self.noise_tab, text=&#39;Noise Removal&#39;)
    noiseFrame.pack(fill=&#39;both&#39;)#.grid(row=1, columnspan=2, sticky=&#39;nsew&#39;)
    
    #Options for manually removing windows
    windowremoveFrame = ttk.LabelFrame(noiseFrame, text=&#39;Manual Window Removal&#39;)
    windowremoveFrame.grid(row=0, column=1, columnspan=1, sticky=&#39;nsew&#39;)
    self.do_window = tk.BooleanVar() # create a BooleanVar to store the state of the Checkbutton
    manualBool = ttk.Checkbutton(master=windowremoveFrame, text=&#34;&#34;, variable=self.do_window) # create the Checkbutton widget
    manualBool.grid(row=0, column=0, sticky=&#39;ew&#39;)
    
    
    def remove_windows_manually():
        #Placeholderfunction
        print(&#39;Ok, this button may not need to do anything&#39;)
        #Plot data in noise preview tab

    self.select_windows = ttk.Button(master=windowremoveFrame, text=&#34;Remove Windows&#34;, command=remove_windows_manually) # create the Checkbutton widget
    self.select_windows.grid(row=0, column=1, sticky=&#39;e&#39;)

    #Options for doing stalta antitrigger for noise removal
    stltaremoveFrame = ttk.LabelFrame(noiseFrame, text=&#39;STA/LTA Antitrigger&#39;)
    stltaremoveFrame.grid(row=0, column=0, columnspan=1, sticky=&#39;nsew&#39;)
    
    self.do_stalta = tk.BooleanVar()
    staltaBool = ttk.Checkbutton(master=stltaremoveFrame, text=&#34;&#34;, variable=self.do_stalta) # create the Checkbutton widget
    staltaBool.grid(row=0, column=0, sticky=&#39;ew&#39;)
    
    ttk.Label(master=stltaremoveFrame, text=&#34;STA [s]&#34;).grid(row=0, column=1)
    self.sta = tk.DoubleVar()
    self.sta.set(5)
    staEntry = ttk.Entry(master=stltaremoveFrame, textvariable=self.sta, width=5) # create the Entry widget
    staEntry.grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5,10))

    ttk.Label(master=stltaremoveFrame, text=&#34;LTA [s]&#34;).grid(row=0, column=3)
    self.lta = tk.DoubleVar()
    self.lta.set(30)
    ltaEntry = ttk.Entry(master=stltaremoveFrame, textvariable=self.lta, width=5) # create the Entry widget
    ltaEntry.grid(row=0, column=4, sticky=&#39;ew&#39;, padx=(5,10))

    ttk.Label(master=stltaremoveFrame, text=&#34;STA/LTA Thresholds (Low, High)&#34;).grid(row=0, column=5)
    self.stalta_thresh_low = tk.DoubleVar()
    self.stalta_thresh_low.set(0.5)
    staltaLowEntry = ttk.Entry(master=stltaremoveFrame, textvariable=self.stalta_thresh_low, width=5) # create the Entry widget
    staltaLowEntry.grid(row=0, column=6, sticky=&#39;ew&#39;, padx=(5,0))
    
    self.stalta_thresh_hi = tk.DoubleVar()
    self.stalta_thresh_hi.set(5)
    staltaHiEntry = ttk.Entry(master=stltaremoveFrame, textvariable=self.stalta_thresh_hi, width=5) # create the Entry widget
    staltaHiEntry.grid(row=0, column=7, sticky=&#39;ew&#39;)
    
    #Options for Percentage threshold removal
    pctThresFrame = ttk.LabelFrame(noiseFrame, text=&#39;Percentage Threshold&#39;)
    pctThresFrame.grid(row=1, column=0, sticky=&#39;nsew&#39;)

    self.do_pctThresh= tk.BooleanVar()
    pctBool = ttk.Checkbutton(master=pctThresFrame, text=&#34;&#34;, variable=self.do_pctThresh) # create the Checkbutton widget
    pctBool.grid(row=0, column=0, sticky=&#39;ew&#39;)

    ttk.Label(master=pctThresFrame, text=&#34;Max Instantaneous %&#34;).grid(row=0, column=1)
    self.pct = tk.DoubleVar()
    self.pct.set(0.995)
    pctEntry = ttk.Entry(master=pctThresFrame, textvariable=self.pct, width=10) # create the Entry widget
    pctEntry.grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5,10))

    ttk.Label(master=pctThresFrame, text=&#34;&#34;, width=27).grid(row=0, column=3, columnspan=2)

    ttk.Label(master=pctThresFrame, text=&#34;Min. Window Size [sec]&#34;).grid(row=0, column=5, sticky=&#39;e&#39;)
    self.win_size_sat = tk.DoubleVar()
    self.win_size_sat.set(0)
    win_size_Entry = ttk.Entry(master=pctThresFrame, textvariable=self.win_size_sat, width=10) # create the Entry widget
    win_size_Entry.grid(row=0, column=6, sticky=&#39;e&#39;, padx=(5,10))

    #Options for noisy window
    noisyWindowFrame = ttk.LabelFrame(noiseFrame, text=&#39;Noisy Windows&#39;)
    noisyWindowFrame.grid(row=2, column=0, sticky=&#39;nsew&#39;)

    self.do_noiseWin = tk.BooleanVar()
    winNoiseBool = ttk.Checkbutton(master=noisyWindowFrame, text=&#34;&#34;, variable=self.do_noiseWin) # create the Checkbutton widget
    winNoiseBool.grid(row=0, column=0, sticky=&#39;ew&#39;)

    ttk.Label(master=noisyWindowFrame, text=&#34;Max Window %&#34;).grid(row=0, column=1)
    self.noise_amp_pct = tk.DoubleVar()
    self.noise_amp_pct.set(0.80)
    winamppctEntry = ttk.Entry(master=noisyWindowFrame, textvariable=self.noise_amp_pct, width=10) # create the Entry widget
    winamppctEntry.grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5,10))

    ttk.Label(master=noisyWindowFrame, text=&#34;Window Length [sec]&#34;).grid(row=0, column=3)
    self.lta_noise = tk.DoubleVar()
    self.lta_noise.set(30)
    winamppctEntry = ttk.Entry(master=noisyWindowFrame, textvariable=self.lta_noise, width=10) # create the Entry widget
    winamppctEntry.grid(row=0, column=4, sticky=&#39;ew&#39;, padx=(5,10))

    ttk.Label(master=noisyWindowFrame, text=&#34;Min. Window Size [sec]&#34;).grid(row=0, column=5)
    self.win_size_thresh = tk.DoubleVar()
    self.win_size_thresh.set(0)
    win_size_Entry = ttk.Entry(master=noisyWindowFrame, textvariable=self.win_size_thresh, width=10) # create the Entry widget
    win_size_Entry.grid(row=0, column=6, sticky=&#39;e&#39;, padx=(5,10))

    #Options for warmup
    warmupFrame = ttk.LabelFrame(noiseFrame, text=&#39;Warmup &amp; Cooldown Time&#39;)
    warmupFrame.grid(row=3, column=0, sticky=&#39;nsew&#39;)

    self.do_warmup= tk.BooleanVar()
    warmupBool = ttk.Checkbutton(master=warmupFrame, text=&#34;&#34;, variable=self.do_warmup) # create the Checkbutton widget
    warmupBool.grid(row=0, column=0, sticky=&#39;ew&#39;)

    ttk.Label(master=warmupFrame, text=&#34;Warmup time [s]&#34;).grid(row=0, column=1)
    self.warmup_time = tk.DoubleVar()
    warmupEntry = ttk.Entry(master=warmupFrame, textvariable=self.warmup_time, width=10) # create the Entry widget
    warmupEntry.grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5,10))
    warmupEntry.delete(0, &#39;end&#39;)
    warmupEntry.insert(0, &#39;0&#39;)

    ttk.Label(master=warmupFrame, text=&#34;Cooldown Time [s]&#34;).grid(row=0, column=3)
    self.cooldown_time = tk.DoubleVar()
    cooldownEntry = ttk.Entry(master=warmupFrame, textvariable=self.cooldown_time, width=10) # create the Entry widget
    cooldownEntry.grid(row=0, column=5, sticky=&#39;ew&#39;, padx=(5,10))
    cooldownEntry.delete(0, &#39;end&#39;)
    cooldownEntry.insert(0, &#39;0&#39;)

    #Options for doing stdev noise removal
    stdremoveFrame = ttk.LabelFrame(noiseFrame, text=&#39;Standard Deviation Antitrigger (not yet implemented)&#39;)
    stdremoveFrame.grid(row=1, column=1, columnspan=1, sticky=&#39;nsew&#39;)
    
    self.do_stdev = tk.BooleanVar()
    stdBool = ttk.Checkbutton(master=stdremoveFrame, text=&#34;&#34;, variable=self.do_stdev, state=&#39;disabled&#39;) # create the Checkbutton widget
    stdBool.grid(row=0, column=0, sticky=&#39;ew&#39;)
    
    ttk.Label(master=stdremoveFrame, text=&#34;Std Deviation Ratio (moving stdev/total stdev)&#34;).grid(row=0, column=1)
    self.stdRatio = tk.DoubleVar()
    stdRatEntry = ttk.Entry(master=stdremoveFrame, textvariable=self.stdRatio, width=5, state=&#39;disabled&#39;) # create the Entry widget
    stdRatEntry.grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5,10))
    stdRatEntry.delete(0, &#39;end&#39;)
    stdRatEntry.insert(0, &#39;1&#39;)
    
    ttk.Label(master=stdremoveFrame, text=&#34;Window Length [s]&#34;).grid(row=0, column=3)
    self.stdWinLen = tk.DoubleVar()
    stdWinLenEntry = ttk.Entry(master=stdremoveFrame, textvariable=self.stdWinLen, width=5, state=&#39;disabled&#39;) # create the Entry widget
    stdWinLenEntry.grid(row=0, column=4, sticky=&#39;ew&#39;, padx=(5,10))
    stdWinLenEntry.delete(0, &#39;end&#39;)
    stdWinLenEntry.insert(0, &#39;5&#39;)

    #Quick set the auto 
    autoFrame = ttk.LabelFrame(noiseFrame, text=&#39;Auto Run&#39;)
    autoFrame.grid(row=2, column=1, columnspan=1, sticky=&#39;nsew&#39;)

    
    def set_auto():
        if self.do_auto.get():
            self.do_stalta.set(True)
            self.do_stdev.set(True)
            self.do_warmup.set(True)
            self.do_noiseWin.set(True)
            self.do_pctThresh.set(True)
        else:
            pass

    self.do_auto= tk.BooleanVar()
    autoBool = ttk.Checkbutton(master=autoFrame, text=&#34;&#34;, variable=self.do_auto, command=set_auto) # create the Checkbutton widget
    autoBool.grid(row=0, column=0, sticky=&#39;ew&#39;)   

    #Export noise windows
    ttk.Label(noiseFrame, text=&#34;Export Figure&#34;).grid(row=4, column=0, sticky=&#39;ew&#39;, padx=5)
    self.results_noise_dir = tk.StringVar()
    self.results_noise_dir_entry = ttk.Entry(noiseFrame, textvariable=self.results_noise_dir)
    self.results_noise_dir_entry.grid(row=4, column=0, columnspan=5, sticky=&#39;ew&#39;, padx=(100,5))
    
    
    def filepath_noise_fig():
        filepath = filedialog.asksaveasfilename(defaultextension=&#39;png&#39;, initialdir=pathlib.Path(self.data_path.get()).parent, initialfile=self.params[&#39;site&#39;]+&#39;_noisewindows.png&#39;)
        if filepath:
            self.results_noise_dir_entry.delete(4, &#39;end&#39;)
            self.results_noise_dir_entry.insert(4, filepath)
    
    
    def save_noise_fig():
        self.fig_noise.savefig(self.results_noise_dir.get())
    
    self.browse_noise_fig = ttk.Button(noiseFrame, text=&#34;Browse&#34;,command=filepath_noise_fig)
    self.browse_noise_fig.grid(row=4, column=7, sticky=&#39;ew&#39;, padx=2.5)
    
    self.save_noise_fig = ttk.Button(noiseFrame, text=&#34;Save&#34;,command=save_noise_fig)
    self.save_noise_fig.grid(row=4, column=8, columnspan=2, sticky=&#39;ew&#39;, padx=2.5)

    self.noise_tab.pack(expand=1)
    self.tab_control.add(self.noise_tab, text=&#34;Noise&#34;)

    # SETTINGS TAB
    self.settings_tab = ttk.Frame(self.tab_control)
    
    self.tab_control.add(self.settings_tab, text=&#34;Settings&#34;)
    
    # Create a new Notebook widget within the Settings tab
    settings_notebook = ttk.Notebook(self.settings_tab)

    # Create the tabs within the Settings tab
    #PPSD SETTINGS SUBTAB
    ppsd_settings_tab = ttk.Frame(settings_notebook)
    ppsdSettingsFrame = ttk.LabelFrame(ppsd_settings_tab, text=&#39;Input Settings&#39;)#.pack(fill=&#39;both&#39;)
    ppsdParamsFrame = ttk.LabelFrame(ppsd_settings_tab, text=&#39;PPSD Parameters&#39;)#.pack(fill=&#39;both&#39;)

    # ppsd_length=30.0
    
    def on_ppsd_length():
        try:
            float(self.ppsd_length.get())
            ppsdLenLabel.configure(text=&#39;ppsd_length={}&#39;.format(self.ppsd_length.get()))
            update_ppsd_call(self.ppsd_call)
            return True
        except ValueError:
            return False
    ppsdLenLabel = ttk.Label(master=ppsdParamsFrame, text=&#39;ppsd_length=30.0 &#39;)#.grid(row=0, column=0)
    ppsdLenLabel.grid(row=0, column=0, sticky=&#39;w&#39;, pady=(6,6), padx=5)
    
    ttk.Label(master=ppsdSettingsFrame, text=&#39;PPSD Length (in seconds) [float]&#39;).grid(row=0, column=0, sticky=&#39;w&#39;, padx=5)
    self.ppsd_length = tk.DoubleVar()
    self.ppsd_length.set(30)
    ppsdLenEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=self.ppsd_length, width=10, validate=&#39;focusout&#39;, validatecommand=on_ppsd_length)
    ppsdLenEntry.grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))

    # overlap=0.5, 
    
    def on_overlap():
        try:
            overlap = float(self.overlap.get())
            if overlap &gt; 1:
                self.overlap.set(overlap/100)
            overlapLabel.configure(text=&#39;overlap={}&#39;.format(self.overlap.get()))
            update_ppsd_call(self.ppsd_call)
            return True
        except ValueError:
            return False
    overlapLabel = ttk.Label(master=ppsdParamsFrame, text=&#39;overlap=0.5 &#39;)#.grid(row=0, column=0)
    overlapLabel.grid(row=1, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
    
    ttk.Label(master=ppsdSettingsFrame, text=&#39;Overlap % (0-1) [float]&#39;).grid(row=1, column=0, sticky=&#39;w&#39;, padx=5)
    self.overlap = tk.DoubleVar()
    self.overlap.set(0.5)
    overlapEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=self.overlap, width=10, validate=&#39;focusout&#39;, validatecommand=on_overlap)
    overlapEntry.grid(row=1, column=1, sticky=&#39;w&#39;, padx=(5, 10))

    # period_step_octaves=0.0625, 
    
    def on_per_step_oct():
        try:
            float(self.perStepOct.get())
            
            pStepOctLabel.configure(text=&#39;period_step_octaves={}&#39;.format(self.perStepOct.get()))
            update_ppsd_call(self.ppsd_call)            
            return True
        except ValueError:
            return False
    pStepOctLabel = ttk.Label(master=ppsdParamsFrame, text=&#39;period_step_octaves=0.0625&#39;)#.grid(row=0, column=0)
    pStepOctLabel.grid(row=2, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
    
    ttk.Label(master=ppsdSettingsFrame, text=&#39;Period Step Octave [float]&#39;).grid(row=2, column=0, sticky=&#39;w&#39;, padx=5)
    self.perStepOct = tk.DoubleVar()
    self.perStepOct.set(0.0625)
    pStepOctEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=self.perStepOct, width=10, validate=&#39;focusout&#39;, validatecommand=on_per_step_oct)
    pStepOctEntry.grid(row=2, column=1, sticky=&#39;w&#39;, padx=(5, 10))

    #skip_on_gaps
    
    def show_sog():
        if self.skip_on_gaps.get():
            sogLabel.configure(text =&#39;skip_on_gaps=True&#39;)
        else:
            sogLabel.configure(text =&#39;skip_on_gaps=False&#39;)
        update_ppsd_call(self.ppsd_call)
        
    self.skip_on_gaps = tk.BooleanVar()
    ttk.Label(master=ppsdSettingsFrame, text=&#39;Skip on Gaps [bool]: &#39;, justify=&#39;left&#39;).grid(row=3, column=0, sticky=&#39;w&#39;, padx=5)
    sogCheckButton = ttk.Checkbutton(master=ppsdSettingsFrame, text=&#39;&#39;, variable=self.skip_on_gaps, command=show_sog) # create the Entry widget
    sogCheckButton.grid(row=3, column=1, sticky=&#39;ew&#39;, padx=(5,10))
    sogLabel = ttk.Label(master=ppsdParamsFrame, text=&#39;skip_on_gaps=False&#39;)
    sogLabel.grid(row=3, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

    # db_bins=(-200, -50, 1.0), 
    
    def show_dbbins():
        try:
            float(minDB.get())
            float(maxDB.get())
            float(dB_step.get())
            dbbinsLabel.configure(text=&#39;db_bins=({}, {}, {})&#39;.format(
                minDB.get(), maxDB.get(), dB_step.get()))
            self.db_bins = (minDB.get(), maxDB.get(), dB_step.get())
            update_ppsd_call(self.ppsd_call)
            return True
        except ValueError:
            return False

    dbbinsLabel = ttk.Label(master=ppsdParamsFrame,
                            text=&#39;db_bins=(-200, -50, 1.0)&#39;)
    dbbinsLabel.grid(row=4, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
    ttk.Label(master=ppsdSettingsFrame, text=&#39;dB Bins (Y Axis) [tuple]&#39;, justify=&#39;left&#39;).grid(row=4, column=0, sticky=&#39;w&#39;, padx=5)
    
    ttk.Label(master=ppsdSettingsFrame, text=&#39;Min. dB&#39;).grid(row=4, column=1, sticky=&#39;e&#39;, padx=5)
    minDB = tk.DoubleVar()
    minDB.set(-200)
    minDBEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=minDB,
                        validate=&#34;focusout&#34;, validatecommand=show_dbbins, width=10)
    minDBEntry.grid(row=4, column=2, sticky=&#39;w&#39;, padx=(5, 10))
    
    ttk.Label(master=ppsdSettingsFrame, text=&#39;Max. dB&#39;).grid(row=4, column=3, sticky=&#39;e&#39;, padx=5)
    maxDB = tk.DoubleVar()
    maxDB.set(-50)
    maxDBEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=maxDB,
                        validate=&#34;focusout&#34;, validatecommand=show_dbbins, width=10)
    maxDBEntry.grid(row=4, column=4, sticky=&#39;w&#39;, padx=(5, 10))

    ttk.Label(master=ppsdSettingsFrame, text=&#39;dB Step&#39;).grid(row=4, column=5, sticky=&#39;e&#39;, padx=5)
    dB_step = tk.DoubleVar()
    dB_step.set(1.0)
    stepEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=dB_step,
                        validate=&#34;focusout&#34;, validatecommand=(show_dbbins), width=10)
    stepEntry.grid(row=4, column=6, sticky=&#39;w&#39;, padx=(5, 10))
    self.db_bins = (minDB.get(), maxDB.get(), dB_step.get())

    # period_limits=None,
    
    def show_per_lims():
        try:
            if minPerLim.get() == &#39;None&#39;:
                pass
            else:
                float(minPerLim.get())
                
            if maxPerLim.get() == &#39;None&#39;:
                pass
            else:
                float(maxPerLim.get())
                
            if minPerLim.get() == &#39;None&#39; or maxPerLim.get() == &#39;None&#39;:
                perLimsLabel.configure(text=&#39;period_limits=None&#39;)
            else:
                perLimsLabel.configure(text=&#39;period_limits=[{}, {}]&#39;.format(minPerLim.get(), maxPerLim.get()))
                self.period_limits = [float(minPerLim.get()), float(maxPerLim.get())]
            update_ppsd_call(self.ppsd_call)
            return True
        except ValueError:
            return False

    perLimsLabel = ttk.Label(master=ppsdParamsFrame,
                            text=&#39;period_limits=None&#39;)
    perLimsLabel.grid(row=5, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
    ttk.Label(master=ppsdSettingsFrame, text=&#39;Period Limits [list of floats or None]&#39;, justify=&#39;left&#39;).grid(row=5, column=0, sticky=&#39;w&#39;, padx=5)
    
    ttk.Label(master=ppsdSettingsFrame, text=&#39;Min. Period Limit&#39;).grid(row=5, column=1, sticky=&#39;e&#39;, padx=5)
    minPerLim = tk.StringVar()
    minPerLim.set(None)
    minPerLimEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=minPerLim,
                        validate=&#34;focusout&#34;, validatecommand=(show_per_lims), width=10)
    minPerLimEntry.grid(row=5, column=2, sticky=&#39;w&#39;, padx=(5, 10))
    
    ttk.Label(master=ppsdSettingsFrame, text=&#39;Max. Period Limit&#39;).grid(row=5, column=3, sticky=&#39;e&#39;, padx=5)
    maxPerLim = tk.StringVar()
    maxPerLim.set(None)
    maxPerLimEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=maxPerLim,
                        validate=&#34;focusout&#34;, validatecommand=(show_per_lims), width=10)
    maxPerLimEntry.grid(row=5, column=4, sticky=&#39;w&#39;, padx=(5, 10))

    if minPerLim.get() == &#39;None&#39; or maxPerLim.get() == &#39;None&#39;:
        self.period_limits=None
    else:
        self.period_limits = [float(minPerLim.get()), float(maxPerLim.get())]

    # period_smoothing_width_octaves=1.0,
    
    def on_per_smoothwidth_oct():
        try:
            float(self.perSmoothWidthOct.get())
            
            pSmoothWidthLabel.configure(text=&#39;period_smoothing_width_octaves={}&#39;.format(self.perSmoothWidthOct.get()))
            update_ppsd_call(self.ppsd_call)
            return True
        except ValueError:
            return False
    pSmoothWidthLabel = ttk.Label(master=ppsdParamsFrame, text=&#39;period_smoothing_width_octaves=1.0&#39;)#.grid(row=0, column=0)
    pSmoothWidthLabel.grid(row=6, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
    
    ttk.Label(master=ppsdSettingsFrame, text=&#39;Period Smoothing Width (octaves) [float]&#39;).grid(row=6, column=0, sticky=&#39;w&#39;, padx=5)
    self.perSmoothWidthOct = tk.DoubleVar()
    self.perSmoothWidthOct.set(1.0)
    pSmoothWidthEntry = ttk.Entry(master=ppsdSettingsFrame, textvariable=self.perSmoothWidthOct, width=10, validate=&#39;focusout&#39;, validatecommand=on_per_smoothwidth_oct)
    pSmoothWidthEntry.grid(row=6, column=1, sticky=&#39;w&#39;, padx=(5, 10))
    
    # special_handling=None, 
    
    def on_special_handling():
        try:
            str(self.special_handling.get())
            if self.special_handling.get() == &#39;None&#39;:
                specialHandlingLabel.configure(text=&#34;special_handling={}&#34;.format(self.special_handling.get()))
                special_handling = None
            else:
                specialHandlingLabel.configure(text=&#34;special_handling=&#39;{}&#39;&#34;.format(self.special_handling.get()))
                special_handling = self.special_handling.get()
            update_ppsd_call(self.ppsd_call)
            return True
        except ValueError:
            return False

    specialHandlingLabel = ttk.Label(master=ppsdParamsFrame, text=&#34;special_handling=None&#34;)
    specialHandlingLabel.grid(row=7, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

    ttk.Label(master=ppsdSettingsFrame, text=&#39;Special Handling [str]&#39;).grid(row=7, column=0, sticky=&#39;w&#39;, padx=5)

    self.special_handling = tk.StringVar()
    self.special_handling.set(&#39;None&#39;)
    ttk.Radiobutton(master=ppsdSettingsFrame, text=&#39;None&#39;, variable=self.special_handling, value=&#39;None&#39;, command=on_special_handling).grid(row=7, column=1, sticky=&#39;w&#39;, padx=(5, 10))
    ttk.Radiobutton(master=ppsdSettingsFrame, text=&#39;Ringlaser&#39;, variable=self.special_handling, value=&#39;ringlaser&#39;, command=on_special_handling).grid(row=7, column=2, sticky=&#39;w&#39;, padx=(5, 10))
    ttk.Radiobutton(master=ppsdSettingsFrame, text=&#39;Hydrophone&#39;, variable=self.special_handling, value=&#39;hydrophone&#39;, command=on_special_handling).grid(row=7, column=3, sticky=&#39;w&#39;, padx=(5, 10))

    if self.special_handling.get()==&#39;None&#39;:
        special_handling = None
    else:
        special_handling = self.special_handling.get()

    separator = ttk.Separator(ppsdSettingsFrame, orient=&#39;horizontal&#39;)
    separator.grid(row=8, columnspan=8, sticky=&#39;ew&#39;, pady=10, padx=5)

    separator = ttk.Separator(ppsdParamsFrame, orient=&#39;horizontal&#39;)
    separator.grid(row=8, sticky=&#39;ew&#39;, pady=10, padx=5)

    #remove_outliers
    
    def show_rem_outliers():
        if self.remove_outliers.get():
            rem_outliers_Label.configure(text =&#39;remove_outliers=True&#39;)
        else:
            rem_outliers_Label.configure(text =&#39;remove_outliers=False&#39;)
        update_ppsd_call(self.ppsd_call)
        
    self.remove_outliers = tk.BooleanVar()
    self.remove_outliers.set(True)
    ttk.Label(master=ppsdSettingsFrame, text=&#39;Remove outlier curves [bool]: &#39;, justify=&#39;left&#39;).grid(row=9, column=0, sticky=&#39;w&#39;, padx=5)
    rem_outliers_CheckButton = ttk.Checkbutton(master=ppsdSettingsFrame, text=&#39;&#39;, variable=self.remove_outliers, command=show_rem_outliers) # create the Entry widget
    rem_outliers_CheckButton.grid(row=9, column=1, sticky=&#39;ew&#39;, padx=(5,10))
    rem_outliers_Label = ttk.Label(master=ppsdParamsFrame, text=&#39;remove_outliers=True&#39;)
    rem_outliers_Label.grid(row=9, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

    # outlier_std=1.5, 
    
    def on_outlier_std():
        try:
            float(self.outlier_std.get())
            outlier_std_Label.configure(text=&#39;outlier_std={}&#39;.format(self.outlier_std.get()))
            update_ppsd_call(self.ppsd_call)            
            return True
        except ValueError:
            return False
    outlier_std_Label = ttk.Label(master=ppsdParamsFrame, text=&#39;outlier_std=1.5&#39;)#.grid(row=0, column=0)
    outlier_std_Label.grid(row=10, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
    
    ttk.Label(master=ppsdSettingsFrame, text=&#39;St. Dev. for Outliers [float]&#39;).grid(row=10, column=0, sticky=&#39;w&#39;, padx=5)
    self.outlier_std = tk.DoubleVar()
    self.outlier_std.set(1.5)
    outlier_std_Entry = ttk.Entry(master=ppsdSettingsFrame, textvariable=self.outlier_std, width=10, validate=&#39;focusout&#39;, validatecommand=on_outlier_std)
    outlier_std_Entry.grid(row=10, column=1, sticky=&#39;w&#39;, padx=(5, 10))


    #PPSD Function Call
    ppsdCallFrame = ttk.LabelFrame(ppsd_settings_tab, text=&#39;sprit_hvsr.generate_ppsds() and obspy PPSD() call&#39;)#.pack(fill=&#39;both&#39;) 
   
    self.ppsd_call = ttk.Label(master=ppsdCallFrame, text=&#39;obspy...PPSD({}, {}, {}, {}, {}, {}, \n\t{}, {}, {}, {})&#39;
              .format(&#39;stats&#39;, &#39;metadata&#39;, ppsdLenLabel.cget(&#39;text&#39;), overlapLabel.cget(&#39;text&#39;), pStepOctLabel.cget(&#39;text&#39;), sogLabel.cget(&#39;text&#39;), 
                      dbbinsLabel.cget(&#39;text&#39;), perLimsLabel.cget(&#39;text&#39;), pSmoothWidthLabel.cget(&#39;text&#39;), specialHandlingLabel.cget(&#39;text&#39;)))
    self.ppsd_call.pack(side=&#39;bottom&#39;, anchor=&#39;w&#39;, padx=(25,0), pady=(10,10))

    self.generate_ppsd_call = ttk.Label(master=ppsdCallFrame, text=&#39;generate_ppsds({}, remove_outliers={}, outlier_std={},...\n\t{}, {}, {}, {}, {}, \n\t{}, {}, {})&#39;
              .format(&#39;params&#39;, self.remove_outliers.get(), self.outlier_std.get(), 
                      ppsdLenLabel.cget(&#39;text&#39;), overlapLabel.cget(&#39;text&#39;), pStepOctLabel.cget(&#39;text&#39;), sogLabel.cget(&#39;text&#39;), 
                      dbbinsLabel.cget(&#39;text&#39;), perLimsLabel.cget(&#39;text&#39;), pSmoothWidthLabel.cget(&#39;text&#39;), specialHandlingLabel.cget(&#39;text&#39;)))
    self.generate_ppsd_call.pack(side=&#39;bottom&#39;, anchor=&#39;w&#39;, padx=(25,0), pady=(10,10))
    
    
    def update_ppsd_call(ppsd_call):
        ppsd_call.configure(text=&#39;obspy...PPSD({}, {}, {}, {}, {}, {}, \n\t{}, {}, {}, {})&#39;.format(&#39;stats&#39;, &#39;metadata&#39;, ppsdLenLabel.cget(&#39;text&#39;), 
                                                                                                overlapLabel.cget(&#39;text&#39;), pStepOctLabel.cget(&#39;text&#39;), sogLabel.cget(&#39;text&#39;), 
                      dbbinsLabel.cget(&#39;text&#39;), perLimsLabel.cget(&#39;text&#39;), pSmoothWidthLabel.cget(&#39;text&#39;), specialHandlingLabel.cget(&#39;text&#39;)))

        self.generate_ppsd_call.configure(text=&#39;generate_ppsds({}, remove_outliers={}, outlier_std={},...\n\t{}, {}, {}, {}, {}, \n\t{}, {}, {})&#39;
                        .format(&#39;params&#39;, self.remove_outliers.get(), self.outlier_std.get(), 
                                ppsdLenLabel.cget(&#39;text&#39;), overlapLabel.cget(&#39;text&#39;), pStepOctLabel.cget(&#39;text&#39;), sogLabel.cget(&#39;text&#39;), 
                                dbbinsLabel.cget(&#39;text&#39;), perLimsLabel.cget(&#39;text&#39;), pSmoothWidthLabel.cget(&#39;text&#39;), specialHandlingLabel.cget(&#39;text&#39;)))
                

    #Stats from trace(s)
    obspyStatsFrame = ttk.LabelFrame(ppsd_settings_tab, text=&#39;Data Trace Stats&#39;)#.pack(fill=&#39;both&#39;)
    self.obspySreamLabel_settings = ttk.Label(obspyStatsFrame, text=&#39;Stats&#39;)
    self.obspySreamLabel_settings.pack(anchor=&#39;nw&#39;, padx=5)

    #Metadata (PAZ)
    obspyMetadataFrame = ttk.LabelFrame(ppsd_settings_tab, text=&#39;Metadata Poles and Zeros&#39;)#.pack(fill=&#39;both&#39;)

    self.metadataZ_settings = ttk.Label(obspyMetadataFrame, text=&#39;Z: &#39;)
    self.metadataZ_settings.grid(row=1, column=0, padx=5)
    self.metadataZ_settings.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))
    self.sensitivityLabelZ_settings = ttk.Label(obspyMetadataFrame, text=&#39;Sensitivity_Z&#39;)
    self.sensitivityLabelZ_settings.grid(row=1, column=1, padx=5)
    self.gainLabelZ_settings = ttk.Label(obspyMetadataFrame, text=&#39;Gain_Z&#39;)
    self.gainLabelZ_settings.grid(row=1, column=2, padx=5)
    self.polesLabelZ_settings = ttk.Label(obspyMetadataFrame, text=&#39;Poles_Z&#39;)
    self.polesLabelZ_settings.grid(row=1, column=3, padx=5)
    self.zerosLabelZ_settings = ttk.Label(obspyMetadataFrame, text=&#39;Zeros_Z&#39;)
    self.zerosLabelZ_settings.grid(row=1, column=4, padx=5)

    self.metadataN_settings = ttk.Label(obspyMetadataFrame, text=&#39;N: &#39;)
    self.metadataN_settings.grid(row=2, column=0, padx=5)
    self.metadataN_settings.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))
    self.sensitivityLabelN_settings = ttk.Label(obspyMetadataFrame, text=&#39;Sensitivity_N&#39;)
    self.sensitivityLabelN_settings.grid(row=2, column=1, padx=5)
    self.gainLabelN_settings = ttk.Label(obspyMetadataFrame, text=&#39;Gain_N&#39;)
    self.gainLabelN_settings.grid(row=2, column=2, padx=5)
    self.polesLabelN_settings = ttk.Label(obspyMetadataFrame, text=&#39;Poles_N&#39;)
    self.polesLabelN_settings.grid(row=2, column=3, padx=5)
    self.zerosLabelN_settings = ttk.Label(obspyMetadataFrame, text=&#39;Zeros_N&#39;)
    self.zerosLabelN_settings.grid(row=2, column=4, padx=5)

    self.metadataE_settings = ttk.Label(obspyMetadataFrame, text=&#39;E: &#39;)
    self.metadataE_settings.grid(row=3, column=0, padx=5)
    self.metadataE_settings.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))
    self.sensitivityLabelE_settings = ttk.Label(obspyMetadataFrame, text=&#39;Sensitivity_E&#39;)
    self.sensitivityLabelE_settings.grid(row=3, column=1)
    self.gainLabelE_settings = ttk.Label(obspyMetadataFrame, text=&#39;Gain_E&#39;)
    self.gainLabelE_settings.grid(row=3, column=2, padx=5)
    self.polesLabelE_settings = ttk.Label(obspyMetadataFrame, text=&#39;Poles_E&#39;)
    self.polesLabelE_settings.grid(row=3, column=3, padx=5)
    self.zerosLabelE_settings = ttk.Label(obspyMetadataFrame, text=&#39;Zeros_E&#39;)
    self.zerosLabelE_settings.grid(row=3, column=4, padx=5)

    self.metadata_sensitivity = ttk.Label(obspyMetadataFrame, text=&#39;Sensitivity&#39;)
    self.metadata_sensitivity.grid(row=0, column=1, padx=5)
    self.metadata_sensitivity.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))

    self.metadata_gain = ttk.Label(obspyMetadataFrame, text=&#39;Gain&#39;)
    self.metadata_gain.grid(row=0, column=2, padx=5)
    self.metadata_gain.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))

    self.metadata_poles = ttk.Label(obspyMetadataFrame, text=&#39;Poles&#39;)
    self.metadata_poles.grid(row=0, column=3, padx=5)
    self.metadata_poles.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))

    self.metadata_zeros = ttk.Label(obspyMetadataFrame, text=&#39;Zeros&#39;)
    self.metadata_zeros.grid(row=0, column=4, padx=5)
    self.metadata_zeros.configure(font=(&#34;TkDefaultFont&#34;, 10, &#39;underline&#39;, &#39;bold&#39;))

    #Run button frame
    runFrame_set_ppsd = ttk.Frame(ppsd_settings_tab)
    self.run_button = ttk.Button(runFrame_set_ppsd, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)
    self.run_button.pack(side=&#39;bottom&#39;, anchor=&#39;e&#39;)
    
    runFrame_set_ppsd.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;, anchor=&#39;e&#39;)            
    obspyMetadataFrame.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;,expand=True)#.grid(row=7, column=0, columnspan=6, sticky=&#39;nsew&#39;)#.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
    obspyStatsFrame.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;,expand=True)#.grid(row=6, column=0, columnspan=6, sticky=&#39;nsew&#39;)#.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
    ppsdCallFrame.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;,expand=True)#row=5, column=0, columnspan=6, sticky=&#39;nsew&#39;)#.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
    ppsdParamsFrame.pack(fill=&#39;both&#39;, side=&#39;right&#39;)#.grid(row=0, column=5, rowspan=4, sticky=&#39;nsew&#39;)#.pack(side=&#39;right&#39;,fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
    ppsdSettingsFrame.pack(fill=&#39;both&#39;, expand=True, side=&#39;top&#39;, anchor=&#39;w&#39;)#.grid(row=0, column=0, columnspan=4, rowspan=4, sticky=&#39;nsew&#39;)#.pack(side=&#39;left&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)

    ppsd_settings_tab.pack(fill=&#39;both&#39;, expand=True)
    settings_notebook.add(ppsd_settings_tab, text=&#34;PPSD&#34;)

    #HVSR SETTINGS TAB
    hvsr_settings_tab = ttk.Frame(settings_notebook)
    
    hvsrSettingsFrame = ttk.LabelFrame(hvsr_settings_tab, text=&#39;H/V Processing Settings&#39;)#.pack(fill=&#39;both&#39;)
    
    hvsrParamsFrame = ttk.LabelFrame(hvsr_settings_tab, text=&#39;Process HVSR Parameters&#39;)#.pack(fill=&#39;both&#39;)
    
    #Method selection, method=4
    ttk.Label(hvsrSettingsFrame, text=&#34;Horizontal Combine Method [int]&#34;).grid(row=0, column=0, padx=(5,0), sticky=&#39;w&#39;)
    method_options = [&#39;&#39;, #Empty to make intuitive and match sprit_hvsr.py
                      &#34;1.Diffuse Field Assumption (not currently implemented)&#34;, 
                      &#34;2. Arithmetic Mean H ≡ (N + E)/2&#34;,
                      &#34;3. Geometric Mean: H ≡ √(N · E) (recommended by SESEAME Project (2004))&#34;,
                      &#34;4. Vector Summation: H ≡ √(N^2 + E^2)&#34;,
                      &#34;5. Quadratic Mean: H ≡ √(N^2 + E^2)/2&#34;,
                      &#34;6. Maximum Horizontal Value: H ≡ max(N, E)&#34;
                      ]

    
    def on_method_select(meth, meth_opts=method_options):
        self.method_ind = meth_opts.index(meth)

        try:
            int(self.method_ind)
            hCombMethodLabel.configure(text=&#34;method={}&#34;.format(self.method_ind))
            update_procHVSR_call(self.procHVSR_call)
            return True
        except ValueError:
            return False

    defaultMeth=3
    hCombMethodLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;method={}&#34;.format(defaultMeth), width=30)
    hCombMethodLabel.grid(row=0, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

    self.method_sel = tk.StringVar(value=method_options[defaultMeth])
    self.method_ind = method_options.index(self.method_sel.get())       
    self.method_dropdown = ttk.OptionMenu(hvsrSettingsFrame, self.method_sel, method_options[defaultMeth], *method_options, command=on_method_select)
    self.method_dropdown.config(width=50)
    self.method_dropdown.grid(row=0, column=1, columnspan=8, sticky=&#39;ew&#39;)
    
    #smooth=True, 
    
    def curve_smooth():
        try:
            int(self.hvsmooth.get())
            bool(self.hvsmoothbool.get())
            if not self.hvsmoothbool.get():
                hvSmoothLabel.configure(text=&#39;smooth={}&#39;.format(self.hvsmoothbool.get()))
                self.hvsmooth_param = False
            else:
                hvSmoothLabel.configure(text=&#39;smooth={}&#39;.format(self.hvsmooth.get()))
                self.hvsmooth_param = self.hvsmooth.get()              
            update_procHVSR_call(self.procHVSR_call)
            return True
        except ValueError:
            return False
        
    hvSmoothLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;smooth=True&#34;, width=30)
    hvSmoothLabel.grid(row=1, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

    ttk.Label(master=hvsrSettingsFrame, text=&#39;Smooth H/V Curve [bool]&#39;).grid(row=1, column=0, padx=(5,0), sticky=&#39;w&#39;)

    self.hvsmoothbool = tk.BooleanVar()
    self.hvsmoothbool.set(True)
    self.hvsmooth_param=True
    smoothCurveBool = ttk.Checkbutton(master=hvsrSettingsFrame, text=&#34;&#34;, compound=&#39;left&#39;, variable=self.hvsmoothbool, command=curve_smooth) # create the Checkbutton widget
    smoothCurveBool.grid(row=1, column=1, sticky=&#39;w&#39;)

    self.hvsmooth = tk.IntVar()
    self.hvsmooth.set(51)
    smoothCurveSamples = ttk.Entry(master=hvsrSettingsFrame, textvariable=self.hvsmooth, width=10, validate=&#39;focusout&#39;, validatecommand=curve_smooth)
    smoothCurveSamples.grid(row=1, column=2, sticky=&#39;w&#39;, padx=(5, 10))
    ttk.Label(master=hvsrSettingsFrame, text=&#39;[int] # pts in smoothing window (default=51)&#39;).grid(row=1, column=3, padx=(0,0))
    
    #freq_smooth=&#39;konno ohmachi&#39;, 
    freqSmoothLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;freq_smooth=&#39;konno ohmachi&#39;&#34;, width=30)
    freqSmoothLabel.grid(row=2, column=0, sticky=&#39;w&#39;, pady=(16,16), padx=5)

    
    def on_freq_smooth():
        try:
            str(self.freq_smooth.get())
            freqSmoothLabel.configure(text=&#34;freq_smooth={}&#34;.format(self.freq_smooth.get()))
            update_procHVSR_call(self.procHVSR_call)
            return True
        except ValueError:
            return False

    self.freq_smooth = tk.StringVar()
    self.freq_smooth.set(&#39;konno ohmachi&#39;)
    ttk.Label(master=hvsrSettingsFrame, text=&#39;Frequency Smoothing [str]&#39;).grid(row=2, column=0, padx=(5,0), sticky=&#39;w&#39;)
    fsmoothOptFrame = ttk.LabelFrame(master=hvsrSettingsFrame, text=&#39;Frequency Smoothing Operations&#39;)
    fsmoothOptFrame.grid(row=2, column=1, columnspan=7, padx=5, sticky=&#39;nsew&#39;)
    ttk.Radiobutton(master=fsmoothOptFrame, text=&#39;Konno-Ohmachi&#39;, variable=self.freq_smooth, value=&#39;konno ohmachi&#39;, command=on_freq_smooth).grid(row=0, column=0, sticky=&#39;w&#39;, padx=(5, 10))
    ttk.Radiobutton(master=fsmoothOptFrame, text=&#39;Constant&#39;, variable=self.freq_smooth, value=&#39;constant&#39;, command=on_freq_smooth).grid(row=0, column=1, sticky=&#39;w&#39;, padx=(5, 10))
    ttk.Radiobutton(master=fsmoothOptFrame, text=&#39;Proportional&#39;, variable=self.freq_smooth, value=&#39;proportional&#39;, command=on_freq_smooth).grid(row=0, column=2, sticky=&#39;w&#39;, padx=(5, 10))
    ttk.Radiobutton(master=fsmoothOptFrame, text=&#39;None&#39;, variable=self.freq_smooth, value=&#39;None&#39;, command=on_freq_smooth).grid(row=0, column=3, sticky=&#39;w&#39;, padx=(5, 10))

    #f_smooth_width=40, 
    fSmoothWidthlabel = ttk.Label(master=hvsrParamsFrame, text=&#34;f_smooth_width=40&#34;, width=30)
    fSmoothWidthlabel.grid(row=3, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

    
    def on_smooth_width():
        try:
            int(self.fSmoothWidth.get())
            fSmoothWidthlabel.configure(text=&#39;f_smooth_width={}&#39;.format(self.fSmoothWidth.get()))                
            update_procHVSR_call(self.procHVSR_call)
            return True
        except ValueError:
            return False
        
    ttk.Label(master=hvsrSettingsFrame, text=&#39;Bandwidth of freq. smoothing [int]&#39;).grid(row=3, column=0, padx=(5,0), sticky=&#39;w&#39;)
    self.fSmoothWidth = tk.IntVar()
    self.fSmoothWidth.set(40)
    fSmoothWidthEntry = ttk.Entry(master=hvsrSettingsFrame, justify=&#39;left&#39;, textvariable=self.fSmoothWidth, validate=&#39;focusout&#39;, validatecommand=on_smooth_width, width=10)
    fSmoothWidthEntry.grid(row=3, column=1, sticky=&#39;w&#39;, padx=(5, 10))
    
    #resample=True, 
    resampleLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;resample=True&#34;, width=30)
    resampleLabel.grid(row=4, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)
    
    def on_curve_resample():
        try:
            if not self.resamplebool.get():
                resampleLabel.configure(text=&#39;resample={}&#39;.format(self.resamplebool.get()))
                self.hvresample_int=self.hvresample.get()
            else:
                resampleLabel.configure(text=&#39;resample={}&#39;.format(self.hvresample.get()))
                self.hvresample_int=self.hvresample.get()    
            update_procHVSR_call(self.procHVSR_call)
            return True
        except ValueError:
            return False
        
    self.resamplebool = tk.BooleanVar()
    self.resamplebool.set(True)
    ttk.Label(master=hvsrSettingsFrame, text=&#39;Resample H/V Curve [bool]&#39;).grid(row=4, column=0, padx=(5,0), sticky=&#39;w&#39;)
    resampleCurveBool = ttk.Checkbutton(master=hvsrSettingsFrame, text=&#34;&#34;, compound=&#39;left&#39;, variable=self.resamplebool, command=on_curve_resample) # create the Checkbutton widget
    resampleCurveBool.grid(row=4, column=1, sticky=&#39;w&#39;)

    self.hvresample = tk.IntVar()
    self.hvresample.set(1000)
    self.hvresample_int = self.hvresample.get()
    resampleCurveSamples = ttk.Entry(master=hvsrSettingsFrame, textvariable=self.hvresample, width=10, validate=&#39;focusout&#39;, validatecommand=on_curve_resample)
    resampleCurveSamples.grid(row=4, column=2, sticky=&#39;w&#39;, padx=(5, 10))
    ttk.Label(master=hvsrSettingsFrame, text=&#39;[int] # pts in resampled curve (default=1000)&#39;).grid(row=4, column=3, padx=(0,0), sticky=&#39;w&#39;)
                    
    #remove_outlier_curves=True, 
    outlierRemLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;remove_outlier_curves=True&#34;, width=30)
    outlierRemLabel.grid(row=5, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)

    
    def on_remove_outlier_curves():
        try:
            bool(self.outlierRembool.get())
            outlierRemLabel.configure(text=&#39;remove_outlier_curves={}&#39;.format(self.outlierRembool.get()))
            #if self.outlierRembool.get():
            #    outlierRemStDev.state([&#39;active&#39;])
            #else:
            #    outlierRemStDev.state([&#39;disabled&#39;])

            update_procHVSR_call(self.procHVSR_call)
            return True
        except ValueError:
            return False
        
    self.outlierRembool = tk.BooleanVar()
    self.outlierRembool.set(True)
    ttk.Label(master=hvsrSettingsFrame, text=&#39;Remove Outlier H/V Curves [bool]&#39;).grid(row=5, column=0, padx=(5,0), sticky=&#39;w&#39;)
    resampleCurveBool = ttk.Checkbutton(master=hvsrSettingsFrame, text=&#34;&#34;, compound=&#39;left&#39;, variable=self.outlierRembool, command=on_remove_outlier_curves) # create the Checkbutton widget
    resampleCurveBool.grid(row=5, column=1, sticky=&#39;w&#39;)

    #outlier_curve_std=1.75
    outlierValLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;outlier_curve_std=1.75&#34;, width=30)
    outlierValLabel.grid(row=6, column=0, sticky=&#39;ew&#39;, pady=(6,6), padx=5)        

    
    def on_outlier_std():
        try:
            float(self.outlierRemStDev.get())
            outlierValLabel.configure(text=&#39;resample={}&#39;.format(self.outlierRemStDev.get()))                
            update_procHVSR_call(self.procHVSR_call)
            return True
        except ValueError:
            return False
        
    ttk.Label(master=hvsrSettingsFrame, text=&#39;Outlier St. Dev. [float]&#39;).grid(row=6, column=0, columnspan=2, padx=(5,0), sticky=&#39;w&#39;)
    self.outlierRemStDev = tk.DoubleVar()
    self.outlierRemStDev.set(1.75)
    outlierRemStDev = ttk.Entry(master=hvsrSettingsFrame, textvariable=self.outlierRemStDev, width=10, validate=&#39;focusout&#39;, validatecommand=on_outlier_std)
    outlierRemStDev.grid(row=6, column=1, sticky=&#39;w&#39;, padx=(5, 10))

    separator = ttk.Separator(hvsrSettingsFrame, orient=&#39;horizontal&#39;)
    separator.grid(row=7, columnspan=7, sticky=&#39;ew&#39;, pady=10)

    #hvsr_band=[0.4, 40]
    hvsrBandLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;hvsr_band=[0.4,40]&#34;, width=30)
    hvsrBandLabel.grid(row=7, column=0, sticky=&#39;w&#39;, pady=(20,6), padx=5)

    ttk.Label(hvsrSettingsFrame,text=&#34;HVSR Band [Hz]&#34;).grid(row=8,column=0, sticky=&#39;w&#39;, padx=(5,0))

    hvsr_band_min_settingsEntry = ttk.Entry(hvsrSettingsFrame, width=10, textvariable=self.hvsrBand_min, validate=&#39;focusout&#39;, validatecommand=on_hvsrband_update)
    hvsr_band_min_settingsEntry.grid(row=8,column=1, sticky=&#39;ew&#39;)

    hvsr_band_max_settingsEntry = ttk.Entry(hvsrSettingsFrame, width=10, textvariable=self.hvsrBand_max, validate=&#39;focusout&#39;, validatecommand=on_hvsrband_update)
    hvsr_band_max_settingsEntry.grid(row=8,column=2, sticky=&#39;ew&#39;)

    #peak_water_level=1.8
    pwaterLevLabel = ttk.Label(master=hvsrParamsFrame, text=&#34;peak_water_level=1.8&#34;, width=30)
    pwaterLevLabel.grid(row=8, column=0, sticky=&#39;w&#39;, pady=(6,6), padx=5)        

    
    def on_pwaterlevel_update():
        try:
            float(self.peak_water_level.get())

            pwaterLevLabel.configure(text=&#39;peak_water_level={}&#39;.format(self.peak_water_level.get()))                
            update_check_peaks_call(self.checkPeaks_Call)
            return True
        except ValueError:
            return False      
            
    ttk.Label(hvsrSettingsFrame,text=&#34;Peak Water Level&#34;).grid(row=9, column=0, sticky=&#39;w&#39;, padx=5)

    self.peak_water_level = tk.DoubleVar()
    self.peak_water_level.set(1.8)
    pWaterLevelEntry = ttk.Entry(hvsrSettingsFrame, width=10, textvariable=self.peak_water_level, validate=&#39;focusout&#39;, validatecommand=on_pwaterlevel_update)
    pWaterLevelEntry.grid(row=9, column=1, sticky=&#39;w&#39;)

    #Process HVSR Function Call
    hvsrCallFrame = ttk.LabelFrame(hvsr_settings_tab, text=&#39;sprit_hvsr.process_hvsr() Call&#39;)#.pack(fill=&#39;both&#39;)
    
    self.procHVSR_call = ttk.Label(master=hvsrCallFrame, text=&#39;process_hvsr({}, {}, {}, {}, {}, \n\t{}, {}, {}, {}, {})&#39;
              .format(&#39;params&#39;, hCombMethodLabel.cget(&#39;text&#39;), hvSmoothLabel.cget(&#39;text&#39;), freqSmoothLabel.cget(&#39;text&#39;), fSmoothWidthlabel.cget(&#39;text&#39;), resampleLabel.cget(&#39;text&#39;), 
                      outlierRemLabel.cget(&#39;text&#39;), outlierValLabel.cget(&#39;text&#39;), hvsrBandLabel.cget(&#39;text&#39;), pwaterLevLabel.cget(&#39;text&#39;)))
    self.procHVSR_call.pack(anchor=&#39;w&#39;, padx=(25,0), pady=(10,10))

    
    def update_procHVSR_call(procHVSR_call):
        procHVSR_call.configure(text=&#39;process_hvsr({}, {}, {}, {}, {}, \n\t{}, {}, {}, {}, {})&#39;
              .format(&#39;params&#39;, hCombMethodLabel.cget(&#39;text&#39;), hvSmoothLabel.cget(&#39;text&#39;), freqSmoothLabel.cget(&#39;text&#39;), fSmoothWidthlabel.cget(&#39;text&#39;), resampleLabel.cget(&#39;text&#39;), 
                      outlierRemLabel.cget(&#39;text&#39;), outlierValLabel.cget(&#39;text&#39;), hvsrBandLabel.cget(&#39;text&#39;), pwaterLevLabel.cget(&#39;text&#39;)))
    
    #Check Peaks Function Call
    checkPeaksCallFrame = ttk.LabelFrame(hvsr_settings_tab, text=&#39;sprit_hvsr.check_peaks() Call&#39;)#.pack(fill=&#39;both&#39;)

    self.checkPeaks_Call = ttk.Label(master=checkPeaksCallFrame, text=&#39;check_peaks({}, {}, {})&#39;
              .format(&#39;hvsr_data&#39;, hvsrBandLabel.cget(&#39;text&#39;), pwaterLevLabel.cget(&#39;text&#39;)))
    self.checkPeaks_Call.pack(anchor=&#39;w&#39;, padx=(25,0), pady=(10,10))

    #check_peaks(hvsr_dict, hvsr_band=[0.4, 40], peak_water_level=1.8)
    
    def update_check_peaks_call(checkPeaks_Call):
        checkPeaks_Call.configure(text=&#39;check_peaks({}, {}, {})&#39;
              .format(&#39;hvsr_data&#39;, hvsrBandLabel.cget(&#39;text&#39;), pwaterLevLabel.cget(&#39;text&#39;)))


    #Run button frame
    runFrame_set_hvsr = ttk.Frame(hvsr_settings_tab)
    self.run_button = ttk.Button(runFrame_set_hvsr, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)
    self.run_button.pack(side=&#39;bottom&#39;, anchor=&#39;e&#39;)

    #Pack tab
    runFrame_set_hvsr.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;, anchor=&#39;e&#39;)    
    checkPeaksCallFrame.pack(fill=&#39;both&#39;, expand=True, side=&#39;bottom&#39;)#.grid(row=10, column=0, columnspan=6, sticky=&#39;nsew&#39;)#.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
    hvsrCallFrame.pack(fill=&#39;both&#39;, expand=True, side=&#39;bottom&#39;)#.grid(row=9, column=0, columnspan=6, sticky=&#39;nsew&#39;)#.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
    hvsrParamsFrame.pack(fill=&#39;both&#39;, side=&#39;right&#39;)#.grid(row=0, column=6, rowspan=4, sticky=&#39;nsew&#39;)#.pack(side=&#39;right&#39;,fill=&#39;both&#39;, anchor=&#39;n&#39;, expand=True)
    hvsrSettingsFrame.pack(fill=&#39;both&#39;, expand=True, side=&#39;top&#39;)#.grid(row=0, column=0, columnspan=6, rowspan=4, sticky=&#39;nsew&#39;)#.pack(fill=&#39;both&#39;, expand=True)
    
    hvsr_settings_tab.pack(fill=&#39;both&#39;, expand=True)           
    settings_notebook.add(hvsr_settings_tab, text=&#34;HVSR Settings&#34;)

    #PLOT SETTINGS TAB
    plot_settings_tab = ttk.Frame(settings_notebook)

    # Create the Plot Options LabelFrame
    plot_options_frame = ttk.LabelFrame(plot_settings_tab, text=&#34;Plot Options&#34;)

    
    def update_hvplot_call():
        kindstr = get_kindstr()
        hvplot_label.configure(text=&#34;hvplot({}, kind={}, xtype=&#39;{}&#39;, {}, {})&#34;.format(&#39;hvsr_data&#39;, kindstr, self.x_type.get(), &#39;[...]&#39;, &#39;kwargs&#39;))

    # Create the Checkbuttons for the plot options
    ttk.Label(plot_options_frame, text=&#39;HVSR Plot&#39;, justify=&#39;center&#39;).grid(row=0, column=1, sticky=&#39;ew&#39;, padx=(5, 5))
    ttk.Label(plot_options_frame, text=&#39;Components H/V Plot&#39;, justify=&#39;center&#39;).grid(row=0, column=2, sticky=&#39;ew&#39;, padx=(5, 5))
    ttk.Label(plot_options_frame, text=&#39;Spectrogram Plot&#39;, justify=&#39;center&#39;).grid(row=0, column=3, sticky=&#39;ew&#39;, padx=(5, 5))

    self.hvsr_chart_bool = tk.BooleanVar()
    self.hvsr_chart_bool.set(True)
    ttk.Checkbutton(plot_options_frame, text=&#39;&#39;, variable=self.hvsr_chart_bool, command=update_hvplot_call).grid(row=1, column=1, sticky=&#39;nsew&#39;, padx=15, pady=(5, 20))
    self.ind_comp_chart_bool = tk.BooleanVar()
    self.ind_comp_chart_bool.set(True)
    ttk.Checkbutton(plot_options_frame, text=&#39;&#39;, variable=self.ind_comp_chart_bool, command=update_hvplot_call).grid(row=1, column=2, sticky=&#39;nsew&#39;, padx=50, pady=(5, 20))
    self.spec_chart_bool = tk.BooleanVar()
    self.spec_chart_bool.set(True)
    ttk.Checkbutton(plot_options_frame, text=&#39;&#39;, variable=self.spec_chart_bool, command=update_hvplot_call).grid(row=1, column=3, sticky=&#39;nsew&#39;, padx=25, pady=(5, 20))
    
    ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=2, columnspan=5, sticky=&#39;ew&#39;, pady=5)
    
    #Separate component chart: c+
    ttk.Label(plot_options_frame, text=&#39;Show Components on same chart as H/V Curve:&#39;).grid(row=3, column=0, sticky=&#39;w&#39;, padx=5)
    
    
    def disable_comp_buttons():
        if self.show_comp_with_hv.get():
            self.annotate_best_peak_comp.set(False)
            self.show_best_peak_comp.set(False)
            bestPeakCompButton.config(state=&#34;disabled&#34;) 
            bestPeakCompAnnButton.config(state=&#39;disabled&#39;)
        else:
            bestPeakCompButton.config(state=&#34;normal&#34;) 
            bestPeakCompAnnButton.config(state=&#39;normal&#39;)
        update_hvplot_call()

    self.show_comp_with_hv = tk.BooleanVar()
    self.show_comp_with_hv.set(False)
    ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_comp_with_hv, 
                    command=disable_comp_buttons).grid(row=3, column=2, sticky=&#34;ew&#34;, padx=50)

    ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=4, columnspan=5, sticky=&#39;ew&#39;, pady=5)

    #Show Best Peak: p
    ttk.Label(plot_options_frame, text=&#39;Show Best Peak:&#39;).grid(row=5, column=0, sticky=&#39;w&#39;, padx=5)

    self.show_best_peak_hv = tk.BooleanVar()
    self.show_best_peak_hv.set(True)
    ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_best_peak_hv, command=update_hvplot_call).grid(row=5, column=1, sticky=&#34;ew&#34;, padx=15)

    self.show_best_peak_comp = tk.BooleanVar()
    self.show_best_peak_comp.set(True)
    bestPeakCompButton=ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_best_peak_comp, command=update_hvplot_call)
    bestPeakCompButton.grid(row=5, column=2, sticky=&#34;ew&#34;, padx=50)

    self.show_best_peak_spec = tk.BooleanVar()
    self.show_best_peak_spec.set(False)
    ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_best_peak_spec, command=update_hvplot_call).grid(row=5, column=3, sticky=&#34;ew&#34;, padx=25)

    ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=6, columnspan=5, sticky=&#39;ew&#39;)

    #Annotate Best Peak: ann
    ttk.Label(plot_options_frame, text=&#39;Annotate Best Peak:&#39;).grid(row=7, column=0, sticky=&#39;w&#39;, padx=5)

    self.annotate_best_peak_hv = tk.BooleanVar()
    self.annotate_best_peak_hv.set(True)
    ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.annotate_best_peak_hv, command=update_hvplot_call).grid(row=7, column=1, sticky=&#34;ew&#34;, padx=15)

    self.annotate_best_peak_comp = tk.BooleanVar()
    self.annotate_best_peak_comp.set(True)
    bestPeakCompAnnButton=ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.annotate_best_peak_comp, command=update_hvplot_call)
    bestPeakCompAnnButton.grid(row=7, column=2, sticky=&#34;ew&#34;, padx=50)

    self.annotate_best_peak_spec = tk.BooleanVar()
    self.annotate_best_peak_spec.set(True)
    ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.annotate_best_peak_spec, command=update_hvplot_call).grid(row=7, column=3, sticky=&#34;ew&#34;, padx=25)

    ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=8, columnspan=5, sticky=&#39;ew&#39;)


    #Show all peaks (main H/V curve): all
    ttk.Label(plot_options_frame, text=&#39;Show All Peaks (H/V Curve):&#39;).grid(row=9, column=0, sticky=&#39;w&#39;, padx=5)

    self.show_all_peaks_hv = tk.BooleanVar()
    self.show_all_peaks_hv.set(False)
    ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_all_peaks_hv, command=update_hvplot_call).grid(row=9, column=1, sticky=&#34;ew&#34;, padx=15)

    ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=10, columnspan=5, sticky=&#39;ew&#39;)

    #Show all curves: t
    ttk.Label(plot_options_frame, text=&#39;Show All H/V Curves:&#39;).grid(row=11, column=0, sticky=&#39;w&#39;, padx=5)

    self.show_ind_curves = tk.BooleanVar()
    self.show_ind_curves.set(False)
    ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_ind_curves, command=update_hvplot_call).grid(row=11, column=1, sticky=&#34;ew&#34;, padx=15)

    ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=12, columnspan=5, sticky=&#39;ew&#39;)

    #Show individual peaks (tp): tp
    ttk.Label(plot_options_frame, text=&#39;Show Individual Peaks:&#39;).grid(row=13, column=0, sticky=&#39;w&#39;, padx=5)

    self.show_ind_peaks = tk.BooleanVar()
    self.show_ind_peaks.set(False)
    ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_ind_peaks, command=update_hvplot_call).grid(row=13, column=1, sticky=&#34;ew&#34;, padx=15)

    ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=14, columnspan=5, sticky=&#39;ew&#39;)

    #Show individual peaks (tp): tp
    ttk.Label(plot_options_frame, text=&#39;Show Standard Deviation:&#39;).grid(row=15, column=0, sticky=&#39;w&#39;, padx=5)

    self.show_stDev_hv = tk.BooleanVar()
    self.show_stDev_hv.set(True)
    ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_stDev_hv, command=update_hvplot_call).grid(row=15, column=1, sticky=&#34;ew&#34;, padx=15)

    self.show_stDev_comp = tk.BooleanVar()
    self.show_stDev_comp.set(True)
    ttk.Checkbutton(plot_options_frame, text=&#34;&#34;, variable=self.show_stDev_comp, command=update_hvplot_call).grid(row=15, column=2, sticky=&#34;ew&#34;, padx=50)

    ttk.Separator(plot_options_frame, orient=&#39;horizontal&#39;).grid(row=16, columnspan=5, sticky=&#39;ew&#39;)

    #Specify X-Type
    ttk.Label(plot_options_frame, text=&#39;X Type:&#39;).grid(row=17, column=0, sticky=&#39;w&#39;, padx=5, pady=10)

    self.x_type = tk.StringVar()
    self.x_type.set(&#39;freq&#39;)
    ttk.Radiobutton(master=plot_options_frame, text=&#39;Frequency&#39;, variable=self.x_type, value=&#39;freq&#39;, command=update_hvplot_call).grid(row=17, column=1, sticky=&#39;w&#39;, padx=(5, 10), pady=10)
    ttk.Radiobutton(master=plot_options_frame, text=&#39;Period&#39;, variable=self.x_type, value=&#39;period&#39;, command=update_hvplot_call).grid(row=17, column=2, sticky=&#39;w&#39;, padx=(5, 10), pady=10)

    #kwargs
    ttk.Label(plot_options_frame, text=&#39;Matplotlib Keyword Arguments (not implemented):&#39;).grid(row=18, column=0, sticky=&#39;w&#39;, padx=5, pady=10)

    self.plot_kwargs = tk.StringVar()
    self.plot_kwargs.set(&#34;cmap=&#39;turbo&#39;&#34;)
    ttk.Entry(plot_options_frame, textvariable=self.plot_kwargs).grid(row=18, column=1, columnspan=3, sticky=&#34;ew&#34;, pady=10)

    plot_options_frame.pack(fill=&#39;both&#39;, expand=True)#.grid(row=1, column=0, padx=10, pady=10, sticky=&#34;nsew&#34;)

    # Create the hvplot Call LabelFrame
    hvplot_call_frame = ttk.LabelFrame(plot_settings_tab, text=&#34;hvplot() Call&#34;)

    #HVSR
    
    def get_kindstr():
        if self.hvsr_chart_bool.get():
            kindstr_hv = &#39;HVSR&#39;
            if self.show_best_peak_hv.get():
                kindstr_hv = kindstr_hv + &#39; p&#39;
            if self.annotate_best_peak_hv.get():
                kindstr_hv = kindstr_hv + &#39; ann&#39;
            if self.show_all_peaks_hv.get():
                kindstr_hv = kindstr_hv + &#39; all&#39;
            if self.show_ind_curves.get():
                kindstr_hv = kindstr_hv + &#39; t&#39;
            if self.show_ind_peaks.get():
                kindstr_hv = kindstr_hv + &#39;p&#39;
            if not self.show_stDev_hv.get():
                kindstr_hv = kindstr_hv + &#39; -s&#39;
        else:
            kindstr_hv = &#39;&#39;

        #Comp
        if self.ind_comp_chart_bool.get():
            kindstr_c = &#39;c&#39;

            if not self.show_comp_with_hv.get():
                kindstr_c = kindstr_c + &#39;+&#39;

                if self.show_best_peak_comp.get():
                    kindstr_c = kindstr_c + &#39; p&#39;
                if self.annotate_best_peak_comp.get():
                    kindstr_c = kindstr_c + &#39; ann&#39;
            if not self.show_stDev_comp.get():
                kindstr_c = kindstr_c + &#39; -s&#39;
        else:
            kindstr_c = &#39;&#39;

        #Specgram
        if self.spec_chart_bool.get():
            kindstr_spec = &#39;Spec&#39;

            if self.show_best_peak_spec.get():
                kindstr_spec = kindstr_spec + &#39; p&#39;
            if self.annotate_best_peak_spec.get():
                kindstr_spec = kindstr_spec + &#39; ann&#39;
        else:
            kindstr_spec = &#39;&#39;
        kindstr = kindstr_hv + &#39; &#39; +  kindstr_c + &#39; &#39; + kindstr_spec
        return kindstr
    

    # Add a Label widget to the hvplot Call Label section
    hvplot_label = ttk.Label(hvplot_call_frame, text=&#34;hvplot({}, kind=&#39;{}&#39;, xtype=&#39;{}&#39;, {}, {})&#34;.format(&#39;hvsr_data&#39;, get_kindstr(), self.x_type.get(), &#39;[...]&#39;, &#39;kwargs&#39;))

    #Run button frame
    runFrame_set_plot = ttk.Frame(plot_settings_tab)

    self.run_button = ttk.Button(runFrame_set_plot, text=&#34;Run&#34;, style=&#39;Run.TButton&#39;, command=process_data)

    
    def update_results_plot():
        self.tab_control.select(self.results_tab)
        sprit_hvsr.hvplot(self.hvsr_results, plot_type=get_kindstr(), fig=self.fig_results, ax=self.ax_results, use_subplots=True, clear_fig=False)

    self.update_results_plot_button = ttk.Button(runFrame_set_plot, text=&#34;Update Plot&#34;, style=&#39;Noise.TButton&#39;, command=update_results_plot, width=30)
    
    self.run_button.pack(side=&#39;right&#39;, anchor=&#39;se&#39;, padx=(10,0))
    self.update_results_plot_button.pack(side=&#39;right&#39;, anchor=&#39;se&#39;)

    runFrame_set_plot.pack(fill=&#39;both&#39;, side=&#39;bottom&#39;, anchor=&#39;e&#39;)
    hvplot_label.pack(fill=&#39;both&#39;, expand=True, padx=(10,0))#.grid(column=0, row=0, padx=10, pady=10, sticky=&#34;w&#34;)
    hvplot_call_frame.pack(fill=&#39;both&#39;, expand=True)#.grid(row=2, column=0, padx=10, pady=10, sticky=&#34;nsew&#34;)

    plot_settings_tab.pack(fill=&#39;both&#39;, expand=True)
    settings_notebook.add(plot_settings_tab, text=&#34;Plot Settings&#34;)

    # Pack the settings Notebook widget
    settings_notebook.pack(expand=True, fill=&#39;both&#39;)
    self.tab_control.add(self.settings_tab, text=&#34;Settings&#34;)

    # RESULTS TAB
    self.results_tab = ttk.Frame(self.tab_control)

    # Create the Batch Site selection LabelFrame
    self.results_siteSelectFrame = ttk.LabelFrame(self.results_tab, text=&#34;HVSR Results&#34;)
    self.results_siteSelectLabel = ttk.Label(self.results_siteSelectFrame, text=&#39;Select Site to display&#39;)


    # Create the hvplot Call LabelFrame
    self.results_chartFrame = ttk.LabelFrame(self.results_tab, text=&#34;Data Plots&#34;)

    #Set up plot     
    #results_mosaic = [[&#39;hvsr&#39;],[&#39;comp&#39;],[&#39;spec&#39;]]
    #self.fig_results, self.ax_results = plt.subplot_mosaic(results_mosaic)  
    #self.results_canvas = FigureCanvasTkAgg(self.fig_results, master=self.results_chartFrame)
    #self.results_canvas.draw()
    #self.results_canvasWidget = self.results_canvas.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)

    self.fig_results = plt.figure()
    results_mosaic = [[&#39;hvsr&#39;],[&#39;comp&#39;],[&#39;spec&#39;]]
    self.ax_results = self.fig_results.subplot_mosaic(results_mosaic)

    self.results_canvas = FigureCanvasTkAgg(self.fig_results, master=self.results_chartFrame)  # A tk.DrawingArea.
    self.results_canvas.draw()
    self.results_canvasWidget = self.results_canvas.get_tk_widget()#.pack(side=tk.TOP, fill=tk.BOTH, expand=1)
    self.results_toolbar = NavigationToolbar2Tk(self.results_canvas, self.results_chartFrame, pack_toolbar=False)
    self.results_toolbar.update()
    self.results_toolbar.pack(fill=tk.X, side=tk.BOTTOM, expand=False)
    self.results_canvasWidget.pack(fill=&#39;both&#39;, expand=True)#.grid(row=0, column=0, sticky=&#39;nsew&#39;)

    #Peak report
    results_peakInfoFrame = ttk.LabelFrame(self.results_tab, text=&#34;Peak Report&#34;)
    curveTitleLabel = ttk.Label(results_peakInfoFrame, text=&#39;Criteria for Reliable H/V Curve (all 3 must pass)&#39;)
    curveTest1Label = ttk.Label(results_peakInfoFrame, text=&#39;Window Length for Frequency&#39;)
    curveTest1ResultFrame = ttk.Frame(results_peakInfoFrame)
    curveTest1ResultText = ttk.Label(curveTest1ResultFrame, text=&#39;&#39;)
    curveTest1Result = ttk.Label(curveTest1ResultFrame, text=&#39;&#39;)

    curveTest2Label = ttk.Label(results_peakInfoFrame, text=&#39;Number of Significant Cycles&#39;)
    curveTest2ResultFrame = ttk.Frame(results_peakInfoFrame)
    curveTest2ResultText = ttk.Label(curveTest2ResultFrame, text=&#39;&#39;)
    curveTest2Result = ttk.Label(curveTest2ResultFrame, text=&#39;&#39;)

    curveTest3Label = ttk.Label(results_peakInfoFrame, text=&#39;Low Curve Standard Deviation for Frequencies Near Peak Over Time&#39;)
    curveTest3ResultFrame = ttk.Frame(results_peakInfoFrame)
    curveTest3ResultText = ttk.Label(curveTest3ResultFrame, text=&#39;&#39;)
    curveTest3Result = ttk.Label(curveTest3ResultFrame, text=&#39;&#39;)

    totalCurveResult = ttk.Label(results_peakInfoFrame, text=&#39;&#39;)

    peakTitleLabel = ttk.Label(results_peakInfoFrame, text=&#39;Criteria for a Clear H/V Peak (5/6 must pass)&#39;)
    peakTest1Label = ttk.Label(results_peakInfoFrame, text=&#39;H/V Amplitude is low Below Peak Frequency&#39;)
    peakTest1ResultFrame = ttk.Frame(results_peakInfoFrame)
    peakTest1ResultText = ttk.Label(peakTest1ResultFrame, text=&#39;&#39;)
    peakTest1Result = ttk.Label(peakTest1ResultFrame, text=&#39;&#39;)
    
    peakTest2Label = ttk.Label(results_peakInfoFrame, text=&#39;H/V Amplitude is low Above Peak Frequency&#39;)
    peakTest2ResultFrame = ttk.Frame(results_peakInfoFrame)
    peakTest2ResultText = ttk.Label(peakTest2ResultFrame, text=&#39;&#39;)
    peakTest2Result = ttk.Label(peakTest2ResultFrame, text=&#39;&#39;)
    
    peakTest3Label = ttk.Label(results_peakInfoFrame, text=&#39;Peak is Prominent&#39;)
    peakTest3ResultFrame = ttk.Frame(results_peakInfoFrame)
    peakTest3ResultText = ttk.Label(peakTest3ResultFrame, text=&#39;&#39;)
    peakTest3Result = ttk.Label(peakTest3ResultFrame, text=&#39;&#39;)
    
    peakTest4Label = ttk.Label(results_peakInfoFrame, text=&#39;Frequency of Peak is Stationary Over Time&#39;)
    peakTest4ResultFrame = ttk.Frame(results_peakInfoFrame)
    peakTest4ResultText = ttk.Label(peakTest4ResultFrame, text=&#39;&#39;)
    peakTest4Result = ttk.Label(peakTest4ResultFrame, text=&#39;&#39;)
    
    peakTest5Label = ttk.Label(results_peakInfoFrame, text=&#39;Standard Deviation of Peak Frequency is low &#39;)
    peakTest5ResultFrame = ttk.Frame(results_peakInfoFrame)
    peakTest5ResultText = ttk.Label(peakTest5ResultFrame, text=&#39;&#39;)
    peakTest5Result = ttk.Label(peakTest5ResultFrame, text=&#39;&#39;)
    
    peakTest6Label = ttk.Label(results_peakInfoFrame, text=&#39;Standard Deviation of Peak Amplitude is low&#39;)
    peakTest6ResultFrame = ttk.Frame(results_peakInfoFrame)
    peakTest6ResultText = ttk.Label(peakTest6ResultFrame, text=&#39;&#39;)
    peakTest6Result = ttk.Label(peakTest6ResultFrame, text=&#39;&#39;)

    totalPeakResult = ttk.Label(results_peakInfoFrame, text=&#39;&#39;)

    totalResult = ttk.Label(results_peakInfoFrame, text=&#39;&#39;)

    curveTitleLabel.grid(row=0, sticky=&#39;w&#39;, padx=5, pady=2.5)
    curveTitleLabel.configure(font=(&#34;TkDefaultFont&#34;, 12, &#39;underline&#39;, &#39;bold&#39;))
    curveTest1Label.grid(row=1, sticky=&#39;w&#39;, padx=5, pady=2.5)
    curveTest1ResultFrame.grid(row=2, sticky=&#39;ew&#39;, padx=5, pady=2.5)
    curveTest1ResultFrame.columnconfigure(0, weight=1)
    curveTest1ResultFrame.columnconfigure(1, weight=6)
    curveTest1ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
    curveTest1Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

    curveTest2Label.grid(row=3, sticky=&#39;w&#39;, padx=5, pady=2.5)
    curveTest2ResultFrame.grid(row=4, sticky=&#39;ew&#39;, padx=5, pady=2.5)
    curveTest2ResultFrame.columnconfigure(0, weight=1)
    curveTest2ResultFrame.columnconfigure(1, weight=6)
    curveTest2ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
    curveTest2Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

    curveTest3Label.grid(row=5, sticky=&#39;w&#39;, padx=5, pady=2.5)
    curveTest3ResultFrame.grid(row=6, sticky=&#39;ew&#39;, padx=5, pady=2.5)
    curveTest3ResultFrame.columnconfigure(0, weight=1)
    curveTest3ResultFrame.columnconfigure(1, weight=6)
    curveTest3ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
    curveTest3Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

    totalCurveResult.grid(row=7, sticky=&#39;e&#39;, padx=5, pady=10 )

    ttk.Separator(results_peakInfoFrame).grid(row=8, sticky=&#39;ew&#39;, pady=5)
    
    peakTitleLabel.grid(row=9, sticky=&#39;w&#39;, padx=5, pady=2.5)
    peakTitleLabel.configure(font=(&#34;TkDefaultFont&#34;, 12, &#39;underline&#39;, &#39;bold&#39;))
    
    peakTest1Label.grid(row=11, sticky=&#39;w&#39;, padx=5, pady=2.5)
    peakTest1ResultFrame.grid(row=12, sticky=&#39;ew&#39;, padx=5, pady=2.5)
    peakTest1ResultFrame.columnconfigure(0, weight=1)
    peakTest1ResultFrame.columnconfigure(1, weight=6)
    peakTest1ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
    peakTest1Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

    peakTest2Label.grid(row=13, sticky=&#39;w&#39;, padx=5, pady=2.5)
    peakTest2ResultFrame.grid(row=14, sticky=&#39;ew&#39;, padx=5, pady=2.5)
    peakTest2ResultFrame.columnconfigure(0, weight=1)
    peakTest2ResultFrame.columnconfigure(1, weight=6)
    peakTest2ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
    peakTest2Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

    peakTest3Label.grid(row=15, sticky=&#39;w&#39;, padx=5, pady=2.5)
    peakTest3ResultFrame.grid(row=16, sticky=&#39;ew&#39;, padx=5, pady=2.5)
    peakTest3ResultFrame.columnconfigure(0, weight=1)
    peakTest3ResultFrame.columnconfigure(1, weight=6)
    peakTest3ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
    peakTest3Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

    peakTest4Label.grid(row=17, sticky=&#39;w&#39;, padx=5, pady=2.5)
    peakTest4ResultFrame.grid(row=18, sticky=&#39;ew&#39;, padx=5, pady=2.5)
    peakTest4ResultFrame.columnconfigure(0, weight=1)
    peakTest4ResultFrame.columnconfigure(1, weight=6)
    peakTest4ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
    peakTest4Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

    peakTest5Label.grid(row=19, sticky=&#39;w&#39;, padx=5, pady=2.5)
    peakTest5ResultFrame.grid(row=20, sticky=&#39;ew&#39;, padx=5, pady=2.5)
    peakTest5ResultFrame.columnconfigure(0, weight=1)
    peakTest5ResultFrame.columnconfigure(1, weight=6)
    peakTest5ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
    peakTest5Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

    peakTest6Label.grid(row=21, sticky=&#39;w&#39;, padx=5, pady=2.5)
    peakTest6ResultFrame.grid(row=22, sticky=&#39;ew&#39;, padx=5, pady=2.5)
    peakTest6ResultFrame.columnconfigure(0, weight=1)
    peakTest6ResultFrame.columnconfigure(1, weight=6)
    peakTest6ResultText.grid(row=0, column=0, sticky=&#39;e&#39;, padx=5, pady=2.5)
    peakTest6Result.grid(row=0, column=1, sticky=&#39;e&#39;, padx=5, pady=2.5)

    totalPeakResult.grid(row=23, sticky=&#39;e&#39;, padx=5, pady=10 )

    ttk.Separator(results_peakInfoFrame).grid(row=24, sticky=&#39;ew&#39;, pady=5)

    totalResult.grid(row=25, sticky=&#39;e&#39;, padx=5, pady=10 )

    #Export results
    results_export_Frame = ttk.LabelFrame(self.results_tab, text=&#34;Export Results&#34;)
    
    ttk.Label(results_export_Frame, text=&#34;Export Figure&#34;).grid(row=0, column=0, sticky=&#39;ew&#39;, padx=5)
    self.results_fig_dir = tk.StringVar()
    self.results_fig_dir_entry = ttk.Entry(results_export_Frame, textvariable=self.results_fig_dir)
    self.results_fig_dir_entry.grid(row=0, column=1, columnspan=5, sticky=&#39;ew&#39;)
    
    
    def filepath_results_fig():
        filepath = filedialog.asksaveasfilename(defaultextension=&#39;png&#39;, initialdir=pathlib.Path(self.data_path.get()).parent, initialfile=self.params[&#39;site&#39;]+&#39;_results.png&#39;)
        if filepath:
            self.results_fig_dir_entry.delete(0, &#39;end&#39;)
            self.results_fig_dir_entry.insert(0, filepath)
    
    
    def save_results_fig():
        if not self.save_ind_subplots.get():
            self.fig_results.savefig(self.results_fig_dir.get())
        else:
            print(&#39;working on individual subplots&#39;)
            for key in self.ax_results.keys():
                extent = self.ax_results[key].get_tightbbox(self.fig_results.canvas.renderer).transformed(self.fig_results.dpi_scale_trans.inverted())
                self.fig_results.savefig(pathlib.Path(self.results_fig_dir.get()).parent.as_posix()+&#39;/Subplot&#39;+key+&#39;.png&#39;,  bbox_inches=extent)
    

    self.browse_results_fig = ttk.Button(results_export_Frame, text=&#34;Browse&#34;,command=filepath_results_fig)
    self.browse_results_fig.grid(row=0, column=7, sticky=&#39;ew&#39;, padx=2.5)
    
    self.save_results_fig = ttk.Button(results_export_Frame, text=&#34;Save&#34;,command=save_results_fig)
    self.save_results_fig.grid(row=0, column=8, columnspan=2, sticky=&#39;ew&#39;, padx=2.5)

    #Save subplots individually
    self.save_ind_subplots = tk.BooleanVar()
    self.save_ind_subplots.set(False)
    ttk.Checkbutton(results_export_Frame, text=&#34;Save ind. subplots&#34;, variable=self.save_ind_subplots).grid(row=0, column=10, sticky=&#34;ew&#34;, padx=5)

    self.browse_results_fig = ttk.Button(results_export_Frame, text=&#34;Update Plot&#34;,command=update_results_plot)
    self.browse_results_fig.grid(row=1, column=10, sticky=&#39;ew&#39;, padx=(7.5, 2.5))


    results_export_Frame.columnconfigure(1, weight=1)
    results_export_Frame.pack(side=&#39;bottom&#39;, fill=&#39;both&#39;)

    #Export Peak Report        
    ttk.Label(results_export_Frame, text=&#34;Export Peak Report&#34;).grid(row=1, column=0, sticky=&#39;ew&#39;, padx=5)
    self.results_report_dir = tk.StringVar()
    self.results_report_dir_entry = ttk.Entry(results_export_Frame, textvariable=self.results_report_dir)
    self.results_report_dir_entry.grid(row=1, column=1, columnspan=5, sticky=&#39;ew&#39;)
    
    
    def filepath_report_fig():
        filepath = filedialog.asksaveasfilename(defaultextension=&#39;csv&#39;, initialdir=pathlib.Path(self.data_path.get()).parent, initialfile=self.params[&#39;site&#39;]+&#39;_peakReport.csv&#39;)
        if filepath:
            self.results_report_dir_entry.delete(0, &#39;end&#39;)
            self.results_report_dir_entry.insert(0, filepath)
    
    
    def save_report_fig():
        sprit_hvsr.get_report(self.hvsr_results, format=&#39;plot&#39;,  export=self.results_report_dir.get())

    self.browse_results_fig = ttk.Button(results_export_Frame, text=&#34;Browse&#34;,command=filepath_report_fig)
    self.browse_results_fig.grid(row=1, column=7, sticky=&#39;ew&#39;, padx=2.5)
    
    self.save_results_fig = ttk.Button(results_export_Frame, text=&#34;Save&#34;,command=save_report_fig)
    self.save_results_fig.grid(row=1, column=8, columnspan=2, sticky=&#39;ew&#39;, padx=2.5)

    results_peakInfoFrame.pack(side=&#39;right&#39;, fill=&#39;both&#39;)
    self.results_chartFrame.pack(side=&#39;top&#39;, expand=True, fill=&#39;both&#39;)
    results_export_Frame.pack(side=&#39;bottom&#39;, fill=&#39;x&#39;)
    
    # Add tabs to tab control
    self.tab_control.add(self.results_tab, text=&#34;Results&#34;)

    # Pack tab control
    self.tab_control.pack(expand=True, fill=&#34;both&#34;)</code></pre>
</details>
</dd>
<dt id="sprit.sprit_gui.SPRIT_App.manual_label_update"><code class="name flex">
<span>def <span class="ident">manual_label_update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def manual_label_update(self):
    for notebook in self.master.winfo_children():
        if isinstance(notebook, ttk.Notebook):
            for tab_id in notebook.tabs():
                tab_frame = notebook.nametowidget(tab_id)
                #print(type(tab_frame))
                for frame in tab_frame.winfo_children():
                    if isinstance(frame, ttk.LabelFrame):
                        for widget in frame.winfo_children():
                            if isinstance(widget, ttk.Label):
                                # apply the updated style to the label
                                
                                self.style.layout(&#39;CustTLabel&#39;, [(&#39;Label.border&#39;, {&#39;sticky&#39;: &#39;nswe&#39;, &#39;border&#39;: &#39;1&#39;, &#39;children&#39;: [(&#39;Label.padding&#39;, {&#39;sticky&#39;: &#39;nswe&#39;, &#39;children&#39;: [(&#39;Label.text&#39;, {&#39;sticky&#39;: &#39;nswe&#39;})]})]})])
                                self.style.configure(&#39;CustTLabel&#39;, background=self.style.lookup(&#39;style&#39;, &#39;background&#39;), foreground=self.style.lookup(&#39;style&#39;, &#39;background&#39;))
                                self.style.map(&#39;CustTLabel&#39;, {&#39;priority&#39;:[(&#39;CustTLabel&#39;,1)]})
                                widget.configure(style=&#39;CustTLabel&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#returns">Returns</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sprit" href="index.html">sprit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sprit.sprit_gui.catch_errors" href="#sprit.sprit_gui.catch_errors">catch_errors</a></code></li>
<li><code><a title="sprit.sprit_gui.on_closing" href="#sprit.sprit_gui.on_closing">on_closing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sprit.sprit_gui.SPRIT_App" href="#sprit.sprit_gui.SPRIT_App">SPRIT_App</a></code></h4>
<ul class="">
<li><code><a title="sprit.sprit_gui.SPRIT_App.create_menubar" href="#sprit.sprit_gui.SPRIT_App.create_menubar">create_menubar</a></code></li>
<li><code><a title="sprit.sprit_gui.SPRIT_App.create_tabs" href="#sprit.sprit_gui.SPRIT_App.create_tabs">create_tabs</a></code></li>
<li><code><a title="sprit.sprit_gui.SPRIT_App.manual_label_update" href="#sprit.sprit_gui.SPRIT_App.manual_label_update">manual_label_update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>