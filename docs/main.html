<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>sprit API documentation</title>
<meta name="description" content="This module enables analysis of ambient seismic data using the Horizontal to Vertical Spectral Ratio (HVSR) technique.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>sprit</code></h1>
</header>
<section id="section-intro">
<p>This module enables analysis of ambient seismic data using the Horizontal to Vertical Spectral Ratio (HVSR) technique.</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="sprit.sprit_calibration" href="sprit_calibration.html">sprit.sprit_calibration</a></code></dt>
<dd>
<div class="desc"><p>This module will be used for calibration of the ambient HVSR data acquired near wells
to derive a relation between the resonant frequency and the …</p></div>
</dd>
<dt><code class="name"><a title="sprit.sprit_cli" href="sprit_cli.html">sprit.sprit_cli</a></code></dt>
<dd>
<div class="desc"><p>This module/script is used to run sprit from the command line …</p></div>
</dd>
<dt><code class="name"><a title="sprit.sprit_hvsr" href="sprit_hvsr.html">sprit.sprit_hvsr</a></code></dt>
<dd>
<div class="desc"><p>This module is the main SpRIT module that contains all the functions needed to run HVSR analysis …</p></div>
</dd>
<dt><code class="name"><a title="sprit.sprit_jupyter_UI" href="sprit_jupyter_UI.html">sprit.sprit_jupyter_UI</a></code></dt>
<dd>
<div class="desc"><p>Functions to create jupyter notebook widget UI</p></div>
</dd>
<dt><code class="name"><a title="sprit.sprit_plot" href="sprit_plot.html">sprit.sprit_plot</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="sprit.sprit_streamlit_ui" href="sprit_streamlit_ui.html">sprit.sprit_streamlit_ui</a></code></dt>
<dd>
<div class="desc"><p>This file contains the code to run the SpRIT app (via streamlit) both locally and on the web.</p></div>
</dd>
<dt><code class="name"><a title="sprit.sprit_utils" href="sprit_utils.html">sprit.sprit_utils</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sprit.batch_data_read"><code class="name flex">
<span>def <span class="ident">batch_data_read</span></span>(<span>batch_data,<br>batch_type='table',<br>param_col=None,<br>batch_params=None,<br>verbose=False,<br>**readcsv_getMeta_fetch_kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def batch_data_read(batch_data, batch_type=&#39;table&#39;, param_col=None, batch_params=None, verbose=False, **readcsv_getMeta_fetch_kwargs):
    &#34;&#34;&#34;Function to read data in data as a batch of multiple data files. 
      This is best used through sprit.fetch_data(*args, source=&#39;batch&#39;, **other_kwargs).

    Parameters
    ----------
    batch_data : filepath or list
        Input data information for how to read in data as batch. Can be filepath or list of filepaths/stream objects.
        If filepath, should point to .csv (or similar that can be read by pandas.read_csv()) with batch data information.
    batch_type : str, optional
        Type of batch read, only &#39;table&#39; and &#39;filelist&#39; accepted. 
        If &#39;table&#39;, will read data from a file read in using pandas.read_csv(), by default &#39;table&#39;
    param_col : None or str, optional
        Name of parameter column from batch information file. Only used if a batch_type=&#39;table&#39; and single parameter column is used, rather than one column per parameter (for single parameter column, parameters are formatted with = between keys/values and , between item pairs), by default None
    batch_params : list, dict, or None, default = None
        Parameters to be used if batch_type=&#39;filelist&#39;. If it is a list, needs to be the same length as batch_data. If it is a dict, will be applied to all files in batch_data and will combined with extra keyword arguments caught by **readcsv_getMeta_fetch_kwargs.
    verbose : bool, optional
        Whether to print information to terminal during batch read, by default False
    **readcsv_getMeta_fetch_kwargs
        Keyword arguments that will be read into pandas.read_csv(), sprit.input_params, sprit.get_metadata(), and/or sprit.fetch_data()

    Returns
    -------
    hvsrBatch
        HVSRBatch object with each item representing a different HVSRData object

    Raises
    ------
    IndexError
        _description_
    &#34;&#34;&#34;

    if verbose:
        print(f&#39;Processing batch data from {batch_type}:&#39;)
        print(f&#34;  Batch data source: {batch_data}&#34;)

    # First figure out which parameters go with which function
    input_params_params = inspect.signature(input_params).parameters
    get_metadata_params = inspect.signature(get_metadata).parameters
    fetch_data_params = inspect.signature(fetch_data).parameters
    calculate_azimuth_params = inspect.signature(calculate_azimuth).parameters
    remove_noise_params = inspect.signature(remove_noise).parameters
    generate_ppsds_params = inspect.signature(generate_psds).parameters
    remove_outlier_curves_params = inspect.signature(remove_outlier_curves).parameters
    process_hvsr_params = inspect.signature(process_hvsr).parameters
    check_peaks_params = inspect.signature(check_peaks).parameters
    get_report_params = inspect.signature(get_report).parameters
  
    dict_of_params = {&#39;input_params&#39;: input_params_params,
                      &#39;get_metadata&#39;: get_metadata_params,
                      &#39;fetch_data_params&#39;: fetch_data_params,
                      &#39;calculate_azimuth_params&#39;: calculate_azimuth_params,
                      &#39;remove_noise_params&#39;: remove_noise_params,
                      &#39;generate_ppsds_params&#39;: generate_ppsds_params,
                      &#39;remove_outlier_curves_params&#39;: remove_outlier_curves_params,
                      &#39;process_hvsr_params&#39;: process_hvsr_params,
                      &#39;check_peaks_params&#39;: check_peaks_params,
                      &#39;get_report_params&#39;: get_report_params}
    
    def __get_run_functions():
        # Get a list of all functions (for which paramters are used) in sprit.run()
        run_functions_list = [input_params, fetch_data, batch_data_read,
                            get_metadata, calculate_azimuth, 
                            remove_noise, generate_psds, remove_outlier_curves, 
                            process_hvsr, check_peaks, 
                            get_report, export_hvsr]
        
        return run_functions_list
    SPRIT_RUN_FUNCTIONS = __get_run_functions()
    # Get default values of all functions in a dict
    default_dict = {}
    for i, fun in enumerate(SPRIT_RUN_FUNCTIONS):
        for param_name, param_info in inspect.signature(fun).parameters.items():
            if param_info.default is not inspect._empty:
                default_dict[param_name] = param_info.default
    
    if batch_type == &#39;sample&#39; or batch_data in sampleFileKeyMap.keys():
        sample_data = True
        batch_type = &#39;table&#39;
    else:
        sample_data = False
    
    # Dictionary to store the stream objects
    stream_dict = {}
    data_dict = {}
    if batch_type == &#39;table&#39;:
        # If this is sample data, we need to create absolute paths to the filepaths
        if sample_data:
            dataReadInfoDF = pd.read_csv(sampleFileKeyMap[&#39;sample_batch&#39;])
            for index, row in dataReadInfoDF.iterrows():
                dataReadInfoDF.loc[index, &#39;input_data&#39;] = SAMPLE_DATA_DIR.joinpath(row.loc[&#39;input_data&#39;])
        elif isinstance(batch_data, pd.DataFrame):
            dataReadInfoDF = batch_data
        elif isinstance(batch_data, dict):
            # For params input
            dataReadInfoDF = pd.DataFrame.from_dict(batch_data)
            pass
        else:  # Read csv
            read_csv_kwargs = {k: v for k, v in locals()[&#39;readcsv_getMeta_fetch_kwargs&#39;].items() if k in inspect.signature(pd.read_csv).parameters}
            dataReadInfoDF = pd.read_csv(batch_data, **read_csv_kwargs)
            if &#39;input_data&#39; in dataReadInfoDF.columns:
                filelist = list(dataReadInfoDF[&#39;input_data&#39;])

        # Generate site names if they don&#39;t exist already           
        if &#39;site&#39; not in dataReadInfoDF.columns:
            siterows = []
            filldigs = len(str(dataReadInfoDF.shape[0]))  # Number of digits in df shape
            for i, row in dataReadInfoDF.iterrows():
                siterows.append(f&#39;HVSRSite_{str(i).zfill(filldigs)}&#39;)
            dataReadInfoDF[&#39;site&#39;] = siterows

        # Print information about batch read, as specified
        print(f&#34;  {dataReadInfoDF.shape[0]} sites found: {list(dataReadInfoDF[&#39;site&#39;])}&#34;)
        if verbose:
            maxLength = 25
            maxColWidth = 12
            if dataReadInfoDF.shape[0] &gt; maxLength:
                print(f&#39;\t Showing information for first {maxLength} files only:&#39;)
            print()
            
            # Print nicely formatted df
            # Print column names
            print(&#39;  &#39;, end=&#39;&#39;)
            for col in dataReadInfoDF.columns:
                print(str(col)[:maxColWidth].ljust(maxColWidth), end=&#39;  &#39;)
            
            print(&#39;\n&#39;, end=&#39;&#39;)
            # Print separator
            tableLen = (maxColWidth+2)*len(dataReadInfoDF.columns)
            for r in range(tableLen):
                print(&#39;-&#39;, end=&#39;&#39;)
            print()

            #Print columns/rows
            for index, row in dataReadInfoDF.iterrows():
                print(&#39;  &#39;, end=&#39;&#39;)
                for col in row:
                    if len(str(col)) &gt; maxColWidth:
                        print((str(col)[:maxColWidth-3]+&#39;...&#39;).ljust(maxColWidth), end=&#39;  &#39;)
                    else:
                        print(str(col)[:maxColWidth].ljust(maxColWidth), end=&#39;  &#39;)
                print()
            if dataReadInfoDF.shape[0] &gt; maxLength:
                endline = f&#39;\t...{dataReadInfoDF.shape[0]-maxLength} more rows in file.\n&#39;
            else:
                endline = &#39;\n&#39;
            print(endline)

            print(&#39;Fetching the following files:&#39;)
            
        # Get processing parameters, either from column param_col or from individual columns
        # If param_col, format is string of format: &#34;param_name=param_val, param_name2=param_val2&#34;
        param_dict_list = []
        verboseStatement = []
        if param_col is None:  # Not a single parameter column, each col=parameter
            for row_ind in range(dataReadInfoDF.shape[0]):
                param_dict = {}
                verboseStatement.append([])
                for col in dataReadInfoDF.columns:
                    for fun in SPRIT_RUN_FUNCTIONS:
                        if col in inspect.signature(fun).parameters:
                            currParam = dataReadInfoDF.loc[row_ind, col]
                            if pd.isna(currParam) or currParam == &#39;nan&#39;:
                                if col in default_dict.keys():
                                    param_dict[col] = default_dict[col]  # Get default value
                                    if verbose:
                                        if type(default_dict[col]) is str:
                                            verboseStatement[row_ind].append(&#34;\t\t&#39;{}&#39; parameter not specified in batch file. Using {}=&#39;{}&#39;&#34;.format(col, col, default_dict[col]))
                                        else:
                                            verboseStatement[row_ind].append(&#34;\t\t&#39;{}&#39; parameter not specified in batch file. Using {}={}&#34;.format(col, col, default_dict[col]))
                                else:
                                    param_dict[col] = None
                            else:
                                param_dict[col] = dataReadInfoDF.loc[row_ind, col]
                param_dict_list.append(param_dict)
        else:
            if param_col not in dataReadInfoDF.columns:
                raise IndexError(&#39;{} is not a column in {} (columns are: {})&#39;.format(param_col, batch_data, dataReadInfoDF.columns))
            for row in dataReadInfoDF[param_col]:
                param_dict = {}
                splitRow = str(row).split(&#39;,&#39;)
                for item in splitRow:
                    param_dict[item.split(&#39;=&#39;)[0]] = item.split(&#39;=&#39;)[1]
                param_dict_list.append(param_dict)

    elif batch_type == &#39;filelist&#39;:
        if not isinstance(batch_data, (list, tuple)):
            raise RuntimeError(f&#34;If batch_type is specified as &#39;filelist&#39; or &#39;list&#39;, batch_data must be list or tuple, not {type(batch_data)}.&#34;)

        # Update formatting of batch_params for rest of processing
        if batch_params is None:
            batch_params = [{}] * len(batch_data)
        
        # Get batch_parameters
        if isinstance(batch_params, list):
            if len(batch_params) != len(batch_data):
                raise RuntimeError(&#39;If batch_params is list, it must be the same length as batch_data. len(batch_params)={} != len(batch_data)={}&#39;.format(len(batch_params), len(batch_data)))
            param_dict_list = batch_params
        elif isinstance(batch_params, dict):
            batch_params.update(readcsv_getMeta_fetch_kwargs)
            param_dict_list = []
            for i in range(len(batch_data)):
                param_dict_list.append(batch_params)
        
        # Read and process each MiniSEED file
        for i, file in enumerate(batch_data):
            param_dict_list[i][&#39;input_data&#39;] = file
    
    # Get a uniformly formatted input DataFrame
    input_df_uniformatted = pd.DataFrame(param_dict_list)   
    
    # Do batch fun of input_params() and fetch_data() (these are skipped in run() if batch mode is used)
    hvsr_batchDict = {}
    zfillDigs = len(str(len(param_dict_list)))  # Get number of digits of length of param_dict_list
    i = 0
    for i, param_dict in enumerate(param_dict_list):       
        # Read the data file into a Stream object
        input_params_kwargs = {k: v for k, v in locals()[&#39;readcsv_getMeta_fetch_kwargs&#39;].items() if k in inspect.signature(input_params).parameters}
        input_params_kwargs2 = {k: v for k, v in param_dict.items() if k in inspect.signature(input_params).parameters}
        input_params_kwargs.update(input_params_kwargs2)

        # Run input_params()
        try:
            ipverboseString = &#39;\tinput_params: &lt;No parameters specified&gt;, &#39;
            for arg, value in input_params_kwargs.items():
                ipverboseString = ipverboseString.replace(&#39;&lt;No parameters specified&gt;, &#39;, &#39;&#39;)                    
                ipverboseString += f&#34;{arg}={value}, &#34;
            ipverboseString = ipverboseString[:-2]
            ipverboseString = (ipverboseString[:96] + &#39;...&#39;) if len(ipverboseString) &gt; 99 else ipverboseString

            params = input_params(**input_params_kwargs)
        except Exception as e:
            params = input_params_kwargs
            params[&#39;processing_status&#39;] = {}
            params[&#39;processing_status&#39;][&#39;input_params_status&#39;] = False
            params[&#39;processing_status&#39;][&#39;overall_status&#39;] = False 
            verboseStatement.append(f&#34;\t{e}&#34;)

        # Run fetch_data()
        fetch_data_kwargs = {k: v for k, v in locals()[&#39;readcsv_getMeta_fetch_kwargs&#39;].items() if k in inspect.signature(fetch_data).parameters}
        fetch_data_kwargs2 = {k: v for k, v in param_dict.items() if k in inspect.signature(fetch_data).parameters}
        fetch_data_kwargs.update(fetch_data_kwargs2)
        
        try:
            fdverboseString = &#39;\tfetch_data: &lt;No parameters specified&gt;, &#39;
            for arg, value in fetch_data_kwargs.items():
                fdverboseString = fdverboseString.replace(&#39;&lt;No parameters specified&gt;, &#39;, &#39;&#39;)
                fdverboseString += f&#34;{arg}={value}, &#34;
            fdverboseString = fdverboseString[:-2]
            fdverboseString = (fdverboseString[:96] + &#39;...&#39;) if len(fdverboseString) &gt; 99 else fdverboseString
                
            hvsrData = fetch_data(params=params, **fetch_data_kwargs)
        except Exception as e:
            hvsrData = params
            hvsrData[&#39;processing_status&#39;][&#39;fetch_data_status&#39;] = False
            hvsrData[&#39;processing_status&#39;][&#39;overall_status&#39;] = False
            verboseStatement.append(f&#34;\t{e}&#34;)
    
        if verbose and hvsrData[&#39;processing_status&#39;][&#39;overall_status&#39;]:
            print(f&#34;  {hvsrData[&#39;site&#39;]}&#34;)
            print(ipverboseString)
            print(fdverboseString)
            if verboseStatement != []:
                for item in verboseStatement[i]:
                    print(item)
        elif verbose and not hvsrData[&#39;processing_status&#39;][&#39;overall_status&#39;]:
            if &#39;site&#39; in param_dict.keys():
                sitename = param_dict[&#39;site&#39;]
            else:
                sitename = &#39;UNSPECIFIED_SITE&#39;
                
            print(f&#34;  {sitename}&#34;)
            print(ipverboseString)
            print(fdverboseString)
            if verboseStatement != []:
                for item in verboseStatement[i]:
                    print(item)
            print(f&#34;     *{sitename} not read correctly. Processing will not be carried out.&#34;)

        hvsrData[&#39;batch&#39;] = True

        # This may be redundant
        if hvsrData[&#39;site&#39;] == default_dict[&#39;site&#39;]:  # If site was not designated
            hvsrData[&#39;site&#39;] = &#34;{}_{}&#34;.format(hvsrData[&#39;site&#39;], str(i).zfill(zfillDigs))
            i += 1
            
        # Get processing parameters for other functions in sprit.run() besides input_params and fetch_data
        if &#39;processing_parameters&#39; in hvsrData.keys():
            processing_parameters = hvsrData[&#39;processing_parameters&#39;].copy()
        else:
            processing_parameters = {}  # &#34;input_params&#34;: input_params_kwargs, &#34;fetch_data&#34;: fetch_data_kwargs}

        for fun in SPRIT_RUN_FUNCTIONS:
            specified_params = {k: v for k, v in param_dict.items() if k in inspect.signature(fun).parameters}
            processing_parameters[fun.__name__] = specified_params

        # Assume source is &#39;file&#39; if not specified
        hvsrData[&#39;processing_parameters&#39;] = processing_parameters
        if &#39;source&#39; not in hvsrData[&#39;processing_parameters&#39;][&#39;fetch_data&#39;].keys():
            hvsrData[&#39;processing_parameters&#39;][&#39;fetch_data&#39;][&#39;source&#39;] = &#39;file&#39;
        
        hvsr_batchDict[hvsrData[&#39;site&#39;]] = hvsrData

    hvsrBatch = HVSRBatch(hvsr_batchDict, df_as_read=input_df_uniformatted)

    print()
    print(&#39;Finished reading input data in preparation for batch processing&#39;)
    return hvsrBatch</code></pre>
</details>
<div class="desc"><p>Function to read data in data as a batch of multiple data files.
This is best used through sprit.fetch_data(<em>args, source='batch', </em>*other_kwargs).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>batch_data</code></strong> :&ensp;<code>filepath</code> or <code>list</code></dt>
<dd>Input data information for how to read in data as batch. Can be filepath or list of filepaths/stream objects.
If filepath, should point to .csv (or similar that can be read by pandas.read_csv()) with batch data information.</dd>
<dt><strong><code>batch_type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Type of batch read, only 'table' and 'filelist' accepted.
If 'table', will read data from a file read in using pandas.read_csv(), by default 'table'</dd>
<dt><strong><code>param_col</code></strong> :&ensp;<code>None</code> or <code>str</code>, optional</dt>
<dd>Name of parameter column from batch information file. Only used if a batch_type='table' and single parameter column is used, rather than one column per parameter (for single parameter column, parameters are formatted with = between keys/values and , between item pairs), by default None</dd>
<dt><strong><code>batch_params</code></strong> :&ensp;<code>list, dict,</code> or <code>None</code>, default <code>= None</code></dt>
<dd>Parameters to be used if batch_type='filelist'. If it is a list, needs to be the same length as batch_data. If it is a dict, will be applied to all files in batch_data and will combined with extra keyword arguments caught by **readcsv_getMeta_fetch_kwargs.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print information to terminal during batch read, by default False</dd>
<dt><strong><code>**readcsv_getMeta_fetch_kwargs</code></strong></dt>
<dd>Keyword arguments that will be read into pandas.read_csv(), sprit.input_params, sprit.get_metadata(), and/or sprit.fetch_data()</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hvsrBatch</code></dt>
<dd>HVSRBatch object with each item representing a different HVSRData object</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>IndexError</code></dt>
<dd><em>description</em></dd>
</dl></div>
</dd>
<dt id="sprit.calculate_azimuth"><code class="name flex">
<span>def <span class="ident">calculate_azimuth</span></span>(<span>hvsr_data,<br>azimuth_angle=45,<br>azimuth_type='multiple',<br>azimuth_unit='degrees',<br>show_az_plot=False,<br>verbose=False,<br>**plot_azimuth_kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_azimuth(hvsr_data, azimuth_angle=45, azimuth_type=&#39;multiple&#39;, azimuth_unit=&#39;degrees&#39;, 
                      show_az_plot=False, verbose=False, **plot_azimuth_kwargs):
    &#34;&#34;&#34;Function to calculate azimuthal horizontal component at specified angle(s). 
       Adds each new horizontal component as a radial component to obspy.Stream object at hvsr_data[&#39;stream&#39;]

    Parameters
    ----------
    hvsr_data : HVSRData
        Input HVSR data
    azimuth_angle : int, default=10
        If `azimuth_type=&#39;multiple&#39;`, this is the angular step (in unit `azimuth_unit`) of each of the azimuthal measurements.
        If `azimuth_type=&#39;single&#39;` this is the angle (in unit `azimuth_unit`) of the single calculated azimuthal measruement. By default 10.
    azimuth_type : str, default=&#39;multiple&#39;
        What type of azimuthal measurement to make, by default &#39;multiple&#39;.
        If &#39;multiple&#39; (or {&#39;multi&#39;, &#39;mult&#39;, &#39;m&#39;}), will take a measurement at each angular step of azimuth_angle of unit azimuth_unit.
        If &#39;single&#39; (or {&#39;sing&#39;, &#39;s&#39;}), will take a single azimuthal measurement at angle specified in azimuth_angle.
    azimuth_unit : str, default=&#39;degrees&#39;
        Angular unit used to specify `azimuth_angle` parameter. By default &#39;degrees&#39;.
        If &#39;degrees&#39; (or {&#39;deg&#39;, &#39;d&#39;}), will use degrees.
        If &#39;radians&#39; (or {&#39;rad&#39;, &#39;r&#39;}), will use radians.
    show_az_plot : bool, default=False
        Whether to show azimuthal plot, by default False.
    verbose : bool, default=False
        Whether to print terminal output, by default False

    Returns
    -------
    HVSRData
        Updated HVSRData object specified in hvsr_data with hvsr_data[&#39;stream&#39;] attribute containing additional components (EHR-***),
        with *** being zero-padded (3 digits) azimuth angle in degrees.
    &#34;&#34;&#34;
    # Get intput paramaters
    orig_args = locals().copy()
    start_time = datetime.datetime.now()

    # Update with processing parameters specified previously in input_params, if applicable
    if &#39;processing_parameters&#39; in hvsr_data.keys():
        if &#39;calculate_azimuth&#39; in hvsr_data[&#39;processing_parameters&#39;].keys():
            update_msg = []
            for k, v in hvsr_data[&#39;processing_parameters&#39;][&#39;calculate_azimuth&#39;].items():
                defaultVDict = dict(zip(inspect.getfullargspec(calculate_azimuth).args[1:], 
                                        inspect.getfullargspec(calculate_azimuth).defaults))
                # Manual input to function overrides the imported parameter values
                if (not isinstance(v, (HVSRData, HVSRBatch))) and (k in orig_args.keys()) and (orig_args[k]==defaultVDict[k]):
                    update_msg.append(f&#39;\t\t{k} = {v} (previously {orig_args[k]})&#39;)
                    orig_args[k] = v
                                     
    azimuth_angle = orig_args[&#39;azimuth_angle&#39;]
    azimuth_unit = orig_args[&#39;azimuth_unit&#39;]
    show_az_plot = orig_args[&#39;show_az_plot&#39;]
    verbose = orig_args[&#39;verbose&#39;]

    if (verbose and isinstance(hvsr_data, HVSRBatch)) or (verbose and not hvsr_data[&#39;batch&#39;]):
        if isinstance(hvsr_data, HVSRData) and hvsr_data[&#39;batch&#39;]:
            pass
        else:
            print(&#39;\nGenerating azimuthal data (calculate_azimuth())&#39;)
            print(&#39;\tUsing the following parameters:&#39;)
            for key, value in orig_args.items():
                if key == &#39;hvsr_data&#39;:
                    pass
                else:
                    print(&#39;\t  {}={}&#39;.format(key, value))

            if &#39;processing_parameters&#39; in hvsr_data.keys() and &#39;calculate_azimuth&#39; in hvsr_data[&#39;processing_parameters&#39;].keys():
                if update_msg != []:
                    print()
                    update_msg.insert(0, &#39;\tThe following parameters were updated using the processing_parameters attribute:&#39;)
                    for msg_line in update_msg:
                        print(msg_line)
                    print()

    if isinstance(hvsr_data, HVSRBatch):
        # If running batch, we&#39;ll loop through each site
        hvsr_out = {}
        for site_name in hvsr_data.keys():
            args = orig_args.copy() #Make a copy so we don&#39;t accidentally overwrite
            args[&#39;hvsr_data&#39;] = hvsr_data[site_name] #Get what would normally be the &#34;hvsr_data&#34; variable for each site
            if hvsr_data[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;]:
                try:
                   hvsr_out[site_name] = __azimuth_batch(**args) #Call another function, that lets us run this function again
                except Exception as e:
                    hvsr_out[site_name][&#39;processing_status&#39;][&#39;calculate_azimuths_status&#39;] = False
                    hvsr_out[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;] = False
                    if verbose:
                        print(e)
            else:
                hvsr_data[site_name][&#39;processing_status&#39;][&#39;calculate_azimuths_status&#39;] = False
                hvsr_data[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;] = False
                hvsr_out = hvsr_data

        output = HVSRBatch(hvsr_out, df_as_read=hvsr_data.input_df)
        return output
    elif isinstance(hvsr_data, (HVSRData, dict, obspy.Stream)):

        degList = [&#39;degrees&#39;, &#39;deg&#39;, &#39;d&#39;, &#39;°&#39;]
        radList = [&#39;radians&#39;, &#39;rad&#39;, &#39;r&#39;]
        if azimuth_unit.lower() in degList:
            az_angle_rad = np.deg2rad(azimuth_angle)
            az_angle_deg = azimuth_angle
        elif azimuth_unit.lower() in radList:
            az_angle_rad = azimuth_angle
            az_angle_deg = np.rad2deg(azimuth_angle)
        else:
            warnings.warn(f&#34;azimuth_unit={azimuth_unit} not supported. Try &#39;degrees&#39; or &#39;radians&#39;. No azimuthal analysis run.&#34;)
            return hvsr_data

        # Limit to 1-180 (and &#34;right&#34; half of compass) (will be reflected on other half if applicable to save computation time)
        conversion_message = &#39;&#39;
        will_convert = False
        if az_angle_deg &lt; 0:
            will_convert = True
            conversion_message = conversion_message + &#39;converted to a positive value&#39;
            if az_angle_deg &lt; -180:
                conversion_message = conversion_message + &#39; between 0 and 180 degrees&#39;

        if az_angle_deg &gt; 180:
            will_convert = True
            conversion_message = conversion_message + &#39; converted to a value between 0 and 180 degrees&#39;

        if will_convert:
            conversion_message = f&#34;\tThe azimuth angle specified will be{conversion_message}&#34;

        if verbose:
            print(conversion_message, end=f&#39;: {az_angle_deg}&#39;)
        # Convert angle to 0-180
        az_angle_deg = az_angle_deg - (180 * (az_angle_deg // 180))
        az_angle_rad = az_angle_rad = np.deg2rad(azimuth_angle)

        if verbose:
            print(f&#39; degrees --&gt; {az_angle_deg} degrees.&#39;)

        multAzList = [&#39;multiple azimuths&#39;, &#39;multiple&#39;, &#39;multi&#39;, &#39;mult&#39;, &#39;m&#39;]
        singleAzList = [&#39;single azimuth&#39;, &#39;single&#39;, &#39;sing&#39;, &#39;s&#39;]
        if azimuth_type.lower() in multAzList:
            azimuth_list = list(np.arange(0, np.pi, az_angle_rad))
            azimuth_list_deg = list(np.arange(0, 180, az_angle_deg))
        elif azimuth_type.lower() in singleAzList:
            azimuth_list = [az_angle_rad]
            azimuth_list_deg = [az_angle_deg]
        else:
            warnings.warn(f&#34;azimuth_type={azimuth_type} not supported. Try &#39;multiple&#39; or &#39;single&#39;. No azimuthal analysis run.&#34;)
            return hvsr_data

        if isinstance(hvsr_data, (HVSRData, dict)):
            zComp = hvsr_data[&#39;stream&#39;].select(component=&#39;Z&#39;).merge()
            eComp = hvsr_data[&#39;stream&#39;].select(component=&#39;E&#39;).merge()
            nComp = hvsr_data[&#39;stream&#39;].select(component=&#39;N&#39;).merge()
        elif isinstance(hvsr_data, obspy.Stream):
            zComp = hvsr_data.select(component=&#39;Z&#39;).merge()
            eComp = hvsr_data.select(component=&#39;E&#39;).merge()
            nComp = hvsr_data.select(component=&#39;N&#39;).merge()          

        # Reset stats for original data too
        zComp[0].stats[&#39;azimuth_deg&#39;] = 0
        eComp[0].stats[&#39;azimuth_deg&#39;] = 90
        nComp[0].stats[&#39;azimuth_deg&#39;] = 0

        zComp[0].stats[&#39;azimuth_rad&#39;] = 0
        eComp[0].stats[&#39;azimuth_rad&#39;] = np.pi/2
        nComp[0].stats[&#39;azimuth_rad&#39;] = 0

        zComp[0].stats[&#39;location&#39;] = &#39;000&#39;
        eComp[0].stats[&#39;location&#39;] = &#39;090&#39;
        nComp[0].stats[&#39;location&#39;] = &#39;000&#39;

        statsDict = {}
        for key, value in eComp[0].stats.items():
            statsDict[key] = value

        for i, az_rad in enumerate(azimuth_list):
            az_deg = azimuth_list_deg[i]
            statsDict[&#39;location&#39;] = f&#34;{str(round(az_deg,0)).zfill(3)}&#34; #Change location name
            statsDict[&#39;channel&#39;] = f&#34;EHR&#34;#-{str(round(az_deg,0)).zfill(3)}&#34; #Change channel name
            statsDict[&#39;azimuth_deg&#39;] = az_deg
            statsDict[&#39;azimuth_rad&#39;] = az_rad

            hasMask = [False, False]
            if np.ma.is_masked(nComp[0].data):
                nData = nComp[0].data.data
                nMask = nComp[0].data.mask
                hasMask[0] = True
            else:
                nData = nComp[0].data
                nMask = [True] * len(nData)

            if np.ma.is_masked(eComp[0].data):
                eData = eComp[0].data.data
                eMask = eComp[0].data.mask
                hasMask[1] = True
            else:
                eData = eComp[0].data
                eMask = [True] * len(eData)

            # From hvsrpy: horizontal = self.ns._amp * math.cos(az_rad) + self.ew._amp*math.sin(az_rad)
            if True in hasMask:
                radial_comp_data = np.ma.array(np.add(nData * np.cos(az_rad), eData * np.sin(az_angle_rad)), mask=list(map(operator.and_, nMask, eMask)))
            else:
                radial_comp_data = np.add(nData * np.cos(az_rad), eData * np.sin(az_rad))

            radial_trace = obspy.Trace(data=radial_comp_data, header=statsDict)
            hvsr_data[&#39;stream&#39;].append(radial_trace)
    
    # Verbose printing
    if verbose and not isinstance(hvsr_data, HVSRBatch):
        dataINStr = hvsr_data.stream.__str__().split(&#39;\n&#39;)
        for line in dataINStr:
            print(&#39;\t\t&#39;, line)
    
    if show_az_plot:
        hvsr_data[&#39;Azimuth_Fig&#39;] = plot_azimuth(hvsr_data=hvsr_data, **plot_azimuth_kwargs)

    hvsr_data[&#39;processing_status&#39;][&#39;calculate_azimuths_status&#39;] = True
    hvsr_data = sprit_utils._check_processing_status(hvsr_data, start_time=start_time, func_name=inspect.stack()[0][3], verbose=verbose)

    return hvsr_data</code></pre>
</details>
<div class="desc"><p>Function to calculate azimuthal horizontal component at specified angle(s).
Adds each new horizontal component as a radial component to obspy.Stream object at hvsr_data['stream']</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code></dt>
<dd>Input HVSR data</dd>
<dt><strong><code>azimuth_angle</code></strong> :&ensp;<code>int</code>, default=<code>10</code></dt>
<dd>If <code>azimuth_type='multiple'</code>, this is the angular step (in unit <code>azimuth_unit</code>) of each of the azimuthal measurements.
If <code>azimuth_type='single'</code> this is the angle (in unit <code>azimuth_unit</code>) of the single calculated azimuthal measruement. By default 10.</dd>
<dt><strong><code>azimuth_type</code></strong> :&ensp;<code>str</code>, default=<code>'multiple'</code></dt>
<dd>What type of azimuthal measurement to make, by default 'multiple'.
If 'multiple' (or {'multi', 'mult', 'm'}), will take a measurement at each angular step of azimuth_angle of unit azimuth_unit.
If 'single' (or {'sing', 's'}), will take a single azimuthal measurement at angle specified in azimuth_angle.</dd>
<dt><strong><code>azimuth_unit</code></strong> :&ensp;<code>str</code>, default=<code>'degrees'</code></dt>
<dd>Angular unit used to specify <code>azimuth_angle</code> parameter. By default 'degrees'.
If 'degrees' (or {'deg', 'd'}), will use degrees.
If 'radians' (or {'rad', 'r'}), will use radians.</dd>
<dt><strong><code>show_az_plot</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to show azimuthal plot, by default False.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to print terminal output, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code></dt>
<dd>Updated HVSRData object specified in hvsr_data with hvsr_data['stream'] attribute containing additional components (EHR-***),
with *** being zero-padded (3 digits) azimuth angle in degrees.</dd>
</dl></div>
</dd>
<dt id="sprit.calculate_depth"><code class="name flex">
<span>def <span class="ident">calculate_depth</span></span>(<span>freq_input,<br>depth_model='ISGS_All',<br>freq_col='Peak',<br>calculate_depth_in_feet=False,<br>calculate_elevation=True,<br>show_depth_curve=True,<br>surface_elevation_data='Elevation',<br>bedrock_elevation_column='BedrockElevation',<br>depth_column='BedrockDepth',<br>verbose=False,<br>export_path=None,<br>swave_velocity=563.0,<br>decimal_places=3,<br>depth_model_in_latex=False,<br>fig=None,<br>ax=None,<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_depth(freq_input,
                    depth_model=&#34;ISGS_All&#34;,
                    freq_col=&#34;Peak&#34;,
                    calculate_depth_in_feet=False,
                    calculate_elevation=True,
                    show_depth_curve=True,
                    surface_elevation_data=&#39;Elevation&#39;,
                    bedrock_elevation_column=&#34;BedrockElevation&#34;,
                    depth_column=&#34;BedrockDepth&#34;,
                    verbose=False,    # if verbose is True, display warnings otherwise not
                    export_path=None,
                    swave_velocity=563.0,
                    decimal_places=3,
                    depth_model_in_latex=False,
                    fig=None,
                    ax=None,
                    #group_by = &#34;County&#34;, -&gt; make a kwarg
                    **kwargs):
    &#34;&#34;&#34;Calculate depth(s) based on a frequency input (usually HVSRData or HVSRBatch oject) and a frequency-depth depth_model (usually a power law relationship).

    Parameters
    ----------
    freq_input : HVSRData, HVSRBatch, float, int, or filepath, optional
        Input with frequency information, by default {sprit_hvsr.HVSRData, sprit_hvsr.HVSRBatch, float, os.PathLike}
    depth_model : str, tuple, list, or dict, optional
        Model describing a relationship between frequency and depth, by default &#34;ISGS_All&#34;
    calculate_depth_in_feet : bool, optional
        Whether to calculate depth in feet (in addition to meters, which is done by default)
    freq_col : str, optional
        Name of the column containing the frequency information of the peak, by default &#34;Peak&#34; (per HVSRData.Table_Report output)
    calculate_elevation : bool, optional
        Whether or not to calculate elevation, by default True
    surface_elevation_data : str or numeric, optional
        The name of the column or a manually specified numeric value to use for the surface elevation value, by default &#34;Elevation&#34;
    bedrock_elevation_column : str, optional
        The name of the column in the TableReport for the bedrock elevation of the point.
        This can be either the name of a column in a table (i.e., Table_Report) or a numeric value, by default &#34;BedrockElevation&#34;
    depth_column : str, optional
        _description_, by default &#34;BedrockDepth&#34;
    verbose : bool, optional
        Whether or not to print information about the processing to the terminal, by default False
    export_path : _type_, optional
        _description_, by default None
    swave_velocity : float, optional
        Shear wave velocity to use for depth calculations in meters/second, 
        if using the quarter wavelength shear wave velocity method, by default 563.0
    decimal_places : int, optional
        Number of decimal places to round depth results, by default 3

    Returns
    -------
    HVSRBatch or list if those are input; otherwise, HVSRData object
        The returns are the same type as freq_input, except filepath which returns pandas.DataFrame

    &#34;&#34;&#34;
    orig_args = locals()
    ip_params, fd_params = __get_ip_df_params()

    # Break out if list (of random or not) items
    if isinstance(freq_input, (list, tuple)):
        outputList = []
        for item in freq_input:
            if &#39;freq_input&#39; in orig_args:
                orig_args.pop(&#39;freq_input&#39;)
            calc_depth_kwargs = orig_args
            outputList.append(calculate_depth(freq_input=item, **calc_depth_kwargs))
        return outputList
    
    # Break out for Batch data
    if isinstance(freq_input, sprit_hvsr.HVSRBatch):
        newBatchList = []
        # Iterate through each site/HVSRData object and run calculate_depth()
        for site in freq_input:
            if &#39;freq_input&#39; in orig_args:
                orig_args.pop(&#39;freq_input&#39;)
            calc_depth_kwargs = orig_args
            newBatchList.append(calculate_depth(freq_input=freq_input[site], **calc_depth_kwargs))
        return sprit_hvsr.HVSRBatch(newBatchList, df_as_read=freq_input.input_df)    
    
    # initialize values
    a = 0
    b = 0
    params = None

    # Fetch parameters for frequency-depth model
    if isinstance(depth_model, (tuple, list, dict)):
        (a, b) = depth_model
        if a == 0 or b == 0:
            raise ValueError(f&#34;Model parameters (a, b)={depth_model} cannot be zero, check model inputs.&#34;)
    elif isinstance(depth_model, str):

        if depth_model.casefold() in list(map(str.casefold, model_parameters)):
            for k, v in model_parameters.items():
                if depth_model.casefold() == k.casefold():
                    (a, b) = v
                    break

        elif depth_model.casefold() in swave:
            params = depth_model.casefold()

        elif depth_model.casefold() == &#34;all&#34;:
            params = depth_model.casefold()

        else:   # parameters a and b could be passed in as a parsable string
            params = depth_model.split(&#39;,&#39;)
            # Work on re update[int(s) for s in re.findall(r&#34;[-+]?(?:\d*\.*\d+)&#34;, 
            # depth_model)]  #figure this out later for floating points; works for integers
            (a, b) = params
            if a == 0 or b == 0:
                raise ValueError(&#34;Parameters cannot be zero, check model inputs&#34;)            

    if b &lt; 0:
        b = b * -1

    # Get frequency input
    # Checking if freq_input is HVSRData object
    if isinstance(freq_input, (sprit_hvsr.HVSRData, str, bytes, os.PathLike, float, int)):
        # Get the table report
        # If not HVSRData object, let&#39;s make a dummy one
        if not isinstance(freq_input, sprit_hvsr.HVSRData):
            # Check if freq_input is float/int, convert to HVSRData (use kwargs too)
            if isinstance(freq_input, (float, int)):
                if freq_input &lt;= 0:
                    raise ValueError(&#34;Peak Frequency cannot be zero or negative&#34;)
                
                if isinstance(surface_elevation_data, numbers.Number):
                    surface_elevation_col = &#39;Elevation&#39;
                else:
                    surface_elevation_col = surface_elevation_data
                
                tableReport = pd.DataFrame(columns=[&#39;Site Name&#39;,
                                                    &#39;Acq_Date&#39;,
                                                    &#39;XCoord&#39;,
                                                    &#39;YCoord&#39;,
                                                    surface_elevation_col,
                                                    freq_col,
                                                    &#39;Peak_StDev&#39;
                                                    &#39;PeakPasses&#39;])
                tableReport.loc[0, freq_col] = freq_input
                
                # Get extra parameters read in via kwargs, if applicable
                paramDict = {&#39;input_data&#39;: &#34;from_user&#34;}
                if isinstance(surface_elevation_data, numbers.Number):
                    kwargs[surface_elevation_col] = surface_elevation_data
                    surface_elevation_data = &#39;Elevation&#39;
                
                for kw, val in kwargs.items():
                    if kw.lower() in [col.lower() for col in tableReport.columns]:
                        colInd = [col.lower() for col in tableReport.columns].index(kw.lower())
                        tableReport.iloc[0, colInd] = val
                        
                    if kw in ip_params or kw in fd_params:
                        paramDict[kw] = val
                paramDict[&#39;Table_Report&#39;] = tableReport
                freq_input = sprit_hvsr.HVSRData(paramDict)
            # Otherwise, assume it is a file to read in
            else:
                if pathlib.Path(freq_input).is_dir():
                    filepathGlob = pathlib.Path(freq_input).glob(&#39;*.hvsr&#39;)
                    batchList = []
                    for hvsrfile in filepathGlob:
                        batchList.append(sprit_hvsr.import_data(hvsrfile))
                    
                    batchArgs = orig_args.copy()
                    try:
                        del batchArgs[&#39;freq_input&#39;]
                    except KeyError:
                        pass
                    
                    hvDataOutList = []
                    for hvData in batchList:
                        hvDataOutList.append(calculate_depth(freq_input=hvData,
                                                             **batchArgs))
                    return sprit_hvsr.HVSRBatch(hvDataOutList)
                # First, check if it is a filepath
                freqDataPath = pathlib.Path(freq_input)
                if not freqDataPath.exists():
                    raise RuntimeError(f&#34;Specified filepath for frequency data does not exist: freq_input={freq_input}&#34;)
                
                if &#39;hvsr&#39; not in freqDataPath.suffix.lower():
                    if verbose:
                        print(&#39;Assuming file is a table readable by pandas.read_csv(), with column containing frequency data specified by freq_col={freq_col}&#39;)
                    tableReport = pd.read_csv(freqDataPath)
                                    
                    # Get parameters from table
                    param_dict_list = [{&#39;input_data&#39;: freq_input,
                                        &#34;Table_Report&#34;: tableReport}] * tableReport.shape[0]
                
                    # Get parameters directly from table
                    tableCols = tableReport.columns
                    for col in tableCols:
                        if col.lower() in ip_params or col.lower() in fd_params:
                            for i, (ind, row) in enumerate(tableReport.iterrows()):
                                param_dict_list[i][col.lower()] = row[col]
                    
                    # Get/overwrite table parameters with directly input parameters
                    hvdList = []
                    for parDict in param_dict_list:
                        for kw, val in kwargs.items():
                            if kw in ip_params or kw in fd_params:
                                parDict[kw] = val
                        hvdList.append(sprit_hvsr.HVSRData(parDict))

                    # Either make HVSRData or HVSRBatch object
                    if len(hvdList) &gt; 1:
                        freq_input = sprit_hvsr.HVSRBatch(hvdList, df_as_read=pd.DataFrame(param_dict_list))
                    else:
                        freq_input = hvdList[0]

                else:
                    if verbose:
                        print(&#39;Assuming file with .*hvsr* suffix is an HVSR data file created by SpRIT.&#39;)
                    freq_input = sprit_hvsr.import_data(freqDataPath)
                    tableReport = freq_input.Table_Report
        elif isinstance(freq_input, sprit_hvsr.HVSRData):
            if not hasattr(freq_input, &#39;Table_Report&#39;):
                if verbose:
                    warn(&#34;Passed HVSRData Object has no attribute Table_Report, attempting to generate one.&#34;)
                tableReport = sprit_hvsr.get_report(freq_input, report_format=&#39;csv&#39;)
            else:
                tableReport = freq_input.Table_Report

        # Break out for Batch data (in case it was generated during readin of file, for example)
        if isinstance(freq_input, sprit_hvsr.HVSRBatch):
            newBatchList = []
            # Iterate through each site/HVSRData object and run calculate_depth()
            for site in freq_input:
                if &#39;freq_input&#39; in orig_args:
                    orig_args.pop(&#39;freq_input&#39;)
                calc_depth_kwargs = orig_args
                newBatchList.append(calculate_depth(freq_input=freq_input[site], **calc_depth_kwargs))
            return sprit_hvsr.HVSRBatch(newBatchList, df_as_read=freq_input.input_df)

        # Calibrate data
        pf_values = tableReport[freq_col].values

        calib_data = []
        depthModelList = []
        depthModelTypeList = []

        for site_peak_freq in pf_values:
            try:
                if depth_model in swave:
                    calib_data.append(swave_velocity/(4*site_peak_freq))
                    
                    if depth_model_in_latex:
                        dModelStr = f&#34;$\\frac{{{swave_velocity}}}{{4\\times{site_peak_freq}}}$&#34;
                    else:
                        dModelStr = f&#34;{swave_velocity}/(4 * {site_peak_freq})&#34;
                    depthModelList.append(dModelStr)
                    depthModelTypeList.append(&#39;Quarter Wavelength&#39;)
                else:
                    if depth_model == &#34;all&#34;:
                        a_list = []
                        b_list = []
                        for name, model_params in model_parameters.items():
                            a_list.append(model_params[0])
                            b_list.append(model_params[1])
                        (a, b) = (np.nanmean(a_list), np.nanmean(b_list))

                    calib_data.append(a*(site_peak_freq**-b))
                    if hasattr(freq_input, &#39;x_freqs&#39;):
                        freq_input[&#39;x_depth_m&#39;] = {&#39;Z&#39;: np.around([a*(f**-b) for f in freq_input[&#34;x_freqs&#34;][&#39;Z&#39;]], decimal_places),
                                                   &#39;E&#39;: np.around([a*(f**-b) for f in freq_input[&#34;x_freqs&#34;][&#39;E&#39;]], decimal_places),
                                                   &#39;N&#39;: np.around([a*(f**-b) for f in freq_input[&#34;x_freqs&#34;][&#39;N&#39;]], decimal_places)}

                        # Calculate depth in feet
                        freq_input[&#39;x_depth_ft&#39;] = {&#39;Z&#39;: np.around(freq_input[&#39;x_depth_m&#39;][&#39;Z&#39;]*3.281, decimal_places),
                                                    &#39;E&#39;: np.around(freq_input[&#39;x_depth_m&#39;][&#39;E&#39;]*3.281, decimal_places),
                                                    &#39;N&#39;: np.around(freq_input[&#39;x_depth_m&#39;][&#39;N&#39;]*3.281, decimal_places)}
                             
                    if depth_model_in_latex:
                        dModelStr = f&#34;{a} \\times {{{site_peak_freq}}}^{{-{b}}}&#34;
                    else:
                        dModelStr = f&#34;{a} * {site_peak_freq}^-{b}&#34;
                    depthModelList.append(dModelStr)
                    depthModelTypeList.append(&#39;Power Law&#39;)

            except Exception as e:
                raise ValueError(&#34;Error in calculating depth, check HVSRData object for empty values or missing columns&#34;) from e

        # Record depth data in table
        tableReport[depth_column] = np.around(calib_data, decimal_places)
        
        # Calculate elevation data
        if calculate_elevation and surface_elevation_data in tableReport.columns:
            tableReport[bedrock_elevation_column] = np.around((float(tableReport.loc[0, surface_elevation_data]) - float(tableReport.loc[0, depth_column])), decimal_places)
            if hasattr(freq_input, &#39;x_depth_m&#39;):
                freq_input[&#39;x_elev_m&#39;] = {&#39;Z&#39;: np.around([float(tableReport[surface_elevation_data].values[0]) - float(f) for f in freq_input[&#34;x_depth_m&#34;][&#39;Z&#39;]], decimal_places),
                                          &#39;E&#39;: np.around([float(tableReport[surface_elevation_data].values[0]) - float(f) for f in freq_input[&#34;x_depth_m&#34;][&#39;E&#39;]], decimal_places),
                                          &#39;N&#39;: np.around([float(tableReport[surface_elevation_data].values[0]) - float(f) for f in freq_input[&#34;x_depth_m&#34;][&#39;N&#39;]], decimal_places)}

        if calculate_depth_in_feet:
            tableReport[depth_column+&#39;_ft&#39;] = np.around(calib_data*3.281,
                                                     decimals=decimal_places)
            if calculate_elevation and surface_elevation_data in tableReport.columns:
                tableReport[bedrock_elevation_column+&#39;_ft&#39;] = np.around(tableReport[bedrock_elevation_column] * 3.281,
                                                                decimals=decimal_places)
                if hasattr(freq_input, &#39;x_elev_m&#39;) and not hasattr(freq_input[&#39;x_depth_ft&#39;]):
                    # Calculate depth in feet
                    freq_input[&#39;x_depth_ft&#39;] = {&#39;Z&#39;: np.around(freq_input[&#39;x_depth_m&#39;][&#39;Z&#39;]*3.281, decimal_places),
                                                &#39;E&#39;: np.around(freq_input[&#39;x_depth_m&#39;][&#39;E&#39;]*3.281, decimal_places),
                                                &#39;N&#39;: np.around(freq_input[&#39;x_depth_m&#39;][&#39;N&#39;]*3.281, decimal_places)}

        tableReport[&#34;DepthModel&#34;] = depthModelList
        tableReport[&#34;DepthModelType&#34;] = depthModelTypeList

        # Do plotting work
        if fig is None and ax is None:
            fig, ax = plt.subplots()
        elif fig is not None:
            ax = fig.get_axes()
            if len(ax) == 1:
                ax = ax[0]

        if hasattr(freq_input, &#39;hvsr_curve&#39;):
            pdc_kwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(sprit_plot.plot_depth_curve).parameters.keys())}
            freq_input = sprit_plot.plot_depth_curve(hvsr_results=freq_input,
                                                     show_depth_curve=show_depth_curve,
                                                     fig=fig, ax=ax,
                                                     **pdc_kwargs)
        else:
            surfElevVal = tableReport.loc[0, surface_elevation_col]
            brElevVal = tableReport.loc[0, bedrock_elevation_column]
            if np.isnan(surfElevVal):
                surfElevVal = 0
                
            if np.isnan(brElevVal):
                brElevVal = tableReport.loc[0, depth_column]
                yLIMITS = [brElevVal*1.1, brElevVal*-0.1]
            else:
                yLIMITS = [0, brElevVal - ((surfElevVal-brElevVal) * 0.1)]

            ax.axhline(0, xmin=-0.1, xmax=1, c=&#39;k&#39;)
            ax.plot([0, 0], [0, brElevVal], linestyle=&#39;dotted&#39;, c=&#39;k&#39;)
            
            ax.scatter(x=0, y=surfElevVal, c=&#39;k&#39;, marker=&#39;v&#39;)
            ax.scatter(x=0, y=brElevVal, c=&#39;k&#39;, marker=&#39;^&#39;)
            
            spc = &#34; &#34;
            ax.text(x=0, y=brElevVal, 
                    s=f&#34;  Depth: {brElevVal}m {spc}({tableReport.loc[0, freq_col]} Hz)&#34;,
                    va=&#39;top&#39;)
            
            ax.set_xlim([-0.1, 1])
            ax.set_ylim(yLIMITS)
            
            ax.set_ylabel(&#39;Depth [m]&#39;)
            ax.set_xticks([])
            titleText = f&#39;Calibrated Depth from Input Frequency&#39;
            fig.suptitle(titleText)
            if isinstance(depth_model, (tuple, list)):
                aText = depth_model[0]
                bText = np.sqrt(depth_model[1]**2)*-1
                ax.text(x=0,
                        y=surfElevVal, va=&#39;bottom&#39;,
                        s=f&#34;  Depth Model: ${aText:.2f} * f_0 ^{{{bText:0.3f}}}$&#34;)
            
        plt.sca(ax)
        if show_depth_curve:
            plt.show()
        else:
            plt.close()
        
        # Export as specified
        if export_path is not None and os.path.exists(export_path):
            if export_path == freq_input:
                tableReport.to_csv(freq_input)
                if verbose:
                    print(&#34;Saving data in the original file&#34;)

            else:
                if &#34;/&#34; in export_path:
                    temp = os.path.join(export_path+ &#34;/&#34;+ site + &#34;.csv&#34;)
                    tableReport.to_csv(temp)
                
                else:
                    temp = os.path.join(export_path+&#34;\\&#34;+ site + &#34;.csv&#34;)
                    tableReport.to_csv(temp)

                if verbose:
                    print(&#34;Saving data to the path specified&#34;)
        
        
        freq_input.Table_Report = tableReport
        return freq_input
            
    else:
        raise RuntimeError(f&#34;The freq_input parameter is not the correct type:\n\ttype(freq_input)={type(freq_input)}&#34;)</code></pre>
</details>
<div class="desc"><p>Calculate depth(s) based on a frequency input (usually HVSRData or HVSRBatch oject) and a frequency-depth depth_model (usually a power law relationship).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>freq_input</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a>, <a title="sprit.HVSRBatch" href="#sprit.HVSRBatch">HVSRBatch</a>, float, int,</code> or <code>filepath</code>, optional</dt>
<dd>Input with frequency information, by default {sprit_hvsr.HVSRData, sprit_hvsr.HVSRBatch, float, os.PathLike}</dd>
<dt><strong><code>depth_model</code></strong> :&ensp;<code>str, tuple, list,</code> or <code>dict</code>, optional</dt>
<dd>Model describing a relationship between frequency and depth, by default "ISGS_All"</dd>
<dt><strong><code>calculate_depth_in_feet</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to calculate depth in feet (in addition to meters, which is done by default)</dd>
<dt><strong><code>freq_col</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the column containing the frequency information of the peak, by default "Peak" (per HVSRData.Table_Report output)</dd>
<dt><strong><code>calculate_elevation</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not to calculate elevation, by default True</dd>
<dt><strong><code>surface_elevation_data</code></strong> :&ensp;<code>str</code> or <code>numeric</code>, optional</dt>
<dd>The name of the column or a manually specified numeric value to use for the surface elevation value, by default "Elevation"</dd>
<dt><strong><code>bedrock_elevation_column</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the column in the TableReport for the bedrock elevation of the point.
This can be either the name of a column in a table (i.e., Table_Report) or a numeric value, by default "BedrockElevation"</dd>
<dt><strong><code>depth_column</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd><em>description</em>, by default "BedrockDepth"</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not to print information about the processing to the terminal, by default False</dd>
<dt><strong><code>export_path</code></strong> :&ensp;<code>_type_</code>, optional</dt>
<dd><em>description</em>, by default None</dd>
<dt><strong><code>swave_velocity</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Shear wave velocity to use for depth calculations in meters/second,
if using the quarter wavelength shear wave velocity method, by default 563.0</dd>
<dt><strong><code>decimal_places</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of decimal places to round depth results, by default 3</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sprit.HVSRBatch" href="#sprit.HVSRBatch">HVSRBatch</a></code> or <code>list if those are input; otherwise, HVSRData object</code></dt>
<dd>The returns are the same type as freq_input, except filepath which returns pandas.DataFrame</dd>
</dl></div>
</dd>
<dt id="sprit.calibrate"><code class="name flex">
<span>def <span class="ident">calibrate</span></span>(<span>calib_filepath,<br>calib_type='power',<br>peak_freq_col='PeakFrequency',<br>calib_depth_col='Bedrock_Depth',<br>outlier_radius=None,<br>xcoord_col='xcoord',<br>ycoord_col='ycoord',<br>bedrock_type=None,<br>show_calibration_plot=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calibrate(calib_filepath, calib_type=&#34;power&#34;, peak_freq_col=&#34;PeakFrequency&#34;, calib_depth_col=&#34;Bedrock_Depth&#34;, 
            outlier_radius=None, xcoord_col=&#39;xcoord&#39;, ycoord_col=&#39;ycoord&#39;, bedrock_type=None,
            show_calibration_plot=True):
    
    &#34;&#34;&#34;The calibrate function allows input of table with f0 and known depths to generate a power-law regression relationship.

    Parameters
    ----------
    calib_filepath : pathlike object
        Path to file readable by pandas.read_csv() with a column for frequencies
        and a column for depths.
    calib_type : str, optional
        Which calibration to use. Currently only power-law is supported, by default &#34;power&#34;
    outlier_radius : None or float, optional
        Radius (in CRS of coordinates) within which to use the points for calibration, by default None.
        Not currently supported.
    bedrock_type : str or None, optional
        Bedrock type by which to select which points to use for calibration, by default None.
        Not currently supported.
    peak_freq_col : str, optional
        Which column in calib_filepath to use for fundamental frequency values, by default &#34;PeakFrequency&#34;
    calib_depth_col : str, optional
        Which column in calib_filepath to use for depth values, by default &#34;Bedrock_Depth&#34;
    show_calibration_plot : bool, optional
        Whether to show the calibration plot, by default True

    Returns
    -------
    tuple
        Tuple (a, b) containing the parameters used for calibration regression.
    &#34;&#34;&#34;

    calib_data = None
    calib_types = [&#34;Power&#34;, &#34;swave_velocity&#34;, &#34;Matrix&#34;]
    calib_type_list = list(map(lambda x : x.casefold(), calib_types))
    power_list = [&#34;power&#34;, &#39;power law&#39;, &#39;powerlaw&#39;, &#39;power-law&#39;, &#34;pow&#34;, &#39;p&#39;]
    bedrock_types = [&#34;shale&#34;, &#34;limestone&#34;, &#34;dolomite&#34;,
                     &#34;sedimentary&#34;, &#34;igneous&#34;, &#34;metamorphic&#34;]
   
    freq_columns_names = [&#34;PeakFrequency&#34;, &#34;ResonanceFrequency&#34;, &#34;peak_freq&#34;,
                &#34;res_freq&#34;, &#34;Peakfrequency&#34;, &#34;Resonancefrequency&#34;, &#34;PF&#34;, &#34;RF&#34;, &#34;pf&#34;, &#34;rf&#34;]
    bedrock_depth_names = [&#34;BedrockDepth&#34;, &#34;DepthToBedrock&#34;, &#34;bedrock_depth&#34;,
                            &#34;depth_bedrock&#34;, &#34;depthtobedrock&#34;, &#34;bedrockdepth&#34;]

    #if calib_type.lower() in power_list:

    depthDataDF = pd.read_csv(calib_filepath)

    depths = depthDataDF[calib_depth_col]
    freqs = depthDataDF[peak_freq_col]

    def hvsrPowerLaw(f0, a, b):
        return a*f0**b

    popt, pcov = curve_fit(hvsrPowerLaw, freqs, depths)

    if show_calibration_plot:
        plt.loglog(sorted(freqs), sorted(hvsrPowerLaw(freqs, popt[0], popt[1]), reverse=True), 
                    linestyle=&#39;dotted&#39;, linewidth=0.5,
                    label=f&#34;${popt[0]:.2f} * f_0 ^{{{popt[1]:0.3f}}}$&#34;)
        plt.scatter(freqs, depths, label=f&#34;a = {popt[0]:0.2f}\nb = {popt[1]:0.3f}&#34;, zorder=100)
        ax = plt.gca()

        plt.legend()
        plt.title(f&#39;Frequency-Depth Calibration&#39;)
        plt.xlabel(&#39;Frequency\n[Hz]&#39;)
        plt.ylabel(&#39;Depth [m]&#39;)
        tickList = [0.01, 0.1, 1, 10, 100, 1000]

        for i, t in enumerate(tickList):
            if min(freqs) &gt; t and min(freqs) &lt;= tickList[i+1]:
                minX = t
            if i!=0 and max(freqs) &gt; tickList[i-1] and max(freqs) &lt;= t:
                maxX = t                
        
        for i, t in enumerate(tickList):
            if min(depths) &gt; t and min(depths) &lt;= tickList[i+1]:
                minY = t
            if i !=0 and max(depths) &gt; tickList[i-1] and max(depths) &lt;= t:
                maxY = t

        plt.grid(True, which=&#39;both&#39;, axis=&#39;both&#39;, linewidth=0.5, zorder=-1)

        if maxX &gt; 100:
            xArr = [0.1, 1, 10, 100, 1000]
            xTick = [&#39;$10^-1$&#39;, &#39;$10^0$&#39;, &#39;$10^1$&#39;, &#39;$10^2$&#39;, &#39;$10^3$&#39;]
        elif maxX &gt; 10:
            xArr = [0.1, 1, 10, 100]
            xTick = [&#39;$10^-1$&#39;, &#39;$10^0$&#39;, &#39;$10^1$&#39;, &#39;$10^2$&#39;]
        elif maxX &gt; 1:
            xArr = [0.1, 1, 10]
            xTick = [&#39;$10^-1$&#39;, &#39;$10^0$&#39;, &#39;$10^1$&#39;]
        else:
            xArr = [0.1, 1, 10, 100]
            xTick = [&#39;$10^-1$&#39;, &#39;$10^0$&#39;, &#39;$10^1$&#39;, &#39;$10^2$&#39;]

        if minX &gt; 0.1:
            xTick = xTick[1:]
            xArr = xArr[1:]
        if minX &gt; 1:
            xTick = xTick[1:]
            xArr = xArr[1:]
        if minX &gt; 10:
            xTick = xTick[1:]
            xArr = xArr[1:]

        if maxY &gt; 100:
            yArr = [1, 10, 100, 1000]
            yTick = [&#39;$10^0$&#39;, &#39;$10^1$&#39;, &#39;$10^2$&#39;, &#39;$10^3$&#39;]
        elif maxY &gt; 10:
            yArr = [1, 10, 100]
            yTick = [&#39;$10^0$&#39;, &#39;$10^1$&#39;, &#39;$10^2$&#39;]
        elif maxY &gt; 11:
            yArr = [1, 10, 100]
            yTick = [&#39;$10^0$&#39;, &#39;$10^1$&#39;]
        else:
            yArr = [1, 10, 100]
            yTick = [&#39;$10^0$&#39;, &#39;$10^1$&#39;, &#39;$10^2$&#39;]

        if minY &gt; 1:
            yTick = yTick[1:]
            yArr = yArr[1:]
        if minY &gt; 10:
            yTick = yTick[1:]
            yArr = yArr[1:]
        if minY &gt; 100:
            yTick = yTick[1:]
            yArr = yArr[1:]

        # Set major ticks
        plt.xticks(xArr, xTick)
        plt.yticks(yArr, yTick)

        # Add minor ticks
        ax = plt.gca()
        ax.xaxis.set_minor_locator(LogLocator(subs=(2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0)))
        ax.yaxis.set_minor_locator(LogLocator(subs=(2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0)))

        plt.xlim([xArr[0]-0.001*xArr[0], xArr[-1]+0.005*xArr[-1]])
        plt.ylim([yArr[0]-0.005*yArr[0], yArr[-1]+0.005*yArr[-1]])
        plt.show()
    
    calibration_vals = tuple(popt)

    return calibration_vals</code></pre>
</details>
<div class="desc"><p>The calibrate function allows input of table with f0 and known depths to generate a power-law regression relationship.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>calib_filepath</code></strong> :&ensp;<code>pathlike object</code></dt>
<dd>Path to file readable by pandas.read_csv() with a column for frequencies
and a column for depths.</dd>
<dt><strong><code>calib_type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Which calibration to use. Currently only power-law is supported, by default "power"</dd>
<dt><strong><code>outlier_radius</code></strong> :&ensp;<code>None</code> or <code>float</code>, optional</dt>
<dd>Radius (in CRS of coordinates) within which to use the points for calibration, by default None.
Not currently supported.</dd>
<dt><strong><code>bedrock_type</code></strong> :&ensp;<code>str</code> or <code>None</code>, optional</dt>
<dd>Bedrock type by which to select which points to use for calibration, by default None.
Not currently supported.</dd>
<dt><strong><code>peak_freq_col</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Which column in calib_filepath to use for fundamental frequency values, by default "PeakFrequency"</dd>
<dt><strong><code>calib_depth_col</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Which column in calib_filepath to use for depth values, by default "Bedrock_Depth"</dd>
<dt><strong><code>show_calibration_plot</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to show the calibration plot, by default True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>Tuple (a, b) containing the parameters used for calibration regression.</dd>
</dl></div>
</dd>
<dt id="sprit.check_peaks"><code class="name flex">
<span>def <span class="ident">check_peaks</span></span>(<span>hvsr_data,<br>hvsr_band=[0.5, 40],<br>peak_selection='max',<br>peak_freq_range=[0.5, 40],<br>azimuth='HV',<br>verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_peaks(hvsr_data, hvsr_band=DEFAULT_BAND, peak_selection=&#39;max&#39;, peak_freq_range=DEFAULT_BAND, azimuth=&#39;HV&#39;, verbose=False):
    &#34;&#34;&#34;Function to run tests on HVSR peaks to find best one and see if it passes SESAME quality checks

        Parameters
        ----------
        hvsr_data : dict
            Dictionary containing all the calculated information about the HVSR data (i.e., hvsr_out returned from process_hvsr)
        hvsr_band : tuple or list, default=[0.1, 50]
            2-item tuple or list with lower and upper limit of frequencies to analyze
        peak_selection : str or numeric, default=&#39;max&#39;
            How to select the &#34;best&#34; peak used in the analysis. For peak_selection=&#34;max&#34; (default value), the highest peak within peak_freq_range is used.
            For peak_selection=&#39;scored&#39;, an algorithm is used to select the peak based in part on which peak passes the most SESAME criteria.
            If a numeric value is used (e.g., int or float), this should be a frequency value to manually select as the peak of interest.
        peak_freq_range : tuple or list, default=[0.1, 50];
            The frequency range within which to check for peaks. If there is an HVSR curve with multiple peaks, this allows the full range of data to be processed while limiting peak picks to likely range.
        verbose : bool, default=False
            Whether to print results and inputs to terminal.
        
        Returns
        -------
        hvsr_data   : HVSRData or HVSRBatch object
            Object containing previous input data, plus information about peak tests
    &#34;&#34;&#34;
    orig_args = locals().copy() # Get the initial arguments
    
    # Update with processing parameters specified previously in input_params, if applicable
    if &#39;processing_parameters&#39; in hvsr_data.keys():
        if &#39;check_peaks&#39; in hvsr_data[&#39;processing_parameters&#39;].keys():
            update_msg = []
            for k, v in hvsr_data[&#39;processing_parameters&#39;][&#39;check_peaks&#39;].items():
                defaultVDict = dict(zip(inspect.getfullargspec(check_peaks).args[1:], 
                                        inspect.getfullargspec(check_peaks).defaults))
                # Manual input to function overrides the imported parameter values
                if (not isinstance(v, (HVSRData, HVSRBatch))) and (k in orig_args.keys()) and (orig_args[k]==defaultVDict[k]):
                    update_msg.append(f&#39;\t\t{k} = {v} (previously {orig_args[k]})&#39;)
                    orig_args[k] = v
                    
    hvsr_band = orig_args[&#39;hvsr_band&#39;]
    peak_selection = orig_args[&#39;peak_selection&#39;]
    peak_freq_range = orig_args[&#39;peak_freq_range&#39;]
    verbose = orig_args[&#39;verbose&#39;]

    #if (verbose and &#39;input_params&#39; not in hvsr_data.keys()) or (verbose and not hvsr_data[&#39;batch&#39;]):
    #    if isinstance(hvsr_data, HVSRData) and hvsr_data[&#39;batch&#39;]:
    #        pass
    #    else:
    if verbose:
        print(&#39;\nChecking peaks in the H/V Curve (check_peaks())&#39;)
        print(&#39;\tUsing the following parameters:&#39;)
        for key, value in orig_args.items():
            if key == &#39;hvsr_data&#39;:
                pass
            else:
                print(&#39;\t  {}={}&#39;.format(key, value))
        print()

        if &#39;processing_parameters&#39; in hvsr_data.keys() and &#39;check_peaks&#39; in hvsr_data[&#39;processing_parameters&#39;].keys():
            if update_msg != []:
                update_msg.insert(0, &#39;\tThe following parameters were updated using the processing_parameters attribute:&#39;)
                for msg_line in update_msg:
                    print(msg_line)
                print()

    # First, divide up for batch or not
    if isinstance(hvsr_data, HVSRBatch):
        if verbose:
            print(&#39;\t  Running in batch mode&#39;)
        #If running batch, we&#39;ll loop through each site
        for site_name in hvsr_data.keys():
            args = orig_args.copy() #Make a copy so we don&#39;t accidentally overwrite
            args[&#39;hvsr_data&#39;] =  hvsr_data[site_name] #Get what would normally be the &#34;params&#34; variable for each site
            if hvsr_data[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;]:
                try:
                    hvsr_data[site_name] = __check_peaks_batch(**args) #Call another function, that lets us run this function again
                except:
                    if verbose:
                        print(f&#34;\t{site_name}: check_peaks() unsuccessful. Peaks not checked.&#34;)
                    else:
                        warnings.warn(f&#34;\t{site_name}: check_peaks() unsuccessful. Peaks not checked.&#34;, RuntimeWarning)
                
        hvsr_data = HVSRBatch(hvsr_data, df_as_read=hvsr_data.input_df)
    else:
        HVColIDList = [&#39;_&#39;.join(col_name.split(&#39;_&#39;)[2:]) for col_name in hvsr_data[&#39;hvsr_windows_df&#39;].columns if col_name.startswith(&#39;HV_Curves&#39;) and &#39;Log&#39; not in col_name]
        HVColIDList[0] = &#39;HV&#39;
        
        if hvsr_data[&#39;processing_status&#39;][&#39;overall_status&#39;]:
            if not hvsr_band:
                hvsr_band = DEFAULT_BAND
            
            hvsr_data[&#39;hvsr_band&#39;] = hvsr_band

            anyK = list(hvsr_data[&#39;x_freqs&#39;].keys())[0]

            hvsr_data[&#39;PeakReport&#39;] = {}
            hvsr_data[&#39;BestPeak&#39;] = {}
            for i, col_id in enumerate(HVColIDList):
                x = hvsr_data[&#39;x_freqs&#39;][anyK]  # Consistent for all curves
                if col_id == &#39;HV&#39;:
                    y = hvsr_data[&#39;hvsr_curve&#39;]  # Calculated based on &#34;Use&#34; column            
                else:
                    y = hvsr_data[&#39;hvsr_az&#39;][col_id]
                
                scorelist = [&#39;score&#39;, &#39;scored&#39;, &#39;best&#39;, &#39;s&#39;]
                maxlist = [&#39;maximum&#39;, &#39;max&#39;, &#39;highest&#39;, &#39;m&#39;]
                # Convert peak_selection to numeric, get index of nearest value as list item for __init_peaks()
                try:
                    peak_val = float(peak_selection)
                    index_list = [np.argmin(np.abs(x - peak_val))]
                except Exception as e:
                    # If score method is being used, get index list for __init_peaks()
                    if peak_selection in scorelist:
                        index_list = hvsr_data[&#39;hvsr_peak_indices&#39;][col_id] #Calculated based on hvsr_curve
                    else:# str(peak_selection).lower() in maxlist:
                        #Get max index as item in list for __init_peaks()
                        startInd = np.argmin(np.abs(x - peak_freq_range[0]))
                        endInd = np.argmin(np.abs(x - peak_freq_range[1]))
                        if startInd &gt; endInd:
                            holder = startInd
                            startInd = endInd
                            endInd = holder
                        subArrayMax = np.argmax(y[startInd:endInd])

                        # If max val is in subarray, this will be the same as the max of curve
                        # Otherwise, it will be the index of the value that is max within peak_freq_range
                        index_list = [subArrayMax+startInd]
                
                hvsrp = hvsr_data[&#39;hvsrp&#39;][col_id]  # Calculated based on &#34;Use&#34; column
                hvsrm = hvsr_data[&#39;hvsrm&#39;][col_id]  # Calculated based on &#34;Use&#34; column
                
                hvsrPeaks = hvsr_data[&#39;hvsr_windows_df&#39;][hvsr_data[&#39;hvsr_windows_df&#39;][&#39;Use&#39;]][&#39;CurvesPeakIndices_&#39;+col_id]
                
                hvsr_log_std = hvsr_data[&#39;hvsr_log_std&#39;][col_id]
                peak_freq_range = hvsr_data[&#39;peak_freq_range&#39;]

                # Do for hvsr
                peak = __init_peaks(x, y, index_list, hvsr_band, peak_freq_range, _min_peak_amp=0.5)

                peak = __check_curve_reliability(hvsr_data, peak, col_id)
                peak = __check_clarity(x, y, peak, do_rank=True)

                # Do for hvsrp
                # Find  the relative extrema of hvsrp (hvsr + 1 standard deviation)
                if not np.isnan(np.sum(hvsrp)):
                    index_p = __find_peaks(hvsrp)
                else:
                    index_p = list()

                peakp = __init_peaks(x, hvsrp, index_p, hvsr_band, peak_freq_range, _min_peak_amp=1)
                peakp = __check_clarity(x, hvsrp, peakp, do_rank=True)

                # Do for hvsrm
                # Find  the relative extrema of hvsrm (hvsr - 1 standard deviation)
                if not np.isnan(np.sum(hvsrm)):
                    index_m = __find_peaks(hvsrm)
                else:
                    index_m = list()

                peakm = __init_peaks(x, hvsrm, index_m, hvsr_band, peak_freq_range, _min_peak_amp=0)
                peakm = __check_clarity(x, hvsrm, peakm, do_rank=True)

                # Get standard deviation of time peaks
                stdf = __get_stdf(x, index_list, hvsrPeaks)
                
                peak = __check_freq_stability(peak, peakm, peakp)
                peak = __check_stability(stdf, peak, hvsr_log_std, rank=True)

                hvsr_data[&#39;PeakReport&#39;][col_id] = peak

                #Iterate through peaks and 
                #   Get the BestPeak based on the peak score
                #   Calculate whether each peak passes enough tests
                curveTests = [&#39;WinLen&#39;,&#39;SigCycles&#39;, &#39;LowCurveStD&#39;]
                peakTests = [&#39;ProminenceLow&#39;, &#39;ProminenceHi&#39;, &#39;AmpClarity&#39;, &#39;FreqStability&#39;, &#39;LowStDev_Freq&#39;, &#39;LowStDev_Amp&#39;]
                bestPeakScore = 0

                for p in hvsr_data[&#39;PeakReport&#39;][col_id]:
                    # Get BestPeak
                    if p[&#39;Score&#39;] &gt; bestPeakScore:
                        bestPeakScore = p[&#39;Score&#39;]
                        bestPeak = p

                    # Calculate if peak passes criteria
                    cTestsPass = 0
                    pTestsPass = 0
                    for testName in p[&#39;PassList&#39;].keys():
                        if testName in curveTests:
                            if p[&#39;PassList&#39;][testName]:
                                cTestsPass += 1
                        elif testName in peakTests:
                            if p[&#39;PassList&#39;][testName]:
                                pTestsPass += 1

                    if cTestsPass == 3 and pTestsPass &gt;= 5:
                        p[&#39;PeakPasses&#39;] = True
                    else:
                        p[&#39;PeakPasses&#39;] = False
                        
                # Designate BestPeak in output dict
                if len(hvsr_data[&#39;PeakReport&#39;][col_id]) == 0:
                    bestPeak = {}
                    print(f&#34;No Best Peak identified for {hvsr_data[&#39;site&#39;]} (azimuth {col_id})&#34;)

                hvsr_data[&#39;BestPeak&#39;][col_id] = bestPeak
        else:
            for i, col_id in enumerate(HVColIDList):
                if hasattr(hvsr_data, &#39;BestPeak&#39;):
                    hvsr_data[&#39;BestPeak&#39;][col_id] = {}
                else:
                    print(f&#34;Processing Errors: No Best Peak identified for {hvsr_data[&#39;site&#39;]} (azimuth {col_id})&#34;)
            try:
                hvsr_data.plot()
            except:
                pass

        hvsr_data[&#39;processing_parameters&#39;][&#39;check_peaks&#39;] = {}
        exclude_params_list = [&#39;hvsr_data&#39;]
        for key, value in orig_args.items():
            if key not in exclude_params_list:  
                hvsr_data[&#39;processing_parameters&#39;][&#39;check_peaks&#39;][key] = value
    return hvsr_data</code></pre>
</details>
<div class="desc"><p>Function to run tests on HVSR peaks to find best one and see if it passes SESAME quality checks</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary containing all the calculated information about the HVSR data (i.e., hvsr_out returned from process_hvsr)</dd>
<dt><strong><code>hvsr_band</code></strong> :&ensp;<code>tuple</code> or <code>list</code>, default=<code>[0.1, 50]</code></dt>
<dd>2-item tuple or list with lower and upper limit of frequencies to analyze</dd>
<dt><strong><code>peak_selection</code></strong> :&ensp;<code>str</code> or <code>numeric</code>, default=<code>'max'</code></dt>
<dd>How to select the "best" peak used in the analysis. For peak_selection="max" (default value), the highest peak within peak_freq_range is used.
For peak_selection='scored', an algorithm is used to select the peak based in part on which peak passes the most SESAME criteria.
If a numeric value is used (e.g., int or float), this should be a frequency value to manually select as the peak of interest.</dd>
<dt><strong><code>peak_freq_range</code></strong> :&ensp;<code>tuple</code> or <code>list</code>, default=<code>[0.1, 50];</code></dt>
<dd>The frequency range within which to check for peaks. If there is an HVSR curve with multiple peaks, this allows the full range of data to be processed while limiting peak picks to likely range.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to print results and inputs to terminal.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hvsr_data
: HVSRData</code> or <code><a title="sprit.HVSRBatch" href="#sprit.HVSRBatch">HVSRBatch</a> object</code></dt>
<dd>Object containing previous input data, plus information about peak tests</dd>
</dl></div>
</dd>
<dt id="sprit.create_jupyter_ui"><code class="name flex">
<span>def <span class="ident">create_jupyter_ui</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_jupyter_ui():
    &#34;&#34;&#34;Function that generates the user interface for Jupyter Notebooks.
    
    This interface uses ipywidgets, plotly, and IPython to create a user interface for processing data in a Jupyter notebook.

    This is functionally equivalent to sprit.gui(&#39;nb&#39;).

    SEE ALSO
    --------
    gui
    &#34;&#34;&#34;
    global hvsr_data
    global results_fig
    global log_textArea

    ui_width = 20
    ui_height= 12
    log_textArea = widgets.Textarea(value=&#34;SESSION LOG&#34;, disabled=True, layout={&#39;height&#39;: &#39;300px&#39;,&#39;width&#39;: &#39;99%&#39;, &#39;overflow&#39;: &#39;scroll&#39;})

    # INPUT TAB
    # Create a VBox for the accordions
    input_HBox = widgets.HBox()
    input_accordion_label_box = widgets.VBox()
    input_accordion_box = widgets.VBox()
    input_accordion = widgets.Accordion()

    # Input Params Accordion
    input_params_grid = widgets.GridspecLayout(5, 10)
    fetch_data_grid = widgets.GridspecLayout(7, 10)
    calculate_azimuths_grid = widgets.GridspecLayout(5, 10)
    noise_removal_grid = widgets.GridspecLayout(10, 10)
    generate_psds_grid = widgets.GridspecLayout(6, 5)
    process_hvsr_grid = widgets.GridspecLayout(5, 10)
    remove_outliers_grid = widgets.GridspecLayout(5, 10)

    # A text box for the site name
    site_textbox = widgets.Text(description=&#39;Site Name&#39;,
                            value=&#39;HVSR_Site&#39;,
                            placeholder=&#39;HVSR_Site&#39;)
                            
    # Text box for project/county name
    project_textbox = widgets.Text(description=&#39;Project&#39;, 
                           placeholder= &#34;Project or County Name&#34;)

    # A text box labeled Metadata Filepath
    metadata_filepath = widgets.Text(description=&#39;Metadata&#39;,
                                     placeholder=&#39;Filepath to file to be read by obspy.read_inventory()&#39;,
                                     layout=widgets.Layout(width=&#39;auto&#39;))

    # A button next to it labeled &#34;Browse&#34;
    browse_metadata_button = widgets.Button(description=&#39;Browse&#39;, layout=widgets.Layout(width=&#39;auto&#39;))
    def select_metapath(event):
        try:
            from tkinter import tk, filedialog
            root = tk.Tk()
            root.wm_attributes(&#39;-topmost&#39;, True)
            root.withdraw()
            metadata_filepath.value = str(filedialog.askopenfilenames(title=&#39;Select Metadata File(s)&#39;))
            root.destroy()
        except Exception as e:
            print(e)
            browse_metadata_button.disabled = True
            browse_metadata_button.description = &#39;Use Text Field&#39;
    browse_metadata_button.on_click(select_metapath)

    # Dropdown with instrument types
    instrument_dropdown = widgets.Dropdown(options=[(&#39;Raspberry Shake&#39;, &#39;raspberry shake&#39;), 
                                                    (&#39;Tromino Yellow&#39;, &#39;tromino yellow&#39;), 
                                                    (&#39;Tromino Blue&#39;, &#39;tromino blue&#39;), 
                                                    (&#39;Other Seismometer&#39;, &#39;seismometer&#39;)],
                                           #style={&#39;description_width&#39;: &#39;initial&#39;},
                                           description=&#39;Instrument:&#39;,
                                           layout=widgets.Layout(width=&#39;100%&#39;))

    network_textbox = widgets.Text(description=&#39;Network:&#39;,
                                    placeholder=_get_default(sprit_hvsr.input_params, &#39;network&#39;),
                                    value=_get_default(sprit_hvsr.input_params, &#39;network&#39;),
                                    tooltip=&#34;input_params(network)&#34;)

    station_textbox = widgets.Text(description=&#39;Station:&#39;,
                                    placeholder=_get_default(sprit_hvsr.input_params, &#39;station&#39;),
                                    value=_get_default(sprit_hvsr.input_params, &#39;station&#39;))

    location_textbox = widgets.Text(description=&#39;Location:&#39;,
                                    placeholder=_get_default(sprit_hvsr.input_params, &#39;location&#39;),
                                    value=_get_default(sprit_hvsr.input_params, &#39;location&#39;))

    z_channel_textbox = widgets.Text(description=&#39;Z Channel:&#39;,
                                    placeholder=_get_default(sprit_hvsr.input_params, &#39;channels&#39;)[0],
                                    value=_get_default(sprit_hvsr.input_params, &#39;channels&#39;)[0])

    e_channel_textbox = widgets.Text(description=&#39;E Channel:&#39;,
                                    placeholder=_get_default(sprit_hvsr.input_params, &#39;channels&#39;)[2],
                                    value=_get_default(sprit_hvsr.input_params, &#39;channels&#39;)[2])

    n_channel_textbox = widgets.Text(description=&#39;N Channel:&#39;,
                                    placeholder=_get_default(sprit_hvsr.input_params, &#39;channels&#39;)[1],
                                    value=_get_default(sprit_hvsr.input_params, &#39;channels&#39;)[1])

    # Instrument Settings
    inst_settings_text = widgets.Text(description=&#39;Inst. Settings&#39;, 
                                      placeholder=&#39;Filepath to data with instrument settings&#39;, 
                                      layout=widgets.Layout(width=&#39;auto&#39;))
    instrument_read_button = widgets.Button(description=&#39;Browse&#39;, icon=&#39;fa-file-import&#39;,
                                            layout=widgets.Layout(width=&#39;auto&#39;))

    
    def select_inst(event):
        try:
            if event.description == &#39;Select .inst file&#39;:
                from tkinter import tk, filedialog
                root = tk.Tk()
                root.wm_attributes(&#39;-topmost&#39;, True)
                root.withdraw()
                inst_files = filedialog.askopenfilenames(defaultextension=&#39;.inst&#39;, filetypes=[(&#39;Inst&#39;, &#39;.inst&#39;)],
                                                                    title=&#34;Select Instrument Settings File&#34;)
                if isinstance(inst_files, tuple):
                    pass
                else:
                    inst_files = tuple(inst_files)
                root.destroy()
            else:
                inst_files = tuple([inst_settings_text.value])

            for i, inst_f in enumerate(inst_files):
                inst_settings_text.value = pathlib.Path(inst_f).as_posix()
                inst_settings = sprit_hvsr.import_settings(settings_import_path=pathlib.Path(inst_f).as_posix(), settings_import_type=&#39;instrument&#39;)
                
                # Go through all items and add them
                if &#39;instrument&#39; in inst_settings.keys():
                    if inst_settings[&#39;instrument&#39;] not in instrument_dropdown.options:
                        instrument_dropdown.options.append(inst_settings[&#39;instrument&#39;])
                    instrument_dropdown.value = inst_settings[&#39;instrument&#39;]
                
                if &#39;net&#39; in inst_settings.keys():
                    network_textbox.value = inst_settings[&#39;net&#39;]

                if &#39;sta&#39; in inst_settings.keys():
                    station_textbox.value = inst_settings[&#39;sta&#39;]

                if &#39;location&#39; in inst_settings.keys():
                    location_textbox.value = inst_settings[&#39;location&#39;]

                if &#39;cha&#39; in inst_settings.keys():
                    for c in inst_settings[&#39;cha&#39;]:
                        if c.lower()[2]==&#39;z&#39;:
                            z_channel_textbox.value = c
                        if c.lower()[2]==&#39;e&#39;:
                            e_channel_textbox.value = c
                        if c.lower()[2] ==&#39;n&#39;:
                            n_channel_textbox.value = c
                
                if &#39;metadata&#39; in inst_settings.keys():
                    metadata_filepath.value = inst_settings[&#39;metadata&#39;]

                if &#39;hvsr_band&#39; in inst_settings.keys():
                    hvsr_band_rangeSlide.value = (inst_settings[&#39;hvsr_band&#39;][0], inst_settings[&#39;hvsr_band&#39;][1])

        except Exception as e:
            print(e)
            instrument_read_button.disabled = True
            instrument_read_button.description = &#39;Use Text Field&#39;
    
    instrument_read_button.on_click(select_inst)

    # Input parameters parameters
    input_params_grid[0, 0:2] = network_textbox
    input_params_grid[0, 6:8] = location_textbox

    input_params_grid[1, 0:2] = z_channel_textbox
    input_params_grid[1, 2:4] = e_channel_textbox
    input_params_grid[1, 4:6] = n_channel_textbox


    input_params_grid[2, :9] = metadata_filepath
    input_params_grid[2, 9:] = browse_metadata_button

    input_params_grid[3, :9] = inst_settings_text
    input_params_grid[3, 9:] = instrument_read_button

    # Acquisition Accordion
    instrument_grid = widgets.GridspecLayout(5, 10)
    # Date Picker labelled &#34;Acquisition Date&#34;
    acquisition_date_picker = widgets.DatePicker(description=&#39;Acq. Date:&#39;,
                                            placeholder=datetime.datetime.today().date(),
                                            value=datetime.datetime.today().date())
    #acquisition_date_picker = widgets.NaiveDatetimePicker(description=&#39;Start time and Date&#39;,
    #                                                      placeholder=datetime.datetime.now(),
    #                                                      value=datetime.datetime.now())

    # Label that shows the Date currently selected in the Date Picker
    acquisition_doy = widgets.IntText(description=&#39;Day of Year&#39;,
                                                placeholder=f&#34;{acquisition_date_picker.value.timetuple().tm_yday}&#34;,
                                                value=f&#34;{acquisition_date_picker.value.timetuple().tm_yday}&#34;,
                                                layout=widgets.Layout(width=&#39;auto&#39;))

    def on_acq_date_change(change):
        acquisition_doy.value = acquisition_date_picker.value.timetuple().tm_yday
    acquisition_date_picker.observe(on_acq_date_change)

    def on_doy_change(change):
        curr_year = datetime.datetime.today().year
        if acquisition_doy.value &gt; datetime.datetime.today().timetuple().tm_yday:
            curr_year -= 1
        acquisition_date_picker.value = (datetime.datetime(curr_year, 1, 1) + datetime.timedelta(days = acquisition_doy.value-1)).date()
    acquisition_doy.observe(on_doy_change)

    # Time selector (hour and minute) labelled &#34;Start Time&#34;.
    try:
        start_time_picker = widgets.TimePicker(description=&#39;Start Time:&#39;,
                                            placeholder=datetime.time(0,0,0),
                                            value=datetime.time(0,0,0),)
                                            #layout=widgets.Layout(width=&#39;auto&#39;))
    except Exception as e:
        start_time_picker = widgets.Text(description=&#39;Start Time:&#39;,
                                        placeholder=&#39;00:00&#39;,
                                        value=&#39;00:00&#39;)
                                        #layout=widgets.Layout(width=&#39;auto&#39;))

    # Time selector (hour and minute) labelled &#34;End Time&#34;. Same as Start Time otherwise.
    try:
        end_time_picker = widgets.TimePicker(description=&#39;End Time:&#39;,
                                        placeholder=datetime.time(23,59),
                                        value=datetime.time(23,59),)
                                        #layout=widgets.Layout(width=&#39;auto&#39;))
    except Exception as e:
        end_time_picker = widgets.Text(description=&#39;End Time:&#39;,
                                        placeholder=&#39;23:59:59.999999&#39;,
                                        value=&#39;23:59:59.999999&#39;,)
                                        #layout=widgets.Layout(width=&#39;auto&#39;))

    tzlist = list(available_timezones())
    tzlist.sort()
    tzlist.remove(&#39;UTC&#39;)
    tzlist.remove(&#39;US/Central&#39;)
    tzlist.insert(0, &#39;US/Central&#39;)
    tzlist.insert(0, &#39;UTC&#39;)
    # A dropdown list with all the items from zoneinfo.available_timezones(), default &#39;UTC&#39;
    time_zone_dropdown = widgets.Dropdown(description=&#39;Time Zone:&#39;,
                                          options=tzlist,
                                          value=_get_default(sprit_hvsr.input_params, &#39;tzone&#39;))

    instrument_grid[0,0] = acquisition_date_picker
    instrument_grid[0,1] = acquisition_doy
    instrument_grid[1,0] = start_time_picker
    instrument_grid[2,0] = end_time_picker
    instrument_grid[3,0] = time_zone_dropdown

    # LOCATION ACCORDION
    location_grid = widgets.GridspecLayout(4, 10)
    # X coordinate input
    xcoord_textbox = widgets.FloatText(description=&#39;X Coordinate:&#39;, tooltip=&#39;xcoord&#39;,
                                       value=_get_default(sprit_hvsr.input_params, &#39;xcoord&#39;),
                                        layout=widgets.Layout(width=&#39;100%&#39;),
                                       placeholder=_get_default(sprit_hvsr.input_params, &#39;xcoord&#39;))
    #location_grid[0, 0] = xcoord_textbox

    # Y coordinate input
    ycoord_textbox = widgets.FloatText(description=&#39;Y Coordinate&#39;, tooltip=&#39;ycoord:&#39;,
                                       value=_get_default(sprit_hvsr.input_params, &#39;ycoord&#39;),
                                        layout=widgets.Layout(width=&#39;100%&#39;),                                       
                                       placeholder=_get_default(sprit_hvsr.input_params, &#39;ycoord&#39;))
    #location_grid[1, 0] = ycoord_textbox

    # Z coordinate input
    zcoord_textbox = widgets.FloatText(description=&#39;Z Coordinate&#39;, tooltip=&#39;elevation:&#39;,
                                       layout=widgets.Layout(width=&#39;100%&#39;),
                                       value=_get_default(sprit_hvsr.input_params, &#39;elevation&#39;),
                                       placeholder=_get_default(sprit_hvsr.input_params, &#39;elevation&#39;))
    #location_grid[2, 0] = zcoord_textbox

    # Input CRS input
    input_crs_textbox = widgets.Text(description=&#39;Input CRS:&#39;,
                                     layout=widgets.Layout(width=&#39;75%&#39;),
                                     placholder=_get_default(sprit_hvsr.input_params, &#39;input_crs&#39;),
                                     value=_get_default(sprit_hvsr.input_params, &#39;input_crs&#39;))
    #location_grid[3, 0] = input_crs_textbox

    # Output CRS input
    output_crs_textbox = widgets.Text(description=&#39;Output CRS:&#39;,
                                        layout=widgets.Layout(width=&#39;75%&#39;),
                                        placholder=_get_default(sprit_hvsr.input_params, &#39;output_crs&#39;),
                                        value=_get_default(sprit_hvsr.input_params, &#39;output_crs&#39;))
    #location_grid[3, 1] = output_crs_textbox

    # Z coordinate unit input
    elev_unit_dropdown = widgets.Dropdown(options=[(&#39;Feet&#39;, &#39;feet&#39;), (&#39;Meters&#39;, &#39;meters&#39;)],
                                         layout=widgets.Layout(width=&#39;75%&#39;),
                                          value=_get_default(sprit_hvsr.input_params, &#39;elev_unit&#39;),
                                          description=&#39;Z Unit:&#39;, tooltip=&#39;elev_unit&#39;)
    #location_grid[2, 1] = elev_unit_dropdown

    # Data format (for obspy format to use to read in)
    peak_freq_rangeSlide = widgets.FloatRangeSlider(value=sprit_hvsr.DEFAULT_BAND,
                                                        min=0.1,
                                                        max=64, 
                                                        step=0.1,
                                                        description=&#39;Peak Range&#39;,
                                                        tooltip=&#39;Define the frequency range over which to search for peaks&#39;,
                                                        readout_format=&#39;.1f&#39;,
                                                        layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;),
                                                        )


    hvsr_band_rangeSlide = widgets.FloatRangeSlider(value=sprit_hvsr.DEFAULT_BAND,
                                               min=0.1,
                                               max=64, 
                                               step=0.1,
                                               description=&#39;HVSR Band&#39;,
                                               tooltip=&#39;Define the frequency range over which HVSR data is processed&#39;,
                                               readout_format=&#39;.1f&#39;,
                                               layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;),
                                               )

    # FETCH DATA ACCORDION
    # A dropdown labeled &#34;Detrend type&#34; with &#34;Spline&#34;, &#34;Polynomial&#34;, or &#34;None&#34;
    detrend_type_dropdown = widgets.Dropdown(options=[(&#39;Spline&#39;, &#39;spline&#39;), (&#39;Polynomial&#39;, &#39;polynomial&#39;), (&#39;None&#39;, &#39;none&#39;)],
                            description=&#39;Detrend type&#39;,  layout=widgets.Layout(width=&#39;auto&#39;))
    detrend_options = widgets.Text(description=&#39;Options&#39;, tooltip=&#39;detrend_options&#39;, 
                                   placeholder=&#34;order=&#34;+str(_get_default(sprit_hvsr.fetch_data, &#39;detrend_options&#39;)), 
                                   value=&#34;order=&#34;+str(_get_default(sprit_hvsr.fetch_data, &#39;detrend_options&#39;)),
                                   layout=widgets.Layout(width=&#39;auto&#39;))

    filter_type_dropdown = widgets.Dropdown(options=[(&#39;Bandpass&#39;, &#39;bandpass&#39;), 
                                                      (&#39;Bandstop&#39;, &#39;bandstop&#39;), 
                                                      (&#39;Highpass&#39;, &#39;highpass&#39;), 
                                                      (&#39;Lowpass&#39;, &#39;lowpass&#39;), 
                                                      (&#39;Lowpass (Cheby 2)&#39;, &#39;lowpass_cheby_2&#39;), 
                                                      (&#39;Lowpass (FIR)&#39;, &#39;lowpass_fir&#39;), 
                                                      (&#39;Remez (FIR)&#39;, &#39;remez_fir&#39;), 
                                                      (&#39;None&#39;, &#39;none&#39;)],
                                             value=&#34;none&#34;,
                                             description=&#39;Filter type&#39;,  layout=widgets.Layout(width=&#39;auto&#39;))

    filter_options = widgets.Text(description=&#39;Options&#39;, 
                                      tooltip=&#34;Options for obspy.filter() method in a format: &#39;option_name=option_value, 2ndoptname=2ndoptvalue&#39;&#34;, 
                                      placeholder=str(_get_default(sprit_hvsr.fetch_data, &#39;filter_options&#39;)),
                                      value=str(_get_default(sprit_hvsr.fetch_data, &#39;filter_options&#39;)),
                                      layout=widgets.Layout(width=&#39;auto&#39;))

    # A text to specify the trim directory
    data_export_path_textbox = widgets.Text(description=&#39;Export Path&#39;, value=&#34;None&#34;,#pathlib.Path().home().as_posix(),
                                    layout=widgets.Layout(width=&#39;auto&#39;))

    data_export_format_dropdown = widgets.Dropdown(options=OBSPY_FORMATS,
                                                   value=&#39;MSEED&#39;,
                                                   description=&#39;Format&#39;, 
                                                   layout=widgets.Layout(width=&#39;auto&#39;))
    
    update_metadata_checkbox = widgets.Checkbox(value=True,
                                                description=&#39;Update Metadata&#39;,
                                                disabled=False,
                                                indent=False,
                                                tooltip=&#39;Only applicable if metadata specified&#39;)
                                                

    # Processing Settings
    proc_settings_text = widgets.Text(placeholder=&#39;Instrument Settings Filepath&#39;, layout=widgets.Layout(width=&#39;55%&#39;))
    proc_settings_read_button = widgets.Button(icon=&#39;fa-file-import&#39;,button_style=&#39;success&#39;,
                                            layout=widgets.Layout(width=&#39;4%&#39;))
    proc_settings_browse_button = widgets.Button(description=&#39;Select .proc file&#39;,
                                            layout=widgets.Layout(width=&#39;10%&#39;))
    proc_settings_hbox = widgets.HBox([proc_settings_text, proc_settings_read_button, proc_settings_browse_button])
    
    excluded_params = [&#39;hvsr_data&#39;, &#39;params&#39;, &#39;hvsr_results&#39;]
    funcList = [sprit_hvsr.fetch_data, sprit_hvsr.remove_noise,
                sprit_hvsr.generate_psds, sprit_hvsr.process_hvsr,
                sprit_hvsr.remove_outlier_curves, sprit_hvsr.check_peaks,
                sprit_hvsr.get_report]

    def select_proc(event):
        try:
            if event.description == &#39;Select .proc file&#39;:
                from tkinter import tk, filedialog
                root = tk.Tk()
                root.wm_attributes(&#39;-topmost&#39;, True)
                root.withdraw()
                proc_files = filedialog.askopenfilenames(defaultextension=&#39;.proc&#39;, filetypes=[(&#39;PROC&#39;, &#39;.proc&#39;)],
                                                                    title=&#34;Select Processing Settings File&#34;)
                if isinstance(proc_files, tuple):
                    pass
                else:
                    proc_files = tuple(proc_files)
                root.destroy()
            else:
                proc_files = tuple([proc_settings_text.value])

            for i, proc_f in enumerate(proc_files):
                proc_settings_text.value = pathlib.Path(proc_f).as_posix()
                proc_settings = sprit_hvsr.import_settings(settings_import_path=pathlib.Path(proc_f).as_posix(), settings_import_type=&#39;processing&#39;)
                
                for func, params in proc_settings.items():
                    if func in widget_param_dict.keys():
                        for prm, val in params.items():
                            if prm in widget_param_dict[func].keys():
                                #print(prm, &#39;:&#39;, widget_param_dict[func][prm],&#39; |  &#39;, val)
                                if val is None or val==&#39;None&#39;:
                                    val=&#39;none&#39;
                                if prm == &#39;export_format&#39;:
                                    val = val.upper()
                                if prm == &#39;smooth&#39;:
                                    if val is True:
                                        val = 51
                                if prm == &#39;resample&#39;:
                                    if val is True:
                                        val = 1000
                                if isinstance(widget_param_dict[func][prm], list):
                                    for i, item in enumerate(widget_param_dict[func][prm]):
                                        item.value = val[i]
                                else:
                                    widget_param_dict[func][prm].value = val
        except Exception as e:
            #print(e)
            proc_settings_browse_button.disabled = True
            proc_settings_browse_button.description = &#39;Use Text Field&#39;
    
    proc_settings_read_button.on_click(select_proc)
    proc_settings_browse_button.on_click(select_proc)

    fetch_data_grid[0, :] = proc_settings_hbox
    fetch_data_grid[1, 0] = data_export_format_dropdown

    fetch_data_grid[2, 0] = detrend_type_dropdown
    fetch_data_grid[2, 1] = detrend_options

    fetch_data_grid[3, 0] = filter_type_dropdown
    fetch_data_grid[3, 1] = filter_options

    fetch_data_grid[4, :] = update_metadata_checkbox

    fetch_data_grid[5, 0] = widgets.Label(&#39;Data Export&#39;)
    fetch_data_grid[5, 1:6] = data_export_path_textbox
    fetch_data_grid[5, 6:8] = data_export_format_dropdown

    # Calculate Azimuth
    #azimuth_angle=45, azimuth_type=&#39;multiple&#39;, azimuth_unit=&#39;degrees&#39;, verbose=False
    azimuth_angle_slide = widgets.IntSlider(value=45,
                                    min=0,
                                    max=360,
                                    step=1,
                                    description=&#39;Angle&#39;,
                                    disabled=False,
                                    continuous_update=False,
                                    orientation=&#39;horizontal&#39;,
                                    readout=True)

    azimuth_type_dropdown = widgets.Dropdown(options=[(&#39;Multiple/steps&#39;, &#39;multiple&#39;), (&#39;Single&#39;, &#39;single&#39;), (&#34;None&#34;, None)],
                                            value=None,
                                            description=&#39;Type&#39;)

    azimuth_unit_dropdown = widgets.Dropdown(options=[(&#39;°&#39;, &#39;degrees&#39;), (&#39;rad&#39;, &#39;radians&#39;)],
                                            value=&#39;degrees&#39;,
                                            description=&#39;Unit&#39;)

    calculate_azimuths_grid[0, 0] = widgets.Label(&#34;Azimuth information&#34;)
    calculate_azimuths_grid[1, 0] = azimuth_type_dropdown
    calculate_azimuths_grid[2, 0] = azimuth_unit_dropdown
    calculate_azimuths_grid[3, :] = azimuth_angle_slide

    # Noise removal
    # remove_method=None, 
    # processing_window=None, 
    # sat_percent=0.995, 
    # noise_percent=0.8, 
    # sta=2, lta=30, stalta_thresh=[8, 16], 
    # std_ratio_thresh=2.0, std_window_size=20.0, min_std_win=5.0, 
    # warmup_time=0, cooldown_time=0, min_win_size=1, 
    # remove_raw_noise=False,
    remove_method_select = widgets.SelectMultiple(options=[(&#39;None&#39;, None),
                                                            (&#34;Moving St. Dev.&#34;, &#34;moving_std&#34;),
                                                            (&#39;Saturation Threshold&#39;, &#39;saturation&#39;),
                                                            (&#34;Noise Threshold&#34;,&#34;noise&#34;),
                                                            (&#39;STA/LTA&#39;, &#39;stalta&#39;),
                                                            (&#39;Warmup&#39;, &#34;warmup&#34;),
                                                            (&#34;Cooldown&#34;, &#34;cooldown&#34;),
                                                            (&#34;Processing Windows&#34;, &#39;processing_window&#39;)],
                                                    value=[None],
                                                    rows=8,
                                                    description=&#39;Method&#39;,
                                                    disabled=False
                                                    )

    std_ratio_thresh_float = widgets.BoundedFloatText(value=float(_get_default(sprit_hvsr.remove_noise, &#34;std_ratio_thresh&#34;)),
                                                      min=0.0,
                                                      max=50,
                                                      step=0.25,
                                                      description=&#39;StDev Ratio&#39;,
                                                      tooltip=&#39;The threshold for the ratio between the moving standard deviation/total standard deviation of the record to use as a threshold&#39;,
                                                      disabled=True)
    
    std_window_size_float = widgets.BoundedFloatText(value=float(_get_default(sprit_hvsr.remove_noise, &#34;std_window_size&#34;)),
                                                     min=0.0,
                                                     max=60,
                                                     step=0.5,
                                                     description=&#39;StDev Window Size&#39;,
                                                     tooltip=&#39;The size of the moving standard deviation window, in seconds&#39;,
                                                     disabled=True)
    
    min_std_win = widgets.BoundedFloatText(value=float(_get_default(sprit_hvsr.remove_noise, &#34;min_std_win&#34;)),
                                                        min=0.0,
                                                        max=30,
                                                        step=0.25,
                                                        description=&#39;Min. StDev Window Size&#39;,
                                                        tooltip=&#39;The minimum size of the window that can be removed by the moving standard deviation method, in seconds&#39;,
                                                        disabled=True)


    sat_percent_float = widgets.BoundedFloatText(value=float(_get_default(sprit_hvsr.remove_noise, &#34;sat_percent&#34;)),
                                                min=0.0,
                                                max=1.0,
                                                step=0.05,
                                                description=&#39;Saturation %&#39;,
                                                tooltip=&#39;Percent (0-1) of absolute value of maximum value in dataset, above which value data is excluded from analysis&#39;,
                                                disabled=True)

    noise_percent_float = widgets.BoundedFloatText(value=float(_get_default(sprit_hvsr.remove_noise, &#34;noise_percent&#34;)),
                                                min=0.0,
                                                max=1.0,
                                                step=0.05,
                                                description=&#39;Noise %&#39;,
                                                tooltip=&#39;Percent (0-1) of absolute value of maximum value in dataset, above which value data is excluded from analysis if persistent for min_win_size&#39;,
                                                disabled=True)


    sta_float = widgets.FloatText(value=float(_get_default(sprit_hvsr.remove_noise, &#34;sta&#34;)),
                                  step=0.1,
                                  description=&#39;STA&#39;,
                                  tooltip=&#39;Length of window to use for short term average&#39;,
                                  disabled=True)

    lta_float = widgets.FloatText(value=float(_get_default(sprit_hvsr.remove_noise, &#34;lta&#34;)),
                                                step=0.1,
                                                description=&#39;LTA&#39;,
                                                tooltip=&#39;Length of window to use for long term average&#39;,
                                                disabled=True)

    stalta_floatSlide = widgets.FloatRangeSlider(
                                        value=_get_default(sprit_hvsr.remove_noise, &#34;stalta_thresh&#34;),
                                        min=0,
                                        max=100,
                                        step=0.1,
                                        description=&#39;STALTA Thresh.&#39;,
                                        disabled=True,
                                        continuous_update=False,
                                        orientation=&#39;horizontal&#39;,
                                        readout=True,
                                        tooltip=&#39;The threshold at which an event is triggered, and at which the event is no longer considered active&#39;,
                                        readout_format=&#39;.1f&#39;)

    warmup_time_int = widgets.IntText(
                                value=int(_get_default(sprit_hvsr.remove_noise, &#34;warmup_time&#34;)),
                                description=&#39;Warmup [s]&#39;,
                                tooltip= &#39;Warmup time in seconds (time to exclude from start of record)&#39;,
                                disabled=True
                            )
    
    cooldown_time_int = widgets.IntText(
                                value=int(_get_default(sprit_hvsr.remove_noise, &#34;cooldown_time&#34;)),
                                description=&#39;Cooldown [s]&#39;,
                                tooltip= &#39;Cooldown time in seconds (time to exclude from end of record)&#39;,
                                disabled=True
                            )

    min_win_size_float = widgets.FloatText(value=float(_get_default(sprit_hvsr.remove_noise, &#34;min_win_size&#34;)),
                                           description=&#39;Min Window Size&#39;,
                                           tooltip=&#39;Minimum length (in seconds) of windows that can be removed&#39;,
                                           disabled=True)

    proc_wind_text = widgets.Text(value=&#39;None&#39;,
                                  tooltip=&#39;Manual specification of windows in the format: [[Starttime0, EndTime0], [Starttime1, Endtime1],....]&#39;,
                                  description=&#39;Windows&#39;,
                                  disabled=True)

    raw_noise_checkbox = widgets.Checkbox(value=False,
                                          description=&#39;Use raw stream&#39;,
                                          disabled=True,
                                          indent=False)



    def on_remove_method_change(event):
        print(&#39;disabling&#39;)
        stalta_disabled = True
        mst_disabled = True
        sat_disabled = True
        noise_disabled = True
        warm_disabled = True
        cool_disabled = True
        proc_win_disabled = True
        any_method_disabled = True

        if &#39;stalta&#39; in remove_method_select.value:
            stalta_disabled = False
            any_method_disabled = False

        if &#39;moving_std&#39; in remove_method_select.value:
            mst_disabled = False
            any_method_disabled = False

        if &#39;saturation&#39; in remove_method_select.value:
            sat_disabled = False
            any_method_disabled = False

        if &#39;noise&#39; in remove_method_select.value:
            noise_disabled = False
            any_method_disabled = False

        if &#39;warmup&#39; in remove_method_select.value:
            warm_disabled = False
            any_method_disabled = False

        if &#39;cooldown&#39; in remove_method_select.value:
            cool_disabled = False
            any_method_disabled = False

        if &#39;processing_window&#39; in remove_method_select.value:
            proc_win_disabled = False
            any_method_disabled = False

        # Now disable them all...or not
        min_std_win.disabled = std_window_size_float.disabled = std_ratio_thresh_float.disabled = mst_disabled
        sat_percent_float.disabled = sat_disabled
        noise_percent_float.disabled = noise_disabled
        sta_float.disabled = lta_float.disabled = stalta_floatSlide.disabled = stalta_disabled
        warmup_time_int.disabled = warm_disabled
        cooldown_time_int.disabled = cool_disabled
        min_win_size_float.disabled = any_method_disabled
        proc_wind_text.disabled = proc_win_disabled
        raw_noise_checkbox.disabled = any_method_disabled
    remove_method_select.observe(on_remove_method_change)

    # Set up arrangement
    noise_removal_grid[0:5, :2] = remove_method_select
    noise_removal_grid[0:5, 2:4] = raw_noise_checkbox

    noise_removal_grid[5, :1] = widgets.Label(&#34;St. Dev. Ratio (Total / Moving)&#34;)
    noise_removal_grid[5, 2:4] = std_ratio_thresh_float
    noise_removal_grid[5, 4:6] = std_window_size_float
    noise_removal_grid[5, 6:8] = min_std_win

    noise_removal_grid[6, :2] = sat_percent_float
    noise_removal_grid[6, 2:4] = noise_percent_float

    noise_removal_grid[7, 0:2] = sta_float
    noise_removal_grid[7, 2:4] = lta_float
    noise_removal_grid[7, 4:6] = stalta_floatSlide

    noise_removal_grid[8, 0:2] = warmup_time_int
    noise_removal_grid[8, 2:4] = cooldown_time_int

    noise_removal_grid[9, :] = proc_wind_text

    # Generate PSDs
    # window_length=30.0, 
    # overlap_pct=0.5, 
    # window_type=&#39;hann&#39;, window_length_method=&#39;length&#39;, 
    # remove_response=False, skip_on_gaps=True, 
    # num_freq_bins=512, 
    # obspy_ppsds=False, azimuthal_psds=False, verbose=False
    
    window_length_float = widgets.FloatText(value=float(_get_default(sprit_hvsr.generate_psds, &#34;window_length&#34;)),
                                        description=&#39;Length&#39;,
                                        tooltip=&#39;Length of windows used for FFT analysis, in seconds or number (depending on window_length_method)&#39;,
                                        disabled=False)

    window_length_method_dropdown = widgets.Dropdown(options=[(&#39;Length&#39;, &#39;length&#39;), (&#39;Number of windows&#39;, &#39;number&#39;)],
                                            value=&#39;length&#39;,
                                            tooltip=&#34;How to define the window length (by length or by number of windows)&#34;,
                                            description=&#39;Method&#39;,)

    overlap_pct_float = widgets.BoundedFloatText(value=float(_get_default(sprit_hvsr.generate_psds, &#34;overlap_pct&#34;)),
                                                 min=0,
                                                 max=1.0,
                                                 step=0.01,
                                                 description=&#39;Overlap %&#39;,
                                                 tooltip=&#39;Percentage by which to overlap windows used for FFT analysis&#39;,
                                                 disabled=False)
    
    window_type_dropdown = widgets.Dropdown(options=[(&#39;Hann&#39;, &#39;hann&#39;), 
                                                     (&#34;Boxcar&#34;, &#39;boxcar&#39;),
                                                     (&#39;Triangle&#39;, &#39;triang&#39;),
                                                     (&#39;Blackman&#39;, &#39;blackman&#39;),
                                                     (&#39;Hamming&#39;, &#39;hamming&#39;),
                                                     (&#39;Bartlett&#39;, &#39;bartlett&#39;),
                                                     (&#39;Flattop&#39;, &#39;flattop&#39;),
                                                     (&#39;Parzen&#39;, &#39;parzen&#39;),
                                                     (&#39;Bohman&#39;, &#39;bohman&#39;),
                                                     (&#39;Blackman-Harris&#39;, &#39;blackmanharris&#39;),
                                                     (&#39;Nuttal&#39;, &#39;nuttall&#39;),
                                                     (&#39;Barthan&#39;, &#39;barthann&#39;),
                                                     (&#39;Cosine&#39;, &#39;cosine&#39;),
                                                     (&#39;Exponential&#39;, &#39;exponential&#39;),
                                                     (&#39;Tukey&#39;, &#39;tukey&#39;),
                                                     (&#39;Taylor&#39;, &#39;taylor&#39;),
                                                     (&#39;Lanczos&#39;, &#39;lanczos&#39;)],
                                            value=&#39;hann&#39;,
                                            tooltip=&#39;Type of window to use. See scip.signal.get_window() for more information.&#39;,
                                            description=&#39;Window Type&#39;,)

    remove_response_check = widgets.Checkbox(value=False,
                                             description=&#39;Remove Response&#39;,
                                             tooltip=&#39;Whether to remove instrument response. Must have metadata attached to data.&#39;,
                                             disabled=False)

    skip_on_gaps_check  = widgets.Checkbox(value=False,
                                           description=&#39;Skip on Gaps&#39;,
                                           tooltip=&#39;Whether to skip windows if there are gaps&#39;,
                                           disabled=False)

    obspy_ppsds_check = widgets.Checkbox(value=False,
                                         description=&#39;Use Obspy PPSDs&#39;,
                                         tooltip=&#39;Whether to use the Obspy PPSD class to create PPSDs&#39;,
                                         disabled=False)
    
    azimuthal_psds_check = widgets.Checkbox(value=False,
                                            description=&#39;Use Azimuths&#39;,
                                            tooltip=&#39;Whether to generate PSDs based on azimuths&#39;,
                                            disabled=False)

    num_freq_bins_dropdown = widgets.Dropdown(options=[64,128,512,1024,2048],
                                            value=512,
                                            tooltip=&#39;The number of frequency bins to use in creating PSDs&#39;,
                                            description=&#39;# Freq. Bins&#39;,)

    hvsr_band_gpsd_Rangeslide = widgets.FloatRangeSlider(value=sprit_hvsr.DEFAULT_BAND,
                                                         min=0.1,
                                                         max=64, 
                                                         step=0.1,
                                                         description=&#39;HVSR Band&#39;,
                                                         tooltip=&#39;Define the frequency range over which HVSR data is processed&#39;,
                                                         readout_format=&#39;.1f&#39;,
                                                         layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    widgets.link((hvsr_band_gpsd_Rangeslide, &#39;value&#39;), (hvsr_band_rangeSlide, &#39;value&#39;))

    peak_freq_gpsd_rangeSlide = widgets.FloatRangeSlider(value=sprit_hvsr.DEFAULT_BAND,
                                                         min=0.1,
                                                         max=64, 
                                                         step=0.1,
                                                         description=&#39;Peak Range&#39;,
                                                         tooltip=&#39;Define the frequency range over which to search for peaks&#39;,
                                                         readout_format=&#39;.1f&#39;,
                                                         layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    widgets.link((peak_freq_gpsd_rangeSlide, &#39;value&#39;), (peak_freq_rangeSlide, &#39;value&#39;))

    # Obspy PPSD SETTINGS
    ppsd_length_label = widgets.Label(value=&#39;Window Length for PPSDs:&#39;)
    ppsd_length = widgets.FloatText(style={&#39;description_width&#39;: &#39;initial&#39;}, 
                                    placeholder=20, value=20,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    
    overlap_pct_label = widgets.Label(value=&#39;Overlap %:&#39;)
    overlap_pct = widgets.FloatText(style={&#39;description_width&#39;: &#39;initial&#39;}, 
                                    placeholder=0.5, value=0.5, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    period_step_label = widgets.Label(value=&#39;Period Step Octaves:&#39;)
    period_step_octave = widgets.FloatText(style={&#39;description_width&#39;: &#39;initial&#39;}, 
                                           placeholder=0.0625, value=0.0625, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    skip_on_gaps_label = widgets.Label(value=&#39;Skip on gaps:&#39;)
    skip_on_gaps = widgets.Checkbox(value=False, disabled=False, indent=False)

    db_step_label = widgets.Label(value=&#39;dB bins:&#39;)
    db_bins_min = widgets.FloatText(description=&#39;Min. dB&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=-200, value=-200, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    db_bins_max = widgets.FloatText(description=&#39;Max. dB&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=-50, value=-50, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    db_bins_step = widgets.FloatText(description=&#39;dB Step&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=1, value=1, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    
    period_limit_label = widgets.Label(value=&#39;Period Limits:&#39;)
    minPLim = round(1/(hvsr_band_rangeSlide.value[1]), 3)
    maxPLim = round(1/(hvsr_band_rangeSlide.value[0]), 3)
    period_limits_min = widgets.FloatText(description=&#39;Min. Period Limit&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=minPLim, value=minPLim, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    period_limits_max = widgets.FloatText(description=&#39;Max. Period Limit&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=maxPLim, value=maxPLim, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    period_smoothing_width = widgets.FloatText(description=&#39;Period Smoothing Width&#39;, style={&#39;description_width&#39;: &#39;initial&#39;},
                                    placeholder=1, value=1, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    special_handling_dropdown = widgets.Dropdown(description=&#39;Special Handling&#39;, value=&#39;none&#39;,
                                                options=[(&#39;None&#39;, &#39;none&#39;), (&#39;Ringlaser&#39;, &#39;ringlaser&#39;), (&#39;Hydrophone&#39;, &#39;hydrophone&#39;)],
                                            style={&#39;description_width&#39;: &#39;initial&#39;},  layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    generate_psds_grid[0, 0] = widgets.Label(&#34;Window settings&#34;)
    generate_psds_grid[0, 1] = window_length_float
    generate_psds_grid[0, 2] = window_length_method_dropdown
    generate_psds_grid[1, 1] = overlap_pct_float
    generate_psds_grid[1, 2] = window_type_dropdown
    generate_psds_grid[2, 0] = remove_response_check
    generate_psds_grid[2, 1] = skip_on_gaps_check
    generate_psds_grid[2, 2] = obspy_ppsds_check
    generate_psds_grid[2, 3] = azimuthal_psds_check
    generate_psds_grid[3, 0] = num_freq_bins_dropdown
    generate_psds_grid[4, 0:2] = peak_freq_gpsd_rangeSlide
    generate_psds_grid[5, 0:2] = hvsr_band_gpsd_Rangeslide
    
    # Process HVSR
    # horizontal_method=None, 
    # smooth=True, freq_smooth=&#39;konno ohmachi&#39;, f_smooth_width=40, 
    # resample=True, 
    # outlier_curve_rmse_percentile=False, 
    # azimuth=None, 
    # verbose=False

    # HVSR SETTINGS SUBTAB
    h_combine_meth_dropdown = widgets.Dropdown(description=&#39;&#39;, value=3,
                                      tooltip=&#34;Select how to combine the horizontal components&#34;,
                                      options=[(&#39;1. Differential Field Assumption&#39;, 1),
                                               (&#39;2. Arithmetic Mean |  H = (N + E)/2&#39;, 2), 
                                               (&#39;3. Geometric Mean | H = √(N * E) (SESAME recommended)&#39;, 3),
                                               (&#39;4. Vector Summation | H = √(N^2 + E^2)&#39;, 4),
                                               (&#39;5. Quadratic Mean | H = √(N^2 + E^2)/2&#39;, 5),
                                               (&#39;6. Maximum Horizontal Value | H = max(N, E)&#39;, 6),
                                               (&#39;7. Minimum Horizontal Value | H = max(N, E)&#39;, 7),
                                               (&#39;8. Single Azimuth |  H = H2·cos(az) + H1·sin(az)&#39;, 8)])

    freq_smoothing_dropdown = widgets.Dropdown(description=&#39;&#39;, value=&#39;konno ohmachi&#39;,
                                      tooltip=&#34;Select which type of frequency smoothing algorithm to use&#34;,
                                      options=[(&#39;Konno-Ohmachi&#39;, &#39;konno ohmachi&#39;),
                                               (&#39;Constant&#39;,&#39;constant&#39;),
                                               (&#39;Proportional&#39;, &#39;proportional&#39;),
                                               (&#39;None&#39;, None)])
    
    freq_smooth_width_float = widgets.FloatText(description=&#39;Width&#39;,
                                          tooltip=&#34;Specify the width for the smoothing algorithm&#34;,
                                          placeholder=40, value=40)

    resample_hv_curve_bool = widgets.Checkbox(value=True, description=&#39;Resample&#39;,
                                              tooltip=&#34;Whether to resample the data to a speicified number of frequency bins.&#34;)
    resample_hv_curve = widgets.IntText(description=&#39;&#39;, tooltip=&#34;If resampling, how many frequency points/bins to use.&#34;,
                                        placeholder=512, value=512)

    smooth_hv_curve_bool = widgets.Checkbox(value=True,description=&#39;Smooth&#39;,
                                            tooltip=&#39;Whether to smooth the data (this does not account for logarithmic frequency width increases.)&#39;)
    smooth_hv_curve = widgets.IntText(description=&#39;&#39;, tooltip=&#34;The window width to use for smoothing.&#34;,
                                    placeholder=51, value=51)

    peak_selection_type = widgets.Dropdown(description=&#39;Peak Method&#39;, value=&#39;max&#39;,
                                        options=[(&#39;Highest Peak&#39;, &#39;max&#39;),
                                             (&#39;Best Scored&#39;,&#39;scored&#39;)],
                                        )#style={&#39;description_width&#39;: &#39;initial&#39;},  layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    process_hvsr_grid[0, 0] = widgets.Label(&#34;Horizontal Combination Method&#34;)
    process_hvsr_grid[0, 1:] = h_combine_meth_dropdown
    process_hvsr_grid[1, 0] = widgets.Label(&#34;Frequency Smoothing Operation&#34;)
    process_hvsr_grid[1, 1] = freq_smoothing_dropdown
    process_hvsr_grid[1, 2] = freq_smooth_width_float
    process_hvsr_grid[2, 0] = resample_hv_curve_bool
    process_hvsr_grid[2, 1] = resample_hv_curve
    process_hvsr_grid[3, 0] = smooth_hv_curve_bool
    process_hvsr_grid[3, 1] = smooth_hv_curve
    process_hvsr_grid[4, 0] = peak_selection_type

    # Remove outlier curves
    # outlier_method=&#39;prototype&#39;,
    # use_percentile=True, 
    # use_hv_curve=False, 
    # outiler_threshold=98, 
    # min_pts=5,
    # plot_engine=&#39;matplotlib&#39;, show_outlier_plot=False, generate_outlier_plot=True, 
    # verbose=False
    

    outlier_method_dropdown = widgets.Dropdown(description=&#39;Method&#39;, value=None,
                                               tooltip=&#34;Select which type of outlier removal algorithm to use.&#34;,
                                               options=[(&#39;Prototype/RMSE&#39;, &#39;prototype&#39;),
                                                        (&#39;DBSCAN&#39;,&#39;dbscan&#39;),
                                                        (&#39;None&#39;, None)])
    outlier_pctile_check = widgets.Checkbox(description=&#39;Use percentile&#39;, 
                                            value=True)
    
    use_hv_curve_outliers_check = widgets.Checkbox(description=&#34;Use HV Curves&#34;,
                                             tooltip=&#39;Whether to use HV Curve Outliers or PSD curves. HV Curves are only used after they have been calculated during the process_hvsr() step&#39;, 
                                             layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), 
                                             #style={&#39;description_width&#39;: &#39;initial&#39;}, 
                                             value=False, 
                                             disabled=False)
    
    outlier_threshold_slider = widgets.FloatSlider(value=_get_default(sprit_hvsr.remove_outlier_curves, &#39;outlier_threshold&#39;), min=0, max=100, step=0.1,
                                                description=&#39;Threshold&#39;,
                                                layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;),
                                                disabled=False)
    
    min_pts_float = widgets.FloatText(description=&#39;Min. Pts.&#39;,
                                      tooltip=&#34;The minimum number of points in a neighborhood, when &#39;DBSCAN&#39; is used for the outlier method.&#34;,
                                      placeholder=5, value=5, disabled=True)
    def outlier_method_update(event):
        if &#39;dbscan&#39; in str(outlier_method_dropdown.value).lower():
            min_pts_float.disabled=False
        else:
            min_pts_float.disabled=True
    outlier_method_dropdown.observe(outlier_method_update)

    # Define Outlier Fig
    global outlier_fig
    outlier_fig = go.FigureWidget()
    outlier_graph_widget = widgets.Output()

    remove_outliers_grid[0, 0] = widgets.Label(&#34;Outlier Curve Removal&#34;)
    remove_outliers_grid[1, 0] = use_hv_curve_outliers_check
    remove_outliers_grid[1, 1] = outlier_method_dropdown
    remove_outliers_grid[1, 2] = min_pts_float
    remove_outliers_grid[2, 0] = outlier_pctile_check
    remove_outliers_grid[2, 1:] = outlier_threshold_slider

    # PYTHON API ACCORDION
    inputAPI_grid = widgets.GridspecLayout(6, 10)

    # A text label with &#34;input_params()&#34;
    #run_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;sprit.run&#39; + &#39;&lt;/p&gt;&#39;, 
    #                                   layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    #run_call = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;()&#39; + &#39;&lt;/p&gt;&#39;,
    #                                 layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-start&#39;,align_content=&#39;flex-start&#39;),)
    #input_params_call =  widgets.Label(value=&#39;input_params()&#39;, layout=widgets.Layout(width=&#39;auto&#39;))
    #inputAPI_grid[0, 0] = run_prefix
    #inputAPI_grid[0, 1:] = run_call

    # A text label with &#34;input_params()&#34;
    input_params_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;input_params&#39; + &#39;&lt;/p&gt;&#39;, 
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    input_params_call = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;()&#39; + &#39;&lt;/p&gt;&#39;,
                                     layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-start&#39;,align_content=&#39;flex-start&#39;),)
    #input_params_call =  widgets.Label(value=&#39;input_params()&#39;, layout=widgets.Layout(width=&#39;auto&#39;))
    inputAPI_grid[0, 0] = input_params_prefix
    inputAPI_grid[0, 1:] = input_params_call

    # A text label with &#34;fetch_data()&#34;
    fetch_data_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;fetch_data&#39; + &#39;&lt;/p&gt;&#39;, 
                                     layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    fetch_data_call = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;()&#39; + &#39;&lt;/p&gt;&#39;,
                                   layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-start&#39;,align_content=&#39;flex-start&#39;),)
    inputAPI_grid[1, 0] = fetch_data_prefix
    inputAPI_grid[1, 1:] = fetch_data_call

    # Generate PPSDs python call
    generate_psds_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;generate_psds&#39; + &#39;&lt;/p&gt;&#39;, 
                                     layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    generate_psds_call = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;()&#39; + &#39;&lt;/p&gt;&#39;,
                                   layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-start&#39;,align_content=&#39;flex-start&#39;),)
    inputAPI_grid[2, 0] = generate_psds_prefix
    inputAPI_grid[2, 1:] = generate_psds_call

    # Process HVSR call
    process_hvsr_call_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;process_hvsr&#39; + &#39;&lt;/p&gt;&#39;, )
                                            #layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;, align_content=&#39;flex-start&#39;))
    process_hvsr_call = widgets.HTML(value=&#39;()&#39;)
    inputAPI_grid[3, 0] = process_hvsr_call_prefix
    inputAPI_grid[3, 1:] = process_hvsr_call

    # Remove Outlier Curves call
    remove_outlier_curves_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;remove_outlier_curves&#39; + &#39;&lt;/p&gt;&#39;, )
                                            #layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;, align_content=&#39;flex-start&#39;))
    remove_outlier_curves_call = widgets.HTML(value=&#39;()&#39;)
    inputAPI_grid[4, 0] = remove_outlier_curves_prefix
    inputAPI_grid[4, 1:] = remove_outlier_curves_call

    # Check peaks
    check_peaks_call_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39;+&#39;check_peaks&#39; + &#39;&lt;/p&gt;&#39;,
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    check_peaks_call = widgets.HTML(value=&#39;()&#39;)
    #check_peaks_call_hbox = widgets.HBox([check_peaks_call_prefix, check_peaks_call])
    inputAPI_grid[5, 0] = check_peaks_call_prefix
    inputAPI_grid[5, 1:] = check_peaks_call

    # Set it all in place
    #metaLabel = widgets.Label(&#39;Input Params&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    #fetchLabel = widgets.Label(&#39;Fetch Data&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    #remNoiseLabel = widgets.Label(&#39;Noise Removal&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    #azimuthLabel = widgets.Label(&#39;Calculate Azimuths&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    #genPSDLabel = widgets.Label(&#39;Generate PSDs&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    #procHVSRLabel = widgets.Label(&#39;Process HVSR&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    #remCurveLabel = widgets.Label(&#39;Remove Outlier Curves&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    #checkPeakLabel = widgets.Label(&#39;Check Peaks&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    #reportLabel = widgets.Label(&#39;Get Reports&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    #apiLabel = widgets.Label(&#39;API Call&#39;, layout=widgets.Layout(height=&#39;20%&#39;, align_content=&#39;center&#39;, justify_content=&#39;flex-end&#39;))
    #input_accordion_label_box.children = [metaLabel, instLabel, locLabel, ioparmLabel, apiLabel]
    #input_accordion_label_box.layout = widgets.Layout(align_content=&#39;space-between&#39;, width=&#39;5%&#39;)

    input_accordion.children = [input_params_grid, 
                                fetch_data_grid,
                                calculate_azimuths_grid,
                                noise_removal_grid,
                                generate_psds_grid,
                                process_hvsr_grid,
                                remove_outliers_grid,
                                inputAPI_grid]
    input_accordion.titles = [&#34;Input Params&#34;, 
                              &#34;Fetch Data&#34;,
                              &#34;Calculate Azimuths&#34;,
                              &#34;Noise Removal&#34;, 
                              &#34;Generate PSDs&#34;,
                              &#34;Process HVSR&#34;,
                              &#34;Remove Outlier Curves&#34;,
                              &#34;See Python API Call&#34;]
    input_accordion_box.layout = widgets.Layout(align_content=&#39;space-between&#39;, width=&#39;99%&#39;)
    
    input_accordion.layout = widgets.Layout(width=&#39;99%&#39;)

    # ADD THE REST OF THE WIDGETS AROUND THE ACCORDIONS
    tenpct_spacer = widgets.Button(description=&#39;&#39;, layout=widgets.Layout(width=&#39;20%&#39;, visibility=&#39;hidden&#39;))
    fivepct_spacer = widgets.Button(description=&#39;&#39;, layout=widgets.Layout(width=&#39;5%&#39;, visibility=&#39;hidden&#39;))

    # A text box labeled Data Filepath
    data_filepath = widgets.Text(description=&#39;Data Filepath&#39;,
                                    placeholder=&#39;sample&#39;, value=&#39;sample&#39;,
                                    #style={&#39;description_width&#39;: &#39;initial&#39;},
                                    layout=widgets.Layout(width=&#39;100%&#39;))
    # A button next to input_data text labeled &#34;Browse&#34;
    browse_data_button = widgets.Button(description=&#39;Browse&#39;, layout=widgets.Layout(width=&#39;100%&#39;))
    def select_datapath(event):
        try:
            from tkinter import tk, filedialog
            root = tk.Tk()
            root.wm_attributes(&#39;-topmost&#39;, True)
            root.withdraw()
            if data_source_type.value == &#39;file&#39; or data_source_type.value == &#39;batch&#39;:
                filepaths = filedialog.askopenfilenames(defaultextension=&#39;.MSEED&#39;, title=&#39;Select Data File&#39;)
                if isinstance(filepaths, tuple):
                    if len(filepaths) == 1:
                        filepaths = str(filepaths[0])
                data_filepath.value = str(filepaths)
            else:
                data_filepath.value = str(filedialog.askdirectory(mustexist=True, title=&#34;Select Data Directory&#34;))
            root.destroy()
        except Exception as e:
            print(e)
            browse_data_button.disabled=True
            browse_data_button.description=&#39;Use Text Field&#39;
    browse_data_button.on_click(select_datapath)

    def on_input_data_change(event):
        export_directory_text.value = pathlib.Path(data_filepath.value).parent.as_posix()
        if export_directory_text.value == &#39;.&#39; or not pathlib.Path(export_directory_text.value).exists():
            export_directory_text.value = pathlib.Path().home().as_posix()
    data_filepath.observe(on_input_data_change)
    # Dropdown with different source types 
    data_source_type = widgets.Dropdown(options=[(&#39;File&#39;, &#39;file&#39;), (&#39;Raw&#39;, &#39;raw&#39;), (&#39;Batch&#39;, &#39;batch&#39;), (&#39;Directory&#39;, &#39;dir&#39;)],
                                            description=&#39;Data Source type:&#39;,
                                            value=&#39;file&#39;,orientation=&#39;horizontal&#39;,
                                            style={&#39;description_width&#39;: &#39;initial&#39;},
                                            layout=widgets.Layout(width=&#39;90%&#39;))
    def on_ds_change(event):
        if data_source_type.value == &#39;file&#39; or data_source_type.value== &#39;batch&#39;:
            browse_data_button.description = &#39;Select Files&#39;
        else:
            browse_data_button.description = &#39;Select Folders&#39;
    data_source_type.observe(on_ds_change)

    # Processing Settings
    processing_settings_button = widgets.FileUpload(accept=&#39;.proc&#39;, description=&#39;Processing Settings&#39;,
                                            multiple=False,layout=widgets.Layout(width=&#39;10%&#39;))

    # Whether to show plots outside of widget
    show_plot_check =  widgets.Checkbox(description=&#39;Print Plots&#39;, value=False, disabled=False, indent=False,
                                    layout=widgets.Layout(width=&#39;8%&#39;, justify_content=&#39;flex-end&#39;))


    # Whether to print to terminal
    verbose_check = widgets.Checkbox(description=&#39;Verbose&#39;, value=False, disabled=False, indent=False,
                                    layout=widgets.Layout(width=&#39;5%&#39;, justify_content=&#39;flex-end&#39;))

    # A progress bar
    progress_bar = widgets.FloatProgress(value=0.0,min=0.0,max=1.0,
                                    bar_style=&#39;info&#39;,
                                    orientation=&#39;horizontal&#39;,layout=widgets.Layout(width=&#39;100%&#39;))

    # A dark yellow button labeled &#34;Read Data&#34;
    read_data_button = widgets.Button(description=&#39;Read Data&#39;,
                                    button_style=&#39;warning&#39;)


    # A forest green button labeled &#34;Run&#34;
    process_hvsr_button = widgets.Button(description=&#39;Run&#39;,
                                         button_style=&#39;success&#39;)

    # Update input_param call
    def update_input_param_call():
        input_param_text = f&#34;&#34;&#34;(input_data=&#39;{data_filepath.value}&#39;, metadata=&#39;{metadata_filepath.value}&#39;, site=&#39;{site_textbox.value}&#39;, project=&#39;{project_textbox.value}&#39;, network=&#39;{network_textbox.value}&#39;,
                    station=&#39;{station_textbox.value}&#39;, location=&#39;{location_textbox.value}&#39;, loc=&#39;{location_textbox.value}&#39;, channels={[z_channel_textbox.value, e_channel_textbox.value, n_channel_textbox.value]},
                    acq_date=&#39;{acquisition_date_picker.value}&#39;, starttime=&#39;{start_time_picker.value}&#39;, endtime=&#39;{end_time_picker.value}&#39;, tzone=&#39;{time_zone_dropdown.value}&#39;,
                    xcoord={xcoord_textbox.value}, ycoord={ycoord_textbox.value}, elevation={zcoord_textbox.value}, depth=0
                    input_crs=&#39;{input_crs_textbox.value}&#39;, output_crs=&#39;{output_crs_textbox.value}&#39;, elev_unit=&#39;{elev_unit_dropdown.value}&#39;,
                    instrument=&#39;{instrument_dropdown.value}&#39;, hvsr_band={hvsr_band_rangeSlide.value},
                    peak_freq_range={[peak_freq_rangeSlide.value[0], peak_freq_rangeSlide.value[1]]}, verbose={verbose_check.value})&#34;&#34;&#34;
        input_params_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + input_param_text + &#39;&lt;/p&gt;&#39;
    update_input_param_call()
    
    # Update fetch_data call
    def update_fetch_data_call():
        fetch_data_text = f&#34;&#34;&#34;(params=hvsr_data, source={data_source_type.value}, data_export_path={data_export_path_textbox.value},
                            data_export_format={data_export_format_dropdown.value}, 
                            detrend_type={detrend_type_dropdown.value}, detrend_options={detrend_options.value}, 
                            filter_type={filter_type_dropdown.value}, filter_options={filter_options.value},
                            update_metadata={update_metadata_checkbox.value},
                            verbose={verbose_check.value}, ...)&#34;&#34;&#34;
        fetch_data_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + fetch_data_text + &#39;&lt;/p&gt;&#39;
    update_fetch_data_call()


    main_settings_grid = widgets.GridspecLayout(15, 10)
    
    main_settings_grid[0, 0:6] = data_filepath
    main_settings_grid[0, 6:7] = browse_data_button
    main_settings_grid[0, 8:] = data_source_type
    
    main_settings_grid[1,:] = widgets.HTML(&#39;&lt;hr&gt;&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;))

    main_settings_grid[2, 0:2] = site_textbox
    main_settings_grid[2, 2:4] = project_textbox

    main_settings_grid[3, 0:2] = station_textbox
    main_settings_grid[3, 2:4] = instrument_dropdown

    main_settings_grid[4,:6] = widgets.HTML(&#39;&lt;hr&gt;&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;))

    main_settings_grid[5, 0:1] = xcoord_textbox
    main_settings_grid[5, 2:3] = ycoord_textbox
    main_settings_grid[5, 4:5] = zcoord_textbox

    main_settings_grid[6, 0] = input_crs_textbox
    main_settings_grid[6, 2] = output_crs_textbox
    main_settings_grid[6, 4] = elev_unit_dropdown
    
    main_settings_grid[7,:6] = widgets.HTML(&#39;&lt;hr&gt;&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;))
    
    main_settings_grid[8, 0:2] = acquisition_date_picker
    main_settings_grid[8, 2] = acquisition_doy

    main_settings_grid[9,0:2] = start_time_picker
    main_settings_grid[9,2] = end_time_picker
    main_settings_grid[9,3:5] = time_zone_dropdown
    
    main_settings_grid[10,:6] = widgets.HTML(&#39;&lt;hr&gt;&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;))
    
    main_settings_grid[11,0:4] = peak_freq_rangeSlide
    main_settings_grid[12,0:4] = hvsr_band_rangeSlide
    
    main_settings_grid[13,:] = widgets.HTML(&#39;&lt;hr&gt;&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;))

    input_accordion_box.children = [input_accordion]
    #main_settings_grid[6:9, :] = input_accordion_box

    main_settings_grid[14, 0:8] = progress_bar
    main_settings_grid[14, 8] = read_data_button
    main_settings_grid[14, 9] = process_hvsr_button


    # Create a GridBox with 12 rows and 20 columns
    global input_tab
    input_tab = widgets.GridBox(layout=widgets.Layout(grid_template_columns=&#39;repeat(10, 1)&#39;,
                                                grid_template_rows=&#39;repeat(12, 1)&#39;))

    input_subtabs = widgets.Tab([main_settings_grid, input_accordion_box])
    input_subtabs.set_title(0, &#34;Main Inputs&#34;)
    input_subtabs.set_title(1, &#34;Additional Settings&#34;)
    
    input_tab = widgets.VBox(children=[input_subtabs])

    def get_input_params():
        input_params_kwargs={
            &#39;input_data&#39;:data_filepath.value,
            &#39;project&#39;:project_textbox.value,
            &#39;metadata&#39;:metadata_filepath.value,
            &#39;site&#39;:site_textbox.value,
            &#39;instrument&#39;:instrument_dropdown.value,
            &#39;network&#39;:network_textbox.value, &#39;station&#39;:station_textbox.value, &#39;location&#39;:location_textbox.value, 
            &#39;channels&#39;:[z_channel_textbox.value, e_channel_textbox.value, n_channel_textbox.value],
            &#39;starttime&#39;:start_time_picker.value,
            &#39;endtime&#39;:end_time_picker.value,
            &#39;tzone&#39;:time_zone_dropdown.value,
            &#39;xcoord&#39;:xcoord_textbox.value,
            &#39;ycoord&#39;:ycoord_textbox.value,
            &#39;elevation&#39;:zcoord_textbox.value, &#39;elev_unit&#39;:elev_unit_dropdown.value,&#39;depth&#39;:0,
            &#39;input_crs&#39;:input_crs_textbox.value,&#39;output_crs&#39;:output_crs_textbox.value,
            &#39;hvsr_band&#39;:hvsr_band_rangeSlide.value,
            &#39;peak_freq_range&#39;:peak_freq_rangeSlide.value}
        return input_params_kwargs

    def get_fetch_data_params():
        fetch_data_kwargs = {
            &#39;source&#39;:data_source_type.value, 
            &#39;data_export_path&#39;:data_export_path_textbox.value,
            &#39;export_format&#39;:data_export_format_dropdown.value,
            &#39;detrend_type&#39;:detrend_type_dropdown.value,
            &#39;detrend_options&#39;:detrend_options.value,
            &#39;filter_type&#39;:filter_type_dropdown.value,
            &#39;filter_options&#39;:filter_options.value,
            &#39;update_metadata&#39;:update_metadata_checkbox.value           
            }

        if str(fetch_data_kwargs[&#39;detrend_type&#39;]).lower() == &#39;none&#39;:
            fetch_data_kwargs[&#39;detrend_type&#39;] = None
        
        if str(fetch_data_kwargs[&#39;data_export_path&#39;]).lower() == &#39;none&#39;:
            fetch_data_kwargs[&#39;data_export_path&#39;] = None

        if str(fetch_data_kwargs[&#39;filter_type&#39;]).lower() == &#39;none&#39;:
            fetch_data_kwargs[&#39;filter_type&#39;] = None

        return fetch_data_kwargs

    def read_data(button):
        progress_bar.value = 0
        log_textArea.value += f&#34;\n\nREADING DATA [{datetime.datetime.now()}]&#34;

        ip_kwargs = get_input_params()
        hvsr_data = sprit_hvsr.input_params(**ip_kwargs, verbose=verbose_check.value)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\ninput_params():\n&#39;{ip_kwargs}&#34;
        if button.description==&#39;Read Data&#39;:
            progress_bar.value=0.333
        else:
            progress_bar.value=0.1
        fd_kwargs = get_fetch_data_params()
        hvsr_data = sprit_hvsr.fetch_data(hvsr_data, **fd_kwargs, verbose=verbose_check.value)
        log_textArea.value += &#39;\n\n&#39;+str(datetime.datetime.now())+&#39;\nfetch_data():\n\t&#39;+str(fd_kwargs)
        if button.description==&#39;Read Data&#39;:
            progress_bar.value=0.666
        else:
            progress_bar.value=0.2
        
        use_hv_curve_outliers_check.value=False
        use_hv_curve_outliers_check.disabled=True

        update_preview_fig(hvsr_data, preview_fig)

        if button.description==&#39;Read Data&#39;:
            sprit_tabs.selected_index = 1
            progress_bar.value=0
        return hvsr_data
    
    read_data_button.on_click(read_data)

    def get_remove_noise_kwargs():
        def get_remove_method():
            remove_method_list=[]
            do_stalta = stalta_check.value
            do_sat_pct = max_saturation_check.value
            do_noiseWin=noisy_windows_check.value
            do_warmcool=warmcool_check.value
            
            if auto_remove_check.value:
                remove_method_list=[&#39;stalta&#39;, &#39;saturation&#39;, &#39;noise&#39;, &#39;warmcool&#39;]
            else:
                if do_stalta:
                    remove_method_list.append(&#39;stalta&#39;)
                if do_sat_pct:
                    remove_method_list.append(&#39;saturation&#39;)
                if do_noiseWin:
                    remove_method_list.append(&#39;noise&#39;)
                if do_warmcool:
                    remove_method_list.append(&#39;warmcool&#39;)
            
            if not remove_method_list:
                remove_method_list = None
            return remove_method_list
        
        remove_noise_kwargs = {&#39;remove_method&#39;:get_remove_method(),
                                &#39;sat_percent&#39;:max_saturation_pct.value, 
                                &#39;noise_percent&#39;:max_window_pct.value,
                                &#39;sta&#39;:sta.value,
                                &#39;lta&#39;:lta.value, 
                                &#39;stalta_thresh&#39;:[stalta_thresh_low.value, stalta_thresh_hi.value], 
                                &#39;warmup_time&#39;:warmup_time.value,
                                &#39;cooldown_time&#39;:cooldown_time.value,
                                &#39;min_win_size&#39;:noisy_window_length.value,
                                &#39;remove_raw_noise&#39;:raw_data_remove_check.value,
                                &#39;verbose&#39;:verbose_check.value}
        return remove_noise_kwargs

    def get_generate_ppsd_kwargs():
        ppsd_kwargs = {
                    &#39;window_length&#39;:window_length_float.value,
                    &#39;overlap_pct&#39;:overlap_pct_float.value,
                    &#39;window_type&#39;:window_type_dropdown.value,
                    &#39;window_length_method&#39;:window_length_method_dropdown.value,
                    &#39;remove_response&#39;:remove_response_check.value,
                    &#39;skip_on_gaps&#39;:skip_on_gaps_check.value,
                    &#39;num_freq_bins&#39;:num_freq_bins_dropdown.value,
                    &#39;obspy_ppsds&#39;:obspy_ppsds_check.value,
                    &#39;azimuthal_psds&#39;:azimuthal_psds_check.value,
                    &#39;verbose&#39;:verbose_check.value,
                    &#39;obspy_ppsds_kwargs&#39;:{&#39;db_bins&#39;:[db_bins_min.value, db_bins_max.value, db_bins_step.value],
                                 &#39;ppsd_length&#39;:ppsd_length.value,
                                 &#39;special_handling&#39;:special_handling_dropdown.value,
                                 &#39;period_smoothing_width_octaves&#39;:period_smoothing_width.value,
                                 &#39;period_step_octaves&#39;:period_step_octave.value,
                                 &#39;period_limits&#39;:[period_limits_min.value, period_limits_max.value]}
                    }

        if str(ppsd_kwargs[&#39;obspy_ppsds_kwargs&#39;][&#39;special_handling&#39;]).lower() == &#39;none&#39;:
            ppsd_kwargs[&#39;obspy_ppsds_kwargs&#39;][&#39;special_handling&#39;] = None        
        return ppsd_kwargs


    # Update process_hvsr call
    def update_generate_psds_call():
        #gp_kwargs = get_generate_ppsd_kwargs()
        gp_text = f&#34;&#34;&#34;(hvsr_data=hvsr_data, 
                        window_length={window_length_float.value}, 
                        overlap_pct={overlap_pct_float.value},
                        window_type={window_type_dropdown.value},
                        window_length_method={window_length_method_dropdown.value},
                        remove_response={remove_response_check.value},
                        skip_on_gaps={skip_on_gaps_check.value},
                        num_freq_bins={num_freq_bins_dropdown.value},
                        obspy_ppsds={obspy_ppsds_check.value},
                        azimuthal_psds={azimuthal_psds_check.value},
                        ...
                        obspy_ppsd_kwargs=...,
                        verbose={verbose_check.value})&#34;&#34;&#34;
        generate_psds_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + gp_text + &#39;&lt;/p&gt;&#39;
    update_generate_psds_call()

    def get_remove_outlier_curve_kwargs():
        roc_kwargs = {
                &#39;outlier_method&#39;:outlier_method_dropdown.value,
                &#39;use_percentile&#39;:outlier_pctile_check.value,
                &#39;use_hv_curves&#39;:use_hv_curve_outliers_check.value,
                &#39;outlier_threshold&#39;:outlier_threshold_slider.value,
                &#39;min_pts&#39;:min_pts_float.value,
                &#39;verbose&#39;:verbose_check.value
            }
        return roc_kwargs

    def get_process_hvsr_kwargs():
        if smooth_hv_curve_bool.value:
            smooth_value = smooth_hv_curve.value
        else:
            smooth_value = smooth_hv_curve_bool.value

        if resample_hv_curve_bool.value:
            resample_value = resample_hv_curve.value
        else:
            resample_value = resample_hv_curve_bool.value

        ph_kwargs={&#39;horizontal_method&#39;:h_combine_meth_dropdown.value,
                    &#39;smooth&#39;:smooth_value,
                    &#39;freq_smooth&#39;:freq_smoothing_dropdown.value,
                    &#39;f_smooth_width&#39;:freq_smooth_width_float.value,
                    &#39;resample&#39;:resample_value,
                    &#39;verbose&#39;:verbose_check.value}
        return ph_kwargs

    # Update process_hvsr call
    def update_process_hvsr_call():
        #ph_kwargs = get_process_hvsr_kwargs()
        ph_text = f&#34;&#34;&#34;(hvsr_data=hvsr_data, 
                        horizontal_method={h_combine_meth_dropdown.value}, 
                        smooth={smooth_hv_curve_bool.value}, 
                        freq_smooth={freq_smoothing_dropdown.value}, 
                        f_smooth_width={freq_smooth_width_float.value}, 
                        resample={resample_hv_curve_bool.value}, 
                        verbose={verbose_check.value})&#34;&#34;&#34;
        process_hvsr_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + ph_text + &#39;&lt;/p&gt;&#39;
    #update_process_hvsr_call()


    def get_check_peaks_kwargs():
        cp_kwargs = {&#39;hvsr_band&#39;:hvsr_band_rangeSlide.value,
                    &#39;peak_freq_range&#39;:peak_freq_rangeSlide.value,
                    &#39;peak_selection&#39;:peak_selection_type.value,
                    &#39;verbose&#39;:verbose_check.value}
        return cp_kwargs

    def _get_get_report_kwargs():
        def get_formatted_plot_str():
            # Initialize plot string
            hvsr_plot_str = &#39;&#39;
            comp_plot_str = &#39;&#39;
            spec_plot_str = &#39;&#39;

            # Whether to use each plot
            if use_plot_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34;HVSR&#34;
            if use_plot_comp.value:
                comp_plot_str=comp_plot_str + &#34;C&#34;
            if use_plot_spec.value:
                spec_plot_str=spec_plot_str + &#34;SPEC&#34;

            # Whether components be on the same plot as HV curve?
            if not combine_hv_comp.value:
                comp_plot_str=comp_plot_str + &#34;+&#34;
            else:
                comp_plot_str=comp_plot_str.replace(&#39;+&#39;,&#39;&#39;)

            # Whether to show (log) standard deviations
            if not show_std_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; -s&#34;
            if not show_std_comp.value:
                comp_plot_str=comp_plot_str + &#34; -s&#34;                

            # Whether to show all peaks
            if show_all_peaks_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; all&#34;

            # Whether curves from each time window are shown
            if show_all_curves_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; t&#34;
            if show_all_curves_comp.value:
                comp_plot_str=comp_plot_str + &#34; t&#34;

            # Whether the best peak is displayed
            if show_best_peak_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; p&#34;
            if show_best_peak_comp.value:
                comp_plot_str=comp_plot_str + &#34; p&#34;
            if show_best_peak_spec.value:
                spec_plot_str=spec_plot_str + &#34; p&#34;

            # Whether best peak value is annotated
            if ann_best_peak_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; ann&#34;
            if ann_best_peak_comp.value:
                comp_plot_str=comp_plot_str + &#34; ann&#34;
            if ann_best_peak_spec.value:
                spec_plot_str=spec_plot_str + &#34; ann&#34;

            # Whether peaks from individual time windows are shown
            if show_ind_peaks_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; tp&#34;
            if show_ind_peaks_spec.value:
                spec_plot_str=spec_plot_str + &#39; tp&#39;
            
            # Whether to show legend
            if show_legend_hv.value:
                hvsr_plot_str=hvsr_plot_str + &#34; leg&#34;
            if ann_best_peak_comp.value:
                comp_plot_str=comp_plot_str + &#34; leg&#34;
            if show_legend_spec.value:
                spec_plot_str=spec_plot_str + &#34; leg&#34;            

            # Combine string into one
            plot_str = hvsr_plot_str + &#39; &#39; + comp_plot_str+ &#39; &#39; + spec_plot_str
            return plot_str

        gr_kwargs = {&#39;report_formats&#39;:[&#39;print&#39;,&#39;table&#39;],
                     &#39;plot_type&#39;:get_formatted_plot_str(),
                     &#39;plot_engine&#39;:&#39;plotly&#39;,
                     &#39;report_export_path&#39;:None,
                     &#39;csv_overwrite_opt&#39;:&#39;overwrite&#39;,
                     &#39;suppress_report_outputs&#39;:False,
                    &#39;verbose&#39;:verbose_check.value
                     }
        return gr_kwargs

    def process_data(button):
        startProc=datetime.datetime.now()
        progress_bar.value = 0
        log_textArea.value += f&#34;\n\nPROCESSING DATA [{startProc}]&#34;
        global hvsr_data
        # Read data again only if internal hvsr_data input_data variable is different from what is in the gui
        if not &#39;hvsr_data&#39; in globals() or not hasattr(hvsr_data, &#39;input_data&#39;) or \
                (pathlib.Path(hvsr_data.input_data).as_posix() != pathlib.Path(data_filepath.value).as_posix()):
            hvsr_data = read_data(button)

        remove_noise_kwargs = get_remove_noise_kwargs()
        hvsr_data = sprit_hvsr.remove_noise(hvsr_data, **remove_noise_kwargs)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nremove_noise()\n\t{remove_noise_kwargs}&#34;
        progress_bar.value = 0.3

        generate_ppsd_kwargs = get_generate_ppsd_kwargs()
        hvsr_data = sprit_hvsr.generate_psds(hvsr_data, **generate_ppsd_kwargs)
        progress_bar.value = 0.5
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\ngenerate_ppsds()\n\t{generate_ppsd_kwargs}&#34;
        
       
        # If this was started by clicking &#34;Generate PPSDs&#34;, stop here
        if button.description == &#39;Generate PPSDs&#39;:
            return

        ph_kwargs = get_process_hvsr_kwargs()
        hvsr_data = sprit_hvsr.process_hvsr(hvsr_data, **ph_kwargs)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nprocess_hvsr()\n\t{ph_kwargs}&#34;
        progress_bar.value = 0.75
        update_outlier_fig()

        roc_kwargs = get_remove_outlier_curve_kwargs()
        hvsr_data = sprit_hvsr.remove_outlier_curves(hvsr_data, **roc_kwargs)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nremove_outlier_curves()\n\t{roc_kwargs}&#34;
        progress_bar.value = 0.85
        outlier_fig, hvsr_data = update_outlier_fig()

        use_hv_curve_outliers_check.value=False
        use_hv_curve_outliers_check.disabled=False

        def get_rmse_range():
            minRMSE = 10000
            maxRMSE = -1
            if roc_kwargs[&#39;use_hv_curves&#39;]:
                colnames = [&#39;HV_Curves&#39;]
            else:
                colnames = [&#39;psd_values_Z&#39;,
                            &#39;psd_values_E&#39;,
                            &#39;psd_values_N&#39;]
            dataList = []
            for col in colnames:
                dataArr = np.stack(hvsr_data.hvsr_windows_df[col])
                medCurveArr = np.nanmedian(dataArr, axis=0)
                rmse = np.sqrt(((np.subtract(dataArr, medCurveArr)**2).sum(axis=1))/dataArr.shape[1])
                if rmse.min() &lt; minRMSE:
                    minRMSE = rmse.min()
                if rmse.max() &gt; maxRMSE:
                    maxRMSE = rmse.max()
            outlier_threshold_slider.min = minRMSE
            outlier_threshold_slider.max = maxRMSE
            outlier_threshold_slider.step = round((maxRMSE-minRMSE)/100, 2)
            outlier_threshold_slider.value = maxRMSE
        get_rmse_range()

        cp_kwargs = get_check_peaks_kwargs()
        hvsr_data = sprit_hvsr.check_peaks(hvsr_data, **cp_kwargs)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\ncheck_peaks()\n\t{cp_kwargs}&#34;
        progress_bar.value = 0.9

        gr_kwargs = _get_get_report_kwargs()
        hvsr_data = sprit_hvsr.get_report(hvsr_data, **gr_kwargs)
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nget_report()\n\t{gr_kwargs}\n\n&#34;
        hvsr_data.get_report(report_formats=[&#39;print&#39;]) # Just in case print wasn&#39;t included
        log_textArea.value += hvsr_data[&#39;Print_Report&#39;]
        printed_results_textArea.value = hvsr_data[&#39;Print_Report&#39;]
        hvsr_data.get_report(report_formats=[&#39;table&#39;]) 
        results_table.value = hvsr_data[&#39;Table_Report&#39;].to_html()
        
        log_textArea.value += f&#39;Processing time: {datetime.datetime.now() - startProc}&#39;
        progress_bar.value = 0.95

        update_results_fig(hvsr_data, gr_kwargs[&#39;plot_type&#39;])
        
        progress_bar.value = 1
        global hvsr_results
        hvsr_results = hvsr_data
        return hvsr_results
        
    def parse_plot_string(plot_string):
        plot_list = plot_string.split()

        hvsrList = [&#39;hvsr&#39;, &#39;hv&#39;, &#39;h&#39;]
        compList = [&#39;component&#39;, &#39;comp&#39;, &#39;c&#39;]
        compPlus = [item + &#39;+&#39; for item in compList]
        specList = [&#39;spectrogram&#39;, &#39;specgram&#39;, &#39;spec&#39;,&#39;sg&#39;, &#39;s&#39;]

        hvInd = np.nan
        compInd = np.nan
        specInd = np.nan

        hvIndFound = False
        compIndFound = False
        specIndFound = False

        for i, item in enumerate(plot_list):
            if item.lower() in hvsrList and not hvIndFound:
                # assign the index
                hvInd = i
                hvIndFound = True
            if (item.lower() in compList or item.lower() in compPlus) and not compIndFound:
                # assign the index
                compInd = i
                compIndFound = True
            if item.lower() in specList and not specIndFound:
                # assign the index
                specInd = i
                specIndFound = True

        # Get individual plot lists (should already be correctly ordered)
        if hvInd is np.nan:
            hvsr_plot_list = [&#39;HVSR&#39;]

        if compInd is np.nan:
            comp_plot_list = []
            if specInd is np.nan:
                if hvInd is not np.nan:
                    hvsr_plot_list = plot_list
                spec_plot_list = []
            else:
                if hvInd is not np.nan:
                    hvsr_plot_list = plot_list[hvInd:specInd]
                spec_plot_list = plot_list[specInd:]
        else:
            if hvInd is not np.nan:
                hvsr_plot_list = plot_list[hvInd:compInd]
            
            if specInd is np.nan:
                comp_plot_list = plot_list[compInd:]
                spec_plot_list = []
            else:
                comp_plot_list = plot_list[compInd:specInd]
                spec_plot_list = plot_list[specInd:]

        # Figure out how many subplots there will be
        plot_list_list = [hvsr_plot_list, comp_plot_list, spec_plot_list]

        return plot_list_list

    def _parse_hv_plot_list(hv_data, hvsr_plot_list, azimuth=&#39;HV&#39;):
        hvsr_data = hv_data
        x_data = hvsr_data.x_freqs[&#39;Z&#39;]
        hvsrDF = hvsr_data.hvsr_windows_df
        if azimuth == &#39;HV&#39;:
            HVCol = &#39;HV_Curves&#39;
        else:
            HVCol = &#39;HV_Curves_&#39;+azimuth

        if &#39;tp&#39; in hvsr_plot_list:
            allpeaks = []
            for row in hvsrDF[hvsrDF[&#39;Use&#39;]][&#39;CurvesPeakFreqs_&#39;+azimuth].values:
                for peak in row:
                    allpeaks.append(peak)
            allInd = []
            for row, peakList in enumerate(hvsrDF[hvsrDF[&#39;Use&#39;]][&#39;CurvesPeakIndices_&#39;+azimuth].values):
                for ind in peakList:
                    allInd.append((row, ind))
            x_vals = []
            y_vals = []
            y_max = np.nanmax(hvsr_data.hvsrp[azimuth])
            hvCurveInd = list(hvsrDF.columns).index(HVCol)

            for i, tp in enumerate(allpeaks):
                x_vals.extend([tp, tp, None]) # add two x values and a None
                y_vals.extend([0, hvsrDF.iloc[allInd[i][0], hvCurveInd][allInd[i][1]], None]) # add the first and last y values and a None            

            results_fig.add_trace(go.Scatter(x=x_vals, y=y_vals, mode=&#39;lines&#39;,
                                            line=dict(width=4, dash=&#34;solid&#34;, 
                                            color=&#34;rgba(128,0,0,0.1)&#34;), 
                                            name=&#39;Best Peaks Over Time&#39;),
                                            row=1, col=1)

        if &#39;t&#39; in hvsr_plot_list:
            alltimecurves = np.stack(hvsrDF[hvsrDF[&#39;Use&#39;]][HVCol])
            for i, row in enumerate(alltimecurves):
                if i==0:
                    showLeg = True
                else:
                    showLeg= False
                results_fig.add_trace(go.Scatter(x=x_data[:-1], y=row, mode=&#39;lines&#39;,
                                            line=dict(width=0.5, dash=&#34;solid&#34;, 
                                            color=&#34;rgba(100, 110, 100, 0.8)&#34;), 
                                            showlegend=showLeg,
                                            name=&#39;Ind. time win. curve&#39;, 
                                            hoverinfo=&#39;none&#39;),
                                            row=1, col=1)

        if &#39;all&#39; in hvsr_plot_list:
            for i, p in enumerate(hvsr_data[&#39;hvsr_peak_freqs&#39;][azimuth]):
                if i==0:
                    showLeg = True
                else:
                    showLeg= False

                results_fig.add_trace(go.Scatter(
                    x=[p, p, None], # set x to None
                    y=[0, np.nanmax(np.stack(hvsrDF[HVCol])),None], # set y to None
                    mode=&#34;lines&#34;, # set mode to lines
                    line=dict(width=1, dash=&#34;dot&#34;, color=&#34;gray&#34;), # set line properties
                    name=&#34;All checked peaks&#34;, # set legend name
                    showlegend=showLeg),
                    row=1, col=1)

        if &#39;-s&#39; not in hvsr_plot_list:
            # Show standard deviation
            results_fig.add_trace(go.Scatter(x=x_data, y=hvsr_data.hvsrp2[azimuth],
                                    line={&#39;color&#39;:&#39;black&#39;, &#39;width&#39;:0.1},marker=None, 
                                    showlegend=False, name=&#39;Log. St.Dev. Upper&#39;,
                                    hoverinfo=&#39;none&#39;),
                                    row=1, col=1)
            
            results_fig.add_trace(go.Scatter(x=x_data, y=hvsr_data.hvsrm2[azimuth],
                                    line={&#39;color&#39;:&#39;black&#39;, &#39;width&#39;:0.1},marker=None,
                                    fill=&#39;tonexty&#39;, fillcolor=&#34;rgba(128, 128, 128, 0.6)&#34;,
                                    name=&#39;Log. St.Dev.&#39;, hoverinfo=&#39;none&#39;),
                                    row=1, col=1)
                
        if &#39;p&#39; in hvsr_plot_list:
            results_fig.add_trace(go.Scatter(
                x=[hvsr_data[&#39;BestPeak&#39;][azimuth][&#39;f0&#39;], hvsr_data[&#39;BestPeak&#39;][azimuth][&#39;f0&#39;], None], # set x to None
                y=[0,np.nanmax(np.stack(hvsrDF[&#39;HV_Curves&#39;])),None], # set y to None
                mode=&#34;lines&#34;, # set mode to lines
                line=dict(width=1, dash=&#34;dash&#34;, color=&#34;black&#34;), # set line properties
                name=&#34;Best Peak&#34;),
                row=1, col=1)

        if &#39;ann&#39; in hvsr_plot_list:
            # Annotate best peak
            results_fig.add_annotation(x=np.log10(hvsr_data[&#39;BestPeak&#39;][azimuth][&#39;f0&#39;]),
                                    y=0, yanchor=&#39;bottom&#39;, xanchor=&#39;center&#39;,
                                    text=f&#34;{hvsr_data[&#39;BestPeak&#39;][azimuth][&#39;f0&#39;]:.3f} Hz&#34;,
                                    bgcolor=&#39;rgba(255, 255, 255, 0.7)&#39;,
                                    showarrow=False,
                                    row=1, col=1)
        return results_fig

    def _parse_comp_plot_list(hv_data, comp_plot_list, azimuth=&#39;HV&#39;):
        
        hvsr_data = hv_data
        # Initial setup
        x_data = hvsr_data.x_freqs[&#39;Z&#39;]
        hvsrDF = hvsr_data.hvsr_windows_df
        same_plot = ((comp_plot_list != []) and (&#39;+&#39; not in comp_plot_list[0]))

        if same_plot:
            yaxis_to_use = &#39;y2&#39;
            use_secondary = True
            transparency_modifier = 0.5
        else:
            yaxis_to_use = &#39;y&#39;
            use_secondary=False
            transparency_modifier = 1

        alpha = 0.4 * transparency_modifier
        components = [&#39;Z&#39;, &#39;E&#39;, &#39;N&#39;]

        compColor_semi_light = {&#39;Z&#39;:f&#39;rgba(128,128,128,{alpha})&#39;,
                    &#39;E&#39;:f&#39;rgba(0,0,128,{alpha})&#39;,
                    &#39;N&#39;:f&#39;rgba(128,0,0,{alpha})&#39;}

        alpha = 0.7 * transparency_modifier
        compColor_semi = {&#39;Z&#39;:f&#39;rgba(128,128,128,{alpha})&#39;,
                        &#39;E&#39;:f&#39;rgba(100,100,128,{alpha})&#39;, 
                        &#39;N&#39;:f&#39;rgba(128,100,100,{alpha})&#39;}

        compColor = {&#39;Z&#39;:f&#39;rgba(128,128,128,{alpha})&#39;, 
                    &#39;E&#39;:f&#39;rgba(100,100,250,{alpha})&#39;, 
                    &#39;N&#39;:f&#39;rgba(250,100,100,{alpha})&#39;}

        for az in hvsr_data.hvsr_az.keys():
            components.append(az)
            compColor_semi_light[az] = f&#39;rgba(0,128,0,{alpha})&#39;
            compColor_semi[az] = f&#39;rgba(100,128,100,{alpha})&#39;
            compColor[az] = f&#39;rgba(100,250,100,{alpha})&#39;

        # Whether to plot in new subplot or not
        if  comp_plot_list != [] and &#39;+&#39; in comp_plot_list[0]:
            compRow=2
        else:
            compRow=1

        # Whether to plot individual time curves
        if &#39;t&#39; in comp_plot_list:
            for comp in components:
                alltimecurves = np.stack(hvsrDF[hvsrDF[&#39;Use&#39;]][&#39;psd_values_&#39;+comp])
                for i, row in enumerate(alltimecurves):
                    if i==0:
                        showLeg = True
                    else:
                        showLeg= False
                    
                    results_fig.add_trace(go.Scatter(x=x_data[:-1], y=row, mode=&#39;lines&#39;,
                                    line=dict(width=0.5, dash=&#34;solid&#34;, 
                                    color=compColor_semi[comp]),
                                    name=&#39;Ind. time win. curve&#39;,
                                    showlegend=False,
                                    hoverinfo=&#39;none&#39;,
                                    yaxis=yaxis_to_use),
                                    secondary_y=use_secondary,
                                    row=compRow, col=1)

        # Code to plot standard deviation windows, if not removed
        if &#39;-s&#39; not in comp_plot_list:
            for comp in components:
                # Show standard deviation
                results_fig.add_trace(go.Scatter(x=x_data, y=hvsr_data.ppsd_std_vals_p[comp],
                                        line={&#39;color&#39;:compColor_semi_light[comp], &#39;width&#39;:0.1},marker=None, 
                                        showlegend=False, name=&#39;Log. St.Dev. Upper&#39;,
                                        hoverinfo=&#39;none&#39;,    
                                        yaxis=yaxis_to_use),
                                        secondary_y=use_secondary,
                                        row=compRow, col=1)
                
                results_fig.add_trace(go.Scatter(x=x_data, y=hvsr_data.ppsd_std_vals_m[comp],
                                        line={&#39;color&#39;:compColor_semi_light[comp], &#39;width&#39;:0.1},marker=None,
                                        fill=&#39;tonexty&#39;, fillcolor=compColor_semi_light[comp],
                                        name=f&#39;St.Dev. [{comp}]&#39;, hoverinfo=&#39;none&#39;, showlegend=False, 
                                        yaxis=yaxis_to_use),
                                        secondary_y=use_secondary,
                                        row=compRow, col=1)
                
        # Code to plot location of best peak
        if &#39;p&#39; in comp_plot_list:
            minVal = 10000
            maxVal = -10000
            for comp in components:
                currPPSDCurve = hvsr_data[&#39;psd_values_tavg&#39;][comp]
                if np.nanmin(currPPSDCurve) &lt; minVal:
                    minVal = np.nanmin(currPPSDCurve)
                if np.nanmax(currPPSDCurve) &gt; maxVal:
                    maxVal = np.nanmax(currPPSDCurve)

            results_fig.add_trace(go.Scatter(
                x=[hvsr_data[&#39;BestPeak&#39;][azimuth][&#39;f0&#39;], hvsr_data[&#39;BestPeak&#39;][azimuth][&#39;f0&#39;], None], # set x to None
                y=[minVal,maxVal,None], # set y to None
                mode=&#34;lines&#34;, # set mode to lines
                line=dict(width=1, dash=&#34;dash&#34;, color=&#34;black&#34;), # set line properties
                name=&#34;Best Peak&#34;,
                yaxis=yaxis_to_use),
                secondary_y=use_secondary,
                row=compRow, col=1)
            
        # Code to annotate value of best peak
        if &#39;ann&#39; in comp_plot_list:
            minVal = 10000
            for comp in components:
                currPPSDCurve = hvsr_data[&#39;psd_values_tavg&#39;][comp]
                if np.nanmin(currPPSDCurve) &lt; minVal:
                    minVal = np.nanmin(currPPSDCurve)
            results_fig.add_annotation(x=np.log10(hvsr_data[&#39;BestPeak&#39;][azimuth][&#39;f0&#39;]),
                            y=minVal,
                            text=f&#34;{hvsr_data[&#39;BestPeak&#39;][azimuth][&#39;f0&#39;]:.3f} Hz&#34;,
                            bgcolor=&#39;rgba(255, 255, 255, 0.7)&#39;,
                            showarrow=False,
                            yref=yaxis_to_use,
                            secondary_y=use_secondary,
                            row=compRow, col=1)

        # Plot the main averaged component PPSDs
        for comp in components:
            results_fig.add_trace(go.Scatter(x=hvsr_data.x_freqs[comp],
                                            y=hvsr_data[&#39;psd_values_tavg&#39;][comp],
                                            line=dict(width=2, dash=&#34;solid&#34;, 
                                            color=compColor[comp]),marker=None, 
                                            name=comp, showlegend=True,
                                            yaxis=yaxis_to_use), 
                                            secondary_y=use_secondary,
                                            row=compRow, col=&#39;all&#39;)

        # If new subplot, update accordingly
        if compRow==2:
            results_fig.update_xaxes(type=&#39;log&#39;,
                            range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])],
                            row=compRow, col=1)
        return results_fig

    def _parse_spec_plot_list(hv_data, spec_plot_list, subplot_num, azimuth=&#39;HV&#39;):
        hvsr_data = hv_data
        if azimuth == &#39;HV&#39;:
            HVCol = &#39;HV_Curves&#39;
        else:
            HVCol = &#39;HV_Curves_&#39;+azimuth

        # Initial setup
        hvsrDF = hvsr_data.hvsr_windows_df
        specAxisTimes = np.array([dt.isoformat() for dt in hvsrDF.index.to_pydatetime()])
        y_data = hvsr_data.x_freqs[&#39;Z&#39;][1:]
        image_data = np.stack(hvsrDF[HVCol]).T

        maxZ = np.percentile(image_data, 100)
        minZ = np.percentile(image_data, 0)

        use_mask = hvsr_data.hvsr_windows_df.Use.values
        use_mask = np.tile(use_mask, (image_data.shape[0],1))
        use_mask = np.where(use_mask is False, np.nan, use_mask)

        hmap = go.Heatmap(z=image_data,
                    x=specAxisTimes,
                    y=y_data,
                    colorscale=&#39;Turbo&#39;,
                    showlegend=False,
                    #opacity=0.7,
                    hovertemplate=&#39;Time [UTC]: %{x}&lt;br&gt;Frequency [Hz]: %{y:.2f}&lt;br&gt;H/V Amplitude: %{z:.2f}&lt;extra&gt;&lt;/extra&gt;&#39;,
                    zmin=minZ,zmax=maxZ, showscale=False, name=&#39;HV Curve Amp. over Time&#39;)
        results_fig.add_trace(hmap, row=subplot_num, col=1)

        data_used = go.Heatmap(
            x=specAxisTimes,
            y=y_data,
            z=use_mask,
            showlegend=False,
            colorscale=[[0, &#39;rgba(0,0,0,0.66)&#39;], [0.25, &#39;rgba(0,0,0,0.66)&#39;], [1, &#39;rgba(250,250,250,0)&#39;]],
            showscale=False, name=&#39;Used&#39;)
        results_fig.add_trace(data_used, row=subplot_num, col=1)


        # tp currently is not being added to spec_plot_list
        if &#39;tp&#39; in spec_plot_list:
            yvals = []
            for row in hvsrDF[HVCol].values:
                maxInd = np.argmax(row)
                yvals.append(y_data[maxInd])
            tp_trace = go.Scatter(x=specAxisTimes, y=yvals, mode=&#39;markers&#39;,
                                    line=None, marker=dict(color=&#39;white&#39;, size=2, line=dict(color=&#39;black&#39;, width=0.1)), name=&#39;Individual H/V Peaks&#39;)
            results_fig.add_trace(tp_trace, row=subplot_num, col=&#39;all&#39;)

        if &#39;p&#39; in spec_plot_list:
            results_fig.add_hline(y=hvsr_data[&#39;BestPeak&#39;][azimuth][&#39;f0&#39;], line_width=1, line_dash=&#39;dash&#39;, line_color=&#39;black&#39;, row=subplot_num, col=&#39;all&#39;)

        if &#39;ann&#39; in spec_plot_list:
            results_fig.add_annotation(x=specAxisTimes[-1],
                                    y=hvsr_data[&#39;hvsr_band&#39;][1],
                                    text=f&#34;Peak: {hvsr_data[&#39;BestPeak&#39;][azimuth][&#39;f0&#39;]:.3f} Hz&#34;,
                                    bgcolor=&#39;rgba(255, 255, 255, 0.7)&#39;,
                                    showarrow=False, xanchor=&#39;right&#39;, yanchor=&#39;top&#39;,
                                    row=subplot_num, col=&#39;all&#39;)

        if &#39;leg&#39; in spec_plot_list:
            pass

        results_fig.update_yaxes(type=&#39;log&#39;,
                        range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])],
                        row=subplot_num, col=1)

        results_fig.add_annotation(
            text=f&#34;{hvsrDF[&#39;Use&#39;].astype(bool).sum()}/{hvsrDF.shape[0]} windows used&#34;,
            x=max(specAxisTimes),
            y=np.log10(min(y_data))+(np.log10(max(y_data))-np.log10(min(y_data)))*0.01,
            xanchor=&#34;right&#34;, yanchor=&#34;bottom&#34;,bgcolor=&#39;rgba(256,256,256,0.7)&#39;,
            showarrow=False,row=subplot_num, col=1)

        return results_fig

    def update_results_fig(hv_data, plot_string, use_sprit_plot=True):
        global results_fig
        global results_subp
        hvsr_data = hv_data

        if use_sprit_plot:
            results_fig = sprit_plot.plot_results_plotly(hv_data=hv_data, plot_string=plot_string, azimuth=&#39;HV&#39;,
                                              results_fig=results_subp, results_graph_widget=results_fig, use_figure_widget=True,
                                              return_fig=True, show_results_plot=False, html_plot=False,
                                              verbose=verbose_check.value)
        else:
            if isinstance(hvsr_data, sprit_hvsr.HVSRBatch):
                hvsr_data=hvsr_data[0]

            hvsrDF = hvsr_data.hvsr_windows_df

            plot_list = parse_plot_string(plot_string)

            combinedComp=False
            noSubplots = 3 - plot_list.count([])
            if plot_list[1] != [] and &#39;+&#39; not in plot_list[1][0]:
                combinedComp = True
                noSubplots -= 1
            
            # Get all data for each plotted item
            # COMP Plot
            # Figure out which subplot is which
            if combinedComp:
                comp_plot_row = 1
                spec_plot_row = 2
            else:
                comp_plot_row = 2
                spec_plot_row = 3

            # Re-initialize results_fig
            results_fig.data = []
            results_fig.update_layout(grid=None)  # Clear the existing grid layout
            if not combinedComp: 
                results_subp = subplots.make_subplots(rows=3, cols=1, horizontal_spacing=0.01, vertical_spacing=0.05,
                                                    row_heights=[2, 1.5, 1.5])
            else:
                results_subp = subplots.make_subplots(rows=2, cols=1, horizontal_spacing=0.01, vertical_spacing=0.07,
                                        specs =[[{&#39;secondary_y&#39;: True}],
                                                [{&#39;secondary_y&#39;: False}]],
                                                row_heights=[1, 1])
            results_fig.update_layout(grid={&#39;rows&#39;: noSubplots})
            #del results_fig
            results_fig = go.FigureWidget(results_subp)

            results_fig = _parse_comp_plot_list(hvsr_data, comp_plot_list=plot_list[1])

            # HVSR Plot (plot this after COMP so it is on top COMP and to prevent deletion with no C+)
            results_fig = _parse_hv_plot_list(hvsr_data, hvsr_plot_list=plot_list[0])
            # Will always plot the HV Curve
            results_fig.add_trace(go.Scatter(x=hvsr_data.x_freqs[&#39;Z&#39;],y=hvsr_data.hvsr_curve,
                                line={&#39;color&#39;:&#39;black&#39;, &#39;width&#39;:1.5},marker=None, name=&#39;HVSR Curve&#39;),
                                row=1, col=&#39;all&#39;)

            # SPEC plot
            results_fig = _parse_spec_plot_list(hvsr_data, spec_plot_list=plot_list[2], subplot_num=spec_plot_row)

            # Final figure updating
            showtickLabels = (plot_list[1]==[] or &#39;+&#39; not in plot_list[1][0])
            if showtickLabels:
                side=&#39;bottom&#39;
            else:
                side=&#39;top&#39;
            results_fig.update_xaxes(type=&#39;log&#39;,
                            range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])],
                            side=&#39;top&#39;,
                            row=1, col=1)
            
            results_fig.update_xaxes(type=&#39;log&#39;,overlaying=&#39;x&#39;,
                            range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])],
                            side=&#39;bottom&#39;,
                            row=1, col=1)
            if comp_plot_row!=1:
                results_fig.update_xaxes(showticklabels=showtickLabels, row=comp_plot_row, col=1)

            results_fig.update_yaxes(title_text=&#39;H/V Ratio&#39;, row=1, col=1)
            results_fig.update_yaxes(title_text=&#39;H/V Over Time&#39;, row=noSubplots, col=1)
            if comp_plot_row==1:
                results_fig.update_yaxes(title_text=&#34;PSD Amp\n[m2/s4/Hz][dB]&#34;, secondary_y=True, row=comp_plot_row, col=1)
            else:
                results_fig.update_yaxes(title_text=&#34;PSD Amp\n[m2/s4/Hz][dB]&#34;, row=comp_plot_row, col=1)

            
        if preview_fig.layout.width is None:
            if outlier_fig.layout.width is None:
                chartwidth = 1200
            else:
                chartwidth = outlier_fig.layout.width

        else:
            chartwidth = preview_fig.layout.width

        results_fig.update_layout(margin={&#34;l&#34;:10, &#34;r&#34;:10, &#34;t&#34;:35, &#39;b&#39;:0}, width=chartwidth,
                                  showlegend=False, height = 0.5625 * float(chartwidth),
                                  title=f&#34;{hvsr_data[&#39;site&#39;]} Results&#34;)

        # Reset results_graph_widget and display 
        with results_graph_widget:
            clear_output(wait=True)
            display(results_fig)

        if show_plot_check.value:
            results_fig.show()


        sprit_tabs.selected_index = 2
        log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nResults Figure Updated: {plot_string}&#34;
        hv_data[&#34;Plot_Report&#34;] = results_fig

    process_hvsr_button.on_click(process_data)

    # PREVIEW TAB
    #Initialize plot
    preview_subp = subplots.make_subplots(rows=4, cols=1, shared_xaxes=True, horizontal_spacing=0.01, vertical_spacing=0.01, row_heights=[3,1,1,1])
    preview_fig = go.FigureWidget(preview_subp)

    def update_preview_fig(hv_data, preview_fig):
        preview_fig.data = []
        
        hvsr_data = hv_data
        if isinstance(hvsr_data, sprit_hvsr.HVSRBatch):
            hvsr_data=hvsr_data[0]

        stream_z = hvsr_data[&#39;stream&#39;].select(component=&#39;Z&#39;) #may be np.ma.masked_array
        stream_e = hvsr_data[&#39;stream&#39;].select(component=&#39;E&#39;) #may be np.ma.masked_array
        stream_n = hvsr_data[&#39;stream&#39;].select(component=&#39;N&#39;) #may be np.ma.masked_array

        # Get iso_times and datetime.datetime
        utcdt = stream_z[0].times(type=&#39;utcdatetime&#39;)
        iso_times=[]
        dt_times = []
        for t in utcdt:
            if t is not np.ma.masked:
                iso_times.append(t.isoformat())
                dt_times.append(datetime.datetime.fromisoformat(t.isoformat()))
            else:
                iso_times.append(np.nan)
        iso_times=np.array(iso_times)
        dt_times = np.array (dt_times)

        # Generate spectrogram
        f, t, Sxx = signal.spectrogram(x=stream_z[0].data, fs=stream_z[0].stats.sampling_rate, mode=&#39;magnitude&#39;)
        
        # Get times for the axis (one time per window)
        axisTimes = []
        for tpass in t:
            axisTimes.append((dt_times[0]+datetime.timedelta(seconds=tpass)).isoformat())

        # Add data to preview_fig
        # Add spectrogram of Z component
        minz = np.percentile(Sxx, 1)
        maxz = np.percentile(Sxx, 99)
        hmap = go.Heatmap(z=Sxx,
                    x=axisTimes,
                    y=f,
                    colorscale=&#39;Turbo&#39;,
                    showlegend=False,
                    hovertemplate=&#39;Time [UTC]: %{x}&lt;br&gt;Frequency [Hz]: %{y:.2f}&lt;br&gt;Spectrogram Magnitude: %{z:.2f}&lt;extra&gt;&lt;/extra&gt;&#39;,
                    zmin=minz, zmax=maxz, showscale=False, name=&#39;Z Component Spectrogram&#39;)
        preview_fig.add_trace(hmap, row=1, col=1)
        preview_fig.update_yaxes(type=&#39;log&#39;, range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])], row=1, col=1)
        preview_fig.update_yaxes(title={&#39;text&#39;:&#39;Spectrogram (Z)&#39;}, row=1, col=1)

        # Add raw traces
        dec_factor=5 #This just makes the plotting go faster, by &#34;decimating&#34; the data
        preview_fig.add_trace(go.Scatter(x=iso_times[::dec_factor], y=stream_z[0].data[::dec_factor],
                                        line={&#39;color&#39;:&#39;black&#39;, &#39;width&#39;:0.5},marker=None, name=&#39;Z component data&#39;), row=2, col=&#39;all&#39;)
        preview_fig.update_yaxes(title={&#39;text&#39;:&#39;Z&#39;}, row=2, col=1)
        preview_fig.add_trace(go.Scatter(x=iso_times[::dec_factor], y=stream_e[0].data[::dec_factor],
                                        line={&#39;color&#39;:&#39;blue&#39;, &#39;width&#39;:0.5},marker=None, name=&#39;E component data&#39;),row=3, col=&#39;all&#39;)
        preview_fig.update_yaxes(title={&#39;text&#39;:&#39;E&#39;}, row=3, col=1)
        preview_fig.add_trace(go.Scatter(x=iso_times[::dec_factor], y=stream_n[0].data[::dec_factor],
                                        line={&#39;color&#39;:&#39;red&#39;, &#39;width&#39;:0.5},marker=None, name=&#39;N component data&#39;), row=4, col=&#39;all&#39;)
        preview_fig.update_yaxes(title={&#39;text&#39;:&#39;N&#39;}, row=4, col=1)
        
        #preview_fig.add_trace(p)
        preview_fig.update_layout(margin={&#34;l&#34;:10, &#34;r&#34;:10, &#34;t&#34;:30, &#39;b&#39;:0}, showlegend=False,
                                  title=f&#34;{hvsr_data[&#39;site&#39;]} Data Preview&#34;,
                                  width=1200)

        if show_plot_check.value:
            preview_fig.show()

    # REMOVE NOISE SUBTAB
    # STA/LTA Antitrigger
    stalta_check = widgets.Checkbox(value=False, disabled=False, indent=False, description=&#39;STA/LTA Antitrigger&#39;)
    sta = widgets.FloatText(description=&#39;STA [s]&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=5, value=5,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    lta = widgets.FloatText(description=&#39;LTA [s]&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=30, value=30,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    stalta_thresh_low = widgets.FloatText(description=&#39;STA/LTA Thresholds (low, high)&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0.5, value=0.5,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    stalta_thresh_hi = widgets.FloatText(style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=5, value=5,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))

    #% Saturation Threshold
    max_saturation_check = widgets.Checkbox(description=&#39;Percentage Threshold (Instantaneous)&#39;, value=False, disabled=False, indent=False)
    max_saturation_pct = widgets.FloatText(description=&#39;Max Saturation %:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0.995, value=0.995,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))

    #Noise Windows
    noisy_windows_check = widgets.Checkbox(description=&#39;Noisy Windows&#39;, value=False, disabled=False, indent=False)
    max_window_pct = widgets.FloatText(description=&#39;Max Window %:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0.8, value=0.8,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    noisy_window_length = widgets.FloatText(description=&#39;Window Length [s]:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=30, value=30,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))

    #Warmup/cooldown
    warmcool_check = widgets.Checkbox(description=&#39;Warmup &amp; Cooldown Time&#39;, value=False, disabled=False, indent=False)
    warmup_time = widgets.FloatText(description=&#39;Warmup time [s]:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0, value=0,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    cooldown_time = widgets.FloatText(description=&#39;Cooldown time [s]:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=0, value=0,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))

    # STD Ratio
    # std_ratio_thresh=2, std_window_s=20, min_win_size=5
    std_ratio_check = widgets.Checkbox(description=&#39;Standard Deviation Antitrigger (not yet implemented)&#39;, value=False, disabled=False, indent=False)
    std_ratio_thresh_text = widgets.FloatText(description=&#39;StdDev Ratio:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=2, value=2, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)
    std_window_length_text = widgets.FloatText(description=&#39;Moving window Length [s]:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=20, value=20, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;),disabled=False)
    std_window_length_text = widgets.FloatText(description=&#39;Minimum Window Size [s]:&#39;,  style={&#39;description_width&#39;: &#39;initial&#39;}, placeholder=2, value=2, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;),disabled=False)

    #Autoremove
    auto_remove_check = widgets.Checkbox(description=&#39;Use Auto Remove&#39;, value=False, disabled=False, indent=False)

    #Remove from raw data
    raw_data_remove_check = widgets.Checkbox(description=&#39;Remove Noise From Raw Data&#39;, value=False, disabled=False, indent=False)

    #remove_noise call
    remove_noise_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;remove_noise&#39; + &#39;&lt;/p&gt;&#39;, 
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    remove_noise_call = widgets.HTML(value=&#39;()&#39;)
    remove_noise_call_hbox = widgets.HBox([remove_noise_prefix, remove_noise_call])

    # Update remove_outlier call
    def update_remove_noise_call():
        #rnkwargs = get_remove_noise_kwargs()
        rn_text = f&#34;&#34;&#34;(hvsr_data=hvsr_data, remove_method={remove_method_select.value},
                    sat_percent={sat_percent_float.value},
                    noise_percent={noise_percent_float.value},
                    sta={sta_float.value},
                    lta={lta_float.value},
                    stalta_thresh={stalta_floatSlide.value},
                    warmup_time={warmup_time_int.value},
                    cooldown_time={cooldown_time_int.value},
                    min_win_size={min_win_size_float.value},
                    remove_raw_noise={raw_data_remove_check.value}, 
                    verbose={verbose_check.value})&#34;&#34;&#34;
        remove_noise_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + rn_text + &#39;&lt;/p&gt;&#39;
    update_remove_noise_call()

    #Update noise windows
    update_noise_windows_button = widgets.Button(description=&#39;Update Noise Windows&#39;,button_style=&#39;info&#39;,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=True)

    preview_graph_widget = widgets.Output()
    #progress bar (same as above)
    preview_progress_hbox = widgets.HBox(children=[progress_bar, update_noise_windows_button, process_hvsr_button])

    # Add it all in to the tab
    stalta_hbox = widgets.HBox([stalta_check, sta, lta, stalta_thresh_low, stalta_thresh_hi])
    sat_hbox = widgets.HBox([max_saturation_check, max_saturation_pct])
    noise_win_hbox = widgets.HBox([noisy_windows_check, max_window_pct, noisy_window_length])
    warmcool_hbox = widgets.HBox([warmcool_check, warmup_time, cooldown_time])
    std_ratio_hbox = widgets.HBox([std_ratio_check, std_ratio_thresh_text, std_window_length_text])
    spacer_hbox = widgets.HBox([tenpct_spacer])

    preview_noise_tab = widgets.VBox([stalta_hbox,
                                      sat_hbox,
                                      noise_win_hbox,
                                      warmcool_hbox,
                                      std_ratio_hbox,
                                      auto_remove_check,
                                      raw_data_remove_check,
                                      spacer_hbox,
                                      remove_noise_call_hbox])

    preview_graph_tab = widgets.VBox(children=[preview_graph_widget])
    preview_subtabs = widgets.Tab([preview_graph_tab, preview_noise_tab])
    preview_tab = widgets.VBox()

    preview_subtabs.set_title(0, &#34;Data Preview&#34;)
    preview_subtabs.set_title(1, &#34;Noise Removal&#34;)

    preview_tab.children = [preview_subtabs, preview_progress_hbox]
    # Initialize tab
    with preview_graph_widget:
        display(preview_fig)

    # SETTINGS TAB
    plot_settings_tab = widgets.GridspecLayout(18, ui_width)
    settings_progress_hbox = widgets.HBox(children=[progress_bar, tenpct_spacer, process_hvsr_button])

    #remove_noise call
    generate_ppsd_prefix = widgets.HTML(value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + &#39;generate_psds&#39; + &#39;&lt;/p&gt;&#39;, 
                                       layout=widgets.Layout(width=&#39;fill&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-start&#39;))
    generate_psds_call = widgets.HTML(value=&#39;()&#39;)
    generate_ppsd_call_hbox = widgets.HBox([generate_ppsd_prefix, generate_psds_call])

    ppsd_length_hbox = widgets.HBox([ppsd_length_label, ppsd_length])
    overlap_pct_hbox = widgets.HBox([overlap_pct_label, overlap_pct])
    pstep_hbox = widgets.HBox([period_step_label, period_step_octave])
    skipgaps_hbox = widgets.HBox([skip_on_gaps_label, skip_on_gaps])
    db_bins_hbox = widgets.HBox([db_step_label, db_bins_min, db_bins_max, db_bins_step])
    plim_hbox = widgets.HBox([period_limit_label, period_limits_min, period_limits_max, period_smoothing_width])

    ppsd_settings_tab = widgets.VBox([ppsd_length_hbox,
                                      overlap_pct_hbox,
                                      pstep_hbox,
                                      skipgaps_hbox,
                                      db_bins_hbox,
                                      plim_hbox,
                                      special_handling_dropdown,
                                      generate_ppsd_call_hbox])


    def calc_rmse(array_2d):
        medArray = np.nanmedian(array_2d, axis=0)
        rmse = np.sqrt(((np.subtract(array_2d, medArray)**2).sum(axis=1))/array_2d.shape[1])
        return rmse
    
    def on_update_outlier_thresh_slider(change):
        if use_hv_curve_outliers_check.value:
            rmse = calc_rmse(np.stack(hvsr_data.hvsr_windows_df[&#39;HV_Curves&#39;]))
        else:
            rmsez = calc_rmse(np.stack(hvsr_data.hvsr_windows_df[&#39;psd_values_Z&#39;]))
            rmsee = calc_rmse(np.stack(hvsr_data.hvsr_windows_df[&#39;psd_values_E&#39;]))
            rmsen = calc_rmse(np.stack(hvsr_data.hvsr_windows_df[&#39;psd_values_N&#39;]))

            rmse = np.stack([rmsez, rmsee, rmsen]).flatten()

        if outlier_pctile_check.value:
            outlier_threshold_slider.value = outlier_threshold_slider.value
        else:
            outlier_threshold_slider.value = outlier_threshold_slider.value
            outlier_threshold_slider.value = ((rmse &lt; outlier_threshold_slider.value).sum() / len(rmse)) * 100

    def on_update_thresh_pctile_slider(change):
        if use_hv_curve_outliers_check.value:
            rmse = calc_rmse(np.stack(hvsr_data.hvsr_windows_df[&#39;HV_Curves&#39;]))
        else:
            rmsez = calc_rmse(np.stack(hvsr_data.hvsr_windows_df[&#39;psd_values_Z&#39;]))
            rmsee = calc_rmse(np.stack(hvsr_data.hvsr_windows_df[&#39;psd_values_E&#39;]))
            rmsen = calc_rmse(np.stack(hvsr_data.hvsr_windows_df[&#39;psd_values_N&#39;]))

            rmse = np.stack([rmsez, rmsee, rmsen])

        if outlier_pctile_check.value:
            outlier_threshold_slider.value = np.percentile(rmse, outlier_threshold_slider.value)
            outlier_threshold_slider.value = outlier_threshold_slider.value
        else:
            outlier_threshold_slider.value = outlier_threshold_slider.value

    #outlier_threshold_chart_slider.observe(on_update_rmse_thresh_slider)
    #outlier_threshold_chart_slider.observe(on_update_rmse_pctile_slider)

    use_hv_curve_label = widgets.Label(value=&#39;NOTE: Outlier curves may only be identified after PPSDs have been calculated (during the generate_psds() step)&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;80%&#39;))
    generate_ppsd_button = widgets.Button(description=&#39;Generate PPSDs&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;20%&#39;, justify_content=&#39;flex-end&#39;), disabled=False)
    update_outlier_plot_button = widgets.Button(description=&#39;Remove Outliers&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;20%&#39;, justify_content=&#39;flex-end&#39;), disabled=False)
    outlier_ppsd_hbox = widgets.HBox([use_hv_curve_label, generate_ppsd_button, update_outlier_plot_button])

    # Update remove_outlier call
    def update_remove_outlier_curve_call():
        roc_text = f&#34;&#34;&#34;(hvsr_data=hvsr_data, 
                        outlier_method:{outlier_method_dropdown.value},
                        outlier_threshold={outlier_threshold_slider.value}, 
                        use_percentile={outlier_pctile_check.value},
                        min_pts:{min_pts_float.value},
                        use_hv_curves={use_hv_curve_outliers_check.value},
                        ...
                        verbose={verbose_check.value})&#34;&#34;&#34;
        remove_outlier_curves_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + roc_text + &#39;&lt;/p&gt;&#39;
    update_remove_outlier_curve_call()

    def update_outlier_fig_button(button):
        outlier_fig, hvsr_data = update_outlier_fig(button)

    generate_ppsd_button.on_click(process_data)

    update_outlier_plot_button.on_click(update_outlier_fig_button)

    with outlier_graph_widget:
        display(outlier_fig)

    def update_outlier_fig(input=None, _rmse_thresh=outlier_threshold_slider.value, _use_percentile=True, _use_hv_curve=use_hv_curve_outliers_check.value, _verbose=verbose_check.value):
        global outlier_fig
        global hvsr_data
        hv_data = hvsr_data


        roc_kwargs = {&#39;outlier_threshold&#39;:outlier_threshold_slider.value,
                        &#39;use_percentile&#39;:True,
                        &#39;use_hv_curves&#39;:use_hv_curve_outliers_check.value,
                        &#39;plot_engine&#39;:&#39;plotly&#39;,
                        &#39;show_plot&#39;:False,
                        &#39;verbose&#39;:verbose_check.value
                      }
        if &#39;generate_psds_status&#39; in hvsr_data.processing_status.keys() and hvsr_data.processing_status[&#39;generate_psds_status&#39;]:
            log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nremove_outlier_curves():\n&#39;{roc_kwargs}&#34;    
            hvsr_data = sprit_hvsr.remove_outlier_curves(hvsr_data, **roc_kwargs)
        else:
            log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nremove_outlier_curves() attempted, but not completed. hvsr_data.processing_status[&#39;generate_psds_status&#39;]=False\n&#39;{roc_kwargs}&#34;
            return outlier_fig, hvsr_data

        if roc_kwargs[&#39;use_hv_curves&#39;]:
            no_subplots = 1
            if hasattr(hvsr_data, &#39;hvsr_windows_df&#39;) and &#39;HV_Curves&#39; in hvsr_data.hvsr_windows_df.columns:
                outlier_fig.data = []
                outlier_fig.update_layout(grid=None)  # Clear the existing grid layout
                outlier_subp = subplots.make_subplots(rows=no_subplots, cols=1, horizontal_spacing=0.01, vertical_spacing=0.1)
                outlier_fig.update_layout(grid={&#39;rows&#39;: 1})
                outlier_fig = go.FigureWidget(outlier_subp)

                x_data = hvsr_data[&#39;x_freqs&#39;]
                curve_traces = []
                for hv in hvsr_data.hvsr_windows_df[&#39;HV_Curves&#39;].iterrows():
                    curve_traces.append(go.Scatter(x=x_data, y=hv[1]))
                outlier_fig.add_traces(curve_traces)
                
                # Calculate a median curve, and reshape so same size as original
                medCurve = np.nanmedian(np.stack(hvsr_data.hvsr_windows_df[&#39;HV_Curves&#39;]), axis=0)
                outlier_fig.add_trace(go.Scatter(x=x_data, y=medCurve, line=dict(color=&#39;rgba(0,0,0,1)&#39;, width=1.5),showlegend=False))
                
                minY = np.nanmin(np.stack(hvsr_data.hvsr_windows_df[&#39;HV_Curves&#39;]))
                maxY = np.nanmax(np.stack(hvsr_data.hvsr_windows_df[&#39;HV_Curves&#39;]))
                totalWindows = hvsr_data.hvsr_windows_df.shape[0]
                #medCurveArr = np.tile(medCurve, (curr_data.shape[0], 1))

        else:
            no_subplots = 3
            outlier_fig.data = []
            outlier_fig.update_layout(grid=None)  # Clear the existing grid layout
            outlier_subp = subplots.make_subplots(rows=no_subplots, cols=1, horizontal_spacing=0.01, vertical_spacing=0.02,
                                                    row_heights=[1, 1, 1])
            outlier_fig.update_layout(grid={&#39;rows&#39;: 3})
            outlier_fig = go.FigureWidget(outlier_subp)

            if hasattr(hvsr_data, &#39;hvsr_windows_df&#39;):
                rowDict = {&#39;Z&#39;:1, &#39;E&#39;:2, &#39;N&#39;:3}
                showTLabelsDict={&#39;Z&#39;:False, &#39;E&#39;:False, &#39;N&#39;:True}
                def comp_rgba(comp, a):
                    compstr = &#39;&#39;
                    if comp==&#39;Z&#39;:
                        compstr = f&#39;rgba(0, 0, 0, {a})&#39;
                    if comp==&#39;E&#39;:
                        compstr = f&#39;rgba(50, 50, 250, {a})&#39;
                    if comp==&#39;N&#39;:
                        compstr = f&#39;rgba(250, 50, 50, {a})&#39;
                    return compstr                         
                compNames = [&#39;Z&#39;, &#39;E&#39;, &#39;N&#39;]
                rmse_to_plot=[]
                med_traces=[]

                noRemoved = 0
                indRemoved = []
                for i, comp in enumerate(compNames):
                    if hasattr(hvsr_data, &#39;x_freqs&#39;):
                        x_data = hvsr_data[&#39;x_freqs&#39;][comp]
                    else:
                        x_data = [1/p for p in hvsr_data[&#39;psds&#39;][comp][&#39;period_xedges&#39;][1:]]                    
                    column = &#39;psd_values_&#39;+comp
                    # Retrieve data from dataframe (use all windows, just in case)
                    curr_data = np.stack(hvsr_data[&#39;hvsr_windows_df&#39;][column])
                    
                    # Calculate a median curve, and reshape so same size as original
                    medCurve = np.nanmedian(curr_data, axis=0)
                    medCurveArr = np.tile(medCurve, (curr_data.shape[0], 1))
                    medTrace = go.Scatter(x=x_data, y=medCurve, line=dict(color=comp_rgba(comp, 1), width=1.5), 
                                                 name=f&#39;{comp} Component&#39;, showlegend=True)
                    # Calculate RMSE
                    rmse = np.sqrt(((np.subtract(curr_data, medCurveArr)**2).sum(axis=1))/curr_data.shape[1])

                    rmse_threshold = np.percentile(rmse, roc_kwargs[&#39;outlier_threshold&#39;])
                    
                    # Retrieve index of those RMSE values that lie outside the threshold
                    timeIndex = hvsr_data[&#39;hvsr_windows_df&#39;].index
                    for j, curve in enumerate(curr_data):
                        if rmse[j] &gt; rmse_threshold:
                            badTrace = go.Scatter(x=x_data, y=curve,
                                                line=dict(color=comp_rgba(comp, 1), width=1.5, dash=&#39;dash&#39;),
                                                #marker=dict(color=comp_rgba(comp, 1), size=3),
                                                name=str(hvsr_data.hvsr_windows_df.index[j]), showlegend=False)
                            outlier_fig.add_trace(badTrace, row=rowDict[comp], col=1)
                            if j not in indRemoved:
                                indRemoved.append(j)
                            noRemoved += 1
                        else:
                            goodTrace = go.Scatter(x=x_data, y=curve,
                                                  line=dict(color=comp_rgba(comp, 0.01)), name=str(hvsr_data.hvsr_windows_df.index[j]), showlegend=False)
                            outlier_fig.add_trace(goodTrace, row=rowDict[comp], col=1)

                    timeIndRemoved = pd.DatetimeIndex([timeIndex[ind] for ind in indRemoved])
                    hvsr_data[&#39;hvsr_windows_df&#39;].loc[timeIndRemoved, &#39;Use&#39;] = False

                    outlier_fig.add_trace(medTrace, row=rowDict[comp], col=1)
                    
                    outlier_fig.update_xaxes(showticklabels=False, row=1, col=1)
                    outlier_fig.update_yaxes(title={&#39;text&#39;:&#39;Z&#39;}, row=1, col=1)
                    outlier_fig.update_xaxes(showticklabels=False, row=2, col=1)
                    outlier_fig.update_yaxes(title={&#39;text&#39;:&#39;E&#39;}, row=2, col=1)
                    outlier_fig.update_xaxes(showticklabels=True, row=3, col=1)
                    outlier_fig.update_yaxes(title={&#39;text&#39;:&#39;N&#39;}, row=3, col=1)

                    outlier_fig.update_layout(margin={&#34;l&#34;:10, &#34;r&#34;:10, &#34;t&#34;:30, &#39;b&#39;:0}, showlegend=True,
                                  title=f&#34;{hvsr_data[&#39;site&#39;]} Outliers&#34;)
                    if comp == &#39;N&#39;:
                        minY = np.nanmin(curr_data)
                        maxY = np.nanmax(curr_data)
                    totalWindows = curr_data.shape[0]
                
                outlier_fig.add_annotation(
                    text=f&#34;{len(indRemoved)}/{totalWindows} outlier windows removed&#34;,
                    x=np.log10(max(x_data)) - (np.log10(max(x_data))-np.log10(min(x_data))) * 0.01,
                    y=minY+(maxY-minY)*0.01,
                    xanchor=&#34;right&#34;, yanchor=&#34;bottom&#34;,#bgcolor=&#39;rgba(256,256,256,0.7)&#39;,
                    showarrow=False,row=no_subplots, col=1)


        outlier_fig.update_xaxes(type=&#39;log&#39;)
        with outlier_graph_widget:
            clear_output(wait=True)
            display(outlier_fig)
        
        if show_plot_check.value:
            outlier_fig.show()

        return outlier_fig, hvsr_data


    # Update process_hvsr call
    def update_check_peaks_call():
        #cp_kwargs = get_check_peaks_kwargs()
        cp_text = f&#34;&#34;&#34;(hvsr_data=hvsr_data, 
                        peak_selection={peak_selection_type.value}, 
                        hvsr_band={hvsr_band_rangeSlide.value}, 
                        peak_freq_range={peak_freq_rangeSlide.value}, 
                        verbose={verbose_check.value})&#34;&#34;&#34;
        check_peaks_call.value=&#39;&lt;style&gt;p {word-wrap: break-word}&lt;/style&gt; &lt;p&gt;&#39; + cp_text + &#39;&lt;/p&gt;&#39;
    update_check_peaks_call()

    #freq_smooth_hbox = widgets.HBox([freq_smoothing_dropdown, freq_smooth_width_float])
    #resample_hbox = widgets.HBox([resample_hv_curve_bool, resample_hv_curve])
    #smooth_hbox = widgets.HBox([smooth_hv_curve_bool, smooth_hv_curve])
    
    # PLOT SETTINGS SUBTAB
    hv_plot_label = widgets.Label(value=&#39;HVSR Plot&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;))
    component_plot_label = widgets.Label(value=&#39;Component Plot&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;))
    spec_plot_label = widgets.Label(value=&#39;Spectrogram Plot&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;))

    use_plot_label = widgets.Label(value=&#39;Use Plot&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    use_plot_hv = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    use_plot_comp = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    use_plot_spec = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    comibne_plot_label = widgets.Label(value=&#39;Combine HV and Comp. Plot&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    combine_hv_comp = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    show_peak_label = widgets.Label(value=&#39;Show Best Peak&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_best_peak_hv = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_best_peak_comp = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_best_peak_spec = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    annotate_peak_label = widgets.Label(value=&#39;Annotate Best Peak&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    ann_best_peak_hv = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    ann_best_peak_comp = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    ann_best_peak_spec = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    show_all_peaks_label = widgets.Label(value=&#39;Show All Peaks&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_all_peaks_hv = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    show_all_curves_label = widgets.Label(value=&#39;Show All Curves&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_all_curves_hv = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_all_curves_comp = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    show_ind_peaks_label = widgets.Label(value=&#39;Show Individual Peaks&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_ind_peaks_hv = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_ind_peaks_spec = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                       style={&#39;description_width&#39;: &#39;initial&#39;})

    show_std_label = widgets.Label(value=&#39;Show Standard Deviation&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_std_hv = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_std_comp = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    show_legend_label = widgets.Label(value=&#39;Show Legend&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    show_legend_hv = widgets.Checkbox(value=True, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_legend_comp = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})
    show_legend_spec = widgets.Checkbox(value=False, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;),
                                   style={&#39;description_width&#39;: &#39;initial&#39;})

    x_type_label = widgets.Label(value=&#39;X Type&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    x_type = widgets.Dropdown(options=[(&#39;Frequency&#39;, &#39;freq&#39;), (&#39;Period&#39;, &#39;period&#39;)],
                              layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), style={&#39;description_width&#39;: &#39;initial&#39;})

    plotly_kwargs_label = widgets.Label(value=&#39;Plotly Kwargs&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    plotly_kwargs = widgets.Text(style={&#39;description_width&#39;: &#39;initial&#39;},
                                layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    mpl_kwargs_label = widgets.Label(value=&#39;Matplotlib Kwargs&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;flex-end&#39;, align_items=&#39;center&#39;))
    mpl_kwargs = widgets.Text(style={&#39;description_width&#39;: &#39;initial&#39;},
                                layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;), disabled=False)

    plot_hvsr_call = widgets.Label(value=f&#34;Plot String: &#39;{_get_default(sprit_hvsr.get_report, &#39;plot_type&#39;)}&#39;&#34;)
    def update_plot_string():
        plot_hvsr_text = f&#34;&#34;&#34;Plot String: {_get_get_report_kwargs()[&#39;plot_type&#39;]}&#34;&#34;&#34;
        plot_hvsr_call.value = plot_hvsr_text
    update_plot_string()

    update_plot_button = widgets.Button(description=&#39;Update Plot&#39;,button_style=&#39;info&#39;,layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;))
    def manually_update_results_fig(change):
        plot_string = _get_get_report_kwargs()[&#39;plot_type&#39;]
        update_results_fig(hvsr_results, plot_string)
        sprit_tabs.selected_index = 4

    # Set up grid for ppsd_settings subtab
    plot_settings_tab[0, 5:10]   = hv_plot_label
    plot_settings_tab[0, 10:15]  = component_plot_label
    plot_settings_tab[0, 15:] = spec_plot_label

    plot_settings_tab[1, :] = widgets.HTML(&#39;&lt;hr&gt;&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;))

    plot_settings_tab[2, :5] = use_plot_label
    plot_settings_tab[2, 5:10] = use_plot_hv
    plot_settings_tab[2, 10:15] = use_plot_comp
    plot_settings_tab[2, 15:] = use_plot_spec

    plot_settings_tab[3, :] = widgets.HTML(&#39;&lt;hr&gt;&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;))

    plot_settings_tab[4, :5] = comibne_plot_label
    plot_settings_tab[4, 10:15] = combine_hv_comp

    plot_settings_tab[5, :5] = show_peak_label
    plot_settings_tab[5, 5:10] = show_best_peak_hv
    plot_settings_tab[5, 10:15] = show_best_peak_comp
    plot_settings_tab[5, 15:] = show_best_peak_spec

    plot_settings_tab[6, :5] = annotate_peak_label
    plot_settings_tab[6, 5:10] = ann_best_peak_hv
    plot_settings_tab[6, 10:15] = ann_best_peak_comp
    plot_settings_tab[6, 15:] = ann_best_peak_spec

    plot_settings_tab[7, :5] = show_all_peaks_label
    plot_settings_tab[7, 5:10] = show_all_peaks_hv

    plot_settings_tab[8, :5] = show_all_curves_label
    plot_settings_tab[8, 5:10] = show_all_curves_hv
    plot_settings_tab[8, 10:15] = show_all_curves_comp

    plot_settings_tab[9, :5] = show_ind_peaks_label
    plot_settings_tab[9, 5:10] = show_ind_peaks_hv
    plot_settings_tab[9, 15:] = show_ind_peaks_spec
   
    plot_settings_tab[10, :5] = show_std_label
    plot_settings_tab[10, 5:10] = show_std_hv
    plot_settings_tab[10, 10:15] = show_std_comp

    plot_settings_tab[11, :5] = show_legend_label
    plot_settings_tab[11, 5:10] = show_legend_hv
    plot_settings_tab[11, 10:15] = show_legend_comp
    plot_settings_tab[11, 15:] = show_legend_spec

    plot_settings_tab[12, :] = widgets.HTML(&#39;&lt;hr&gt;&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;))

    plot_settings_tab[13, :5] = x_type_label
    plot_settings_tab[13, 6:] = x_type

    plot_settings_tab[14, :5] = plotly_kwargs_label
    plot_settings_tab[14, 6:] = plotly_kwargs

    plot_settings_tab[15, :5] = mpl_kwargs_label
    plot_settings_tab[15, 6:] = mpl_kwargs

    plot_settings_tab[16, :] = widgets.HTML(&#39;&lt;hr&gt;&#39;, layout=widgets.Layout(height=&#39;auto&#39;, width=&#39;auto&#39;, justify_content=&#39;center&#39;, align_items=&#39;center&#39;))

    plot_settings_tab[17, :18] = plot_hvsr_call
    plot_settings_tab[17, 18:] = update_plot_button
    update_plot_button.on_click(manually_update_results_fig)

    # Place everything in Settings Tab
    #settings_subtabs = widgets.Tab([ppsd_settings_tab, plot_settings_tab])
    #settings_tab = widgets.VBox(children=[settings_subtabs, settings_progress_hbox])
    #settings_subtabs.set_title(0, &#34;PSD Settings&#34;)
    #settings_subtabs.set_title(1, &#34;Plot Settings&#34;)

    # LOG TAB - not currently using
    log_tab = widgets.VBox(children=[log_textArea])
    #log_textArea = widgets.Textarea(value=&#34;SESSION LOG&#34;, disabled=True, layout={&#39;height&#39;: &#39;99%&#39;,&#39;width&#39;: &#39;99%&#39;, &#39;overflow&#39;: &#39;scroll&#39;})

    # RESULTS TAB
    # PLOT SUBTAB
    global results_subp
    results_subp = subplots.make_subplots(rows=3, cols=1, horizontal_spacing=0.01, vertical_spacing=0.01, row_heights=[2,1,1])
    results_fig = go.FigureWidget(results_subp)
    global results_graph_widget
    results_graph_widget = widgets.Output()   

    with results_graph_widget:
        display(results_fig)

    global printed_results_textArea
    printed_results_textArea = widgets.Textarea(value=&#34;RESULTS&#34;, disabled=True, layout={&#39;height&#39;: &#39;500px&#39;,&#39;width&#39;: &#39;99%&#39;, &#39;overflow&#39;: &#39;scroll&#39;})

    global results_table
    initialTableCols=[&#39;SiteName&#39;, &#39;Acq_Date&#39;, &#39;Longitude&#39;, &#39;Latitude&#39;, &#39;Elevation&#39;,
                      &#39;PeakFrequency&#39;, &#39;WindowLengthFreq.&#39;, &#39;SignificantCycles&#39;, &#39;LowCurveStDevOverTime&#39;, 
                      &#39;PeakProminenceBelow&#39;, &#39;PeakProminenceAbove&#39;, &#39;PeakAmpClarity&#39;, 
                      &#39;FreqStability&#39;, &#39;PeakStability_FreqStD&#39;, &#39;PeakStability_AmpStD&#39;, &#39;PeakPasses&#39;]
    results_table = widgets.HTML(value=pd.DataFrame(columns=initialTableCols).to_html())

    # A text box labeled Data Filepath
    export_results_table_filepath = widgets.Text(description=&#39;Export Filepath:&#39;,
                                    placeholder=&#39;&#39;, value=&#39;&#39;,
                                    style={&#39;description_width&#39;: &#39;initial&#39;},layout=widgets.Layout(width=&#39;90%&#39;))

    export_results_table_read_button = widgets.Button(description=&#39;&#39;, icon=&#39;fa-file-import&#39;,button_style=&#39;success&#39;,
                                            layout=widgets.Layout(width=&#39;10%&#39;))
    export_results_table_browse_button = widgets.Button(description=&#39;Export Table&#39;,
                                            layout=widgets.Layout(width=&#39;10%&#39;))
    def export_results_table(button):
        try:
            if button.value == &#39;Export Table&#39;:
                from tkinter import tk, filedialog
                root = tk.Tk()
                root.wm_attributes(&#39;-topmost&#39;, True)
                root.withdraw()
                export_results_table_filepath.value = str(filedialog.asksaveasfilename(defaultextension=&#39;.csv&#39;, title=&#39;Save Table Report&#39;))
                root.destroy()
        except Exception as e:
            print(e)
            export_results_table_browse_button.disabled=True
            export_results_table_browse_button.description=&#39;Use Text Field&#39;

        out_path = export_results_table_filepath.value
        if not hasattr(hvsr_results, &#34;Table_Report&#34;):
            sprit_hvsr.get_report(hvsr_results, report_formats=[&#39;table&#39;], export_path=out_path,
                              csv_overwrite_opt=&#39;overwrite&#39;)
        else:
            hvsr_results[&#39;Table_Report&#39;].to_csv(out_path)

    export_results_table_browse_button.on_click(export_results_table)
    export_results_table_read_button.on_click(export_results_table)

    exportLabel = widgets.Label(&#34;Exports&#34;, layout=widgets.Layout(width=&#39;5%&#39;))
    export_directory_text = widgets.Text(description=&#34;Directory&#34;, layout=widgets.Layout(width=&#39;50%&#39;),
                                         value= pathlib.Path().home().as_posix())
    export_data_button = widgets.Button(description=&#39;Data (.MSeed)&#39;, layout=widgets.Layout(width=&#39;10%&#39;))
    export_report_button = widgets.Button(description=&#34;Report (.PDF)&#34;, layout=widgets.Layout(width=&#39;10%&#39;))
    export_hvsr_button = widgets.Button(description=&#34;HVSR Data (.HVSR)&#34;, layout=widgets.Layout(width=&#39;10%&#39;))
    export_subdirectories_check = widgets.Checkbox(description=&#39;Use Subfolders&#39;, value=True,
                                                   layout=widgets.Layout(width=&#39;15%&#39;))
    
    
    def on_export_data(event):
        hvID = &#39;&#39;
        if hasattr(hvsr_results, &#39;hvsr_id&#39;):
            hvID = hvsr_results[&#39;hvsr_id&#39;]
        nowTimeStr = datetime.datetime.now().strftime(&#34;%Y-%m-%d&#34;)
        export_dir = pathlib.Path(export_directory_text.value)
        
        if export_subdirectories_check.value:
            export_dir = export_dir.joinpath(&#39;Data&#39;)
            if not export_dir.exists():
                export_dir.mkdir(parents=True)

        sprit_hvsr.export_data(hvsr_results, data_export_path=export_dir)
        print(&#34;Data exported successfully to: &#34;, export_dir)
    
    def on_export_report(event):
        hvID = &#39;&#39;
        if hasattr(hvsr_results, &#39;hvsr_id&#39;):
            hvID = hvsr_results[&#39;hvsr_id&#39;]
        nowTimeStr = datetime.datetime.now().strftime(&#34;%Y-%m-%d&#34;)
        export_dir = pathlib.Path(export_directory_text.value)
        
        if export_subdirectories_check.value:
            export_dir = export_dir.joinpath(&#39;Reports&#39;)
            if not export_dir.exists():
                export_dir.mkdir(parents=True)

        sprit_hvsr.export_report(hvsr_results, report_export_path=export_dir)
        print(&#34;Report exported successfully to: &#34;, export_dir)
    
    
    def on_export_hvsr(event):
        hvID = &#39;&#39;
        if hasattr(hvsr_results, &#39;hvsr_id&#39;):
            hvID = hvsr_results[&#39;hvsr_id&#39;]
        nowTimeStr = datetime.datetime.now().strftime(&#34;%Y-%m-%d&#34;)
        export_dir = pathlib.Path(export_directory_text.value)
        
        if export_subdirectories_check.value:
            export_dir = export_dir.joinpath(&#39;HVSRFiles&#39;)
            if not export_dir.exists():
                export_dir.mkdir(parents=True)
            
        sprit_hvsr.export_hvsr(hvsr_results, hvsr_export_path=export_dir)
        print(&#34;HVSR file exported successfully to: &#34;, export_dir)
            
    export_data_button.on_click(on_export_data)
    export_report_button.on_click(on_export_report)
    export_hvsr_button.on_click(on_export_hvsr)
    
    results_table_export_hbox = widgets.HBox([export_results_table_filepath, export_results_table_read_button, export_results_table_browse_button])
    results_table_vbox = widgets.VBox([results_table, results_table_export_hbox])
    results_export_hbox = widgets.HBox([exportLabel, export_directory_text,
                                        export_data_button, export_report_button, export_hvsr_button,
                                        export_subdirectories_check])
    global results_tab
    plots_subtabs = widgets.Tab([results_graph_widget, plot_settings_tab])
    plots_subtabs.set_title(0, &#34;Plot Viewer&#34;)
    plots_subtabs.set_title(1, &#34;Plot Settings&#34;)
    results_subtabs = widgets.Tab([plots_subtabs, printed_results_textArea, results_table_vbox])
    results_tab = widgets.VBox(children=[results_subtabs, results_export_hbox])
    results_subtabs.set_title(0, &#34;Plot&#34;)
    results_subtabs.set_title(1, &#34;Peak Tests&#34;)
    results_subtabs.set_title(2, &#34;Peak Table&#34;)

    widget_param_dict = {
        &#39;fetch_data&#39;: 
            {&#39;source&#39;: data_source_type,
            &#39;data_export_path&#39;: data_export_path_textbox,
            &#39;data_export_format&#39;: data_export_format_dropdown,
            &#39;detrend_type&#39;: detrend_type_dropdown,
            &#39;detrend_options&#39;: detrend_options,
            &#39;filter_type&#39;: filter_type_dropdown,
            &#39;filter_options&#39;: filter_options,
            &#39;update_metadata&#39;:update_metadata_checkbox.value,
            &#39;verbose&#39;: verbose_check},
        &#39;remove_noise&#39;: 
            {
            &#39;sat_percent&#39;: max_saturation_pct,
            &#39;noise_percent&#39;: max_window_pct,
            &#39;sta&#39;: sta,
            &#39;lta&#39;: lta,
            &#39;stalta_thresh&#39;: [stalta_thresh_low, stalta_thresh_hi],
            &#39;warmup_time&#39;: warmup_time,
            &#39;cooldown_time&#39;: cooldown_time,
            &#39;min_win_size&#39;: noisy_window_length,
            &#39;remove_raw_noise&#39;: raw_data_remove_check,
            &#39;verbose&#39;: verbose_check},
        &#39;generate_psds&#39;: 
            {&#39;verbose&#39;: verbose_check,
             &#39;skip_on_gaps&#39;:skip_on_gaps, 
             &#39;db_bins&#39;:[db_bins_min, db_bins_max, db_bins_step],
             &#39;ppsd_length&#39;:ppsd_length, 
             &#39;overlap&#39;:overlap_pct_float, 
             &#39;special_handling&#39;:special_handling_dropdown, 
             &#39;period_smoothing_width_octaves&#39;:period_smoothing_width, 
             &#39;period_step_octaves&#39;:period_step_octave, 
             &#39;period_limits&#39;:hvsr_band_rangeSlide},
        &#39;process_hvsr&#39;: 
            {&#39;horizontal_method&#39;: h_combine_meth_dropdown,
            &#39;smooth&#39;: smooth_hv_curve,
            &#39;freq_smooth&#39;: freq_smoothing_dropdown,
            &#39;f_smooth_width&#39;: freq_smooth_width_float,
            &#39;resample&#39;: resample_hv_curve,
            &#39;verbose&#39;: verbose_check},
        &#39;remove_outlier_curves&#39;: 
            {&#39;outlier_threshold&#39;: outlier_threshold_slider,
            &#39;use_percentile&#39;: outlier_pctile_check,
            &#39;use_hv_curves&#39;: use_hv_curve_outliers_check,
            &#39;verbose&#39;: verbose_check},
        &#39;check_peaks&#39;: 
            {&#39;hvsr_band&#39;: hvsr_band_rangeSlide,
            &#39;peak_freq_range&#39;: peak_freq_rangeSlide,
            &#39;verbose&#39;: verbose_check},
        &#39;get_report&#39;: 
            {
            &#39;export_path&#39;: export_results_table_filepath,
            &#39;verbose&#39;: verbose_check}}

    # SPRIT WIDGET
    # Add all  a tab and add the grid to it
    global sprit_tabs
    sprit_tabs = widgets.Tab([input_tab, preview_tab, results_tab, log_tab])
    sprit_tabs.set_title(0, &#34;Input&#34;)
    sprit_tabs.set_title(1, &#34;Data View&#34;)
    sprit_tabs.set_title(2, &#34;Results&#34;)
    sprit_tabs.set_title(3, &#34;Log&#34;)

    with open(spritLogoPath.as_posix(), &#34;rb&#34;) as file:
        image = file.read()

    sprit_logo = widgets.Image(value=image, format=&#39;png&#39;, width=30,height=30)
    sprit_title = widgets.Label(value=&#39;pRIT&#39;, layout=widgets.Layout(width=&#39;150px&#39;))
    sprit_subtitle = widgets.Label(value=&#39;Tools for ambient siesmic noise analysis using HVSR&#39;,
                                   layout=widgets.Layout(flex=&#39;1&#39;, justify_content=&#39;flex-start&#39;, align_content=&#39;flex-end&#39;))

    # Function to open a link
    def open_dist(button):
        link = &#39;https://pypi.org/project/sprit/&#39;
        webbrowser.open_new_tab(link)

    def open_repo(button):
        link = &#39;https://github.com/RJbalikian/SPRIT-HVSR&#39;
        webbrowser.open_new_tab(link)

    def open_docs(button):
        link = &#39;https://rjbalikian.github.io/SPRIT-HVSR/main.html&#39;
        webbrowser.open_new_tab(link)

    sourcebutton = widgets.Button(description=&#34;PyPI&#34;,
                                layout=widgets.Layout(width=&#39;4%&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-end&#39;))
    repobutton = widgets.Button(description=&#34;Repo&#34;,
                                layout=widgets.Layout(width=&#39;4%&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-end&#39;))
    docsbutton = widgets.Button(description=&#34;Docs&#34;,
                                layout=widgets.Layout(width=&#39;8%&#39;, justify_content=&#39;flex-end&#39;,align_content=&#39;flex-end&#39;))

    # Attach the open_link function to the button&#39;s on_click event
    sourcebutton.on_click(open_dist)
    repobutton.on_click(open_repo)
    docsbutton.on_click(open_docs)

    titlehbox = widgets.HBox([sprit_logo, sprit_title, sprit_subtitle, 
                              show_plot_check, verbose_check, 
                              repobutton, sourcebutton, docsbutton],
                            layout = widgets.Layout(align_content=&#39;space-between&#39;))
    
    title_style = {
        &#39;font_family&#39;: &#39;Arial, sans-serif&#39;,
        &#39;font_size&#39;: &#39;36px&#39;,
        &#39;font_weight&#39;: &#39;bold&#39;,
        &#39;color&#39;: &#39;black&#39;
    }

    # Apply the style to the label
    sprit_title.style = title_style

    sprit_widget = widgets.VBox([titlehbox, sprit_tabs], 
                                layout = widgets.Layout(align_content=&#39;space-between&#39;))

    def observe_children(widget, callback):
        if hasattr(widget, &#39;children&#39;):
            for child in widget.children:
                child.observe(callback)
                observe_children(child, callback)

    def any_update(change):
        update_input_param_call()
        update_fetch_data_call()
        update_remove_noise_call()
        update_generate_psds_call()
        update_process_hvsr_call()
        update_remove_outlier_curve_call()
        update_check_peaks_call()
        update_plot_string()

    observe_children(sprit_tabs, any_update)

    # Display the tab
    display(sprit_widget)</code></pre>
</details>
<div class="desc"><p>Function that generates the user interface for Jupyter Notebooks.</p>
<p>This interface uses ipywidgets, plotly, and IPython to create a user interface for processing data in a Jupyter notebook.</p>
<p>This is functionally equivalent to sprit.gui('nb').</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="sprit.gui" href="#sprit.gui">gui()</a></code></p></div>
</dd>
<dt id="sprit.export_data"><code class="name flex">
<span>def <span class="ident">export_data</span></span>(<span>hvsr_data,<br>data_export_path,<br>data_export_format='mseed',<br>starttime=None,<br>endtime=None,<br>tzone=None,<br>export_edited_stream=False,<br>site=None,<br>project=None,<br>verbose=False,<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_data(hvsr_data, data_export_path, data_export_format=&#39;mseed&#39;, starttime=None, endtime=None, tzone=None, export_edited_stream=False, 
                site=None, project=None, verbose=False, **kwargs):
    &#34;&#34;&#34;Export data stream to file. This uses the obspy.Stream.write() method on the hvsr_data[&#39;stream&#39;] object,
    but the stream can first be trimmed using starttime, endtime, and tzone.

    Parameters
    ----------
    hvsr_data : HVSRData, HVSRBatch, obspy.Stream, obspy.Trace
        Input stream or HVSR object
    data_export_path : pathlike-object
        Filepath at which to format data. If directory (recommended), filename will be generated automatically.
    data_export_format : str, optional
        Format of data, should be file format supported by obspy.write(), by default &#39;mseed&#39;
    starttime : str, UTCDateTime, or datetime.datetime, optional
        Starttime of stream, if trimming is desired, by default None
    endtime : str, UTCDateTime, or datetime.datetime, optional
        Endtime of stream, if trimming is desired, by default None
    tzone : str, zoneinfo.Zoneinfo, optional
        String readable by zoneinfo.Zoneinfo() or Zoneinfo object, by default None
    export_edited_stream : bool, optional
        Whether to export the raw stream (&#39;stream&#39; property; if False) or edited stream (&#39;stream_edited&#39; property; if True) in HVSRData object, by default False.
    site : str, optional
        Site name, to be used in filename generation, by default None
    project : str, optional
        Project or county name, to be used in filename generation, by default None
    verbose : bool, optional
        Whether to print information to terminal, by default False

    Returns
    -------
    obspy.Stream
        Stream object exported

    Raises
    ------
    TypeError
        hvsr_data must be of type HVSRData, HVSRBatch, obspy.Stream, or obspy.Trace
    &#34;&#34;&#34;
    
    # Extract stream for export
    if isinstance(hvsr_data, HVSRBatch):
        for site in hvsr_data:
            export_data(hvsr_data[site], data_export_path=data_export_path, data_export_format=data_export_format,
                        starttime=starttime, endtime=endtime, verbose=verbose, **kwargs)
        return
    elif isinstance(hvsr_data, (obspy.Stream, obspy.Trace)):
        if isinstance(hvsr_data, obspy.Stream):
            outputStream = hvsr_data.copy()
        else:
            outputStream = obspy.Stream([hvsr_data])
    else:
        # Assume data is in hvsr_data
        if not isinstance(hvsr_data, HVSRData):
            raise TypeError(f&#34;The sprit.export_data() parameter hvsr_data must be of type HVSRData, HVSRBatch, obspy.Stream, or obspy.Trace, not {type(hvsr_data)}&#34;)

        if export_edited_stream and hasattr(hvsr_data, &#39;stream_edited&#39;):
            outputStream = hvsr_data[&#39;stream_edited&#39;].copy()
        else:
            outputStream = hvsr_data[&#39;stream&#39;].copy()
        
    # Get starttime in obspy.UTCDateTime format
    if starttime is not None:
        if type(starttime) == str:
            sTimeDT = sprit_utils._format_time(starttime, tzone=tzone)
            acqDate = outputStream[0].stats.starttime.date
            sTimeDT.replace(year=acqDate.year, month=acqDate.month, day=acqDate.day)
            sTimeUTC = obspy.UTCDateTime(sTimeDT)
        elif isinstance(starttime, datetime.datetime):
            if tzone is not None:
                starttime = starttime.replace(tzinfo=tzone)
            sTimeUTC = obspy.UTCDateTime(starttime.astimezone(datetime.timezone.utc))
        else:
            sTimeUTC = obspy.UTCDateTime(starttime)
    else:
        sTimeUTC = outputStream[0].stats.starttime
    
    # Get endtime in obspy.UTCDateTime format
    if endtime is not None:
        if type(endtime) == str:
            eTimeDT = sprit_utils._format_time(endtime, tzone=tzone)
            acqDate = outputStream[-1].stats.endtime.date
            eTimeDT.replace(year=acqDate.year, month=acqDate.month, day=acqDate.day)
            eTimeUTC = obspy.UTCDateTime(eTimeDT)
        elif isinstance(endtime, datetime.datetime):
            if tzone is not None:
                endtime = endtime.replace(tzinfo=tzone)
            eTimeUTC = obspy.UTCDateTime(endtime.astimezone(datetime.timezone.utc))
        else:
            eTimeUTC = obspy.UTCDateTime(endtime)    
    else:
        eTimeUTC = outputStream[-1].stats.endtime

    # Build filepath
    
    siteName = site
    if site is None:
        siteName = &#34;HVSRSite&#34;
    
    projectName = project
    if project is None:
        projectName = &#34;&#34;
    if projectName != &#34;&#34; and len(projectName)&gt;0 and projectName[-1] != &#39;-&#39;:
        projectName += &#34;-&#34;

    sDateStr = outputStream[0].stats.starttime.strftime(&#34;%Y%m%d&#34;)
    sTimeStr = outputStream[0].stats.starttime.strftime(&#34;%H%M&#34;)
    staStr = outputStream[0].stats.station
    
    deFormat = str(data_export_format).upper()
    if data_export_format[0] == &#39;.&#39;:
        deFormat = deFormat[1:]
    
    dePath = pathlib.Path(data_export_path)    
    autoFname = f&#34;{siteName}_Stream_{projectName}{sDateStr}-{sTimeStr}-{staStr}_{datetime.date.today()}.{deFormat}&#34;
    if dePath.is_dir():
        if not dePath.exists():
            dePath.mkdir(parents=True)
        outfPath = dePath.joinpath(autoFname)
    elif dePath.is_file():
        outfPath = dePath
    
    # Trim stream as needed
    if starttime is None and endtime is None:
        pass
    else:
        isMasked = False
        doTrim = False
        
        for tr in outputStream:
            if isinstance(tr.data, np.ma.masked_array):
                isMasked = True
            if sTimeUTC &gt; tr.stats.endtime or eTimeUTC &lt; tr.stats.starttime:
                doTrim = True

        if isMasked:
            outputStream = outputStream.split()
        
        if doTrim:
            if verbose:
                print(f&#34;\t Trimming data to {sTimeUTC} and {eTimeUTC}\n\t\t Stream starttime: {outputStream[0].stats.starttime}\n\t\t Stream endtime: {outputStream[0].stats.endtime}&#34;)
            outputStream.trim(starttime=sTimeUTC, endtime=eTimeUTC)
        
    outputStream.merge(method=1)

    # Take care of masked arrays for writing purposes
    if &#39;fill_value&#39; in kwargs.keys():
        for tr in outputStream:
            if isinstance(tr.data, np.ma.masked_array):
                tr.data = tr.data.filled(kwargs[&#39;fill_value&#39;])
    else:
        outputStream = outputStream.split()
    
    outputStream.write(filename=outfPath.as_posix())
    
    if verbose:
        print(&#39;Stream has been written to &#39; + outfPath.as_posix())
    return outputStream</code></pre>
</details>
<div class="desc"><p>Export data stream to file. This uses the obspy.Stream.write() method on the hvsr_data['stream'] object,
but the stream can first be trimmed using starttime, endtime, and tzone.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a>, <a title="sprit.HVSRBatch" href="#sprit.HVSRBatch">HVSRBatch</a>, obspy.Stream, obspy.Trace</code></dt>
<dd>Input stream or HVSR object</dd>
<dt><strong><code>data_export_path</code></strong> :&ensp;<code>pathlike-object</code></dt>
<dd>Filepath at which to format data. If directory (recommended), filename will be generated automatically.</dd>
<dt><strong><code>data_export_format</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Format of data, should be file format supported by obspy.write(), by default 'mseed'</dd>
<dt><strong><code>starttime</code></strong> :&ensp;<code>str, UTCDateTime,</code> or <code>datetime.datetime</code>, optional</dt>
<dd>Starttime of stream, if trimming is desired, by default None</dd>
<dt><strong><code>endtime</code></strong> :&ensp;<code>str, UTCDateTime,</code> or <code>datetime.datetime</code>, optional</dt>
<dd>Endtime of stream, if trimming is desired, by default None</dd>
<dt><strong><code>tzone</code></strong> :&ensp;<code>str, zoneinfo.Zoneinfo</code>, optional</dt>
<dd>String readable by zoneinfo.Zoneinfo() or Zoneinfo object, by default None</dd>
<dt><strong><code>export_edited_stream</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to export the raw stream ('stream' property; if False) or edited stream ('stream_edited' property; if True) in HVSRData object, by default False.</dd>
<dt><strong><code>site</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Site name, to be used in filename generation, by default None</dd>
<dt><strong><code>project</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Project or county name, to be used in filename generation, by default None</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print information to terminal, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>obspy.Stream</code></dt>
<dd>Stream object exported</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>hvsr_data must be of type HVSRData, HVSRBatch, obspy.Stream, or obspy.Trace</dd>
</dl></div>
</dd>
<dt id="sprit.export_hvsr"><code class="name flex">
<span>def <span class="ident">export_hvsr</span></span>(<span>hvsr_data,<br>hvsr_export_path=None,<br>ext='hvsr',<br>export_type='gzip',<br>export_plots=False,<br>verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_hvsr(hvsr_data, hvsr_export_path=None, ext=&#39;hvsr&#39;, export_type=&#39;gzip&#39;,
                export_plots=False,
                verbose=False):
    &#34;&#34;&#34;Export data into pickle format that can be read back in using import_data().
       Intended so data does not need to be processed each time it needs to be used. 
       By default, first, export_hvsr serializes the HVSRData object(s) using pickle.dumps(). 
       Then, to save space, it writes that to a gzip file.
       Default extension is .hvsr no matter the format, though this can be set with `ext` parameter.

    Parameters
    ----------
    hvsr_data : HVSRData or HVSRBatch
        Data to be exported
    hvsr_export_path : str or filepath object, default = None
        String or filepath object to be read by pathlib.Path() and/or a with open(hvsr_export_path, &#39;wb&#39;) statement. If None, defaults to input input_data directory, by default None
    ext : str, default = &#39;hvsr&#39;
        Filepath extension to use for data file, by default &#39;hvsr&#39;. 
        This will be the extension no matter the export_type
    export_type : str, default = &#39;gzip&#39;
        Export type to use. If `export_type` is &#39;pickle&#39;, will just save to disk using pickle.dump.
        Otherwise, saves a pickle-serialized object to a gzip file (with a .hvsr extension in both cases, by default).
    verbose : bool, default=False
        Whether to print information about export. A confirmation message is printed no matter what.
    &#34;&#34;&#34;
    def _hvsr_export(_hvsr_data=hvsr_data, _export_path=hvsr_export_path, _ext=ext):
        
        fname = f&#34;{_hvsr_data[&#39;site&#39;]}_HVSRData_{_hvsr_data[&#39;hvsr_id&#39;]}_{datetime.date.today()}_pickled.{ext}&#34;
        if _export_path is None or _export_path is True:
            _export_path = _hvsr_data[&#39;input_data&#39;]
            _export_path = pathlib.Path(_export_path).with_name(fname)
        else:
            _export_path = pathlib.Path(_export_path)
            if _export_path.is_dir():
                _export_path = _export_path.joinpath(fname)    

        _export_path = str(_export_path)

        if export_type == &#39;pickle&#39;:
            with open(_export_path, &#39;wb&#39;) as f:
                pickle.dump(_hvsr_data, f)
        else:
            with gzip.open(_export_path, &#39;wb&#39;) as f:
                f.write(pickle.dumps(_hvsr_data))

        if verbose:
            print(&#39;EXPORT COMPLETE&#39;)
        print(f&#34;Processed data exported as pickled data to: {_export_path} [~{round(float(pathlib.Path(_export_path).stat().st_size)/2**20,1)} Mb]&#34;)    

    hvData = hvsr_data
    #hvData = copy.deepcopy(hvsr_data)
    #if export_plots is False:
    #    for pk in PLOT_KEYS:
    #        if hasattr(hvData, pk):
    #            del hvData[pk]

    if isinstance(hvData, HVSRBatch):
        for sitename in hvData.keys():
            _hvsr_export(_hvsr_data=hvData[sitename], _export_path=hvsr_export_path, _ext=ext)
    elif isinstance(hvData, HVSRData):
        _hvsr_export(_hvsr_data=hvData, _export_path=hvsr_export_path, _ext=ext)
    else:
        print(&#34;Error in data export. Data must be either of type sprit.HVSRData or sprit.HVSRBatch&#34;)         
    
    return</code></pre>
</details>
<div class="desc"><p>Export data into pickle format that can be read back in using import_data().
Intended so data does not need to be processed each time it needs to be used.
By default, first, export_hvsr serializes the HVSRData object(s) using pickle.dumps().
Then, to save space, it writes that to a gzip file.
Default extension is .hvsr no matter the format, though this can be set with <code>ext</code> parameter.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code> or <code><a title="sprit.HVSRBatch" href="#sprit.HVSRBatch">HVSRBatch</a></code></dt>
<dd>Data to be exported</dd>
<dt><strong><code>hvsr_export_path</code></strong> :&ensp;<code>str</code> or <code>filepath object</code>, default <code>= None</code></dt>
<dd>String or filepath object to be read by pathlib.Path() and/or a with open(hvsr_export_path, 'wb') statement. If None, defaults to input input_data directory, by default None</dd>
<dt><strong><code>ext</code></strong> :&ensp;<code>str</code>, default <code>= 'hvsr'</code></dt>
<dd>Filepath extension to use for data file, by default 'hvsr'.
This will be the extension no matter the export_type</dd>
<dt><strong><code>export_type</code></strong> :&ensp;<code>str</code>, default <code>= 'gzip'</code></dt>
<dd>Export type to use. If <code>export_type</code> is 'pickle', will just save to disk using pickle.dump.
Otherwise, saves a pickle-serialized object to a gzip file (with a .hvsr extension in both cases, by default).</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to print information about export. A confirmation message is printed no matter what.</dd>
</dl></div>
</dd>
<dt id="sprit.export_report"><code class="name flex">
<span>def <span class="ident">export_report</span></span>(<span>hvsr_results,<br>report_export_path=None,<br>report_export_format=['pdf'],<br>azimuth='HV',<br>csv_handling='rename',<br>show_report=True,<br>verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_report(hvsr_results, report_export_path=None, report_export_format=[&#39;pdf&#39;], azimuth=&#39;HV&#39;, csv_handling=&#39;rename&#39;, show_report=True, verbose=False):
    &#34;&#34;&#34;Function to export reports to disk. Exportable formats for report_export_format include: 
        * &#39;table&#39;: saves a pandas DataFrame as a csv)
        * &#39;plot&#39;: saves the matplotlib or plotly plot figure (depending on what is designated via plot_engine) as an image (png by default)
        * &#39;print&#39;: saves the print report as a .txt file
        * &#39;html&#39;: saves the html report as a .html file
        * &#39;pdf&#39;: saves the pdf report as a .pdf file

    Parameters
    ----------
    hvsr_results : HVSRData object
        HVSRData object containing the HVSR data
    report_export_path : path-like object, optional
        The path to where the report should be exported. 
        If this is None (default), this is written to the home directory.
        If this is a True, uses the same directory as the input data, but generates a filename.
        If this is a directory, generates a filename. 
        If filename is specified and the extension does not match the report type, the extension is adjusted.
        Otherwise, this is the output file or , by default None
    csv_handling : {&#39;rename&#39;, &#39;append&#39;, &#39;overwrite&#39;, &#39;keep&#39;}, optional
        If table is the report type, this can prevent overwriting data, by default &#39;rename&#39;.
        * &#34;rename&#34; (or &#34;keep&#34;): renames the new file to prevent overwrite, appends a digit to the end of filename
        * &#34;append&#34;: appends the new data to the existing file
        * &#34;overwrite&#34;: overwrites the existing file
    report_export_format : str or list, optional
        The format (or a list of formats) to export the report, by default [&#39;pdf&#39;].
    show_report : bool, optional
        Whether to show the designated reports that were chosen for export, by default True
    verbose : bool, optional
        Whether to print progress and other information to terminal, by default False

    Returns
    -------
    HVSRData
        An HVSRData object that is the same as hvsr_results, but with any additionally generated reports.
    &#34;&#34;&#34;

    if type(report_export_format) is str:
        report_export_format = [report_export_format]
    
    for ref in report_export_format:

        if report_export_path is None:
            print(&#39;The export_report(report_export_path) parameter was not specified.&#39;)
            print(f&#39;The report will be saved the home directory: {pathlib.Path.home()}&#39;)

        if ref == &#39;table&#39;:
            ext = &#39;.csv&#39;
        elif ref == &#39;plot&#39;:
            ext = &#39;.png&#39;
        elif ref == &#39;print&#39;:
            ext = &#39;.txt&#39;
        elif ref == &#39;html&#39;:
            ext = &#39;.html&#39;
        else:
            ref == &#39;pdf&#39;
            ext = &#39;.pdf&#39;
            
        sitename = hvsr_results[&#39;input_params&#39;][&#39;site&#39;]
        fname = f&#34;{sitename}_REPORT_{hvsr_results[&#39;hvsr_id&#39;]}_{datetime.date.today()}{ext}&#34;
        fname = fname.replace(&#39;:&#39;, &#39;&#39;)

        # Initialize output as file in home directory (if not updated)
        outFile = pathlib.Path().home().joinpath(fname)
        if report_export_path is True or report_export_path is None:
            # Check so we don&#39;t write in sample directory
            if pathlib.Path(hvsr_results[&#39;input_params&#39;][&#39;input_data&#39;]) in sampleFileKeyMap.values():
                if pathlib.Path(os.getcwd()) in sampleFileKeyMap.values(): #Just in case current working directory is also sample directory
                    inFile = pathlib.Path.home() #Use the path to user&#39;s home if all else fails
                else:
                    inFile = pathlib.Path(os.getcwd())
            else:
                inFile = pathlib.Path(hvsr_results[&#39;input_params&#39;][&#39;input_data&#39;])
                            
            if inFile.is_dir():
                outFile = inFile.joinpath(fname)
            else:
                outFile = inFile.with_name(fname)
        else:
            if report_export_path is False:
                pass
            elif pathlib.Path(report_export_path).is_dir():
                outFile = pathlib.Path(report_export_path).joinpath(fname)
            else:
                outFile = pathlib.Path(report_export_path)

        if ref == &#39;table&#39;:
            if not hasattr(hvsr_results, &#39;Table_Report&#39;):
                hvsr_results = _generate_table_report(hvsr_results, azimuth=azimuth, show_table_report=show_report, verbose=verbose)
            reportDF = hvsr_results[&#39;Table_Report&#39;]

            # Check if file already exists, and handle as specified in csv_handling
            if outFile.exists():
                existFile = pd.read_csv(outFile)

                 

                if csv_handling.lower() == &#39;append&#39;:
                    # Append report to existing report as new row
                    reportDF = pd.concat([existFile, reportDF], ignore_index=True, join=&#39;inner&#39;)
                elif csv_handling.lower() == &#39;overwrite&#39;:
                    # Overwrite existing report file
                    pass
                else:  # csv_handling.lower() in [&#39;keep&#39;, &#39;rename&#39;, or other]:
                    # Rename new report so as not to modify existing report (default handling)
                    if outFile.stem[-3] == &#39;_&#39; and outFile.stem[-2:].isdigit():
                        fileDigit = int(outFile.stem[-2:]) + 1
                    else:
                        fileDigit = 1
                    fileDigit = str(fileDigit).zfill(2)
                    outFile = outFile.with_stem(outFile.stem + &#39;_&#39; + fileDigit)

            # Export to csv using pandas to_csv method
            try:
                print(f&#39;\nSaving table report to: {outFile}&#39;)
                reportDF.to_csv(outFile, index_label=&#39;ID&#39;)
            except:
                warnings.warn(&#34;Table report not exported. \n\tDataframe to be exported as csv has been saved in hvsr_results[&#39;BestPeak&#39;][&#39;Report&#39;][&#39;Table_Report]&#34;, category=RuntimeWarning)
 
            if show_report or verbose:
                print(&#39;\nTable Report:\n&#39;)
                maxColWidth = 13
                print(&#39;  &#39;, end=&#39;&#39;)
                for col in reportDF.columns:
                    if len(str(col)) &gt; maxColWidth:
                        colStr = str(col)[:maxColWidth-3]+&#39;...&#39;
                    else:
                        colStr = str(col)
                    print(colStr.ljust(maxColWidth), end=&#39;  &#39;)
                print() #new line
                for c in range(len(reportDF.columns) * (maxColWidth+2)):
                    if c % (maxColWidth+2) == 0:
                        print(&#39;|&#39;, end=&#39;&#39;)
                    else:
                        print(&#39;-&#39;, end=&#39;&#39;)
                print(&#39;|&#39;) #new line
                print(&#39;  &#39;, end=&#39;&#39;) #Small indent at start                    
                for row in reportDF.iterrows():
                    for col in row[1]:
                        if len(str(col)) &gt; maxColWidth:
                            colStr = str(col)[:maxColWidth-3]+&#39;...&#39;
                        else:
                            colStr = str(col)
                        print(colStr.ljust(maxColWidth), end=&#39;  &#39;)
                    print()
        elif ref == &#39;plot&#39;:
            if not hasattr(hvsr_results, &#39;Plot_Report&#39;):
                fig = plot_hvsr(hvsr_results, return_fig=True)
            hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;Report&#39;][&#39;Plot_Report&#39;] = hvsr_results[&#39;Plot_Report&#39;] = fig

            if verbose:
                print(f&#39;\nSaving plot to: {outFile}&#39;)
            plt.scf = fig
            plt.savefig(outFile)
        elif ref == &#39;print&#39;:
            if not hasattr(hvsr_results, &#34;Print_Report&#34;) or hvsr_results[&#39;Print_Report&#39;] is None:
                hvsr_results = _generate_print_report(hvsr_results, azimuth=azimuth, show_print_report=show_report, verbose=verbose)            
            with open(outFile, &#39;w&#39;) as outF:
                outF.write(hvsr_results[&#39;Print_Report&#39;])
                # Could write more details in the future
                if show_report or verbose:
                    print(hvsr_results[&#39;Print_Report&#39;])
        elif ref == &#34;html&#34;:
            if not hasattr(hvsr_results, &#34;HTML_Report&#34;) or hvsr_results[&#39;HTML_Report&#39;] is None:
                hvsr_results = _generate_html_report(hvsr_results)
            with open(outFile, &#39;w&#39;) as outF:
                outF.write(hvsr_results[&#39;HTML_Report&#39;])
        elif ref == &#34;pdf&#34;:
            hvsr_results = _generate_pdf_report(hvsr_results, pdf_report_filepath=report_export_path, show_pdf_report=show_report, verbose=verbose)
        
    return hvsr_results</code></pre>
</details>
<div class="desc"><p>Function to export reports to disk. Exportable formats for report_export_format include:
* 'table': saves a pandas DataFrame as a csv)
* 'plot': saves the matplotlib or plotly plot figure (depending on what is designated via plot_engine) as an image (png by default)
* 'print': saves the print report as a .txt file
* 'html': saves the html report as a .html file
* 'pdf': saves the pdf report as a .pdf file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_results</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a> object</code></dt>
<dd>HVSRData object containing the HVSR data</dd>
<dt><strong><code>report_export_path</code></strong> :&ensp;<code>path-like object</code>, optional</dt>
<dd>The path to where the report should be exported.
If this is None (default), this is written to the home directory.
If this is a True, uses the same directory as the input data, but generates a filename.
If this is a directory, generates a filename.
If filename is specified and the extension does not match the report type, the extension is adjusted.
Otherwise, this is the output file or , by default None</dd>
<dt><strong><code>csv_handling</code></strong> :&ensp;<code>{'rename', 'append', 'overwrite', 'keep'}</code>, optional</dt>
<dd>If table is the report type, this can prevent overwriting data, by default 'rename'.
* "rename" (or "keep"): renames the new file to prevent overwrite, appends a digit to the end of filename
* "append": appends the new data to the existing file
* "overwrite": overwrites the existing file</dd>
<dt><strong><code>report_export_format</code></strong> :&ensp;<code>str</code> or <code>list</code>, optional</dt>
<dd>The format (or a list of formats) to export the report, by default ['pdf'].</dd>
<dt><strong><code>show_report</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to show the designated reports that were chosen for export, by default True</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print progress and other information to terminal, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code></dt>
<dd>An HVSRData object that is the same as hvsr_results, but with any additionally generated reports.</dd>
</dl></div>
</dd>
<dt id="sprit.export_settings"><code class="name flex">
<span>def <span class="ident">export_settings</span></span>(<span>hvsr_data,<br>export_settings_path='default',<br>export_settings_type='all',<br>include_location=False,<br>verbose=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_settings(hvsr_data, export_settings_path=&#39;default&#39;, export_settings_type=&#39;all&#39;, include_location=False, verbose=True):
    &#34;&#34;&#34;Save processing settings to json file.

    Parameters
    ----------
    export_settings_path : str, default=&#34;default&#34;
        Where to save the json file(s) containing the settings, by default &#39;default&#39;. 
        If &#34;default,&#34; will save to sprit package resources. Otherwise, set a filepath location you would like for it to be saved to.
        If &#39;all&#39; is selected, a directory should be supplied. 
        Otherwise, it will save in the directory of the provided file, if it exists. Otherwise, defaults to the home directory.
    export_settings_type : str, {&#39;all&#39;, &#39;instrument&#39;, &#39;processing&#39;}
        What kind of settings to save. 
        If &#39;all&#39;, saves all possible types in their respective json files.
        If &#39;instrument&#39;, save the instrument settings to their respective file.
        If &#39;processing&#39;, saves the processing settings to their respective file. By default &#39;all&#39;
    include_location : bool, default=False, input CRS
        Whether to include the location parametersin the exported settings document.This includes xcoord, ycoord, elevation, elev_unit, and input_crs
    verbose : bool, default=True
        Whether to print outputs and information to the terminal

    &#34;&#34;&#34;
    fnameDict = {}
    fnameDict[&#39;instrument&#39;] = &#34;instrument_settings.json&#34;
    fnameDict[&#39;processing&#39;] = &#34;processing_settings.json&#34;

    if export_settings_path == &#39;default&#39; or export_settings_path is True:
        settingsPath = RESOURCE_DIR.joinpath(&#39;settings&#39;)
    else:
        export_settings_path = pathlib.Path(export_settings_path)
        if not export_settings_path.exists():
            if not export_settings_path.parent.exists():
                print(f&#39;The provided value for export_settings_path ({export_settings_path}) does not exist. Saving settings to the home directory: {pathlib.Path.home()}&#39;)
                settingsPath = pathlib.Path.home()
            else:
                settingsPath = export_settings_path.parent
        
        if export_settings_path.is_dir():
            settingsPath = export_settings_path
        elif export_settings_path.is_file():
            settingsPath = export_settings_path.parent
            fnameDict[&#39;instrument&#39;] = export_settings_path.name+&#34;_instrumentSettings.json&#34;
            fnameDict[&#39;processing&#39;] = export_settings_path.name+&#34;_processingSettings.json&#34;

    #Get final filepaths        
    instSetFPath = settingsPath.joinpath(fnameDict[&#39;instrument&#39;])
    procSetFPath = settingsPath.joinpath(fnameDict[&#39;processing&#39;])

    #Get settings values
    instKeys = [&#34;instrument&#34;, &#34;net&#34;, &#34;sta&#34;, &#34;loc&#34;, &#34;cha&#34;, &#34;depth&#34;, &#34;metadata&#34;, &#34;hvsr_band&#34;]
    inst_location_keys = [&#39;xcoord&#39;, &#39;ycoord&#39;, &#39;elevation&#39;, &#39;elev_unit&#39;, &#39;input_crs&#39;]
    procFuncs = [fetch_data, remove_noise, generate_psds, process_hvsr, check_peaks, get_report]

    instrument_settings_dict = {}
    processing_settings_dict = {}

    for k in instKeys:
        if isinstance(hvsr_data[k], pathlib.PurePath):
            #For those that are paths and cannot be serialized
            instrument_settings_dict[k] = hvsr_data[k].as_posix()
        else:
            instrument_settings_dict[k] = hvsr_data[k]

    if include_location:
        for k in inst_location_keys:
            if isinstance(hvsr_data[k], pathlib.PurePath):
                #For those that are paths and cannot be serialized
                instrument_settings_dict[k] = hvsr_data[k].as_posix()
            else:
                instrument_settings_dict[k] = hvsr_data[k]

    
    for func in procFuncs:
        funcName = func.__name__
        processing_settings_dict[funcName] = {}
        for arg in hvsr_data[&#39;processing_parameters&#39;][funcName]:
            if isinstance(hvsr_data[&#39;processing_parameters&#39;][funcName][arg], (HVSRBatch, HVSRData)):
                pass
            else:
                processing_settings_dict[funcName][arg] = hvsr_data[&#39;processing_parameters&#39;][funcName][arg]
    
    if verbose:
        print(&#34;Exporting Settings&#34;)
    #Save settings files
    if export_settings_type.lower()==&#39;instrument&#39; or export_settings_type.lower()==&#39;all&#39;:
        try:
            with open(instSetFPath.with_suffix(&#39;.inst&#39;).as_posix(), &#39;w&#39;) as instSetF:
                jsonString = json.dumps(instrument_settings_dict, indent=2)
                #Format output for readability
                jsonString = jsonString.replace(&#39;\n    &#39;, &#39; &#39;)
                jsonString = jsonString.replace(&#39;[ &#39;, &#39;[&#39;)
                jsonString = jsonString.replace(&#39;\n  ]&#39;, &#39;]&#39;)
                #Export
                instSetF.write(jsonString)
        except:
            instSetFPath = pathlib.Path.home().joinpath(instSetFPath.name)
            with open(instSetFPath.with_suffix(&#39;.inst&#39;).as_posix(), &#39;w&#39;) as instSetF:
                jsonString = json.dumps(instrument_settings_dict, indent=2)
                #Format output for readability
                jsonString = jsonString.replace(&#39;\n    &#39;, &#39; &#39;)
                jsonString = jsonString.replace(&#39;[ &#39;, &#39;[&#39;)
                jsonString = jsonString.replace(&#39;\n  ]&#39;, &#39;]&#39;)
                #Export
                instSetF.write(jsonString)
                            
        if verbose:
            print(f&#34;Instrument settings exported to {instSetFPath}&#34;)
            print(f&#34;{jsonString}&#34;)
            print()
    if export_settings_type.lower()==&#39;processing&#39; or export_settings_type.lower()==&#39;all&#39;:
        try:
            with open(procSetFPath.with_suffix(&#39;.proc&#39;).as_posix(), &#39;w&#39;) as procSetF:
                jsonString = json.dumps(processing_settings_dict, indent=2)
                #Format output for readability
                jsonString = jsonString.replace(&#39;\n    &#39;, &#39; &#39;)
                jsonString = jsonString.replace(&#39;[ &#39;, &#39;[&#39;)
                jsonString = jsonString.replace(&#39;\n  ]&#39;, &#39;]&#39;)
                jsonString = jsonString.replace(&#39;\n  },&#39;,&#39;\n\t\t},\n&#39;)
                jsonString = jsonString.replace(&#39;{ &#34;&#39;, &#39;\n\t\t{\n\t\t&#34;&#39;)
                jsonString = jsonString.replace(&#39;, &#34;&#39;, &#39;,\n\t\t&#34;&#39;)
                jsonString = jsonString.replace(&#39;\n  }&#39;, &#39;\n\t\t}&#39;)
                jsonString = jsonString.replace(&#39;: {&#39;, &#39;:\n\t\t\t{&#39;)
                
                #Export
                procSetF.write(jsonString)
        except:
            procSetFPath = pathlib.Path.home().joinpath(procSetFPath.name)
            with open(procSetFPath.with_suffix(&#39;.proc&#39;).as_posix(), &#39;w&#39;) as procSetF:
                jsonString = json.dumps(processing_settings_dict, indent=2)
                #Format output for readability
                jsonString = jsonString.replace(&#39;\n    &#39;, &#39; &#39;)
                jsonString = jsonString.replace(&#39;[ &#39;, &#39;[&#39;)
                jsonString = jsonString.replace(&#39;\n  ]&#39;, &#39;]&#39;)
                jsonString = jsonString.replace(&#39;\n  },&#39;,&#39;\n\t\t},\n&#39;)
                jsonString = jsonString.replace(&#39;{ &#34;&#39;, &#39;\n\t\t{\n\t\t&#34;&#39;)
                jsonString = jsonString.replace(&#39;, &#34;&#39;, &#39;,\n\t\t&#34;&#39;)
                jsonString = jsonString.replace(&#39;\n  }&#39;, &#39;\n\t\t}&#39;)
                jsonString = jsonString.replace(&#39;: {&#39;, &#39;:\n\t\t\t{&#39;)
                
                #Export
                procSetF.write(jsonString)            
        if verbose:
            print(f&#34;Processing settings exported to {procSetFPath}&#34;)
            print(f&#34;{jsonString}&#34;)
            print()</code></pre>
</details>
<div class="desc"><p>Save processing settings to json file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>export_settings_path</code></strong> :&ensp;<code>str</code>, default=<code>"default"</code></dt>
<dd>Where to save the json file(s) containing the settings, by default 'default'.
If "default," will save to sprit package resources. Otherwise, set a filepath location you would like for it to be saved to.
If 'all' is selected, a directory should be supplied.
Otherwise, it will save in the directory of the provided file, if it exists. Otherwise, defaults to the home directory.</dd>
<dt><strong><code>export_settings_type</code></strong> :&ensp;<code>str, {'all', 'instrument', 'processing'}</code></dt>
<dd>What kind of settings to save.
If 'all', saves all possible types in their respective json files.
If 'instrument', save the instrument settings to their respective file.
If 'processing', saves the processing settings to their respective file. By default 'all'</dd>
<dt><strong><code>include_location</code></strong> :&ensp;<code>bool</code>, default=<code>False, input CRS</code></dt>
<dd>Whether to include the location parametersin the exported settings document.This includes xcoord, ycoord, elevation, elev_unit, and input_crs</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to print outputs and information to the terminal</dd>
</dl></div>
</dd>
<dt id="sprit.fetch_data"><code class="name flex">
<span>def <span class="ident">fetch_data</span></span>(<span>params,<br>source='file',<br>data_export_path=None,<br>data_export_format='mseed',<br>detrend='spline',<br>detrend_options=2,<br>filter_type=None,<br>filter_options={},<br>update_metadata=True,<br>plot_input_stream=False,<br>plot_engine='matplotlib',<br>show_plot=True,<br>verbose=False,<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_data(params, source=&#39;file&#39;, data_export_path=None, data_export_format=&#39;mseed&#39;, 
               detrend=&#39;spline&#39;, detrend_options=2, filter_type=None, filter_options={},
               update_metadata=True, 
               plot_input_stream=False, plot_engine=&#39;matplotlib&#39;, show_plot=True, 
               verbose=False, **kwargs):
    
    &#34;&#34;&#34;Fetch ambient seismic data from a source to read into obspy stream. 
    
    Parameters
    ----------
    params  : dict
        Dictionary containing all the necessary params to get data.
            Parameters defined using input_params() function.
    source  : str, {&#39;raw&#39;, &#39;dir&#39;, &#39;file&#39;, &#39;batch&#39;}
        String indicating where/how data file was created. For example, if raw data, will need to find correct channels.
            &#39;raw&#39; finds raspberry shake data, from raw output copied using scp directly from Raspberry Shake, either in folder or subfolders; 
            &#39;dir&#39; is used if the day&#39;s 3 component files (currently Raspberry Shake supported only) are all 3 contained in a directory by themselves.
            &#39;file&#39; is used if the params[&#39;input_data&#39;] specified in input_params() is the direct filepath to a single file to be read directly into an obspy stream.
            &#39;batch&#39; is used to read a list or specified set of seismic files. 
                Most commonly, a csv file can be read in with all the parameters. Each row in the csv is a separate file. Columns can be arranged by parameter.
    data_export_path : None or str or pathlib obj, default=None
        If None (or False), data is not trimmed in this function.
        Otherwise, this is the directory to save trimmed and exported data.
    data_export_format: str=&#39;mseed&#39;
        If data_export_path is not None, this is the format in which to save the data
    detrend : str or bool, default=&#39;spline&#39;
        If False, data is not detrended.
        Otherwise, this should be a string accepted by the type parameter of the obspy.core.trace.Trace.detrend method: https://docs.obspy.org/packages/autogen/obspy.core.trace.Trace.detrend.html
    detrend_options : int, default=2
        If detrend parameter is &#39;spline&#39; or &#39;polynomial&#39;, this is passed directly to the order parameter of obspy.core.trace.Trace.detrend method.
    filter_type : None, str
        Type of filter to use on raw data.
        This should either be None or any of {&#39;bandpass&#39;, &#39;bandstop&#39;, &#39;lowpass&#39;, &#39;highpass&#39;, &#39;lowpass_cheby_2&#39;, &#39;lowpass_fir&#39;, &#39;remez_fir&#39;}.
        This passes `filter_type` to the `type` parameter and `**filter_options` to the `**options` parameter of the obspy.Stream filter() method.
        See here for more information: https://docs.obspy.org/packages/autogen/obspy.core.stream.Stream.filter.html
        If None, no filtering is done on the input seismic data.
    filter_options : dict
        Dictionary that will be unpacked into the `**options` parameter of the filter() method of the obspy.Stream class.
        This should fit the parameters of whichever filter type is specifed by filter_type.
        Example options for the &#39;bandpass&#39; filter_type might be: `filter_options={&#39;freqmin&#39;: 0.1, &#39;freqmax&#39;:50, &#39;df&#39;:100, &#39;corners&#39;:4, &#39;zerophase&#39;:True}`.
        See here for more information: https://docs.obspy.org/packages/autogen/obspy.core.stream.Stream.filter.html
    update_metadata : bool, default=True
        Whether to update the metadata file, used primarily with Raspberry Shake data which uses a generic inventory file.
    plot_input_stream : bool, default=False
        Whether to plot the raw input stream. This plot includes a spectrogram (Z component) and the raw (with decimation for speed) plots of each component signal.
    plot_engine : str, default=&#39;matplotlib&#39;
        Which plotting library/engine to use for plotting the Input stream. Options are &#39;matplotlib&#39;, &#39;plotly&#39;, or &#39;obspy&#39; (not case sensitive).
    verbose : bool, default=False
        Whether to print outputs and inputs to the terminal
    **kwargs
        Keywords arguments, primarily for &#39;batch&#39; and &#39;dir&#39; sources
        
    Returns
    -------
    params : HVSRData or HVSRBatch object
        Same as params parameter, but with an additional &#34;stream&#34; attribute with an obspy data stream with 3 traces: Z (vertical), N (North-south), and E (East-west)
    &#34;&#34;&#34;
    # Get intput paramaters
    orig_args = locals().copy()
    start_time = datetime.datetime.now()
    
    # Keep track of any updates made to raw input along the way
    update_msg = []

    # Update with processing parameters specified previously in input_params, if applicable
    if &#39;processing_parameters&#39; in params.keys():
        if &#39;fetch_data&#39; in params[&#39;processing_parameters&#39;].keys():
            defaultVDict = dict(zip(inspect.getfullargspec(fetch_data).args[1:], 
                        inspect.getfullargspec(fetch_data).defaults))
            defaultVDict[&#39;kwargs&#39;] = kwargs
            for k, v in params[&#39;processing_parameters&#39;][&#39;fetch_data&#39;].items():
                # Manual input to function overrides the imported parameter values
                if k != &#39;params&#39; and k in orig_args.keys() and orig_args[k]==defaultVDict[k]:
                    update_msg.append(f&#39;\t\t{k} = {v} (previously {orig_args[k]})&#39;)
                    orig_args[k] = v
                    
    # Update local variables, in case of previously-specified parameters
    source = orig_args[&#39;source&#39;].lower()
    data_export_path = orig_args[&#39;data_export_path&#39;]
    data_export_format = orig_args[&#39;data_export_format&#39;]
    detrend = orig_args[&#39;detrend&#39;]
    detrend_options = orig_args[&#39;detrend_options&#39;]
    filter_type = orig_args[&#39;filter_type&#39;]
    filter_options = orig_args[&#39;filter_options&#39;]
    update_metadata = orig_args[&#39;update_metadata&#39;]
    plot_input_stream = orig_args[&#39;plot_input_stream&#39;]
    plot_engine = orig_args[&#39;plot_engine&#39;]
    verbose = orig_args[&#39;verbose&#39;]
    kwargs = orig_args[&#39;kwargs&#39;]

    # Print inputs for verbose setting
    if verbose:
        print(&#39;\nFetching data (fetch_data())&#39;)
        for key, value in orig_args.items():
            if not isinstance(value, (HVSRData, HVSRBatch)):
                print(&#39;\t  {}={}&#39;.format(key, value))
        print()
        
        if &#39;processing_parameters&#39; in params.keys() and &#39;fetch_data&#39; in params[&#39;processing_parameters&#39;].keys():
            if update_msg != []:
                update_msg.insert(0, &#39;\tThe following parameters were updated using the processing_parameters attribute:&#39;)
                for msg_line in update_msg:
                    print(msg_line)
                print()

    raspShakeInstNameList = [&#39;raspberry shake&#39;, &#39;shake&#39;, &#39;raspberry&#39;, &#39;rs&#39;, &#39;rs3d&#39;, &#39;rasp. shake&#39;, &#39;raspshake&#39;]
    trominoNameList = [&#39;tromino&#39;, &#39;trom&#39;,&#39;tromino blue&#39;, &#39;tromino blu&#39;, &#39;tromino 3g&#39;, &#39;tromino 3g+&#39;, &#39;tr&#39;, &#39;t&#39;]

    # Check if data is from tromino, and adjust parameters accordingly
    if &#39;trc&#39; in pathlib.Path(str(params[&#39;input_data&#39;])).suffix:
        if verbose and hasattr(params, &#39;instrument&#39;) and params[&#39;instrument&#39;].lower() not in trominoNameList:
            print(f&#34;\t Data from tromino detected. Changing instrument from {params[&#39;instrument&#39;]} to &#39;Tromino&#39;&#34;)
        if &#39;tromino&#39; not in str(params[&#39;instrument&#39;]).lower():
            params[&#39;instrument&#39;] = &#39;Tromino&#39;

    # Get metadata (inventory/response information)
    params = get_metadata(params, update_metadata=update_metadata, source=source, verbose=verbose)
    inv = params[&#39;inv&#39;]
    date = params[&#39;acq_date&#39;]

    # Cleanup for gui input
    if isinstance(params[&#39;input_data&#39;], (obspy.Stream, obspy.Trace)):
        pass
    elif &#39;}&#39; in str(params[&#39;input_data&#39;]): # This is how tkinter gui data comes in
        params[&#39;input_data&#39;] = params[&#39;input_data&#39;].as_posix().replace(&#39;{&#39;, &#39;&#39;)
        params[&#39;input_data&#39;] = params[&#39;input_data&#39;].split(&#39;}&#39;)

    # Make sure input_data is pointing to an actual file
    if isinstance(params[&#39;input_data&#39;], list):
        for i, d in enumerate(params[&#39;input_data&#39;]):
            params[&#39;input_data&#39;][i] = sprit_utils._checkifpath(str(d).strip(), sample_list=SAMPLE_LIST)
        dPath = params[&#39;input_data&#39;]
    elif isinstance(params[&#39;input_data&#39;], (obspy.Stream, obspy.Trace)):
        dPath = pathlib.Path() #params[&#39;input_data&#39;]
    elif isinstance(params[&#39;input_data&#39;], HVSRData):
        dPath = pathlib.Path(params[&#39;input_data&#39;][&#39;input_data&#39;])
        if not isinstance(params[&#39;input_data&#39;][&#39;stream&#39;], (obspy.Stream, obspy.Trace)):
            try:
                for k, v in params.items():
                    if isinstance(v, (obspy.Trace, obspy.Stream)):
                        params[&#39;input_data&#39;][&#39;stream&#39;] = v
                    elif pathlib.Path(str(v)).exists():
                        try:
                            params[&#39;input_data&#39;][&#39;stream&#39;] = obspy.read(v)
                        except Exception as e:
                            pass
            except:
                raise RuntimeError(f&#39;The params[&#34;input_data&#34;] parameter of fetch_data() was determined to be an HVSRData object, but no data in the &#34;stream&#34; attribute.&#39;)
        else:
            if verbose:
                print(&#39;\tThe params[&#34;input_data&#34;] argument is already an HVSRData obect.&#39;)
                print(&#34;\tChecking metadata then moving on.&#34;)
    else:
        dPath = sprit_utils._checkifpath(params[&#39;input_data&#39;], sample_list=SAMPLE_LIST)

    inst = params[&#39;instrument&#39;]

    # Need to put dates and times in right formats first
    if type(date) is datetime.datetime:
        doy = date.timetuple().tm_yday
        year = date.year
    elif type(date) is datetime.date:
        date = datetime.datetime.combine(date, datetime.time(hour=0, minute=0, second=0))
        doy = date.timetuple().tm_yday
        year = date.year
    elif type(date) is tuple:
        if date[0]&gt;366:
            raise ValueError(&#39;First item in date tuple must be day of year (0-366)&#39;, 0)
        elif date[1] &gt; datetime.datetime.now().year:
            raise ValueError(&#39;Second item in date tuple should be year, but given item is in the future&#39;, 0)
        else:
            doy = date[0]
            year = date[1]
    elif type(date) is str:
        if &#39;/&#39; in date:
            dateSplit = date.split(&#39;/&#39;)
        elif &#39;-&#39; in date:
            dateSplit = date.split(&#39;-&#39;)
        else:
            dateSplit = date

        if int(dateSplit[0]) &gt; 31:
            date = datetime.datetime(int(dateSplit[0]), int(dateSplit[1]), int(dateSplit[2]))
            doy = date.timetuple().tm_yday
            year = date.year
        elif int(dateSplit[0])&lt;=12 and int(dateSplit[2]) &gt; 31:
            warnings.warn(&#34;Preferred date format is &#39;yyyy-mm-dd&#39; or &#39;yyyy/mm/dd&#39;. Will attempt to parse date.&#34;)
            date = datetime.datetime(int(dateSplit[2]), int(dateSplit[0]), int(dateSplit[1]))
            doy = date.timetuple().tm_yday
            year = date.year
        else:
            warnings.warn(&#34;Preferred date format is &#39;yyyy-mm-dd&#39; or &#39;yyyy/mm/dd&#39;. Cannot parse date.&#34;)
    elif type(date) is int:
        doy = date
        year = datetime.datetime.today().year
    else:  
        date = datetime.datetime.now()
        doy = date.timetuple().tm_yday
        year = date.year
        warnings.warn(&#34;Did not recognize date, using year {} and day {}&#34;.format(year, doy))

    # Select which instrument we are reading from (requires different processes for each instrument)
    # Get any kwargs that are included in obspy.read
    obspyReadKwargs = {}
    for argName in inspect.getfullargspec(obspy.read)[0]:
        if argName in kwargs.keys():
            obspyReadKwargs[argName] = kwargs[argName]

    # Select how reading will be done
    if isinstance(params[&#39;input_data&#39;], obspy.Stream):
        rawDataIN = params[&#39;input_data&#39;].copy()
        tr = params[&#39;input_data&#39;][0]
        params[&#39;input_data&#39;] = &#39;_&#39;.join([tr.id, str(tr.stats.starttime)[:10],
                                       str(tr.stats.starttime)[11:19],
                                       str(tr.stats.endtime)[11:19]])
    elif isinstance(params[&#39;input_data&#39;], obspy.Trace):
        rawDataIN = obspy.Stream(params[&#39;input_data&#39;])
        tr = params[&#39;input_data&#39;]
        params[&#39;input_data&#39;] = &#39;_&#39;.join([tr.id, str(tr.stats.starttime)[:10], 
                                       str(tr.stats.starttime)[11:19], 
                                       str(tr.stats.endtime)[11:19]])
    elif isinstance(params[&#39;input_data&#39;], HVSRData):
        rawDataIN = params[&#39;input_data&#39;][&#39;stream&#39;]
    else:
        if   source == &#39;raw&#39;:
            try:
                if inst.lower() in trominoNameList:
                    params[&#39;instrument&#39;] = &#39;Tromino&#39;
                    params[&#39;params&#39;][&#39;instrument&#39;] = &#39;Tromino&#39;

                    trominoKwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(read_tromino_files).parameters.keys())}
                    paramDict = {k: v for k, v in params.items()}
                    trominoKwargs.update(paramDict)
                    rawDataIN = read_tromino_files(params, verbose=verbose, **trominoKwargs)

                    if &#39;site&#39; in rawDataIN[0].stats:
                        if hasattr(params, &#39;site&#39;):
                            params[&#39;site&#39;] = rawDataIN[0].stats.site
                        if hasattr(params, input_params):
                            params[&#39;input_params&#39;][&#39;site&#39;] = rawDataIN[0].stats.site
                else:
                    if inst.lower() not in raspShakeInstNameList:
                        print(f&#34;Unrecognized value instrument={inst}. Defaulting to raw raspberry shake data.&#34;)
                    rawDataIN = __read_RS_file_struct(dPath, source, year, doy, inv, params, verbose=verbose)

            except Exception as e:
                raise RuntimeError(f&#34;Data not fetched for {params[&#39;site&#39;]}. Check input parameters or the data file.\n\n{e}&#34;)
        elif source == &#39;stream&#39; or isinstance(params, (obspy.Stream, obspy.Trace)):
            rawDataIN = params[&#39;input_data&#39;].copy()
        elif source == &#39;dir&#39;:
            if inst.lower() in raspShakeInstNameList:
                rawDataIN = __read_RS_file_struct(dPath, source, year, doy, inv, params, verbose=verbose)
            else:
                obspyFiles = {}
                for obForm in OBSPY_FORMATS:
                    temp_file_glob = pathlib.Path(dPath.as_posix().lower()).glob(&#39;.&#39;+obForm.lower())
                    for f in temp_file_glob:
                        currParams = params
                        currParams[&#39;input_data&#39;] = f

                        curr_data = fetch_data(params, source=&#39;file&#39;, #all the same as input, except just reading the one file using the source=&#39;file&#39;
                                    data_export_path=data_export_path, data_export_format=data_export_format, detrend=detrend, detrend_options=detrend_options, update_metadata=update_metadata, verbose=verbose, **kwargs)
                        curr_data.merge()
                        obspyFiles[f.stem] = curr_data  #Add path object to dict, with filepath&#39;s stem as the site name
                return HVSRBatch(obspyFiles)
        elif source == &#39;file&#39; and str(params[&#39;input_data&#39;]).lower() not in SAMPLE_LIST:
            # Read the file specified by input_data
            # Automatically read tromino data
            if str(inst).lower() in trominoNameList or &#39;tromino&#39; in str(inst).lower() or &#39;trc&#39; in dPath.suffix:
                params[&#39;instrument&#39;] = &#39;Tromino&#39;
                params[&#39;params&#39;][&#39;instrument&#39;] = &#39;Tromino&#39;

                if &#39;blu&#39; in str(inst).lower():
                    params[&#39;instrument&#39;] = &#39;Tromino Blue&#39;
                    params[&#39;params&#39;][&#39;instrument&#39;] = &#39;Tromino Blue&#39;

                try:
                    trominoKwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(read_tromino_files).parameters.keys())}
                    paramDict = {k: v for k, v in params.items()}

                    if &#39;input_data&#39; in trominoKwargs:
                        del trominoKwargs[&#39;input_data&#39;]
                    if &#39;tromino_model&#39; not in trominoKwargs:
                        trominoKwargs[&#39;tromino_model&#39;] = params[&#39;instrument&#39;]
                    
                    rawDataIN = read_tromino_files(input_data=params, verbose=verbose, **trominoKwargs)

                    if &#39;site&#39; in rawDataIN[0].stats and params[&#39;site&#39;] == &#39;HVSRSite&#39;:
                        if hasattr(params, &#39;site&#39;):
                            params[&#39;site&#39;] = rawDataIN[0].stats.site
                        if hasattr(params, &#39;params&#39;):
                            params[&#39;params&#39;][&#39;site&#39;] = rawDataIN[0].stats.site

                    params[&#39;acq_date&#39;] = rawDataIN[0].stats.starttime.date
                    params[&#39;starttime&#39;] = rawDataIN[0].stats.starttime
                    params[&#39;endtime&#39;] = rawDataIN[0].stats.endtime

                except Exception:
                    try:
                        rawDataIN = obspy.read(dPath)
                    except Exception:
                        raise ValueError(f&#34;{dPath.suffix} is not a a filetype that can be read by SpRIT (via ObsPy)&#34;)
            else:
                if isinstance(dPath, list) or isinstance(dPath, tuple):
                    rawStreams = []
                    for datafile in dPath:
                        rawStream = obspy.read(datafile, **obspyReadKwargs)
                        rawStreams.append(rawStream) #These are actually streams, not traces
                    for i, stream in enumerate(rawStreams):
                        if i == 0:
                            rawDataIN = obspy.Stream(stream) #Just in case
                        else:
                            rawDataIN = rawDataIN + stream #This adds a stream/trace to the current stream object
                elif str(dPath)[:6].lower() == &#39;sample&#39;:
                    pass
                else:
                    rawDataIN = obspy.read(dPath, **obspyReadKwargs)#, starttime=obspy.core.UTCDateTime(params[&#39;starttime&#39;]), endttime=obspy.core.UTCDateTime(params[&#39;endtime&#39;]), nearest_sample =True)

        elif source == &#39;batch&#39; and str(params[&#39;input_data&#39;]).lower() not in SAMPLE_LIST:
            if verbose:
                print(&#39;\nFetching data (fetch_data())&#39;)
            batch_data_read_kwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(batch_data_read).parameters.keys())}
            params = batch_data_read(batch_data=params[&#39;input_data&#39;], verbose=verbose, **batch_data_read_kwargs)
            params = HVSRBatch(params, df_as_read=params.input_df)
            return params
        elif str(params[&#39;input_data&#39;]).lower() in SAMPLE_LIST or f&#34;sample{params[&#39;input_data&#39;].lower()}&#34; in SAMPLE_LIST:
            if source==&#39;batch&#39;:
                params[&#39;input_data&#39;] = SAMPLE_DATA_DIR.joinpath(&#39;Batch_SampleData.csv&#39;)
                params = batch_data_read(batch_data=params[&#39;input_data&#39;], batch_type=&#39;sample&#39;, verbose=verbose)
                params = HVSRBatch(params, df_as_read=params.input_df)
                return params
            elif source==&#39;dir&#39;:
                params[&#39;input_data&#39;] = SAMPLE_DATA_DIR.joinpath(&#39;Batch_SampleData.csv&#39;)
                params = batch_data_read(batch_data=params[&#39;input_data&#39;], batch_type=&#39;sample&#39;, verbose=verbose)
                params = HVSRBatch(params, df_as_read=params.input_df)
                return params
            elif source==&#39;file&#39;:
                params[&#39;input_data&#39;] = str(params[&#39;input_data&#39;]).lower()
                
                if params[&#39;input_data&#39;].lower() in sampleFileKeyMap.keys():
                    if params[&#39;input_data&#39;].lower() == &#39;sample&#39;:
                        params[&#39;input_data&#39;] = sampleFileKeyMap
                        
                    params[&#39;input_data&#39;] = sampleFileKeyMap[params[&#39;input_data&#39;].lower()]
                else:
                    params[&#39;input_data&#39;] = SAMPLE_DATA_DIR.joinpath(&#39;SampleHVSRSite1_AM.RAC84.00.2023.046_2023-02-15_1704-1734.MSEED&#39;)

                dPath = params[&#39;input_data&#39;]
                rawDataIN = obspy.read(dPath)#, starttime=obspy.core.UTCDateTime(params[&#39;starttime&#39;]), endttime=obspy.core.UTCDateTime(params[&#39;endtime&#39;]), nearest_sample =True)
                #import warnings
                #with warnings.catch_warnings():
                #    warnings.simplefilter(action=&#39;ignore&#39;, category=UserWarning)
                #    rawDataIN.attach_response(inv)
        else:
            # Last try if source cannot be read correctly
            try:
                rawDataIN = obspy.read(dPath)
            except:
                RuntimeError(f&#39;source={source} not recognized, and input_data cannot be read using obspy.read()&#39;)

    if verbose:
        print(&#39;\t Data as read in initially:&#39;)
        print(f&#39;\t  {len(rawDataIN)} trace(s) in Stream:&#39;)
        for i, trace in enumerate(rawDataIN):
            if i == 0:
                prevComponent = trace.stats.component
                print(f&#39;\t\t{prevComponent} Component&#39;)
                
            currComponent = trace.stats.component
            if prevComponent != currComponent:
                print(f&#34;\t\t{currComponent} Component&#34;)
            print(&#34;\t\t  &#34;, trace)
            prevComponent = trace.stats.component
        print()
        
    # Get metadata from the data itself, if not reading raw data
    try:
        # If the data already exists (not reading in raw from RS, for example), get the parameters from the data
        dataIN = rawDataIN.copy()
        if source != &#39;raw&#39;:           
            # Use metadata from file for updating: 
            # site
            site_default = inspect.signature(input_params).parameters[&#39;site&#39;].default
            updateMsg = []
            if params[&#39;site&#39;] == site_default and params[&#39;site&#39;] != dPath.stem:
                if isinstance(dPath, (list, tuple)):
                    dPath = dPath[0]
                params[&#39;site&#39;] = dPath.stem
                params[&#39;params&#39;][&#39;site&#39;] = dPath.stem
                if verbose:
                    updateMsg.append(f&#34;\tSite name updated to {params[&#39;site&#39;]}&#34;)
            
            # network
            net_default = inspect.signature(input_params).parameters[&#39;network&#39;].default
            if params[&#39;net&#39;] == net_default and net_default != dataIN[0].stats.network:
                params[&#39;net&#39;] = dataIN[0].stats.network
                params[&#39;params&#39;][&#39;net&#39;] = dataIN[0].stats.network
                if verbose:
                    updateMsg.append(f&#34;\tNetwork name updated to {params[&#39;net&#39;]}&#34;)

            # station
            sta_default = inspect.signature(input_params).parameters[&#39;station&#39;].default
            if str(params[&#39;sta&#39;]) == sta_default and str(params[&#39;sta&#39;]) != dataIN[0].stats.station:
                params[&#39;sta&#39;] = dataIN[0].stats.station
                params[&#39;station&#39;] = dataIN[0].stats.station
                params[&#39;params&#39;][&#39;sta&#39;] = dataIN[0].stats.station
                params[&#39;params&#39;][&#39;station&#39;] = dataIN[0].stats.station
                if verbose:
                    updateMsg.append(f&#34;\tStation name updated to {params[&#39;sta&#39;]}&#34;)

            # location
            loc_default = inspect.signature(input_params).parameters[&#39;location&#39;].default
            if params[&#39;location&#39;] == loc_default and params[&#39;location&#39;] != dataIN[0].stats.location:
                params[&#39;location&#39;] = dataIN[0].stats.location
                params[&#39;params&#39;][&#39;location&#39;] = dataIN[0].stats.location
                if verbose:
                    updateMsg.append(f&#34;\tLocation updated to {params[&#39;location&#39;]}&#34;)

            # channels
            channelList = []
            cha_default = inspect.signature(input_params).parameters[&#39;channels&#39;].default
            if str(params[&#39;cha&#39;]) == cha_default:
                for tr in dataIN:
                    if tr.stats.channel not in channelList:
                        channelList.append(tr.stats.channel)
                        channelList.sort(reverse=True) #Just so z is first, just in case
                if set(params[&#39;cha&#39;]) != set(channelList):
                    params[&#39;cha&#39;] = channelList
                    params[&#39;params&#39;][&#39;cha&#39;] = channelList
                    if verbose:
                        updateMsg.append(f&#34;\tChannels updated to {params[&#39;cha&#39;]}&#34;)

            # Acquisition date
            # acqdate_default = inspect.signature(input_params).parameters[&#39;acq_date&#39;].default
            acqdate_default = str(datetime.datetime.now().date())

            if str(params[&#39;acq_date&#39;]) == acqdate_default and params[&#39;acq_date&#39;] != dataIN[0].stats.starttime.date:
                params[&#39;acq_date&#39;] = dataIN[0].stats.starttime.date
                if verbose:
                    updateMsg.append(f&#34;\tAcquisition Date updated to {params[&#39;acq_date&#39;]}&#34;)

            # starttime
            today_Starttime = obspy.UTCDateTime(datetime.datetime(year=datetime.date.today().year, month=datetime.date.today().month,
                                                                 day = datetime.date.today().day,
                                                                hour=0, minute=0, second=0, microsecond=0))
            maxStarttime = datetime.datetime(year=params[&#39;acq_date&#39;].year, month=params[&#39;acq_date&#39;].month, day=params[&#39;acq_date&#39;].day, 
                                             hour=0, minute=0, second=0, microsecond=0, tzinfo=datetime.timezone.utc)

            stime_default = obspy.UTCDateTime(NOWTIME)#.year, NOWTIME.month, NOWTIME.day, 0, 0, 0, 0)
            if str(params[&#39;starttime&#39;]) == str(stime_default):
                for tr in dataIN.merge():
                    currTime = datetime.datetime(year=tr.stats.starttime.year, month=tr.stats.starttime.month, day=tr.stats.starttime.day,
                                        hour=tr.stats.starttime.hour, minute=tr.stats.starttime.minute, 
                                       second=tr.stats.starttime.second, microsecond=tr.stats.starttime.microsecond, tzinfo=datetime.timezone.utc)
                    if currTime &gt; maxStarttime:
                        maxStarttime = currTime

                newStarttime = obspy.UTCDateTime(datetime.datetime(year=params[&#39;acq_date&#39;].year, month=params[&#39;acq_date&#39;].month,
                                                                 day = params[&#39;acq_date&#39;].day,
                                                                hour=maxStarttime.hour, minute=maxStarttime.minute, 
                                                                second=maxStarttime.second, microsecond=maxStarttime.microsecond))
                if params[&#39;starttime&#39;] != newStarttime:
                    params[&#39;starttime&#39;] = newStarttime
                    params[&#39;params&#39;][&#39;starttime&#39;] = newStarttime
                    if verbose:
                        updateMsg.append(f&#34;\tStarttime updated to {params[&#39;starttime&#39;]}&#34;)

            # endttime
            today_Endtime = obspy.UTCDateTime(datetime.datetime(year=datetime.date.today().year, month=datetime.date.today().month,
                                                                 day = datetime.date.today().day,
                                                                hour=23, minute=59, second=59, microsecond=999999))
            tomorrow_Endtime = today_Endtime + (60*60*24)
            minEndtime = datetime.datetime.now(tz=datetime.timezone.utc)#.replace(tzinfo=datetime.timezone.utc)#(hour=23, minute=59, second=59, microsecond=999999)

            etime_default = obspy.UTCDateTime(NOWTIME.year, NOWTIME.month, NOWTIME.day, 23, 59, 59, 999999)
            if str(params[&#39;endtime&#39;]) == etime_default or str(params[&#39;endtime&#39;]) == tomorrow_Endtime:
                for tr in dataIN.merge():
                    currTime = datetime.datetime(year=tr.stats.endtime.year, month=tr.stats.endtime.month, day=tr.stats.endtime.day,
                                        hour=tr.stats.endtime.hour, minute=tr.stats.endtime.minute, 
                                       second=tr.stats.endtime.second, microsecond=tr.stats.endtime.microsecond, tzinfo=datetime.timezone.utc)
                    if currTime &lt; minEndtime:
                        minEndtime = currTime
                newEndtime = obspy.UTCDateTime(datetime.datetime(year=minEndtime.year, month=minEndtime.month,
                                                                 day = minEndtime.day,
                                                                hour=minEndtime.hour, minute=minEndtime.minute, 
                                                                second=minEndtime.second, microsecond=minEndtime.microsecond, tzinfo=datetime.timezone.utc))
                
                if params[&#39;endtime&#39;] != newEndtime:
                    params[&#39;endtime&#39;] = newEndtime
                    params[&#39;params&#39;][&#39;endtime&#39;] = newEndtime
                    if verbose:
                        updateMsg.append(f&#34;\tEndtime updated to {params[&#39;endtime&#39;]}&#34;)

            # HVSR_ID (derived)
            project = params[&#39;project&#39;]
            if project is None:
                proj_id = &#39;&#39;
            else:
                proj_id = str(project)+&#39;-&#39;
            
            # Update HVSR_ID with new information
            params[&#39;hvsr_id&#39;] = f&#34;{proj_id}{params[&#39;acq_date&#39;].strftime(&#39;%Y%m%d&#39;)}-{params[&#39;starttime&#39;].strftime(&#39;%H%M&#39;)}-{params[&#39;station&#39;]}&#34;
            params[&#39;params&#39;][&#39;hvsr_id&#39;] = f&#34;{proj_id}{params[&#39;acq_date&#39;].strftime(&#39;%Y%m%d&#39;)}-{params[&#39;starttime&#39;].strftime(&#39;%H%M&#39;)}-{params[&#39;station&#39;]}&#34;

            if verbose and len(updateMsg) &gt; 0:
                updateMsg.insert(0, &#39;The following parameters have been updated directly from the data:&#39;)
                for msgLine in updateMsg:
                    print(&#39;\t&#39;, msgLine)
                print()

            # Clean up
            dataIN = dataIN.split()
            dataIN = dataIN.trim(starttime=params[&#39;starttime&#39;], endtime=params[&#39;endtime&#39;])
            dataIN.merge()

    except Exception as e:
        raise RuntimeError(f&#39;Data as read by obspy does not contain the proper metadata. \n{e}.\nCheck your input parameters or the data file.&#39;)

    # Latitude, Longitude, Elevation
    # Maybe make this more comprehensive, like for all input_params
    if hasattr(dataIN[0].stats, &#39;latitude&#39;):
        params[&#39;latitude&#39;] = params[&#39;params&#39;][&#39;latitude&#39;] = dataIN[0].stats[&#39;latitude&#39;]
    if hasattr(dataIN[0].stats, &#39;longitude&#39;):
        params[&#39;longitude&#39;] = params[&#39;params&#39;][&#39;longitude&#39;] = dataIN[0].stats[&#39;longitude&#39;]
    if hasattr(dataIN[0].stats, &#39;elevation&#39;):
        params[&#39;elevation&#39;]  = params[&#39;params&#39;][&#39;elevation&#39;] = dataIN[0].stats[&#39;elevation&#39;]
    if hasattr(dataIN[0].stats, &#39;elev_unit&#39;):
        params[&#39;elev_unit&#39;] = params[&#39;params&#39;][&#39;elev_unit&#39;] = dataIN[0].stats[&#39;elev_unit&#39;]
    if hasattr(dataIN[0].stats, &#39;input_crs&#39;):
        params[&#39;input_crs&#39;] = params[&#39;params&#39;][&#39;input_crs&#39;] = dataIN[0].stats[&#39;input_crs&#39;]

    # Get and update metadata after updating data from source
    params = get_metadata(params, update_metadata=update_metadata, source=source)
    inv = params[&#39;inv&#39;]

    # Trim and save data as specified
    if data_export_path == &#39;None&#39;:
        data_export_path = None
    
    if not data_export_path:
        pass
    else:
        if isinstance(params, HVSRBatch):
            pass
        else:
            dataIN = _trim_data(input=params, stream=dataIN, export_dir=data_export_path, source=source, data_export_format=data_export_format)

    # Split data if masked array (if there are gaps)...detrending cannot be done without
    for tr in dataIN:
        if isinstance(tr.data, np.ma.masked_array):
            dataIN = dataIN.split()
            #Splits entire stream if any trace is masked_array
            break

    # Detrend data
    if isinstance(params, HVSRBatch):
        pass
    else:
        dataIN = __detrend_data(input=dataIN, detrend=detrend, detrend_options=detrend_options, verbose=verbose, source=source)

    # Filter data
    if isinstance(params, HVSRBatch):
        pass
    elif filter_type is None:
        pass
    else:
        dataIN.filter_type(type=filter_type, **filter_options)

    # Remerge data
    dataIN = dataIN.merge(method=1)

    # Plot the input stream?
    if plot_input_stream:
        if plot_engine.lower() in [&#39;plotly&#39;, &#39;plty&#39;, &#39;p&#39;]:
            if &#39;spectrogram_component&#39; in kwargs.keys():
                specComp = kwargs[&#39;spectrogram_component&#39;]
            else:
                specComp = &#39;Z&#39;
            params[&#39;Input_Plot&#39;] = sprit_plot.plot_input_stream(hv_data=params, stream=dataIN, spectrogram_component=specComp, show_plot=show_plot, return_fig=True)
        elif plot_engine.lower() in [&#39;obspy&#39;, &#39;ospby&#39;, &#39;osbpy&#39;, &#39;opsby&#39;, &#39;opspy&#39;, &#39;o&#39;]:
            params[&#39;Input_Plot&#39;] = dataIN.plot(method=&#39;full&#39;, linewidth=0.25, handle=True, show=False)
            if show_plot:
                plt.show()
            else:
                plt.close()
        else:
            try:
                params[&#39;Input_Plot&#39;] = sprit_plot._plot_input_stream_mpl(stream=dataIN, hv_data=params, component=&#39;Z&#39;, stack_type=&#39;linear&#39;, detrend=&#39;mean&#39;, dbscale=True, fill_gaps=None, ylimstd=3, return_fig=True, fig=None, ax=None, show_plot=False)
                
                if show_plot:
                    plt.show()
                else:
                    plt.close()                    
            except Exception as e:
                print(f&#39;Error with default plotting method: {e}.\n Falling back to internal obspy plotting method&#39;)
                params[&#39;Input_Plot&#39;] = dataIN.plot(method=&#39;full&#39;, linewidth=0.25, handle=True, show=False)
                if show_plot:
                    plt.show()
                else:
                    plt.close()
    else:
        params[&#39;Input_Plot&#39;] = None

    # Sort channels (make sure Z is first, makes things easier later)
    if isinstance(params, HVSRBatch):
        pass
    else:
        dataIN = _sort_channels(input=dataIN, source=source, verbose=verbose)

    # Clean up the ends of the data unless explicitly specified to do otherwise (this is a kwarg, not a parameter)
    if &#39;clean_ends&#39; not in kwargs.keys():
        clean_ends = True 
    else:
        clean_ends = kwargs[&#39;clean_ends&#39;]

    if clean_ends:
        maxStarttime = datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(days=36500)  # 100 years ago
        minEndtime = datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(days=36500)  # 100 years from now

        for tr in dataIN:
            currStarttime = datetime.datetime(year=tr.stats.starttime.year, month=tr.stats.starttime.month, day=tr.stats.starttime.day, 
                                              hour=tr.stats.starttime.hour, minute=tr.stats.starttime.minute, 
                                              second=tr.stats.starttime.second, microsecond=tr.stats.starttime.microsecond, tzinfo=datetime.timezone.utc)
            if currStarttime &gt; maxStarttime:
                maxStarttime = currStarttime

            currEndtime = datetime.datetime(year=tr.stats.endtime.year, month=tr.stats.endtime.month, day=tr.stats.endtime.day, 
                                         hour=tr.stats.endtime.hour, minute=tr.stats.endtime.minute, 
                                         second=tr.stats.endtime.second, microsecond=tr.stats.endtime.microsecond, tzinfo=datetime.timezone.utc)

            if currEndtime &lt; minEndtime:
                minEndtime = currEndtime

        maxStarttime = obspy.UTCDateTime(maxStarttime)
        minEndtime = obspy.UTCDateTime(minEndtime)
        dataIN = dataIN.split()
        for tr in dataIN:
            tr.trim(starttime=maxStarttime, endtime=minEndtime)
            pass
        dataIN.merge()
    
    params[&#39;batch&#39;] = False  # Set False by default, will get corrected later if batch
    params[&#39;input_stream&#39;] = dataIN.copy()  # Original stream as read
    params[&#39;stream&#39;] = dataIN.copy()  # Stream that may be modified later
    
    if &#39;processing_parameters&#39; not in params.keys():
        params[&#39;processing_parameters&#39;] = {}
    params[&#39;processing_parameters&#39;][&#39;fetch_data&#39;] = {}
    exclude_params_list = [&#39;params&#39;]
    for key, value in orig_args.items():
        if key not in exclude_params_list:
            params[&#39;processing_parameters&#39;][&#39;fetch_data&#39;][key] = value

    # Attach response data to stream and get paz (for PPSD later)
    # Check if response can be attached
    try:
        responseMatch = {}
        for trace in params[&#39;stream&#39;]:
            k = trace.stats.component
            
            # Check if station, channel, location, and timing match
            responseMatch[k] = False  # Default to false until proven otherwise

            for sta in params[&#39;inv&#39;].networks[0].stations:  # Assumes only one network per inst
                hasCha = False  # all default to false until proven otherwise
                hasLoc = False
                hasSta = False
                isStarted = False
                notEnded = False
                
                # Check station
                if sta.code == params[&#39;stream&#39;][0].stats.station:
                    hasSta = True
                else:
                    continue

                # Check Channel
                for cha in sta:
                    if cha.code == trace.stats.channel:
                        hasCha = True

                    # Check location
                    if cha.location_code == trace.stats.location:
                        hasLoc = True


                    # Check time
                    if (cha.start_date is None or cha.start_date &lt;= tr.stats.starttime):
                        isStarted = True

                    if (cha.end_date is None or cha.end_date &gt;= tr.stats.endtime):
                        notEnded = True

                    
                    if all([hasSta, hasCha, hasLoc, isStarted, notEnded]):
                        responseMatch[k] = True

            if responseMatch[k] is not True:
                responseMatch[k] = {&#39;Station&#39;:  (hasSta, [sta.code for sta in params[&#39;inv&#39;].networks[0].stations]),
                                    &#39;Channel&#39;:  (hasCha, [cha.code for cha in sta for sta in params[&#39;inv&#39;].networks[0].stations]), 
                                    &#39;Location&#39;: (hasLoc, [cha.location_code for cha in sta for sta in params[&#39;inv&#39;].networks[0].stations]), 
                                    &#39;Starttime&#39;:(isStarted, [cha.start_date for cha in sta for sta in params[&#39;inv&#39;].networks[0].stations]), 
                                    &#39;Endtime&#39;:  (notEnded,  [cha.end_date for cha in sta for sta in params[&#39;inv&#39;].networks[0].stations])}

        metadataMatchError = False
        for comp, matchItems in responseMatch.items():
            if matchItems is not True:
                metadataMatchError = True
                errorMsg = &#39;The following items in your data need to be matched in the instrument response/metadata:&#39;
                for matchType, match in matchItems.items():
                    if match[0] is False:
                        errorMsg = errorMsg + f&#34;\n\t{matchType} does not match {match[1]} correctly for component {comp}: {params[&#39;stream&#39;].select(component=comp)[0].stats[matchType.lower()]}&#34;

        if metadataMatchError:
            if verbose:
                print(errorMsg)
            raise ValueError(&#39;Instrument Response/Metadata does not match input data and cannot be used!!\n&#39;+errorMsg)
        else:
            params[&#39;stream&#39;].attach_response(params[&#39;inv&#39;])
            for tr in params[&#39;stream&#39;]:
                cmpnt = tr.stats.component

                params[&#39;paz&#39;][cmpnt][&#39;poles&#39;] = tr.stats.response.get_paz().poles
                params[&#39;paz&#39;][cmpnt][&#39;zeros&#39;] = tr.stats.response.get_paz().zeros
                params[&#39;paz&#39;][cmpnt][&#39;sensitivity&#39;] = tr.stats.response.get_paz().stage_gain
                params[&#39;paz&#39;][cmpnt][&#39;gain&#39;] = tr.stats.response.get_paz().normalization_factor
    except Exception as e:
        if &#39;obspy_ppsds&#39; in kwargs and kwargs[&#39;obspy_ppsds&#39;]:
            errMsg = &#34;Metadata missing, incomplete, or incorrect. Instrument response cannot be removed.&#34;
            errMsg += &#34;if metadata cannot be matched, use obspy_ppsds=False to perform analysis on raw data (without instrument response removed)&#34;
            raise ValueError(errMsg)
        else:
            if verbose:
                print(&#34;\tMetadata/instrument response does not match data.&#34;)
                print(&#34;\t  Raw data (without the instrument response removed) will be used for processing.&#34;)
    
    params[&#39;processing_status&#39;][&#39;fetch_data_status&#39;] = True
    if verbose and not isinstance(params, HVSRBatch):
        print(&#39;\n&#39;)
        dataINStr = dataIN.__str__().split(&#39;\n&#39;)
        for line in dataINStr:
            print(&#39;\t\t&#39;, line)
    
    params = sprit_utils._check_processing_status(params, start_time=start_time, func_name=inspect.stack()[0][3], verbose=verbose)

    return params</code></pre>
</details>
<div class="desc"><p>Fetch ambient seismic data from a source to read into obspy stream. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>params
: dict</dt>
<dt>Dictionary containing all the necessary params to get data.</dt>
<dt>Parameters defined using input_params() function.</dt>
<dt _batch_="'batch'" _dir_="'dir'," _file_="'file'," _raw_="'raw',">source
: str,</dt>
<dt>String indicating where/how data file was created. For example, if raw data, will need to find correct channels.</dt>
<dt>'raw' finds raspberry shake data, from raw output copied using scp directly from Raspberry Shake, either in folder or subfolders;</dt>
<dt>'dir' is used if the day's 3 component files (currently Raspberry Shake supported only) are all 3 contained in a directory by themselves.</dt>
<dt>'file' is used if the params['input_data'] specified in input_params() is the direct filepath to a single file to be read directly into an obspy stream.</dt>
<dt>'batch' is used to read a list or specified set of seismic files.</dt>
<dt>Most commonly, a csv file can be read in with all the parameters. Each row in the csv is a separate file. Columns can be arranged by parameter.</dt>
<dt><strong><code>data_export_path</code></strong> :&ensp;<code>None</code> or <code>str</code> or <code>pathlib obj</code>, default=<code>None</code></dt>
<dd>If None (or False), data is not trimmed in this function.
Otherwise, this is the directory to save trimmed and exported data.</dd>
<dt><strong><code>data_export_format</code></strong> :&ensp;<code>str='mseed'</code></dt>
<dd>If data_export_path is not None, this is the format in which to save the data</dd>
<dt><strong><code>detrend</code></strong> :&ensp;<code>str</code> or <code>bool</code>, default=<code>'spline'</code></dt>
<dd>If False, data is not detrended.
Otherwise, this should be a string accepted by the type parameter of the obspy.core.trace.Trace.detrend method: <a href="https://docs.obspy.org/packages/autogen/obspy.core.trace.Trace.detrend.html">https://docs.obspy.org/packages/autogen/obspy.core.trace.Trace.detrend.html</a></dd>
<dt><strong><code>detrend_options</code></strong> :&ensp;<code>int</code>, default=<code>2</code></dt>
<dd>If detrend parameter is 'spline' or 'polynomial', this is passed directly to the order parameter of obspy.core.trace.Trace.detrend method.</dd>
<dt><strong><code>filter_type</code></strong> :&ensp;<code>None, str</code></dt>
<dd>Type of filter to use on raw data.
This should either be None or any of {'bandpass', 'bandstop', 'lowpass', 'highpass', 'lowpass_cheby_2', 'lowpass_fir', 'remez_fir'}.
This passes <code>filter_type</code> to the <code>type</code> parameter and <code>**filter_options</code> to the <code>**options</code> parameter of the obspy.Stream filter() method.
See here for more information: <a href="https://docs.obspy.org/packages/autogen/obspy.core.stream.Stream.filter.html">https://docs.obspy.org/packages/autogen/obspy.core.stream.Stream.filter.html</a>
If None, no filtering is done on the input seismic data.</dd>
<dt><strong><code>filter_options</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary that will be unpacked into the <code>**options</code> parameter of the filter() method of the obspy.Stream class.
This should fit the parameters of whichever filter type is specifed by filter_type.
Example options for the 'bandpass' filter_type might be: <code>filter_options={'freqmin': 0.1, 'freqmax':50, 'df':100, 'corners':4, 'zerophase':True}</code>.
See here for more information: <a href="https://docs.obspy.org/packages/autogen/obspy.core.stream.Stream.filter.html">https://docs.obspy.org/packages/autogen/obspy.core.stream.Stream.filter.html</a></dd>
<dt><strong><code>update_metadata</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to update the metadata file, used primarily with Raspberry Shake data which uses a generic inventory file.</dd>
<dt><strong><code>plot_input_stream</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to plot the raw input stream. This plot includes a spectrogram (Z component) and the raw (with decimation for speed) plots of each component signal.</dd>
<dt><strong><code>plot_engine</code></strong> :&ensp;<code>str</code>, default=<code>'matplotlib'</code></dt>
<dd>Which plotting library/engine to use for plotting the Input stream. Options are 'matplotlib', 'plotly', or 'obspy' (not case sensitive).</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to print outputs and inputs to the terminal</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keywords arguments, primarily for 'batch' and 'dir' sources</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code> or <code><a title="sprit.HVSRBatch" href="#sprit.HVSRBatch">HVSRBatch</a> object</code></dt>
<dd>Same as params parameter, but with an additional "stream" attribute with an obspy data stream with 3 traces: Z (vertical), N (North-south), and E (East-west)</dd>
</dl></div>
</dd>
<dt id="sprit.generate_psds"><code class="name flex">
<span>def <span class="ident">generate_psds</span></span>(<span>hvsr_data,<br>window_length=30.0,<br>overlap_pct=0.5,<br>window_type='hann',<br>window_length_method='length',<br>remove_response=False,<br>skip_on_gaps=True,<br>num_freq_bins=512,<br>hvsr_band=[0.5, 40],<br>obspy_ppsds=False,<br>azimuthal_psds=False,<br>verbose=False,<br>plot_psds=False,<br>**obspy_ppsd_kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_psds(hvsr_data, window_length=30.0, overlap_pct=0.5, window_type=&#39;hann&#39;, window_length_method=&#39;length&#39;, 
                  remove_response=False, skip_on_gaps=True, num_freq_bins=512, hvsr_band=DEFAULT_BAND,
                  obspy_ppsds=False, azimuthal_psds=False, verbose=False, plot_psds=False, **obspy_ppsd_kwargs):
    
    &#34;&#34;&#34;Calculate Power Spectral Density (PSD) curves for each channel.
        Uses the [scipy.signal.welch()](https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.welch.html) function 
        to generate PSDs by default, or can use Obspy&#39;s PPSD class.
        Info on Obspy PPSD creation here (if obspy_ppsds=True): https://docs.obspy.org/packages/autogen/obspy.signal.spectral_estimation.PPSD.html
        
        Parameters
        ----------
        hvsr_data : dict, HVSRData object, or HVSRBatch object
            Data object containing all the parameters and other data of interest (stream and paz, for example)
        window_length : float
            Length of the window, in seconds, to use for each PSD calculation. Defaults to 30.0.
        overlap_pct : float
            Percentage (should be 0-1) for overlapping each window used for PSD calculation. Defaults to 0.5.
        window_type : str
            Type of window to use. This is passed to the window parameter of the scipy.signal.welch function
        window_length_method : str = {&#39;length&#39;, &#39;number&#39;}
            Whether the window length should be a measure of length in seconds or number of windows. 
            If number of windows uses integer value.
        remove_response : bool, default=False
            Whether to remove the instrument response from the data traces before calculating PSD data.
            If True, the appropriate metadata (i.e., obspy.Inventory object) must be attached to the stream and should be stored in the &#39;inv&#39; attribute of hvsr_data.
        skip_on_gaps : bool, default=True
            Whether to skip data gaps when processing windows. 
            This is passed to the skip_on_gaps parameter of the Obspy PPSD class.
        num_freq_bins : int, default=512
            Number of frequency bins to use. When using the default (i.e., scipy.signal.welch) PSD function, the frequency bins are created manually for processing.
        obspy_ppsds : bool, default=False
            Whether to use the Obspy PPSD class.
        azimuthal_psds : bool, default=False
            Whether to generate PPSDs for azimuthal data
        verbose : bool, default=True
            Whether to print inputs and results to terminal
        plot_psds : bool, default=False
            Whether to show a plot of the psds here.
        **obspy_ppsd_kwargs : dict
            Dictionary with keyword arguments that are passed directly to obspy.signal.PPSD.
            If the following keywords are not specified, their defaults are amended in this function from the obspy defaults for its PPSD function. Specifically:
                - ppsd_length defaults to 30 (seconds) here instead of 3600
                - skip_on_gaps defaults to True instead of False
                - period_step_octaves defaults to 0.03125 instead of 0.125

        Returns
        -------
            psds : HVSRData object
                Dictionary containing entries with psds for each channel
                
        See Also
        --------
        [scipy.signal.welch](https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.welch.html)
        [obspy.signal.spectral_estimation.PPSD](https://docs.obspy.org/packages/autogen/obspy.signal.spectral_estimation.PPSD.html)
        
    &#34;&#34;&#34;
    
    # First, divide up for batch or not
    orig_args = locals().copy()  # Get the initial arguments
    start_time = datetime.datetime.now()

    obspy_ppsd_kwargs_sprit_defaults = obspy_ppsd_kwargs.copy()
    # Set defaults here that are different than obspy defaults
    if &#39;ppsd_length&#39; not in obspy_ppsd_kwargs.keys():
        obspy_ppsd_kwargs_sprit_defaults[&#39;ppsd_length&#39;] = 30.0      
    if &#39;period_step_octaves&#39; not in obspy_ppsd_kwargs.keys():
        obspy_ppsd_kwargs_sprit_defaults[&#39;period_step_octaves&#39;] = 0.03125
    if &#39;period_limits&#39; not in obspy_ppsd_kwargs.keys():
        if &#39;hvsr_band&#39; in hvsr_data.keys():
            obspy_ppsd_kwargs_sprit_defaults[&#39;period_limits&#39;] = [1/hvsr_data[&#39;hvsr_band&#39;][1], 1/hvsr_data[&#39;hvsr_band&#39;][0]]
        elif &#39;input_params&#39; in hvsr_data.keys() and &#39;hvsr_band&#39; in hvsr_data[&#39;input_params&#39;].keys():
            obspy_ppsd_kwargs_sprit_defaults[&#39;period_limits&#39;] = [1/hvsr_data[&#39;input_params&#39;][&#39;hvsr_band&#39;][1], 1/hvsr_data[&#39;input_params&#39;][&#39;hvsr_band&#39;][0]]
        else:
            obspy_ppsd_kwargs_sprit_defaults[&#39;period_limits&#39;] = [1/hvsr_band[1], 1/hvsr_band[0]]
    else:
        if verbose:
            print(f&#34;\t\tUpdating hvsr_band to band specified by period_limits={obspy_ppsd_kwargs[&#39;period_limits&#39;]}&#34;)
        
        if &#39;hvsr_band&#39; in hvsr_data.keys():
            if obspy_ppsd_kwargs[&#39;period_limits&#39;] is None:
                obspy_ppsd_kwargs[&#39;period_limits&#39;] = np.round([1/hvsr_data[&#39;hvsr_band&#39;][1], 1/hvsr_data[&#39;hvsr_band&#39;][0]], 3).tolist()
            else:
                hvsr_data[&#39;hvsr_band&#39;] = np.round([1/obspy_ppsd_kwargs[&#39;period_limits&#39;][1], 1/obspy_ppsd_kwargs[&#39;period_limits&#39;][0]], 2).tolist()
        
        if &#39;input_params&#39; in hvsr_data.keys() and &#39;hvsr_band&#39; in hvsr_data[&#39;input_params&#39;].keys():
            hvsr_data[&#39;input_params&#39;][&#39;hvsr_band&#39;] = np.round([1/obspy_ppsd_kwargs[&#39;period_limits&#39;][1], 1/obspy_ppsd_kwargs[&#39;period_limits&#39;][0]], 2).tolist()
            
        
    # Get Probablistic power spectral densities (PPSDs)
    # Get default args for function
    obspy_ppsd_kwargs = sprit_utils._get_default_args(PPSD)
    obspy_ppsd_kwargs.update(obspy_ppsd_kwargs_sprit_defaults)  # Update with sprit defaults, or user input
    orig_args[&#39;obspy_ppsd_kwargs&#39;] = obspy_ppsd_kwargs

    # Update with processing parameters specified previously in input_params, if applicable
    if &#39;processing_parameters&#39; in hvsr_data.keys():
        if &#39;generate_psds&#39; in hvsr_data[&#39;processing_parameters&#39;].keys():
            defaultVDict = dict(zip(inspect.getfullargspec(generate_psds).args[1:], 
                                    inspect.getfullargspec(generate_psds).defaults))
            defaultVDict[&#39;obspy_ppsd_kwargs&#39;] = obspy_ppsd_kwargs
            update_msg = []
            for k, v in hvsr_data[&#39;processing_parameters&#39;][&#39;generate_psds&#39;].items():
                # Manual input to function overrides the imported parameter values
                if not isinstance(v, (HVSRData, HVSRBatch)) and (k in orig_args.keys()) and (orig_args[k] == defaultVDict[k]):
                    update_msg.append(f&#39;\t\t{k} = {v} (previously {orig_args[k]})&#39;)
                    orig_args[k] = v

    azimuthal_psds = orig_args[&#39;azimuthal_psds&#39;]
    verbose = orig_args[&#39;verbose&#39;]
    obspy_ppsd_kwargs = orig_args[&#39;obspy_ppsd_kwargs&#39;]

    # if (verbose and isinstance(hvsr_data, HVSRBatch)) or (verbose and not hvsr_data[&#39;batch&#39;]):
    if verbose:
        print(&#39;\nGenerating Probabilistic Power Spectral Densities (generate_psds())&#39;)
        print(&#39;\tUsing the following parameters:&#39;)
        for key, value in orig_args.items():
            if key == &#39;hvsr_data&#39;:
                pass
            else:
                print(&#39;\t  {}={}&#39;.format(key, value))
        print()

        if &#39;processing_parameters&#39; in hvsr_data.keys() and &#39;generate_psds&#39; in hvsr_data[&#39;processing_parameters&#39;].keys():
            if update_msg != []:
                update_msg.insert(0, &#39;\tThe following parameters were updated using the processing_parameters attribute:&#39;)
                for msg_line in update_msg:
                    print(msg_line)
                print()

    if isinstance(hvsr_data, HVSRBatch):
        # If running batch, we&#39;ll loop through each one
        for site_name in hvsr_data.keys():
            args = orig_args.copy()  # Make a copy so we don&#39;t accidentally overwrite
            individual_params = hvsr_data[site_name]  # Get what would normally be the &#34;hvsr_data&#34; variable for each site
            args[&#39;hvsr_data&#39;] = individual_params  # reset the hvsr_data parameter we originally read in to an individual site hvsr_data

            if hvsr_data[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;]:
                try:
                    hvsr_data[site_name] = __generate_ppsds_batch(**args) #Call another function, that lets us run this function again
                except:
                    hvsr_data[site_name][&#39;processing_status&#39;][&#39;generate_psds_status&#39;]=False
                    hvsr_data[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;] = False                     
            else:
                hvsr_data[site_name][&#39;processing_status&#39;][&#39;generate_psds_status&#39;]=False
                hvsr_data[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;] = False                
            
            try:
                sprit_tkinter_ui.update_progress_bars(prog_percent=5)
            except Exception as e:
                pass
                #print(e)
        return hvsr_data
    
    def _get_obspy_ppsds(hvsr_data,**obspy_ppsd_kwargs):
        paz = hvsr_data[&#39;paz&#39;]
        stream = hvsr_data[&#39;stream&#39;]

        # Get ppsds of e component
        eStream = stream.select(component=&#39;E&#39;)
        estats = eStream.traces[0].stats
        ppsdE = PPSD(estats, paz[&#39;E&#39;],  **obspy_ppsd_kwargs)
        ppsdE.add(eStream)

        # Get ppsds of n component
        nStream = stream.select(component=&#39;N&#39;)
        nstats = nStream.traces[0].stats
        ppsdN = PPSD(nstats, paz[&#39;N&#39;], **obspy_ppsd_kwargs)
        ppsdN.add(nStream)

        # Get ppsds of z component
        zStream = stream.select(component=&#39;Z&#39;)
        zstats = zStream.traces[0].stats
        ppsdZ = PPSD(zstats, paz[&#39;Z&#39;], **obspy_ppsd_kwargs)
        ppsdZ.add(zStream)

        # Get ppsds of R components (azimuthal data)
        has_az = False
        ppsds = {&#39;Z&#39;:ppsdZ, &#39;E&#39;:ppsdE, &#39;N&#39;:ppsdN}
        rStream = stream.select(component=&#39;R&#39;)
        for curr_trace in stream:
            if &#39;R&#39; in curr_trace.stats.channel:
                curr_stats = curr_trace.stats
                ppsd_curr = PPSD(curr_stats, paz[&#39;E&#39;], **obspy_ppsd_kwargs)        
                has_az = True
                ppsdName = curr_trace.stats.location
                ppsd_curr.add(rStream)
                ppsds[ppsdName] = ppsd_curr
        
        # Add to the input dictionary, so that some items can be manipulated later on, and original can be saved
        hvsr_data[&#39;ppsds_obspy&#39;] = ppsds
        hvsr_data[&#39;psds&#39;] = {}
        anyKey = list(hvsr_data[&#39;ppsds_obspy&#39;].keys())[0]
        
        # Get ppsd class members
        members = [mems for mems in dir(hvsr_data[&#39;ppsds_obspy&#39;][anyKey]) if not callable(mems) and not mems.startswith(&#34;_&#34;)]
        for k in ppsds.keys():
            hvsr_data[&#39;psds&#39;][k] = {}
        
        #Get lists/arrays so we can manipulate data later and copy everything over to main &#39;psds&#39; subdictionary (convert lists to np.arrays for consistency)
        listList = [&#39;times_data&#39;, &#39;times_gaps&#39;, &#39;times_processed&#39;,&#39;current_times_used&#39;, &#39;psd_values&#39;] #Things that need to be converted to np.array first, for consistency
        timeKeys= [&#39;times_processed&#39;,&#39;current_times_used&#39;,&#39;psd_values&#39;]
        timeDiffWarn = True
        dfList = []
        time_data = {}
        time_dict = {}
        for m in members:
            for k in hvsr_data[&#39;psds&#39;].keys():
                hvsr_data[&#39;psds&#39;][k][m] = getattr(hvsr_data[&#39;ppsds_obspy&#39;][k], m)
                if m in listList:
                    hvsr_data[&#39;psds&#39;][k][m] = np.array(hvsr_data[&#39;psds&#39;][k][m])
            
            if str(m)==&#39;times_processed&#39;:
                unique_times = np.unique(np.array([hvsr_data[&#39;psds&#39;][&#39;Z&#39;][m],
                                                    hvsr_data[&#39;psds&#39;][&#39;E&#39;][m],
                                                    hvsr_data[&#39;psds&#39;][&#39;N&#39;][m]]))

                common_times = []
                for currTime in unique_times:
                    if currTime in hvsr_data[&#39;psds&#39;][&#39;Z&#39;][m]:
                        if currTime in hvsr_data[&#39;psds&#39;][&#39;E&#39;][m]:
                            if currTime in hvsr_data[&#39;psds&#39;][&#39;N&#39;][m]:
                                common_times.append(currTime)

                cTimeIndList = []
                for cTime in common_times:
                    ZArr = hvsr_data[&#39;psds&#39;][&#39;Z&#39;][m]
                    EArr = hvsr_data[&#39;psds&#39;][&#39;E&#39;][m]
                    NArr = hvsr_data[&#39;psds&#39;][&#39;N&#39;][m]

                    cTimeIndList.append([int(np.where(ZArr == cTime)[0][0]),
                                        int(np.where(EArr == cTime)[0][0]),
                                        int(np.where(NArr == cTime)[0][0])])
                    
            # Make sure number of time windows is the same between PPSDs (this can happen with just a few slightly different number of samples)
            if m in timeKeys:
                if str(m) != &#39;times_processed&#39;:
                    time_data[str(m)] = (hvsr_data[&#39;psds&#39;][&#39;Z&#39;][m], hvsr_data[&#39;psds&#39;][&#39;E&#39;][m], hvsr_data[&#39;psds&#39;][&#39;N&#39;][m])

                tSteps_same = hvsr_data[&#39;psds&#39;][&#39;Z&#39;][m].shape[0] == hvsr_data[&#39;psds&#39;][&#39;E&#39;][m].shape[0] == hvsr_data[&#39;psds&#39;][&#39;N&#39;][m].shape[0]

                if not tSteps_same:
                    shortestTimeLength = min(hvsr_data[&#39;psds&#39;][&#39;Z&#39;][m].shape[0], hvsr_data[&#39;psds&#39;][&#39;E&#39;][m].shape[0], hvsr_data[&#39;psds&#39;][&#39;N&#39;][m].shape[0])

                    maxPctDiff = 0
                    for comp in hvsr_data[&#39;psds&#39;].keys():
                        currCompTimeLength = hvsr_data[&#39;psds&#39;][comp][m].shape[0]
                        timeLengthDiff = currCompTimeLength - shortestTimeLength
                        percentageDiff = timeLengthDiff / currCompTimeLength
                        if percentageDiff &gt; maxPctDiff:
                            maxPctDiff = percentageDiff

                    for comp in hvsr_data[&#39;psds&#39;].keys():
                        while hvsr_data[&#39;psds&#39;][comp][m].shape[0] &gt; shortestTimeLength:
                            hvsr_data[&#39;psds&#39;][comp][m] = hvsr_data[&#39;psds&#39;][comp][m][:-1]
                    
                    
                    if maxPctDiff &gt; 0.05 and timeDiffWarn:
                        warnings.warn(f&#34;\t  Number of ppsd time windows between different components is significantly different: {round(maxPctDiff*100,2)}% &gt; 5%. Last windows will be trimmed.&#34;)
                    elif verbose  and timeDiffWarn:
                        print(f&#34;\t  Number of ppsd time windows between different components is different by {round(maxPctDiff*100,2)}%. Last window(s) of components with larger number of ppsd windows will be trimmed.&#34;)
                    timeDiffWarn = False #So we only do this warning once, even though there may be multiple arrays that need to be trimmed

        for i, currTStep in enumerate(cTimeIndList):
            colList = []
            currTStepList = []
            colList.append(&#39;Use&#39;)
            currTStepList.append(np.ones_like(common_times[i]).astype(bool))
            for tk in time_data.keys():
                if &#39;current_times_used&#39; not in tk:
                    for i, k in enumerate(hvsr_data[&#39;psds&#39;].keys()):
                        if k.lower() in [&#39;z&#39;, &#39;e&#39;, &#39;n&#39;]:
                            colList.append(str(tk)+&#39;_&#39;+k)
                            currTStepList.append(time_data[tk][i][currTStep[i]])
            dfList.append(currTStepList)
        
        return hvsr_data, dfList, colList, common_times

    if obspy_ppsds:
        hvsr_data, dfList, colList, common_times = _get_obspy_ppsds(hvsr_data, **obspy_ppsd_kwargs)
    else:
        psdDict, common_times = __single_psd_from_raw_data(hvsr_data, window_length=window_length, window_length_method=window_length_method, window_type=window_type,
                                                           num_freq_bins=num_freq_bins,
                                                           overlap=overlap_pct, remove_response=remove_response, do_azimuths=azimuthal_psds, show_psd_plot=False)

        x_freqs = np.flip(np.logspace(np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1]), num_freq_bins))
        
        psdDictUpdate = {}
        hvsr_data[&#39;psds&#39;] = {}
        for key, compdict in psdDict.items():
            psdDictUpdate[key] = np.array([list(np.flip(arr)) for time, arr in compdict.items()])
            hvsr_data[&#39;psds&#39;][key] = {}
        
        #hvsr_data[&#39;psds&#39;] = {&#39;Z&#39;:{}, &#39;E&#39;:{}, &#39;N&#39;:{}}
        for key, item in psdDict.items():
            currSt = hvsr_data.stream.select(component=key).merge()
                      
            hvsr_data[&#39;psds&#39;][key][&#39;channel&#39;] = currSt[0].stats.channel
            hvsr_data[&#39;psds&#39;][key][&#39;current_times_used&#39;] = common_times
            hvsr_data[&#39;psds&#39;][key][&#39;delta&#39;] = float(currSt[0].stats.delta)
            #hvsr_data[&#39;psds&#39;][key][&#39;get_mean&#39;] = np.nanmean(item)
            #hvsr_data[&#39;psds&#39;][key][&#39;mean&#39;] = np.nanmean(item)
            #hvsr_data[&#39;psds&#39;][key][&#39;get_mode&#39;] = scipy.stats.mode(item)
            #hvsr_data[&#39;psds&#39;][key][&#39;mode&#39;] = scipy.stats.mode(item)
            hvsr_data[&#39;psds&#39;][key][&#39;id&#39;] = currSt[0].id
            hvsr_data[&#39;psds&#39;][key][&#39;len&#39;] = int(window_length / hvsr_data[&#39;psds&#39;][key][&#39;delta&#39;])
            hvsr_data[&#39;psds&#39;][key][&#39;location&#39;] = currSt[0].stats.location
            hvsr_data[&#39;psds&#39;][key][&#39;metadata&#39;] = [currSt[0].stats.response if hasattr(currSt[0].stats, &#39;response&#39;) else None][0]
            hvsr_data[&#39;psds&#39;][key][&#39;network&#39;] = currSt[0].stats.network
            hvsr_data[&#39;psds&#39;][key][&#39;nfft&#39;] = int(window_length / hvsr_data[&#39;psds&#39;][key][&#39;delta&#39;])
            hvsr_data[&#39;psds&#39;][key][&#39;nlap&#39;] = int(overlap_pct*window_length / hvsr_data[&#39;psds&#39;][key][&#39;delta&#39;])
            hvsr_data[&#39;psds&#39;][key][&#39;overlap&#39;] = overlap_pct
            hvsr_data[&#39;psds&#39;][key][&#39;period_bin_centers&#39;] = [round(1/float(f + np.diff(x_freqs)[i]/2), 4) for i, f in enumerate(x_freqs[:-1])]
            hvsr_data[&#39;psds&#39;][key][&#39;period_bin_centers&#39;].append(float(round(1/x_freqs[-1], 3)))
            hvsr_data[&#39;psds&#39;][key][&#39;period_bin_centers&#39;] = np.array(hvsr_data[&#39;psds&#39;][key][&#39;period_bin_centers&#39;])
            hvsr_data[&#39;psds&#39;][key][&#39;period_bin_left_edges&#39;] = 1/x_freqs[:-1]
            hvsr_data[&#39;psds&#39;][key][&#39;period_bin_right_edges&#39;] = 1/x_freqs[1:]
            hvsr_data[&#39;psds&#39;][key][&#39;period_xedges&#39;] = 1/x_freqs
            hvsr_data[&#39;psds&#39;][key][&#39;ppsd_length&#39;] = window_length
            hvsr_data[&#39;psds&#39;][key][&#39;psd_length&#39;] = window_length
            hvsr_data[&#39;psds&#39;][key][&#39;psd_frequencies&#39;] = x_freqs
            hvsr_data[&#39;psds&#39;][key][&#39;psd_periods&#39;] = 1/x_freqs
            hvsr_data[&#39;psds&#39;][key][&#39;psd_values&#39;] = psdDictUpdate[key]
            hvsr_data[&#39;psds&#39;][key][&#39;sampling_rate&#39;] = currSt[0].stats.sampling_rate
            hvsr_data[&#39;psds&#39;][key][&#39;skip_on_gaps&#39;] = skip_on_gaps
            hvsr_data[&#39;psds&#39;][key][&#39;station&#39;] = currSt[0].stats.station
            hvsr_data[&#39;psds&#39;][key][&#39;step&#39;] = window_length * (1-overlap_pct)
            hvsr_data[&#39;psds&#39;][key][&#39;times_data&#39;] = common_times
            hvsr_data[&#39;psds&#39;][key][&#39;times_gaps&#39;] = [[None, None]]
            hvsr_data[&#39;psds&#39;][key][&#39;times_processed&#39;] = [[None, None]]
            
        hvsr_data[&#39;ppsds_obspy&#39;] = {}
        dfList = []
        for i, w in enumerate(common_times):
            ws = str(w)
            dfList.append([True, psdDictUpdate[&#39;Z&#39;][i], psdDictUpdate[&#39;E&#39;][i], psdDictUpdate[&#39;N&#39;][i]])
        colList = [&#34;Use&#34;, &#34;psd_values_Z&#34;, &#34;psd_values_E&#34;, &#34;psd_values_N&#34;]
        # dfList: list of np.arrays, fitting the above column
        # common_times: times in common between all, should be length of 1 psd dimension above
        # hvsr_data[&#39;psds&#39;][&#39;Z&#39;][&#39;times_gaps&#39;]: list of two-item lists with UTCDatetimes for gaps
        
        # #Maybe not needed hvsr_data[&#39;psds&#39;][&#39;Z&#39;][&#39;current_times_used&#39;]

    hvsrDF = pd.DataFrame(dfList, columns=colList)
    if verbose:
        print(f&#34;\t\t{hvsrDF.shape[0]} processing windows generated and psd values stored in hvsr_windows_df with columns: {&#39;, &#39;.join(hvsrDF.columns)}&#34;)
    hvsrDF[&#39;Use&#39;] = hvsrDF[&#39;Use&#39;].astype(bool)
    # Add azimuthal psds values
    for k in hvsr_data[&#39;psds&#39;].keys():
        if k.upper() not in [&#39;Z&#39;, &#39;E&#39;, &#39;N&#39;]:
            hvsrDF[&#39;psd_values_&#39;+k] = hvsr_data[&#39;psds&#39;][k][&#39;psd_values&#39;].tolist()

    hvsrDF[&#39;TimesProcessed_Obspy&#39;] = common_times
    hvsrDF[&#39;TimesProcessed_ObspyEnd&#39;] = hvsrDF[&#39;TimesProcessed_Obspy&#39;] + obspy_ppsd_kwargs[&#39;ppsd_length&#39;]
    #    colList.append(&#39;TimesProcessed_Obspy&#39;)
    #    currTStepList.append(common_times[i])            
    # Add other times (for start times)
    
    # Create functions to be used in pandas .apply() for datetime conversions
    def convert_to_datetime(obspyUTCDateTime):
        return obspyUTCDateTime.datetime.replace(tzinfo=datetime.timezone.utc)
    def convert_to_mpl_dates(obspyUTCDateTime):
        return obspyUTCDateTime.matplotlib_date

    hvsrDF[&#39;TimesProcessed&#39;] = hvsrDF[&#39;TimesProcessed_Obspy&#39;].apply(convert_to_datetime)
    
    hvsrDF[&#39;TimesProcessed_End&#39;] = hvsrDF[&#39;TimesProcessed&#39;] + datetime.timedelta(days=0, seconds=obspy_ppsd_kwargs[&#39;ppsd_length&#39;])
    hvsrDF[&#39;TimesProcessed_MPL&#39;] = hvsrDF[&#39;TimesProcessed_Obspy&#39;].apply(convert_to_mpl_dates)
    hvsrDF[&#39;TimesProcessed_MPLEnd&#39;] = hvsrDF[&#39;TimesProcessed_MPL&#39;] + (obspy_ppsd_kwargs[&#39;ppsd_length&#39;]/86400)
    
    # Take care of existing time gaps, in case not taken care of previously
    if obspy_ppsds:
        for gap in hvsr_data[&#39;psds&#39;][&#39;Z&#39;][&#39;times_gaps&#39;]:
            hvsrDF[&#39;Use&#39;] = (hvsrDF[&#39;TimesProcessed_MPL&#39;].gt(gap[1].matplotlib_date))| \
                        (hvsrDF[&#39;TimesProcessed_MPLEnd&#39;].lt(gap[0].matplotlib_date)).astype(bool)# | \
    
    hvsrDF.set_index(&#39;TimesProcessed&#39;, inplace=True)
    hvsr_data[&#39;hvsr_windows_df&#39;] = hvsrDF
    
    # Remove data set for removal during remove_noise()
    if &#39;x_windows_out&#39; in hvsr_data.keys():
        if verbose:
            print(&#34;\t\tRemoving Noisy windows from hvsr_windows_df.&#34;)
        hvsr_data = __remove_windows_from_df(hvsr_data, verbose=verbose)
        #for window in hvsr_data[&#39;x_windows_out&#39;]:
        #    print(window)
        #    hvsrDF[&#39;Use&#39;] = (hvsrDF[&#39;TimesProcessed_MPL&#39;][hvsrDF[&#39;Use&#39;]].lt(window[0]) &amp; hvsrDF[&#39;TimesProcessed_MPLEnd&#39;][hvsrDF[&#39;Use&#39;]].lt(window[0]) )| \
        #            (hvsrDF[&#39;TimesProcessed_MPL&#39;][hvsrDF[&#39;Use&#39;]].gt(window[1]) &amp; hvsrDF[&#39;TimesProcessed_MPLEnd&#39;][hvsrDF[&#39;Use&#39;]].gt(window[1])).astype(bool)
        #hvsrDF[&#39;Use&#39;] = hvsrDF[&#39;Use&#39;].astype(bool)
        
    # Create dict entry to keep track of how many outlier hvsr curves are removed 
    # This is a (2-item list with [0]=current number, [1]=original number of curves)
    hvsr_data[&#39;tsteps_used&#39;] = [int(hvsrDF[&#39;Use&#39;].sum()), hvsrDF[&#39;Use&#39;].shape[0]]
    #hvsr_data[&#39;tsteps_used&#39;] = [hvsr_data[&#39;psds&#39;][&#39;Z&#39;][&#39;times_processed&#39;].shape[0], hvsr_data[&#39;psds&#39;][&#39;Z&#39;][&#39;times_processed&#39;].shape[0]]
    #hvsr_data[&#39;tsteps_used&#39;][0] = hvsr_data[&#39;psds&#39;][&#39;Z&#39;][&#39;current_times_used&#39;].shape[0]
    
    hvsr_data = sprit_utils._make_it_classy(hvsr_data)

    if &#39;processing_parameters&#39; not in hvsr_data.keys():
        hvsr_data[&#39;processing_parameters&#39;] = {}
    hvsr_data[&#39;processing_parameters&#39;][&#39;generate_psds&#39;] = {}
    exclude_params_list = [&#39;hvsr_data&#39;]
    for key, value in orig_args.items():
        if key not in exclude_params_list:
            hvsr_data[&#39;processing_parameters&#39;][&#39;generate_psds&#39;][key] = value
    
    hvsr_data[&#39;processing_status&#39;][&#39;generate_psds_status&#39;] = True
    hvsr_data = sprit_utils._check_processing_status(hvsr_data, start_time=start_time, func_name=inspect.stack()[0][3], verbose=verbose)
    
    #for ind, row in hvsrDF.iterrows():
    #    print(row[&#39;psd_values_Z&#39;].shape)
    if plot_psds:
        for i, r in hvsrDF.iterrows():
            plt.plot(r[&#39;psd_values_Z&#39;], c=&#39;k&#39;, linewidth=0.5)
            plt.plot(r[&#39;psd_values_E&#39;], c=&#39;b&#39;, linewidth=0.5)
            plt.plot(r[&#39;psd_values_N&#39;], c=&#39;r&#39;, linewidth=0.5)
        plt.show()

    return hvsr_data</code></pre>
</details>
<div class="desc"><p>Calculate Power Spectral Density (PSD) curves for each channel.
Uses the <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.welch.html">scipy.signal.welch()</a> function
to generate PSDs by default, or can use Obspy's PPSD class.
Info on Obspy PPSD creation here (if obspy_ppsds=True): <a href="https://docs.obspy.org/packages/autogen/obspy.signal.spectral_estimation.PPSD.html">https://docs.obspy.org/packages/autogen/obspy.signal.spectral_estimation.PPSD.html</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>dict, <a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a> object,</code> or <code><a title="sprit.HVSRBatch" href="#sprit.HVSRBatch">HVSRBatch</a> object</code></dt>
<dd>Data object containing all the parameters and other data of interest (stream and paz, for example)</dd>
<dt><strong><code>window_length</code></strong> :&ensp;<code>float</code></dt>
<dd>Length of the window, in seconds, to use for each PSD calculation. Defaults to 30.0.</dd>
<dt><strong><code>overlap_pct</code></strong> :&ensp;<code>float</code></dt>
<dd>Percentage (should be 0-1) for overlapping each window used for PSD calculation. Defaults to 0.5.</dd>
<dt><strong><code>window_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of window to use. This is passed to the window parameter of the scipy.signal.welch function</dd>
<dt><strong><code>window_length_method</code></strong> :&ensp;<code>str = {'length', 'number'}</code></dt>
<dd>Whether the window length should be a measure of length in seconds or number of windows.
If number of windows uses integer value.</dd>
<dt><strong><code>remove_response</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to remove the instrument response from the data traces before calculating PSD data.
If True, the appropriate metadata (i.e., obspy.Inventory object) must be attached to the stream and should be stored in the 'inv' attribute of hvsr_data.</dd>
<dt><strong><code>skip_on_gaps</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to skip data gaps when processing windows.
This is passed to the skip_on_gaps parameter of the Obspy PPSD class.</dd>
<dt><strong><code>num_freq_bins</code></strong> :&ensp;<code>int</code>, default=<code>512</code></dt>
<dd>Number of frequency bins to use. When using the default (i.e., scipy.signal.welch) PSD function, the frequency bins are created manually for processing.</dd>
<dt><strong><code>obspy_ppsds</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to use the Obspy PPSD class.</dd>
<dt><strong><code>azimuthal_psds</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to generate PPSDs for azimuthal data</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to print inputs and results to terminal</dd>
<dt><strong><code>plot_psds</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to show a plot of the psds here.</dd>
<dt><strong><code>**obspy_ppsd_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with keyword arguments that are passed directly to obspy.signal.PPSD.
If the following keywords are not specified, their defaults are amended in this function from the obspy defaults for its PPSD function. Specifically:
- ppsd_length defaults to 30 (seconds) here instead of 3600
- skip_on_gaps defaults to True instead of False
- period_step_octaves defaults to 0.03125 instead of 0.125</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>psds : HVSRData object
    Dictionary containing entries with psds for each channel
</code></pre>
<h2 id="see-also">See Also</h2>
<p><code>[scipy.signal.welch](https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.welch.html)</code>
<code>[obspy.signal.spectral_estimation.PPSD](https://docs.obspy.org/packages/autogen/obspy.signal.spectral_estimation.PPSD.html)</code></p></div>
</dd>
<dt id="sprit.get_metadata"><code class="name flex">
<span>def <span class="ident">get_metadata</span></span>(<span>params,<br>write_path='',<br>update_metadata=True,<br>source=None,<br>verbose=False,<br>**read_inventory_kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metadata(params, write_path=&#39;&#39;, update_metadata=True, source=None, verbose=False, **read_inventory_kwargs):
    &#34;&#34;&#34;Get metadata and calculate or get paz parameter needed for PSD
       Adds an obspy.Inventory object to the &#34;inv&#34; attribute or key of params
    

    Parameters
    ----------
    params : dict
        Dictionary containing all the input and other parameters needed for processing
            Ouput from input_params() function
    write_path : str
        String with output filepath of where to write updated inventory or metadata file
            If not specified, does not write file 
    update_metadata : bool
        Whether to update the metadata file itself, or just read as-is. If using provided raspberry shake metadata file, select True.
    source : str, default=None
        This passes the source variable value to _read_RS_metadata. It is expected that this is passed directly from the source parameter of sprit.fetch_data()

    Returns
    -------
    params : dict
        Modified input dictionary with additional key:value pair containing paz dictionary (key = &#34;paz&#34;)
    &#34;&#34;&#34;
    
    invPath = params[&#39;metadata&#39;]
    raspShakeInstNameList = [&#39;raspberry shake&#39;, &#39;shake&#39;, &#39;raspberry&#39;, 
                             &#39;rs&#39;, &#39;rs3d&#39;, &#39;rasp. shake&#39;, 
                             &#39;raspshake&#39;, &#39;raspberry shake 3d&#39;]
    trominoNameList = [&#39;tromino&#39;, &#39;trom&#39;, &#39;trm&#39;, &#39;t&#39;]
       
    if str(params[&#39;instrument&#39;]).lower() in raspShakeInstNameList:
        if update_metadata:
            params = _update_shake_metadata(filepath=invPath, params=params, write_path=write_path, verbose=verbose)
        params = _read_RS_Metadata(params, source=source)
    elif params[&#39;instrument&#39;].lower() in trominoNameList:
        params[&#39;paz&#39;] = {&#39;Z&#39;:{}, &#39;E&#39;:{}, &#39;N&#39;:{}}

        # Initially started here: https://ds.iris.edu/NRL/sensors/Sunfull/RESP.XX.NS721..BHZ.PS-4.5C1_LF4.5_RC3400_RSNone_SG82_STgroundVel
        tromino_paz = { &#39;zeros&#39;: [-3.141592653589793/2-0j, -3.141592653589793/2-0j],
                        &#39;poles&#39;: [(17-24j), (17+24j)],
                        &#39;stage_gain&#39;:100,
                        &#39;stage_gain_frequency&#39;:10,
                        &#39;normalization_frequency&#39;:5, 
                        &#39;normalization_factor&#39;:1}
        
        params[&#39;paz&#39;][&#39;Z&#39;] =  params[&#39;paz&#39;][&#39;E&#39;] = params[&#39;paz&#39;][&#39;N&#39;] = tromino_paz
        
        tromChaResponse = obspy.core.inventory.response.Response().from_paz(**tromino_paz)

        obspyStartDate = obspy.UTCDateTime(1900,1,1)
        obspyNow = obspy.UTCDateTime.now()

        # Update location code to match partition
        if type(params[&#39;station&#39;]) is int or str(params[&#39;station&#39;]).isdigit():
            params[&#39;location&#39;] = str(params[&#39;station&#39;])

        # Create channel objects to be used in inventory                
        channelObj_Z = obspy.core.inventory.channel.Channel(code=&#39;EHZ&#39;, location_code=params[&#39;location&#39;], latitude=params[&#39;params&#39;][&#39;latitude&#39;], 
                                                longitude=params[&#39;params&#39;][&#39;longitude&#39;], elevation=params[&#39;params&#39;][&#39;elevation&#39;], depth=params[&#39;params&#39;][&#39;depth&#39;], 
                                                azimuth=0, dip=90, start_date=obspyStartDate, end_date=obspyNow, response=tromChaResponse)
        channelObj_E = obspy.core.inventory.channel.Channel(code=&#39;EHE&#39;, location_code=params[&#39;location&#39;], latitude=params[&#39;params&#39;][&#39;latitude&#39;], 
                                                longitude=params[&#39;params&#39;][&#39;longitude&#39;], elevation=params[&#39;params&#39;][&#39;elevation&#39;], depth=params[&#39;params&#39;][&#39;depth&#39;], 
                                                azimuth=90, dip=0, start_date=obspyStartDate, end_date=obspyNow, response=tromChaResponse) 
        channelObj_N = obspy.core.inventory.channel.Channel(code=&#39;EHN&#39;, location_code=params[&#39;location&#39;], latitude=params[&#39;params&#39;][&#39;latitude&#39;], 
                                                longitude=params[&#39;params&#39;][&#39;longitude&#39;], elevation=params[&#39;params&#39;][&#39;elevation&#39;], depth=params[&#39;params&#39;][&#39;depth&#39;], 
                                                azimuth=0, dip=0, start_date=obspyStartDate, end_date=obspyNow, response=tromChaResponse) 
        
        # Create site object for inventory
        siteObj = obspy.core.inventory.util.Site(name=params[&#39;params&#39;][&#39;site&#39;], description=None, town=None, county=None, region=None, country=None)
        
        # Create station object for inventory
        stationObj = obspy.core.inventory.station.Station(code=&#39;TRMNO&#39;, latitude=params[&#39;params&#39;][&#39;latitude&#39;], longitude=params[&#39;params&#39;][&#39;longitude&#39;], 
                                            elevation=params[&#39;params&#39;][&#39;elevation&#39;], channels=[channelObj_Z, channelObj_E, channelObj_N], site=siteObj, 
                                            vault=None, geology=None, equipments=None, operators=None, creation_date=obspyStartDate,
                                            termination_date=obspy.UTCDateTime(2100,1,1), total_number_of_channels=3, 
                                            selected_number_of_channels=3, description=&#39;Estimated data for Tromino, this is NOT from the manufacturer&#39;,
                                            comments=None, start_date=obspyStartDate, end_date=obspyNow, 
                                            restricted_status=None, alternate_code=None, historical_code=None, 
                                            data_availability=obspy.core.inventory.util.DataAvailability(obspyStartDate, obspy.UTCDateTime.now()), 
                                            identifiers=None, water_level=None, source_id=None)

        # Create network object for inventory
        network = [obspy.core.inventory.network.Network(code=&#39;AM&#39;, stations=[stationObj], total_number_of_stations=None, 
                                            selected_number_of_stations=None, description=None, comments=None, start_date=obspyStartDate, 
                                            end_date=obspyNow, restricted_status=None, alternate_code=None, historical_code=None, 
                                            data_availability=None, identifiers=None, operators=None, source_id=None)]
        
        params[&#39;inv&#39;] = obspy.Inventory(networks=network)
    else:
        if not invPath:
            pass #if invPath is None
        elif not pathlib.Path(invPath).exists() or invPath == &#39;&#39;:
            warnings.warn(f&#34;The metadata parameter was not specified correctly. Returning original params value {params[&#39;metadata&#39;]}&#34;)
        readInvKwargs = {}
        argspecs = inspect.getfullargspec(obspy.read_inventory)
        for argName in argspecs[0]:
            if argName in read_inventory_kwargs.keys():
                readInvKwargs[argName] = read_inventory_kwargs[argName]

        readInvKwargs[&#39;path_or_file_object&#39;] = invPath
        params[&#39;inv&#39;] = obspy.read_inventory(invPath)
        if &#39;params&#39; in params.keys():
            params[&#39;params&#39;][&#39;inv&#39;] = params[&#39;inv&#39;]

    return params</code></pre>
</details>
<div class="desc"><p>Get metadata and calculate or get paz parameter needed for PSD
Adds an obspy.Inventory object to the "inv" attribute or key of params</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary containing all the input and other parameters needed for processing
Ouput from input_params() function</dd>
<dt><strong><code>write_path</code></strong> :&ensp;<code>str</code></dt>
<dd>String with output filepath of where to write updated inventory or metadata file
If not specified, does not write file</dd>
<dt><strong><code>update_metadata</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to update the metadata file itself, or just read as-is. If using provided raspberry shake metadata file, select True.</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>str</code>, default=<code>None</code></dt>
<dd>This passes the source variable value to _read_RS_metadata. It is expected that this is passed directly from the source parameter of sprit.fetch_data()</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Modified input dictionary with additional key:value pair containing paz dictionary (key = "paz")</dd>
</dl></div>
</dd>
<dt id="sprit.get_report"><code class="name flex">
<span>def <span class="ident">get_report</span></span>(<span>hvsr_results,<br>report_formats=['print', 'table', 'plot', 'html', 'pdf'],<br>azimuth='HV',<br>plot_type='HVSR p ann COMP+ p ann SPEC p ann',<br>plot_engine='matplotlib',<br>show_print_report=True,<br>show_table_report=False,<br>show_plot_report=False,<br>show_html_report=False,<br>show_pdf_report=True,<br>suppress_report_outputs=False,<br>show_report_outputs=False,<br>csv_handling='append',<br>report_export_format=None,<br>report_export_path=None,<br>verbose=False,<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_report(hvsr_results, report_formats=[&#39;print&#39;, &#39;table&#39;, &#39;plot&#39;, &#39;html&#39;, &#39;pdf&#39;], azimuth=&#39;HV&#39;,
               plot_type=DEFAULT_PLOT_STR, plot_engine=&#39;matplotlib&#39;, 
               show_print_report=True, show_table_report=False, show_plot_report=False, show_html_report=False, show_pdf_report=True,
               suppress_report_outputs=False, show_report_outputs=False,
               csv_handling=&#39;append&#39;, 
               report_export_format=None, report_export_path=None, 
               verbose=False, **kwargs):    
    &#34;&#34;&#34;Generate and/or print and/or export a report of the HVSR analysis in a variety of formats. 
    
    Formats include:
    * &#39;print&#39;: A (monospace) text summary of the HVSR results
    * &#39;table&#39;: A pandas.DataFrame summary of the HVSR Results.
            This is useful for copy/pasting directly into a larger worksheet.
    * &#39;plot&#39;: A plot summary of the HVSR results, generated using the plot_hvsr() function.
    * &#39;html&#39;: An HTML document/text of the HVSR results. This includes the table, print, and plot reports in one document.
    * &#39;pdf&#39;: A PDF document showing the summary of the HVSR Results. 
            The PDF report is simply the HTML report saved to an A4-sized PDF document.

        
    Parameters
    ----------
    hvsr_results : dict
        Dictionary containing all the information about the processed hvsr data
    report_formats : {&#39;table&#39;, &#39;print&#39;, plot}
        Format in which to print or export the report.
        The following report_formats return the following items in the following attributes:
            - &#39;plot&#39;: hvsr_results[&#39;Print_Report&#39;] as a str
            - &#39;print&#39;: hvsr_results[&#39;Plot_Report&#39;] - matplotlib.Figure object
            - &#39;table&#39;:  hvsr_results[&#39;Table_Report&#39;]- pandas.DataFrame object
                - list/tuple - a list or tuple of the above objects, in the same order they are in the report_formats list
            - &#39;html&#39;: hvsr_results[&#39;HTML_Report&#39;] - a string containing the text for an HTML document
            - &#39;pdf&#39;: currently does not save to the HVSRData object itself, can only be saved to the disk directly
    plot_type : str, default = &#39;HVSR p ann C+ p ann Spec p ann&#39;
        What type of plot to plot, if &#39;plot&#39; part of report_formats input
    azimuth : str, default = &#39;HV&#39;
        Which azimuth to plot, by default &#34;HV&#34; which is the main &#34;azimuth&#34; combining the E and N components
    csv_handling : str, {&#39;append&#39;, &#39;overwrite&#39;, &#39;keep/rename&#39;}
        How to handle table report outputs if the designated csv output file already exists. By default, appends the new information to the end of the existing file.
    suppress_report_outputs : bool, default=False
        If True, only reads output to appropriate attribute of data class (ie, print does not print, only reads text into variable). If False, performs as normal.
    report_export_format : list or str, default=[&#39;pdf&#39;]
        A string or list of strings indicating which report formats should be exported to disk.
    report_export_path : None, bool, or filepath, default = None
        If None or False, does not export; if True, will export to same directory as the input_data parameter in the input_params() function.
        Otherwise, it should be a string or path object indicating where to export results. May be a file or directory.
        If a directory is specified, the filename will be  &#34;&lt;site_name&gt;_&lt;acq_date&gt;_&lt;UTC start time&gt;-&lt;UTC end time&gt;&#34;. 
        The extension/suffix defaults to png for report_formats=&#34;plot&#34;, csv for &#39;table&#39;, txt for &#39;print&#39;, html for &#39;html&#39;, and pdf for &#39;pdf.&#39;
    verbose : bool, default=True
        Whether to print the results to terminal. This is the same output as report_formats=&#39;print&#39;, and will not repeat if that is already selected

    Returns
    -------
    sprit.HVSRData
    &#34;&#34;&#34;
    orig_args = locals().copy() #Get the initial arguments
    orig_args[&#39;report_formats&#39;] = [str(f).lower() for f in orig_args[&#39;report_formats&#39;]]
    update_msg = []

    # Update with processing parameters specified previously in input_params, if applicable
    if &#39;processing_parameters&#39; in hvsr_results.keys():
        if &#39;get_report&#39; in hvsr_results[&#39;processing_parameters&#39;].keys():
            for k, v in hvsr_results[&#39;processing_parameters&#39;][&#39;get_report&#39;].items():
                defaultVDict = dict(zip(inspect.getfullargspec(get_report).args[1:], 
                                        inspect.getfullargspec(get_report).defaults))
                defaultVDict[&#39;kwargs&#39;] = {}
                # Manual input to function overrides the imported parameter values
                if (not isinstance(v, (HVSRData, HVSRBatch))) and (k in orig_args.keys()) and (orig_args[k]==defaultVDict[k]):
                    update_msg.append(f&#39;\t\t{k} = {v} (previously {orig_args[k]})&#39;)
                    orig_args[k] = v
                    
    report_formats = orig_args[&#39;report_formats&#39;]
    azimuth = orig_args[&#39;azimuth&#39;]
    plot_type = orig_args[&#39;plot_type&#39;]
    plot_engine = orig_args[&#39;plot_engine&#39;]
    show_print_report = orig_args[&#39;show_print_report&#39;]
    show_table_report = orig_args[&#39;show_table_report&#39;]
    show_plot_report = orig_args[&#39;show_plot_report&#39;]
    show_html_report = orig_args[&#39;show_html_report&#39;]
    show_pdf_report = orig_args[&#39;show_pdf_report&#39;]
    suppress_report_outputs = orig_args[&#39;suppress_report_outputs&#39;]
    show_report_outputs = orig_args[&#39;show_report_outputs&#39;]
    report_export_format = orig_args[&#39;report_export_format&#39;]
    report_export_path = orig_args[&#39;report_export_path&#39;]
    csv_handling = orig_args[&#39;csv_handling&#39;]
    verbose = orig_args[&#39;verbose&#39;]
    kwargs = orig_args[&#39;kwargs&#39;]

    # Put Processing parameters in hvsr_results immediately (gets used later local function in get_report)
    hvsr_results[&#39;processing_parameters&#39;][&#39;get_report&#39;] = {}
    exclude_params_list = [&#39;hvsr_results&#39;]
    for key, value in orig_args.items():
        if key not in exclude_params_list:
            hvsr_results[&#39;processing_parameters&#39;][&#39;get_report&#39;][key] = value
    
    if verbose:
        print(&#39;\nGetting HVSR Report: get_report()&#39;)
        print(&#39;\tUsing the following parameters:&#39;)
        for key, value in orig_args.items():
            if key == &#39;params&#39; or isinstance(value, (HVSRData, HVSRBatch)):
                pass
            else:
                print(&#39;\t  {}={}&#39;.format(key, value))
        print()

        if update_msg != [] and verbose:
            update_msg.insert(0, &#39;\tThe following parameters were updated using the processing_parameters attribute:&#39;)
            for msg_line in update_msg:
                print(msg_line)
                    
    if isinstance(hvsr_results, HVSRBatch):
        if verbose:
            print(&#39;\nGetting Reports: Running in batch mode&#39;)

            print(&#39;\tUsing parameters:&#39;)
            for key, value in orig_args.items():
                print(f&#39;\t  {key}={value}&#39;)    
            print()
        
        #If running batch, we&#39;ll loop through each site
        for site_name in hvsr_results.keys():
            args = orig_args.copy() #Make a copy so we don&#39;t accidentally overwrite
            individual_params = hvsr_results[site_name] #Get what would normally be the &#34;params&#34; variable for each site
            args[&#39;hvsr_results&#39;] = individual_params #reset the params parameter we originally read in to an individual site params
            if hvsr_results[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;]:
                try:
                    hvsr_results[site_name] = __get_report_batch(**args) #Call another function, that lets us run this function again
                except:
                    hvsr_results[site_name] = hvsr_results[site_name]
            else:
                hvsr_results[site_name] = hvsr_results[site_name]
        
        combined_csvReport = pd.DataFrame()
        for site_name in hvsr_results.keys():
            if &#39;Table_Report&#39; in hvsr_results[site_name].keys():
                combined_csvReport = pd.concat([combined_csvReport, hvsr_results[site_name][&#39;Table_Report&#39;]], ignore_index=True, join=&#39;inner&#39;)
        
        if report_export_path is not None:
            if report_export_path is True:
                if pathlib.Path(hvsr_results[&#39;input_params&#39;][&#39;input_data&#39;]) in sampleFileKeyMap.values():
                    csvExportPath = pathlib.Path(os.getcwd())
                else:
                    csvExportPath = pathlib.Path(hvsr_results[&#39;input_params&#39;][&#39;input_data&#39;])
            elif pathlib.Path(report_export_path).is_dir():
                csvExportPath = report_export_path
            elif pathlib.Path(report_export_path).is_file():
                csvExportPath = report_export_path.parent
            else:
                csvExportPath = pathlib.Path(hvsr_results[site_name].input_data)
                if csvExportPath.is_dir():
                    pass
                else:
                    csvExportPath = csvExportPath.parent
                
            combined_csvReport.to_csv(csvExportPath, index=False)
        return hvsr_results
    
    if suppress_report_outputs:
        show_print_report = show_plot_report = show_table_report = show_html_report = show_pdf_report = False
    elif show_report_outputs:
        show_print_report = show_plot_report = show_table_report = show_html_report = show_pdf_report = True
    #if &#39;BestPeak&#39; in hvsr_results.keys() and &#39;PassList&#39; in hvsr_results[&#39;BestPeak&#39;].keys():
    try:
        curvTestsPassed = (hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;WinLen&#39;] +
                            hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;SigCycles&#39;]+
                            hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;LowCurveStD&#39;])
        curvePass = curvTestsPassed &gt; 2
        
        #Peak Pass?
        peakTestsPassed = ( hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;ProminenceLow&#39;] +
                    hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;ProminenceHi&#39;]+
                    hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;AmpClarity&#39;]+
                    hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;FreqStability&#39;]+
                    hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;LowStDev_Freq&#39;]+
                    hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;LowStDev_Amp&#39;])
        peakPass = peakTestsPassed &gt;= 5
    except Exception as e:
        errMsg= &#39;No BestPeak identified. Check peak_freq_range or hvsr_band or try to remove bad noise windows using remove_noise() or change processing parameters in process_hvsr() or generate_psds(). Otherwise, data may not be usable for HVSR.&#39;
        print(errMsg)
        print(e)
        plotString_noBestPeak = &#39;HVSR t all C+ t SPEC&#39;
        hvsr_results[&#39;Plot_Report&#39;] = plot_hvsr(hvsr_results, plot_type=plotString_noBestPeak, azimuth=azimuth, return_fig=True)
        return hvsr_results
        #raise RuntimeError(&#39;No BestPeak identified. Check peak_freq_range or hvsr_band or try to remove bad noise windows using remove_noise() or change processing parameters in process_hvsr() or generate_psds(). Otherwise, data may not be usable for HVSR.&#39;)

    # Figure out which reports will be used, and format them correctly
    if isinstance(report_formats, (list, tuple)):
        report_formats = [str(rf).lower() for rf in report_formats]
    else:
        #We will use a loop later even if it&#39;s just one report type, so reformat to prepare for for loop
        allList = [&#39;:&#39;, &#39;all&#39;]
        if report_formats.lower() in allList:
            report_formats = [&#39;print&#39;, &#39;table&#39;, &#39;plot&#39;, &#39;html&#39;, &#39;pdf&#39;]
        else:
            report_formats = [str(report_formats).lower()]   

    # Format the export formats correctly
    if isinstance(report_export_format, (list, tuple)):
        pass
    elif report_export_format is None:
        pass
    else:
        # We will use list methods later even if it&#39;s just one report type, so reformat as list
        allList = [&#39;:&#39;, &#39;all&#39;]
        if report_export_format.lower() in allList:
            report_export_format = [&#39;print&#39;, &#39;table&#39;, &#39;plot&#39;, &#39;html&#39;, &#39;pdf&#39;]
        else:
            report_export_format = [report_export_format]   

    # Put print first to get results immediatley while plots and others are created
    if &#39;print&#39; in report_formats and report_formats[0] != &#39;print&#39;:
        report_formats = [&#39;table&#39;, &#39;plot&#39;, &#39;print&#39;, &#39;html&#39;, &#39;pdf&#39;]
        report_formats.pop(report_formats.index(&#39;print&#39;))
        report_formats.insert(0, &#39;print&#39;)

    for i, rep_form in enumerate(report_formats):
        if isinstance(report_export_path, (list, tuple)):
            if not isinstance(report_formats, (list, tuple)):
                warnings.warn(&#39;report_export_path is a list/tuple and report_formats is not. This may result in unexpected behavior.&#39;)
            if isinstance(report_formats, (list, tuple)) and isinstance(report_export_path, (list, tuple)) and len(report_formats) != len(report_export_path):
                warnings.warn(&#39;report_export_path and report_formats are both lists or tuples, but they are not the same length. This may result in unexpected behavior.&#39;)
            exp_path = report_export_path[i]
        else:
            exp_path = report_export_path
        
        if report_export_format is None:
            report_export_format = &#39;&#39;
       
        # Print_Report
        if rep_form == &#39;print&#39;:
            verbose_print = verbose
            if show_print_report:
                verbose_print = True
            
            # Generates print report and saves to hvsr_results[&#34;Print_Report&#34;]
            hsvr_results = _generate_print_report(hvsr_results, 
                                azimuth = azimuth, 
                                show_print_report = True, verbose=verbose_print)

            if &#39;print&#39; in report_export_format:
                if exp_path is None:
                    print_exp_path = exp_path
                else:
                    print_exp_path = pathlib.Path(exp_path).with_suffix(&#39;.txt&#39;)
                
                export_report(hvsr_results, azimuth=azimuth,
                              report_export_format=&#39;print&#39;, report_export_path=print_exp_path, 
                              show_report = False, # If report is to be shown, done in previous step
                              verbose = verbose_print)

        # Table_Report
        elif rep_form == &#39;table&#39;:
            verbose_table = verbose
            if show_table_report:
                verbose_table = True
            
            hsvr_results = _generate_table_report(hvsr_results, 
                                azimuth=azimuth,
                                show_table_report=show_table_report,
                                verbose=verbose_table)

            if &#39;table&#39; in report_export_format:
                if exp_path is None:
                    table_exp_path = exp_path
                else:
                    table_exp_path = pathlib.Path(exp_path).with_suffix(&#39;.csv&#39;)
                
                export_report(hvsr_results, azimuth=azimuth,
                            report_export_format=&#39;table&#39;, report_export_path=table_exp_path,
                            csv_handling=csv_handling,
                            show_report = False, # If report is to be shown, done in previous step
                            verbose = verbose_table)

        # Plot_Report
        elif rep_form == &#39;plot&#39;:
            plot_hvsr_kwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(plot_hvsr).parameters.keys())}
            if &#39;plot_type&#39; in plot_hvsr_kwargs.keys():
                plot_hvsr_kwargs.pop(&#39;plot_type&#39;)
            if &#39;plot_engine&#39; in plot_hvsr_kwargs.keys():
                plot_hvsr_kwargs.pop(&#39;plot_engine&#39;)

            fig = plot_hvsr(hvsr_results, plot_type=plot_type, azimuth=azimuth, plot_engine=plot_engine, show_plot=show_plot_report, return_fig=True)
            expFigAx = fig
            
            if &#39;plot&#39; in report_export_format:
                export_report(hvsr_results=hvsr_results, report_export_path=report_export_path, report_export_format=&#39;plot&#39;)
            #hvsr_results[&#39;BestPeak&#39;][azimuth][&#39;Report&#39;][&#39;Plot_Report&#39;] = fig
            hvsr_results[&#39;Plot_Report&#39;] = fig

            if show_plot_report:#&#39;show_plot&#39; in plot_hvsr_kwargs.keys() and plot_hvsr_kwargs[&#39;show_plot&#39;] is False:
                if not verbose:
                    if str(plot_engine).lower():
                        plt.show()
                    else:
                        fig.show()
                else:
                    print(&#39;\nPlot of data report:&#39;)
                    if str(plot_engine).lower():
                        plt.show()
                    else:
                        fig.show()                    
            else:
                if verbose:
                    print(&#34;\n\tPlot of data report created and saved in [&#39;Plot_Report&#39;] attribute&#34;)

        # HTML_Report
        elif rep_form == &#39;html&#39;:
            verbose_html = verbose
            if verbose or show_html_report:
                verbose_html = True
            hvsr_results = _generate_html_report(hsvr_results, show_html_report=show_html_report, verbose=verbose_html)

            if &#39;html&#39; in report_export_format:
                if exp_path is None:
                    html_exp_path = exp_path
                else:
                    html_exp_path = pathlib.Path(exp_path).with_suffix(&#39;.html&#39;)

                export_report(hvsr_results, azimuth=azimuth,
                            report_export_format=&#39;html&#39;, report_export_path=html_exp_path,
                            show_report = False, # If report is to be shown, done in previous step
                            verbose = verbose_html)

        # PDF_Report
        elif rep_form == &#39;pdf&#39;:
            verbose_pdf = verbose

            # Don&#39;t repeat html printing, etc. if already done
            if &#39;html&#39; in report_formats:
                show_html_report = False
            else:
                show_html_report = show_html_report

            if exp_path is None:
                pdf_exp_path = exp_path
            else:
                pdf_exp_path = pathlib.Path(exp_path)
            hvsr_results = _generate_pdf_report(hvsr_results, pdf_report_filepath=pdf_exp_path,
                            show_pdf_report=show_pdf_report, show_html_report=show_html_report, verbose=verbose_pdf)


    return hvsr_results</code></pre>
</details>
<div class="desc"><p>Generate and/or print and/or export a report of the HVSR analysis in a variety of formats. </p>
<p>Formats include:
* 'print': A (monospace) text summary of the HVSR results
* 'table': A pandas.DataFrame summary of the HVSR Results.
This is useful for copy/pasting directly into a larger worksheet.
* 'plot': A plot summary of the HVSR results, generated using the plot_hvsr() function.
* 'html': An HTML document/text of the HVSR results. This includes the table, print, and plot reports in one document.
* 'pdf': A PDF document showing the summary of the HVSR Results.
The PDF report is simply the HTML report saved to an A4-sized PDF document.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_results</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary containing all the information about the processed hvsr data</dd>
<dt><strong><code>report_formats</code></strong> :&ensp;<code>{'table', 'print', plot}</code></dt>
<dd>Format in which to print or export the report.
The following report_formats return the following items in the following attributes:
- 'plot': hvsr_results['Print_Report'] as a str
- 'print': hvsr_results['Plot_Report'] - matplotlib.Figure object
- 'table':
hvsr_results['Table_Report']- pandas.DataFrame object
- list/tuple - a list or tuple of the above objects, in the same order they are in the report_formats list
- 'html': hvsr_results['HTML_Report'] - a string containing the text for an HTML document
- 'pdf': currently does not save to the HVSRData object itself, can only be saved to the disk directly</dd>
<dt><strong><code>plot_type</code></strong> :&ensp;<code>str</code>, default <code>= 'HVSR p ann C+ p ann Spec p ann'</code></dt>
<dd>What type of plot to plot, if 'plot' part of report_formats input</dd>
<dt><strong><code>azimuth</code></strong> :&ensp;<code>str</code>, default <code>= 'HV'</code></dt>
<dd>Which azimuth to plot, by default "HV" which is the main "azimuth" combining the E and N components</dd>
<dt><strong><code>csv_handling</code></strong> :&ensp;<code>str, {'append', 'overwrite', 'keep/rename'}</code></dt>
<dd>How to handle table report outputs if the designated csv output file already exists. By default, appends the new information to the end of the existing file.</dd>
<dt><strong><code>suppress_report_outputs</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>If True, only reads output to appropriate attribute of data class (ie, print does not print, only reads text into variable). If False, performs as normal.</dd>
<dt><strong><code>report_export_format</code></strong> :&ensp;<code>list</code> or <code>str</code>, default=<code>['pdf']</code></dt>
<dd>A string or list of strings indicating which report formats should be exported to disk.</dd>
<dt><strong><code>report_export_path</code></strong> :&ensp;<code>None, bool,</code> or <code>filepath</code>, default <code>= None</code></dt>
<dd>If None or False, does not export; if True, will export to same directory as the input_data parameter in the input_params() function.
Otherwise, it should be a string or path object indicating where to export results. May be a file or directory.
If a directory is specified, the filename will be
"<site_name><em><acq_date></em><UTC start time>-<UTC end time>".
The extension/suffix defaults to png for report_formats="plot", csv for 'table', txt for 'print', html for 'html', and pdf for 'pdf.'</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to print the results to terminal. This is the same output as report_formats='print', and will not repeat if that is already selected</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="sprit.gui"><code class="name flex">
<span>def <span class="ident">gui</span></span>(<span>kind: str = 'browser')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gui(kind: str = &#39;browser&#39;):
    &#34;&#34;&#34;Function to open a graphical user interface (gui)

    Parameters
    ----------
    kind : str, optional
        What type of gui to open: 
        * &#34;browser&#34; or &#34;default&#34; opens browser interface (using streamlit)
        * &#34;widget&#34; opens jupyter widget (using ipywidgets)
        * &#34;window&#34; opens windowed gui (using tkinter)
        
    &#34;&#34;&#34;
    browserList = [&#39;browser&#39;, &#39;streamlit&#39;, &#39;default&#39;, &#39;d&#39;, &#39;b&#39;, &#39;s&#39;]
    windowList = [&#39;windowed&#39;, &#39;window&#39;, &#39;tkinter&#39;, &#39;tk&#39;, &#39;t&#39;, &#39;win&#39;]
    widgetList = [&#39;widget&#39;, &#39;jupyter&#39;, &#39;notebook&#39;, &#39;nb&#39;]
    liteList = [&#39;lite&#39;, &#39;light&#39;, &#39;basic&#39;, &#39;l&#39;]

    if kind.lower() in browserList:
        import subprocess
        streamlitPath = pathlib.Path(__file__).parent.joinpath(&#34;sprit_streamlit_ui.py&#34;)
        cmd = [&#39;streamlit&#39;, &#39;run&#39;, streamlitPath.as_posix()]
        #subprocess.run(cmd)
        import sys

        from streamlit.web import cli as stcli
        import streamlit
        import sys

        import subprocess
        import tempfile

        temp_dir = tempfile.TemporaryDirectory()
        def run_streamlit_app(path_dir):
            temp_dir = tempfile.TemporaryDirectory()
            # create a temporary directory
            fpathList = [&#39;sprit_hvsr.py&#39;, &#39;sprit_tkinter_ui.py&#39;, &#39;sprit_jupyter_ui.py&#39;, &#39;sprit_utils.py&#39;, &#39;sprit_plot.py&#39;, &#39;__init__.py&#39;, &#39;sprit_streamlit_ui.py&#39;]
            currDir = os.path.dirname(os.path.abspath(__file__))
            for fpath in fpathList:
                temp_file_path = os.path.join(temp_dir.name, fpath)
                with open(pathlib.Path(currDir).joinpath(fpath), &#39;r&#39;) as cf:
                    scriptText = cf.read()
                # write the streamlit app code to a Python script in the temporary directory
                with open(temp_file_path, &#39;w&#39;) as f:
                    f.write(scriptText)
            
            # execute the streamlit app
            try:
                # execute the streamlit app
                subprocess.run(
                    [&#39;streamlit&#39;, &#34;run&#34;, temp_file_path],
                    stderr=subprocess.DEVNULL
                    )
                
            except KeyboardInterrupt:
                pass
            # clean up the temporary directory when done
            temp_dir.cleanup()
        
        #with open(streamlitPath.parent.as_posix(), &#39;r&#39;) as file:
        #    appText = file.read()

        run_streamlit_app(pathlib.Path(__name__).parent)

        #streamlit.web.bootstrap.run(streamlitPath.as_posix(), &#39;&#39;, [], [])
        #process = subprocess.Popen([&#34;streamlit&#34;, &#34;run&#34;, os.path.join(
        #            &#39;application&#39;, &#39;main&#39;, &#39;services&#39;, &#39;streamlit_app.py&#39;)])             
    elif kind.lower() in windowList:
        #guiPath = pathlib.Path(os.path.realpath(__file__))
        try:
            import tkinter as tk
            from sprit.sprit_tkinter_ui import SPRIT_App
        except:
            if sys.platform == &#39;linux&#39;:
                raise ImportError(&#39;The SpRIT graphical interface uses tkinter, which ships with python but is not pre-installed on linux machines. Use &#34;apt-get install python-tk&#34; or &#34;apt-get install python3-tk&#34; to install tkinter. You may need to use the sudo command at the start of those commands.&#39;)
            else:
                print(&#34;Tkinter may not be installed on your system, or is not functioning correctly. Please download and install tkinter, or use another interface.&#34;)
        
        def on_gui_closing():
            plt.close(&#39;all&#39;)
            gui_root.quit()
            gui_root.destroy()

        if sys.platform == &#39;linux&#39;:
            if not pathlib.Path(&#34;/usr/share/doc/python3-tk&#34;).exists():
                warnings.warn(&#39;The SpRIT graphical interface uses tkinter, which ships with python but is not pre-installed on linux machines. Use &#34;apt-get install python-tk&#34; or &#34;apt-get install python3-tk&#34; to install tkinter. You may need to use the sudo command at the start of those commands.&#39;)

        gui_root = tk.Tk()
        try:
            try:
                icon_path = pathlib.Path(str(importlib.resources.files(&#39;sprit&#39;))).joinpath(&#39;resources&#39;).joinpath(&#34;icon&#34;).joinpath(&#39;sprit_icon_alpha.ico&#39;) 
                gui_root.iconbitmap(icon_path.as_posix())
            except:
                icon_path = pathlib.Path(str(importlib.resources.files(&#39;sprit&#39;))).joinpath(&#39;resources&#39;).joinpath(&#34;icon&#34;).joinpath(&#39;sprit_icon.png&#39;) 
                gui_root.iconphoto(False, tk.PhotoImage(file=icon_path.as_posix()))
        except Exception as e:
            print(&#34;ICON NOT LOADED, still opening GUI&#34;)

        gui_root.resizable(True, True)
        spritApp = SPRIT_App(master=gui_root)  # Open the app with a tk.Tk root

        gui_root.protocol(&#34;WM_DELETE_WINDOW&#34;, on_gui_closing)    
        gui_root.mainloop()  # Run the main loop
    elif kind.lower() in widgetList:
        try:
            sprit_jupyter_UI.create_jupyter_ui()
        except Exception as e:
            if hasattr(e, &#39;message&#39;):
                errMsg = e.message
            else:
                errMsg = e
            print(errMsg)
            raise e
            
    elif kind.lower() in liteList:
        print(&#34;Lite GUI is not currently supported&#34;)</code></pre>
</details>
<div class="desc"><p>Function to open a graphical user interface (gui)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>kind</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>What type of gui to open:
* "browser" or "default" opens browser interface (using streamlit)
* "widget" opens jupyter widget (using ipywidgets)
* "window" opens windowed gui (using tkinter)</dd>
</dl></div>
</dd>
<dt id="sprit.import_data"><code class="name flex">
<span>def <span class="ident">import_data</span></span>(<span>import_filepath, data_format='gzip', show_data=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_data(import_filepath, data_format=&#39;gzip&#39;, show_data=True):
    &#34;&#34;&#34;Function to import .hvsr (or other extension) data exported using export_hvsr() function

    Parameters
    ----------
    import_filepath : str or path object
        Filepath of file created using export_hvsr() function. This is usually a pickle file with a .hvsr extension
    data_format : str, default=&#39;pickle&#39;
        Type of format data is in. Currently, only &#39;pickle&#39; supported. Eventually, json or other type may be supported, by default &#39;pickle&#39;.

    Returns
    -------
    HVSRData or HVSRBatch object
    &#34;&#34;&#34;
    
    sample_list = [&#39;sample&#39;, &#39;sampledata&#39;, &#39;s&#39;]
    if import_filepath in sample_list:
        import_filepath = RESOURCE_DIR.joinpath(r&#39;sample_data&#39;)
        import_filepath = import_filepath.joinpath(r&#39;SampleHVSRSite01.hvsr&#39;)

    if data_format == &#39;pickle&#39;:
        with open(import_filepath, &#39;rb&#39;) as f:
            dataIN = pickle.load(f)
    elif data_format.lower() == &#39;dataframe&#39;:
        dataIN = pd.read_csv(import_filepath)
    else:
        try:
            with gzip.open(import_filepath, &#39;rb&#39;) as f:
                dataIN = pickle.loads(f.read())
        except Exception as e:
            with open(import_filepath, &#39;rb&#39;) as f:
                dataIN = pickle.load(f)
    
    if show_data:
        print(dataIN)
    
    return dataIN</code></pre>
</details>
<div class="desc"><p>Function to import .hvsr (or other extension) data exported using export_hvsr() function</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>import_filepath</code></strong> :&ensp;<code>str</code> or <code>path object</code></dt>
<dd>Filepath of file created using export_hvsr() function. This is usually a pickle file with a .hvsr extension</dd>
<dt><strong><code>data_format</code></strong> :&ensp;<code>str</code>, default=<code>'pickle'</code></dt>
<dd>Type of format data is in. Currently, only 'pickle' supported. Eventually, json or other type may be supported, by default 'pickle'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code> or <code><a title="sprit.HVSRBatch" href="#sprit.HVSRBatch">HVSRBatch</a> object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="sprit.import_settings"><code class="name flex">
<span>def <span class="ident">import_settings</span></span>(<span>settings_import_path, settings_import_type='instrument', verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_settings(settings_import_path, settings_import_type=&#39;instrument&#39;, verbose=False):
    &#34;&#34;&#34;Function to import settings, intended for use with settings saved to disk using export_settings

    Parameters
    ----------
    settings_import_path : pathlike object
        Filepath to exported settings document
    settings_import_type : str, optional
        What type of settings to export (can be &#39;instrument&#39; or &#39;all&#39;), by default &#39;instrument&#39;
    verbose : bool, optional
        Whether to print information to terminal, by default False

    Returns
    -------
    dict
        A dictionary containing the function names as keys of internal dictionaries, 
        with key:value pairs for each parameter name:value in that function.

    &#34;&#34;&#34;
    allList = [&#39;all&#39;, &#39;:&#39;, &#39;both&#39;, &#39;any&#39;]
    if settings_import_type.lower() not in allList:
        # if just a single settings dict is desired
        with open(settings_import_path, &#39;r&#39;) as f:
            settingsDict = json.load(f)
    else:
        # Either a directory or list
        if isinstance(settings_import_path, (list, tuple)):
            for setPath in settings_import_path:
                pass
        else:
            settings_import_path = sprit_utils._checkifpath(settings_import_path)
            if not settings_import_path.is_dir():
                raise RuntimeError(f&#39;settings_import_type={settings_import_type}, but settings_import_path is not list/tuple or filepath to directory&#39;)
            else:
                instFile = settings_import_path.glob(&#39;*.inst&#39;)
                procFile = settings_import_path.glob(&#39;*.proc&#39;)
    return settingsDict</code></pre>
</details>
<div class="desc"><p>Function to import settings, intended for use with settings saved to disk using export_settings</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>settings_import_path</code></strong> :&ensp;<code>pathlike object</code></dt>
<dd>Filepath to exported settings document</dd>
<dt><strong><code>settings_import_type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>What type of settings to export (can be 'instrument' or 'all'), by default 'instrument'</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print information to terminal, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the function names as keys of internal dictionaries,
with key:value pairs for each parameter name:value in that function.</dd>
</dl></div>
</dd>
<dt id="sprit.input_params"><code class="name flex">
<span>def <span class="ident">input_params</span></span>(<span>input_data,<br>site='HVSRSite',<br>project=None,<br>network='AM',<br>station='NONE',<br>location='00',<br>channels=['EHZ', 'EHN', 'EHE'],<br>acq_date=None,<br>starttime=None,<br>endtime=None,<br>tzone='UTC',<br>xcoord=-88.229,<br>ycoord=40.101,<br>elevation=225,<br>input_crs='EPSG:4326',<br>output_crs=None,<br>elev_unit='meters',<br>depth=0,<br>instrument='Seismometer',<br>metadata=None,<br>hvsr_band=[0.5, 40],<br>peak_freq_range=[0.5, 40],<br>processing_parameters={},<br>verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def input_params(input_data,
                site=&#39;HVSRSite&#39;,
                project=None,
                network=&#39;AM&#39;, 
                station=&#39;NONE&#39;, 
                location=&#39;00&#39;, 
                channels=[&#39;EHZ&#39;, &#39;EHN&#39;, &#39;EHE&#39;],
                acq_date = None,
                starttime = None,
                endtime = None,
                tzone = &#39;UTC&#39;,
                xcoord = -88.229,
                ycoord =  40.101,
                elevation = 225,
                input_crs = &#39;EPSG:4326&#39;, #Default is WGS84,#4269 is NAD83
                output_crs = None,
                elev_unit = &#39;meters&#39;,
                depth = 0,
                instrument = &#34;Seismometer&#34;,
                metadata = None,
                hvsr_band = DEFAULT_BAND,
                peak_freq_range = DEFAULT_BAND,
                processing_parameters={},
                verbose=False
                ):
    &#34;&#34;&#34;Function for designating input parameters for reading in and processing data
    
    Parameters
    ----------
    input_data : str or pathlib.Path object
        Filepath of data. This can be a directory or file, but will need to match with what is chosen later as the source parameter in fetch_data()
    site : str, default=&#34;HVSR Site&#34;
        Site name as designated by user for ease of reference. Used for plotting titles, filenames, etc.
    project : str, default=None
        A prefix that may be used to create unique identifiers for each site. 
        The identifier created is saved as the [&#39;HVSR_ID&#39;] attribute of the HVSRData object,
        and is equivalent to the following formatted string:
        f&#34;{project}-{acq_date.strftime(&#34;%Y%m%d&#34;)}-{starttime.strftime(&#34;%H%M&#34;)}-{station}&#34;.
    network : str, default=&#39;AM&#39;
        The network designation of the seismometer. This is necessary for data from Raspberry Shakes. &#39;AM&#39; is for Amateur network, which fits Raspberry Shakes.
    station : str, default=&#39;None&#39;
        The station name of the seismometer. This is necessary for data from Raspberry Shakes.
    location : str, default=&#39;00&#39;
        Location information of the seismometer.
    channels : list, default=[&#39;EHZ&#39;, &#39;EHN&#39;, &#39;EHE&#39;]
        The three channels used in this analysis, as a list of strings. Preferred that Z component is first, but not necessary
    acq_date : str, int, date object, or datetime object
        If string, preferred format is &#39;YYYY-MM-DD&#39;. 
        If int, this will be interpreted as the time_int of year of current year (e.g., 33 would be Feb 2 of current year)
        If date or datetime object, this will be the date. Make sure to account for time change when converting to UTC (if UTC is the following time_int, use the UTC time_int).
    starttime : str, time object, or datetime object, default=&#39;00:00:00.00&#39;
        Start time of data stream. This is necessary for Raspberry Shake data in &#39;raw&#39; form, or for trimming data. Format can be either &#39;HH:MM:SS.micros&#39; or &#39;HH:MM&#39; at minimum.
    endtime : str, time obejct, or datetime object, default=&#39;23:59:99.99&#39;
        End time of data stream. This is necessary for Raspberry Shake data in &#39;raw&#39; form, or for trimming data. Same format as starttime.
    tzone : str or int, default = &#39;UTC&#39;
        Timezone of input data. If string, &#39;UTC&#39; will use the time as input directly. Any other string value needs to be a TZ identifier in the IANA database, a wikipedia page of these is available here: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
        If int, should be the int value of the UTC offset (e.g., for American Eastern Standard Time: -5). 
        This is necessary for Raspberry Shake data in &#39;raw&#39; format.
    xcoord : float, default=-88.2290526
        Longitude (or easting, or, generally, X coordinate) of data point, in Coordinate Reference System (CRS) designated by input_crs. Currently only used in table output, but will likely be used in future for mapping/profile purposes.
    ycoord : float, default=40.1012122
        Latitute (or northing, or, generally, X coordinate) of data point, in Coordinate Reference System (CRS) designated by input_crs. Currently only used in table output, but will likely be used in future for mapping/profile purposes.
    input_crs : str or other format read by pyproj, default=&#39;EPSG:4326&#39;
        Coordinate reference system of input data, as used by pyproj.CRS.from_user_input()
    output_crs : str or other format read by pyproj, default=&#39;EPSG:4326&#39;
        Coordinate reference system to which input data will be transformed, as used by pyproj.CRS.from_user_input()
    elevation : float, default=755
        Surface elevation of data point. Not currently used (except in table output), but will likely be used in the future.
    depth : float, default=0
        Depth of seismometer. Not currently used, but will likely be used in the future.
    instrument : str {&#39;Raspberry Shake&#39;, &#34;Tromino&#34;}
        Instrument from which the data was acquired. 
    metadata : str or pathlib.Path object, default=None
        Filepath of metadata, in format supported by obspy.read_inventory. If default value of None, will read from resources folder of repository (only supported for Raspberry Shake).
    hvsr_band : list, default=[0.1, 50]
        Two-element list containing low and high &#34;corner&#34; frequencies (in Hz) for processing. This can specified again later.
    peak_freq_range : list or tuple, default=[0.1, 50]
        Two-element list or tuple containing low and high frequencies (in Hz) that are used to check for HVSR Peaks. This can be a tigher range than hvsr_band, but if larger, it will still only use the hvsr_band range.
    processing_parameters={} : dict or filepath, default={}
        If filepath, should point to a .proc json file with processing parameters (i.e, an output from sprit.export_settings()). 
        Note that this only applies to parameters for the functions: &#39;fetch_data&#39;, &#39;remove_noise&#39;, &#39;generate_psds&#39;, &#39;process_hvsr&#39;, &#39;check_peaks&#39;, and &#39;get_report.&#39;
        If dictionary, dictionary containing nested dictionaries of function names as they key, and the parameter names/values as key/value pairs for each key. 
        If a function name is not present, or if a parameter name is not present, default values will be used.
        For example: 
            `{ &#39;fetch_data&#39; : {&#39;source&#39;:&#39;batch&#39;, &#39;data_export_path&#39;:&#34;/path/to/trimmed/data&#34;, &#39;data_export_format&#39;:&#39;mseed&#39;, &#39;detrend&#39;:&#39;spline&#39;, &#39;plot_input_stream&#39;:True, &#39;verbose&#39;:False, kwargs:{&#39;kwargskey&#39;:&#39;kwargsvalue&#39;}} }`
    verbose : bool, default=False
        Whether to print output and results to terminal

    Returns
    -------
    params : sprit.HVSRData
        sprit.HVSRData class containing input parameters, including data file path and metadata path. This will be used as an input to other functions. If batch processing, params will be converted to batch type in fetch_data() step.

    &#34;&#34;&#34;
    orig_args = locals().copy() #Get the initial arguments
    # Record starting time for this function run
    start_time = datetime.datetime.now()

    # Record any updates that are made to input_params based
    update_msg = []
    
    # Reformat times
    # Date will come out of this block as a string of datetime.date
    if acq_date is None:
        date = str(datetime.datetime.now().date())
    elif type(acq_date) is datetime.datetime:
        date = str(acq_date.date())
    elif type(acq_date) is datetime.date:
        date=str(acq_date)
    elif type(acq_date) is str:
        monthStrs = {&#39;jan&#39;:1, &#39;january&#39;:1,
                    &#39;feb&#39;:2, &#39;february&#39;:2,
                    &#39;mar&#39;:3, &#39;march&#39;:3,
                    &#39;apr&#39;:4, &#39;april&#39;:4,
                    &#39;may&#39;:5,
                    &#39;jun&#39;:6, &#39;june&#39;:6,
                    &#39;jul&#39;:7, &#39;july&#39;:7,
                    &#39;aug&#39;:8, &#39;august&#39;:8,
                    &#39;sep&#39;:9, &#39;sept&#39;:9, &#39;september&#39;:9,
                    &#39;oct&#39;:10,&#39;october&#39;:10, 
                    &#39;nov&#39;:11,&#39;november&#39;:11,
                    &#39;dec&#39;:12,&#39;december&#39;:12}

        spelledMonth = False
        for m in monthStrs.keys():
            acq_date = acq_date.lower()
            if m in acq_date:
                spelledMonth = True
                break

        if spelledMonth is not False:
            month = monthStrs[m]

        if &#39;/&#39; in acq_date:
            sep = &#39;/&#39;
        elif &#39;.&#39; in acq_date:
            sep=&#39;.&#39;
        elif &#39; &#39; in acq_date:
            sep = &#39; &#39;
            acq_date = acq_date.replace(&#39;,&#39;, &#39;&#39;)
        else:
            sep = &#39;-&#39;

        acq_date = acq_date.split(sep)
        if len(acq_date[2]) &gt; 2: #American format
            date = &#39;{}-{}-{}&#39;.format(acq_date[2], acq_date[0], acq_date[1])
        else: #international format, one we&#39;re going to use
            date = &#39;{}-{}-{}&#39;.format(acq_date[0], acq_date[1], acq_date[2])     
    elif type(acq_date) is int:
        year=datetime.datetime.today().year
        date = str((datetime.datetime(year, 1, 1) + datetime.timedelta(acq_date - 1)).date())

    # Starttime will be standardized as string, then converted to UTCDateTime
    # If not specified, will be set to 00:00 of current UTC date
    if starttime is None:
        starttime = obspy.UTCDateTime(NOWTIME.year, NOWTIME.month, NOWTIME.day, 0, 0, 0, 0)
    elif type(starttime) is str:
        if &#39;T&#39; in starttime:
            #date=starttime.split(&#39;T&#39;)[0]
            starttime = starttime.split(&#39;T&#39;)[1]
        else:
            pass
            #starttime = date+&#39;T&#39;+starttime
    elif isinstance(starttime, datetime.datetime):
        starttime = starttime.time()
    elif type(starttime) is datetime.time():
        starttime = str(starttime)
    
    if not isinstance(starttime, obspy.UTCDateTime):
        starttime = str(date)+&#34;T&#34;+str(starttime)
    starttime = obspy.UTCDateTime(sprit_utils._format_time(starttime, tzone=tzone))
    
    if not isinstance(orig_args[&#39;starttime&#39;], obspy.UTCDateTime) or starttime != orig_args[&#39;starttime&#39;]:
        update_msg.append(f&#34;\t\tstarttime was updated from {orig_args[&#39;starttime&#39;]} to {starttime}&#34;)

    # endtime will be standardized as string, then converted to UTCDateTime
    # If not specified, will be set to 23:59:59.999999 of current UTC date
    if endtime is None:
        endtime = obspy.UTCDateTime(NOWTIME.year, NOWTIME.month, NOWTIME.day, 23, 59, 59, 999999)
    elif type(endtime) is str:
        if &#39;T&#39; in endtime:
            date=endtime.split(&#39;T&#39;)[0]
            endtime = endtime.split(&#39;T&#39;)[1]
    elif type(endtime) is datetime.datetime:
        date = str(endtime.date())
        endtime = str(endtime.time())
    elif type(endtime) is datetime.time():
        endtime = str(endtime)

    if not isinstance(endtime, obspy.UTCDateTime):
        endtime = str(date)+&#34;T&#34;+str(endtime)
    endtime = obspy.UTCDateTime(sprit_utils._format_time(endtime, tzone=tzone))

    if not isinstance(orig_args[&#39;starttime&#39;], obspy.UTCDateTime) or starttime != orig_args[&#39;starttime&#39;]:
        update_msg.append(f&#34;\t\tendtime was updated from {orig_args[&#39;endtime&#39;]} to {endtime}&#34;)

    acq_date = datetime.date(year=int(date.split(&#39;-&#39;)[0]), month=int(date.split(&#39;-&#39;)[1]), day=int(date.split(&#39;-&#39;)[2]))
    if acq_date != orig_args[&#39;acq_date&#39;]:
        update_msg.append(f&#34;\t\tacq_date was updated from {orig_args[&#39;acq_date&#39;]} to {acq_date}&#34;)

    raspShakeInstNameList = [&#39;raspberry shake&#39;, &#39;shake&#39;, &#39;raspberry&#39;, &#39;rs&#39;, &#39;rs3d&#39;, &#39;rasp. shake&#39;, &#39;raspshake&#39;]
    
    # If no CRS specified, assume WGS84
    if input_crs is None or input_crs == &#39;&#39;:
        if verbose:
            update_msg.append(f&#34;\t\tNo value specified for input_crs, assuming WGS84 (EPSG:4326)&#34;)
        input_crs = &#39;EPSG:4326&#39;
    
    if output_crs is None:
        if verbose:
            update_msg.append(f&#34;\t\tNo value specified for output_crs, using same coordinate system is input_crs: ({input_crs})&#34;)
        output_crs = input_crs

    if xcoord is None or xcoord == &#39;&#39;:
        xcoord = 0.0
    else:
        xcoord = float(xcoord)
    
    if ycoord is None or ycoord == &#39;&#39;:
        ycoord = 0.0
    else:
        ycoord = float(ycoord)
    # Get CRS Objects
    input_crs = CRS.from_user_input(input_crs)
    output_crs = CRS.from_user_input(output_crs)

    # We always need latitude and longitude, so specify this regadless of in/output crs
    # Get WGS84 coordinates (needed for inventory)
    wgs84_crs = CRS.from_user_input(&#39;EPSG:4326&#39;)
    wgs84_transformer = Transformer.from_crs(input_crs, wgs84_crs, always_xy=True)
    xcoord_wgs84, ycoord_wgs84 = wgs84_transformer.transform(xcoord, ycoord)

    xcoord_wgs84 = round(xcoord_wgs84, 7)
    ycoord_wgs84 = round(ycoord_wgs84, 7)

    update_msg.append(f&#34;\t\tLongitude ({xcoord_wgs84}) and Latitude ({ycoord_wgs84}) calculated for compatibility with obspy.&#34;)

    # Get coordinates in CRS specified in output_crs
    xcoordIN = xcoord
    ycoordIN = ycoord
    coord_transformer = Transformer.from_crs(input_crs, output_crs, always_xy=True)
    xcoord, ycoord = coord_transformer.transform(xcoordIN, ycoordIN)

    if isinstance(processing_parameters, dict):
        pass
    else:
        processing_parameters = sprit_utils._checkifpath(processing_parameters)
        processing_parameters = import_settings(processing_parameters, settings_import_type=&#39;processing&#39;, verbose=verbose)

    # Get elevation in meters
    if str(elev_unit).lower() in [&#39;feet&#39;, &#39;foot&#39;, &#39;ft&#39;, &#39;f&#39;, &#39;imperial&#39;, &#39;imp&#39;, &#39;american&#39;, &#39;us&#39;]:
        elevation = elevation * 0.3048
        elev_unit = &#39;meters&#39;
        update_msg.append(f&#34;\t\t Elevations are automatically converted to meters during processing&#34;)
        update_msg.append(f&#34;\t\t elevation was updated to {elevation} m (from {orig_args[&#39;elevation&#39;]} ft)&#34;)
        update_msg.append(f&#34;\t\t elev_unit was also updated to {elev_unit} (from {orig_args[&#39;elev_unit&#39;]})&#34;)
    
    # Create a unique identifier for each site
    if project is None:
        proj_id = &#39;&#39;
    else:
        proj_id = str(project)+&#39;-&#39;
    
    hvsr_id = f&#34;{proj_id}{acq_date.strftime(&#39;%Y%m%d&#39;)}-{starttime.strftime(&#39;%H%M&#39;)}-{station}&#34;
    update_msg.append(f&#34;\t\thvsr_id generated from input parameters: {hvsr_id}&#34;)

    #Add key/values to input parameter dictionary for use throughout the rest of the package
    inputParamDict = {&#39;site&#39;:site, &#39;project&#39;:project, &#39;hvsr_id&#39;:hvsr_id, &#39;network&#39;:network, &#39;station&#39;:station,&#39;location&#39;:location, &#39;channels&#39;:channels,
                      &#39;net&#39;:network,&#39;sta&#39;:station, &#39;loc&#39;:location, &#39;cha&#39;:channels, &#39;instrument&#39;:instrument,
                      &#39;acq_date&#39;:acq_date,&#39;starttime&#39;:starttime,&#39;endtime&#39;:endtime, &#39;timezone&#39;:&#39;UTC&#39;, #Will be in UTC by this point
                      &#39;xcoord_input&#39;:xcoordIN, &#39;ycoord_input&#39;: ycoordIN ,&#39;xcoord&#39;:xcoord, &#39;ycoord&#39;:ycoord, &#39;longitude&#39;:xcoord_wgs84,&#39;latitude&#39;:ycoord_wgs84,
                      &#39;elevation&#39;:elevation, &#39;elev_unit&#39;:elev_unit, &#39;input_crs&#39;:input_crs, &#39;output_crs&#39;:output_crs,
                      &#39;depth&#39;:depth, &#39;input_data&#39;: input_data, &#39;metadata&#39;:metadata, &#39;hvsr_band&#39;:hvsr_band, &#39;peak_freq_range&#39;:peak_freq_range,
                      &#39;processing_parameters&#39;:processing_parameters, &#39;processing_status&#39;:{&#39;input_params_status&#39;:True, &#39;overall_status&#39;:True}
                      }
    

    #Replace any default parameter settings with those from json file of interest, potentially
    instrument_settings_dict = {}
    if pathlib.Path(str(instrument)).exists():
        instrument_settings = import_settings(settings_import_path=instrument, settings_import_type=&#39;instrument&#39;, verbose=verbose)
        input_params_args = inspect.getfullargspec(input_params).args
        input_params_args.append(&#39;net&#39;)
        input_params_args.append(&#39;sta&#39;)
        for k, settings_value in instrument_settings.items():
            if k in input_params_args:
                instrument_settings_dict[k] = settings_value
        inputParamDict[&#39;instrument_settings&#39;] = inputParamDict[&#39;instrument&#39;]
        inputParamDict.update(instrument_settings_dict)
    
    if str(instrument).lower() in raspShakeInstNameList:
        if metadata is None or metadata==&#39;&#39;:
            metadata = pathlib.Path(str(importlib.resources.files(&#39;sprit&#39;))).joinpath(&#39;resources&#39;).joinpath(&#34;rs3dv5plus_metadata.inv&#34;).as_posix()
            inputParamDict[&#39;metadata&#39;] = metadata

    for settingName in instrument_settings_dict.keys():
        if settingName in inputParamDict.keys():
            inputParamDict[settingName] = instrument_settings_dict[settingName]

    if verbose:
        print(&#39;Gathering input parameters (input_params())&#39;)
        for key, value in inputParamDict.items():
            print(&#39;\t  {}={}&#39;.format(key, value))
        print()

        update_msg.insert(0, &#39;\tThe following parameters were modified from the raw input:&#39;)
        for msg_line in update_msg:
            print(msg_line)
        print()
        
    #Format everything nicely
    params = sprit_utils._make_it_classy(inputParamDict)
    params[&#39;processing_status&#39;][&#39;input_params_status&#39;] = True
    params = sprit_utils._check_processing_status(params, start_time=start_time, func_name=inspect.stack()[0][3], verbose=verbose)
    return params</code></pre>
</details>
<div class="desc"><p>Function for designating input parameters for reading in and processing data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>input_data</code></strong> :&ensp;<code>str</code> or <code>pathlib.Path object</code></dt>
<dd>Filepath of data. This can be a directory or file, but will need to match with what is chosen later as the source parameter in fetch_data()</dd>
<dt><strong><code>site</code></strong> :&ensp;<code>str</code>, default=<code>"HVSR Site"</code></dt>
<dd>Site name as designated by user for ease of reference. Used for plotting titles, filenames, etc.</dd>
<dt><strong><code>project</code></strong> :&ensp;<code>str</code>, default=<code>None</code></dt>
<dd>A prefix that may be used to create unique identifiers for each site.
The identifier created is saved as the ['HVSR_ID'] attribute of the HVSRData object,
and is equivalent to the following formatted string:
f"{project}-{acq_date.strftime("%Y%m%d")}-{starttime.strftime("%H%M")}-{station}".</dd>
<dt><strong><code>network</code></strong> :&ensp;<code>str</code>, default=<code>'AM'</code></dt>
<dd>The network designation of the seismometer. This is necessary for data from Raspberry Shakes. 'AM' is for Amateur network, which fits Raspberry Shakes.</dd>
<dt><strong><code>station</code></strong> :&ensp;<code>str</code>, default=<code>'None'</code></dt>
<dd>The station name of the seismometer. This is necessary for data from Raspberry Shakes.</dd>
<dt><strong><code>location</code></strong> :&ensp;<code>str</code>, default=<code>'00'</code></dt>
<dd>Location information of the seismometer.</dd>
<dt><strong><code>channels</code></strong> :&ensp;<code>list</code>, default=<code>['EHZ', 'EHN', 'EHE']</code></dt>
<dd>The three channels used in this analysis, as a list of strings. Preferred that Z component is first, but not necessary</dd>
<dt><strong><code>acq_date</code></strong> :&ensp;<code>str, int, date object,</code> or <code>datetime object</code></dt>
<dd>If string, preferred format is 'YYYY-MM-DD'.
If int, this will be interpreted as the time_int of year of current year (e.g., 33 would be Feb 2 of current year)
If date or datetime object, this will be the date. Make sure to account for time change when converting to UTC (if UTC is the following time_int, use the UTC time_int).</dd>
<dt><strong><code>starttime</code></strong> :&ensp;<code>str, time object,</code> or <code>datetime object</code>, default=<code>'00:00:00.00'</code></dt>
<dd>Start time of data stream. This is necessary for Raspberry Shake data in 'raw' form, or for trimming data. Format can be either 'HH:MM:SS.micros' or 'HH:MM' at minimum.</dd>
<dt><strong><code>endtime</code></strong> :&ensp;<code>str, time obejct,</code> or <code>datetime object</code>, default=<code>'23:59:99.99'</code></dt>
<dd>End time of data stream. This is necessary for Raspberry Shake data in 'raw' form, or for trimming data. Same format as starttime.</dd>
<dt><strong><code>tzone</code></strong> :&ensp;<code>str</code> or <code>int</code>, default <code>= 'UTC'</code></dt>
<dd>Timezone of input data. If string, 'UTC' will use the time as input directly. Any other string value needs to be a TZ identifier in the IANA database, a wikipedia page of these is available here: <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.">https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.</a>
If int, should be the int value of the UTC offset (e.g., for American Eastern Standard Time: -5).
This is necessary for Raspberry Shake data in 'raw' format.</dd>
<dt><strong><code>xcoord</code></strong> :&ensp;<code>float</code>, default=<code>-88.2290526</code></dt>
<dd>Longitude (or easting, or, generally, X coordinate) of data point, in Coordinate Reference System (CRS) designated by input_crs. Currently only used in table output, but will likely be used in future for mapping/profile purposes.</dd>
<dt><strong><code>ycoord</code></strong> :&ensp;<code>float</code>, default=<code>40.1012122</code></dt>
<dd>Latitute (or northing, or, generally, X coordinate) of data point, in Coordinate Reference System (CRS) designated by input_crs. Currently only used in table output, but will likely be used in future for mapping/profile purposes.</dd>
<dt><strong><code>input_crs</code></strong> :&ensp;<code>str</code> or <code>other format read by pyproj</code>, default=<code>'EPSG:4326'</code></dt>
<dd>Coordinate reference system of input data, as used by pyproj.CRS.from_user_input()</dd>
<dt><strong><code>output_crs</code></strong> :&ensp;<code>str</code> or <code>other format read by pyproj</code>, default=<code>'EPSG:4326'</code></dt>
<dd>Coordinate reference system to which input data will be transformed, as used by pyproj.CRS.from_user_input()</dd>
<dt><strong><code>elevation</code></strong> :&ensp;<code>float</code>, default=<code>755</code></dt>
<dd>Surface elevation of data point. Not currently used (except in table output), but will likely be used in the future.</dd>
<dt><strong><code>depth</code></strong> :&ensp;<code>float</code>, default=<code>0</code></dt>
<dd>Depth of seismometer. Not currently used, but will likely be used in the future.</dd>
<dt><strong><code>instrument</code></strong> :&ensp;<code>str {'Raspberry Shake', "Tromino"}</code></dt>
<dd>Instrument from which the data was acquired.</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>str</code> or <code>pathlib.Path object</code>, default=<code>None</code></dt>
<dd>Filepath of metadata, in format supported by obspy.read_inventory. If default value of None, will read from resources folder of repository (only supported for Raspberry Shake).</dd>
<dt><strong><code>hvsr_band</code></strong> :&ensp;<code>list</code>, default=<code>[0.1, 50]</code></dt>
<dd>Two-element list containing low and high "corner" frequencies (in Hz) for processing. This can specified again later.</dd>
<dt><strong><code>peak_freq_range</code></strong> :&ensp;<code>list</code> or <code>tuple</code>, default=<code>[0.1, 50]</code></dt>
<dd>Two-element list or tuple containing low and high frequencies (in Hz) that are used to check for HVSR Peaks. This can be a tigher range than hvsr_band, but if larger, it will still only use the hvsr_band range.</dd>
<dt>processing_parameters={} : dict or filepath, default={}</dt>
<dt>If filepath, should point to a .proc json file with processing parameters (i.e, an output from sprit.export_settings()).</dt>
<dt>Note that this only applies to parameters for the functions: 'fetch_data', 'remove_noise', 'generate_psds', 'process_hvsr', 'check_peaks', and 'get_report.'</dt>
<dt>If dictionary, dictionary containing nested dictionaries of function names as they key, and the parameter names/values as key/value pairs for each key.</dt>
<dt>If a function name is not present, or if a parameter name is not present, default values will be used.</dt>
<dt>For example:</dt>
<dt><code>{ 'fetch_data' : {'source':'batch', 'data_export_path':"/path/to/trimmed/data", 'data_export_format':'mseed', 'detrend':'spline', 'plot_input_stream':True, 'verbose':False, kwargs:{'kwargskey':'kwargsvalue'}} }</code></dt>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to print output and results to terminal</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code></dt>
<dd>sprit.HVSRData class containing input parameters, including data file path and metadata path. This will be used as an input to other functions. If batch processing, params will be converted to batch type in fetch_data() step.</dd>
</dl></div>
</dd>
<dt id="sprit.parse_plot_string"><code class="name flex">
<span>def <span class="ident">parse_plot_string</span></span>(<span>plot_string)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_plot_string(plot_string):
    &#34;&#34;&#34;Function to parse a plot string into a list readable by plotting functions

    Parameters
    ----------
    plot_string : str
        Plot string used by sprit.plot_hvsr to define results plot

    Returns
    -------
    list
        A list readable by various sprit plotting functions to show what to include in the results plot.
    &#34;&#34;&#34;
    plot_list = plot_string.split()

    hvsrList = [&#39;hvsr&#39;, &#39;hv&#39;, &#39;h&#39;]
    compList = [&#39;component&#39;, &#39;comp&#39;, &#39;c&#39;]
    compPlus = [item + &#39;+&#39; for item in compList]
    specList = [&#39;spectrogram&#39;, &#39;specgram&#39;, &#39;spec&#39;,&#39;sg&#39;, &#39;s&#39;]

    hvInd = np.nan
    compInd = np.nan
    specInd = np.nan

    hvIndFound = False
    compIndFound = False
    specIndFound = False

    for i, item in enumerate(plot_list):
        if item.lower() in hvsrList and not hvIndFound:
            # assign the index
            hvInd = i
            hvIndFound = True
        if (item.lower() in compList or item.lower() in compPlus) and not compIndFound:
            # assign the index
            compInd = i
            compIndFound = True
        if item.lower() in specList and not specIndFound:
            # assign the index
            specInd = i
            specIndFound = True

    # Get individual plot lists (should already be correctly ordered)
    if hvInd is np.nan:
        hvsr_plot_list = [&#39;HVSR&#39;]

    if compInd is np.nan:
        comp_plot_list = []
        if specInd is np.nan:
            if hvInd is not np.nan:
                hvsr_plot_list = plot_list
            spec_plot_list = []
        else:
            if hvInd is not np.nan:
                hvsr_plot_list = plot_list[hvInd:specInd]
            spec_plot_list = plot_list[specInd:]
    else:
        if hvInd is not np.nan:
            hvsr_plot_list = plot_list[hvInd:compInd]
        
        if specInd is np.nan:
            comp_plot_list = plot_list[compInd:]
            spec_plot_list = []
        else:
            comp_plot_list = plot_list[compInd:specInd]
            spec_plot_list = plot_list[specInd:]

    # Figure out how many subplots there will be
    plot_list_list = [hvsr_plot_list, comp_plot_list, spec_plot_list]

    return plot_list_list</code></pre>
</details>
<div class="desc"><p>Function to parse a plot string into a list readable by plotting functions</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>plot_string</code></strong> :&ensp;<code>str</code></dt>
<dd>Plot string used by sprit.plot_hvsr to define results plot</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list readable by various sprit plotting functions to show what to include in the results plot.</dd>
</dl></div>
</dd>
<dt id="sprit.plot_azimuth"><code class="name flex">
<span>def <span class="ident">plot_azimuth</span></span>(<span>hvsr_data,<br>fig=None,<br>ax=None,<br>show_azimuth_peaks=False,<br>interpolate_azimuths=True,<br>show_azimuth_grid=False,<br>show_plot=True,<br>**plot_azimuth_kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_azimuth(hvsr_data, fig=None, ax=None, show_azimuth_peaks=False, interpolate_azimuths=True, show_azimuth_grid=False, show_plot=True, **plot_azimuth_kwargs):
    &#34;&#34;&#34;Function to plot azimuths when azimuths are calculated

    Parameters
    ----------
    hvsr_data : HVSRData or HVSRBatch
        HVSRData that has gone through at least the sprit.fetch_data() step, and before sprit.generate_psds()
    show_azimuth_peaks : bool, optional
        Whether to display the peak value at each azimuth calculated on the chart, by default False
    interpolate_azimuths : bool, optional
        Whether to interpolate the azimuth data to get a smoother plot. 
        This is just for visualization, does not change underlying data.
        It takes a lot of time to process the data, but interpolation for vizualization can happen fairly fast. By default True.
    show_azimuth_grid : bool, optional
        Whether to display the grid on the chart, by default False

    Returns
    -------
    matplotlib.Figure, matplotlib.Axis
        Figure and axis of resulting azimuth plot
    &#34;&#34;&#34;
    orig_args = locals().copy() #Get the initial arguments

    if isinstance(hvsr_data, HVSRBatch):
        #If running batch, we&#39;ll loop through each site
        for site_name in hvsr_data.keys():
            args = orig_args.copy() #Make a copy so we don&#39;t accidentally overwrite
            individual_params = hvsr_data[site_name] #Get what would normally be the &#34;params&#34; variable for each site
            args[&#39;hvsr_data&#39;] = individual_params #reset the params parameter we originally read in to an individual site params
            if hvsr_data[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;]:
                try:
                    hvsr_data[&#39;Azimuth_Fig&#39;] = __plot_azimuth_batch(**args) #Call another function, that lets us run this function again
                except:
                    print(f&#34;ERROR: {site_name} will not have azimuths plotted.&#34;)
    elif isinstance(hvsr_data, HVSRData):
        if fig is None:
            fig = plt.figure()

        hvsr_band = hvsr_data.hvsr_band

        azDataList = []
        azExtraDataList = []

        for k in sorted(hvsr_data.hvsr_az.keys()):
            currData = hvsr_data.hvsr_az[k]
            azDataList.append(currData)
            azExtraDataList.append(currData)
        
            
        freq = hvsr_data.x_freqs[&#39;Z&#39;].tolist()[1:]
        a = np.deg2rad(np.array(sorted(hvsr_data.hvsr_az.keys())).astype(float))
        b = a + np.pi

        z = np.array(azDataList)
        z2 =np.array(azExtraDataList)

        def interp_along_theta(orig_array, orig_ind):
            newArrayList = []
            for a1 in orig_array.T:
                # Resample the array along the first dimension using numpy.interp
                newZ = np.interp(
                    np.linspace(np.pi/180, np.pi, 180),  # New indices
                    orig_ind,  # Original indices
                    a1)
                newArrayList.append(newZ)
            return np.array(newArrayList).T

        if &#39;plot_type&#39; in plot_azimuth_kwargs.keys():
            if &#39;i&#39; in plot_azimuth_kwargs[&#39;plot_type&#39;]:
                interpolate_azimuths = True
            if &#39;-i&#39; in plot_azimuth_kwargs[&#39;plot_type&#39;]:
                interpolate_azimuths = False


        if interpolate_azimuths:
            z = interp_along_theta(z, a)
            z2 = interp_along_theta(z2, a)

            a =  np.linspace(np.deg2rad(1), np.pi, 180)
            b = (a + np.pi).tolist()
            a = a.tolist()

        r, th = np.meshgrid(freq, a)
        r2, th2 = np.meshgrid(freq, b)

        # Set up plot
        if ax is None:
            ax = plt.subplot(polar=True)
            plt.title(hvsr_data[&#39;site&#39;])

        else:
            plt.sca(ax)

        plt.semilogy()
        ax.set_theta_zero_location(&#34;N&#34;)
        ax.set_theta_direction(-1)
        plt.xlim([0, np.pi*2])
        plt.ylim([hvsr_band[1], hvsr_band[0]])

        # Plot data
        pmesh1 = plt.pcolormesh(th, r, z, cmap = &#39;jet&#39;)
        pmesh2 = plt.pcolormesh(th2, r2, z2, cmap = &#39;jet&#39;)

        azList = [&#39;azimuth&#39;, &#39;az&#39;, &#39;a&#39;, &#39;radial&#39;, &#39;r&#39;]
        azOpts = []
        if &#39;plot_type&#39; in plot_azimuth_kwargs.keys():
            if type(plot_azimuth_kwargs[&#39;plot_type&#39;]) is str:
                ptList = plot_azimuth_kwargs[&#39;plot_type&#39;].split(&#39; &#39;)
            elif isinstance(plot_azimuth_kwargs[&#39;plot_type&#39;], (list, tuple)):
                ptList = list(plot_azimuth_kwargs[&#39;plot_type&#39;])

            for az in azList:
                if az in ptList:
                    azOpts = [item.lower() for item in ptList[ptList.index(az)+1:]]

        if &#39;p&#39; in azOpts:
            show_azimuth_peaks = True

        if &#39;g&#39; in azOpts:
            show_azimuth_grid = True

        if show_azimuth_peaks:
            peakVals = []
            peakThetas = []
            for k in sorted(hvsr_data.hvsr_az.keys()):
                peakVals.append(hvsr_data.BestPeak[k][&#39;f0&#39;])
                peakThetas.append(int(k))
            peakThetas = peakThetas + (180 + np.array(peakThetas)).tolist()
            peakThetas = np.deg2rad(peakThetas).tolist()
            peakVals = peakVals + peakVals
            peakVals.append(peakVals[0])
            peakThetas.append(peakThetas[0]+(np.pi*2))
            peakThetas.append(peakThetas[1]+(np.pi*2))

            peakThetas = (np.convolve(peakThetas, np.ones(2), &#39;full&#39;)/2).tolist()[1:-1]
            newThetas = []
            newVals = []
            for i, p in enumerate(peakThetas):
                newThetas.append(p)
                newThetas.append(p)
                if i == 0:
                    newVals.append(peakVals[-1])
                    newVals.append(peakVals[-1])
                else:
                    newVals.append(peakVals[i])
                    newVals.append(peakVals[i])

            newThetas.insert(0, newThetas[-1])
            newThetas.pop()

            newVals.append(newVals[0])
            newThetas.append(newThetas[0])

            #peakThetas = newThetas
            #peakVals = newVals
            if len(peakThetas) &gt;= 20:
                alphaVal = 0.2
            else:
                alphaVal = 0.9 - (19/28) 
            plt.scatter(peakThetas, peakVals, marker=&#39;h&#39;, facecolors=&#39;none&#39;, edgecolors=&#39;k&#39;, alpha=alphaVal)
        #plt.plot(a, r, ls=&#39;none&#39;, color = &#39;k&#39;) 

        if show_azimuth_grid:
            plt.grid(visible=show_azimuth_grid, which=&#39;both&#39;, alpha=0.5)
            plt.grid(visible=show_azimuth_grid, which=&#39;major&#39;, c=&#39;k&#39;, linewidth=1, alpha=1)
        #plt.colorbar(pmesh1)
        if show_plot:
            plt.show()

        hvsr_data[&#39;AzimuthFig&#39;] = fig
    else:
        warnings.warn(f&#39;hvsr_data must be of type HVSRData or HVSRBatch, not {type(hvsr_data)}&#39;)
    return fig, ax</code></pre>
</details>
<div class="desc"><p>Function to plot azimuths when azimuths are calculated</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code> or <code><a title="sprit.HVSRBatch" href="#sprit.HVSRBatch">HVSRBatch</a></code></dt>
<dd>HVSRData that has gone through at least the sprit.fetch_data() step, and before sprit.generate_psds()</dd>
<dt><strong><code>show_azimuth_peaks</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to display the peak value at each azimuth calculated on the chart, by default False</dd>
<dt><strong><code>interpolate_azimuths</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to interpolate the azimuth data to get a smoother plot.
This is just for visualization, does not change underlying data.
It takes a lot of time to process the data, but interpolation for vizualization can happen fairly fast. By default True.</dd>
<dt><strong><code>show_azimuth_grid</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to display the grid on the chart, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>matplotlib.Figure, matplotlib.Axis</code></dt>
<dd>Figure and axis of resulting azimuth plot</dd>
</dl></div>
</dd>
<dt id="sprit.plot_cross_section"><code class="name flex">
<span>def <span class="ident">plot_cross_section</span></span>(<span>hvsr_data,<br>title=None,<br>fig=None,<br>ax=None,<br>use_elevation=True,<br>show_feet=False,<br>primary_unit='m',<br>show_curves=True,<br>annotate_curves=False,<br>curve_alignment='peak',<br>grid_size='auto',<br>orientation='WE',<br>interpolation_type='cloughtocher',<br>interpolate_log_values=True,<br>surface_elevations=None,<br>show_peak_points=True,<br>smooth_bedrock_surface=False,<br>depth_limit=150,<br>minimum_elevation=None,<br>show_bedrock_surface=True,<br>return_data_batch=True,<br>show_cross_section=True,<br>verbose=False,<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_cross_section(hvsr_data,  title=None, fig=None, ax=None, use_elevation=True, show_feet=False, primary_unit=&#39;m&#39;, 
                       show_curves=True, annotate_curves=False, curve_alignment=&#39;peak&#39;,
                       grid_size=&#39;auto&#39;, orientation=&#39;WE&#39;, 
                       interpolation_type=&#39;cloughtocher&#39;, interpolate_log_values=True,
                       surface_elevations=None, show_peak_points=True, smooth_bedrock_surface=False,
                       depth_limit=150, minimum_elevation=None, show_bedrock_surface=True,
                       return_data_batch=True, show_cross_section=True, verbose=False,
                       **kwargs):
    &#34;&#34;&#34;Function to plot a cross section given an HVSRBatch or similar object

    Parameters
    ----------
    hvsr_data : HVSRBatch, list, or similar
        HVSRBatch (intended usage) object with HVSRData objects to show in profile/cross section view
    title : str, optional
        Title to use for plot, by default None
    fig : matplotlib.Figure, optional
        Figure to use for plot, by default None
    ax : matplotlib.Axis, optional
        Axis to use for plot, by default None
    use_elevation : bool, optional
        Whether to use elevation (if True) or depth (if False), by default True
    show_feet : bool, optional
        Whether to show feet (if True) or meters (if False), by default False
    primary_unit : str, optional
        Primary unit to use (&#39;m&#39; or &#39;ft&#39;), by default &#39;m&#39;
    show_curves : bool, optional
        Whether to also show curves on plot, by default True
    annotate_curves : bool, optional
        Whether to annotate curves by plotting site names next to them, by default False
    curve_alignment : str, optional
        How to horizontally align the curve. 
        If &#34;peak&#34; the curve will be aligned so that the peak is at the correct latitude or longitude.
        If &#34;max&#34; will align the maximum point of the curve to the correct location.
        If any other value, will align at the surface (i.e., highest frequency). By default &#39;peak&#39;.
    grid_size : list, optional
        Two item list with height and width of grid for interpolation.
        If &#34;auto&#34; this will be calculated based on the data, by default &#39;auto&#39;.
    orientation : str, optional
        The orientation of the cross section. 
        Should be either &#34;WE&#34;, &#34;EW&#34;, &#34;NS&#34;, or &#34;SN&#34;, by default &#39;WE&#39;.
    interpolation_type : str, optional
        Interpolation type to use. Uses scipy.interpolation.
        Options include: &#39;cloughtocher&#39;, &#39;nearest neighbor&#39;, &#39;linear&#39;, 
        or &#39;radial basis function&#39;, by default &#39;cloughtocher&#39;.
    interpolate_log_values : bool, optional
        Whether to use log values of the H/V curve for interpolation (can be useful for better normalizing data)
    surface_elevations : shapely.LineString, optional
        A shapely.LineString object containing surface elevation coordinates along cross section path.
        If None, uses elevation data in HVSRBatch specified by hvsr_data, by default None.
    show_peak_points : bool, optional
        Whether to plot small triangles where peaks were picked, by default True
    smooth_bedrock_surface : bool, optional
        Whether to smooth the bedrock surface when plotting, by default False
    depth_limit : int, optional
        Depth limit for the plot, by default 150
    minimum_elevation : _type_, optional
        Minimum elevation of the plot, by default None
    show_bedrock_surface : bool, optional
        Whether to show the bedrock surface, by default True
    return_data_batch : bool, optional
        Whether to return the HVSRBatch object, by default True
    show_cross_section : bool, optional
        Whether to show the cross section plot, by default True
    verbose : bool, optional
        Whether to print information about the process to terminal, by default False

    Returns
    -------
    figure
        Currently only matplotlib figure supported
    &#34;&#34;&#34;
    if verbose:
        print(&#34;Getting cross section plot configuration&#34;)
        
    if fig is None and ax is None:
        fig, ax = plt.subplots()
    elif ax is None and fig is not None:
        fig = fig
        ax = fig.get_axes()[0]
    elif fig is None and ax is not None:
        ax = ax
        fig = plt.figure()
        fig.axes.append(ax)
    else:
        fig = fig
        ax = ax
    plt.sca(ax)
    
    if verbose:
        print(&#34;Getting data batch for cross section plot&#34;)
    batchExt = None
    if isinstance(hvsr_data, (str, os.PathLike, pathlib.Path)):
        if pathlib.Path(hvsr_data).exists() and pathlib.Path(hvsr_data).is_dir():
            batchExt = &#39;hvsr&#39;
    hvDataBatch = sprit_hvsr.HVSRBatch(hvsr_data, batch_ext=batchExt)
    
    if verbose:
        print(&#34;Sorting and Orienting data&#34;)
    # Get orientation/order of data
    nsList = [&#39;ns&#39;, &#34;north-south&#34;, &#39;northsouth&#39;, &#39;south&#39;, &#39;s&#39;]
    snList = [&#39;sn&#39;, &#34;south-north&#34;, &#39;southnorth&#39;, &#39;north&#39;, &#39;n&#39;]
    weList = [&#39;we&#39;, &#34;west-east&#34;, &#39;westeast&#39;, &#39;east&#39;, &#39;e&#39;]
    ewList = [&#39;ew&#39;, &#34;east-west&#34;, &#39;eastwest&#39;, &#39;west&#39;, &#39;w&#39;]

    if str(orientation).lower() in nsList:
        ordercoord = &#39;latitude&#39;
        order = &#39;descending&#39;
        profile_direction = &#39;north-south&#39;
    elif str(orientation).lower() in snList:
        ordercoord = &#39;latitude&#39;
        order = &#39;ascending&#39;
        profile_direction  = &#39;south-north&#39;
    elif str(orientation).lower() in weList:
        ordercoord = &#39;longitude&#39;
        order = &#39;ascending&#39;
        profile_direction = &#39;west-east&#39;
    elif str(orientation).lower() in ewList:
        ordercoord = &#39;longitude&#39;
        order = &#39;descending&#39;
        profile_direction = &#39;east-west&#39;
    else:
        if verbose:
            print(f&#34;Value for orientation={orientation} is not recognized. Using West-East orientation.&#34;)
        order = &#39;ascending&#39;
        ordercoord=&#39;longitude&#39;
        profile_direction = &#39;west-east (default)&#39;

    # Get data in correct order, as specified by orientation parameter
    reverseit = (order == &#39;descending&#39;)
    sorted_sites = sorted(hvDataBatch, key=lambda site: hvDataBatch[site][ordercoord], reverse=reverseit)
    hvDataSorted = [hvDataBatch[h] for h in sorted_sites]

    if verbose:
        print(f&#39;Plotting {len(hvDataBatch.sites)} sites, {profile_direction}.&#39;)
        [print(f&#34;\t{hvdata.site[:12]:&lt;12}: {hvdata.longitude:&gt;8.4f}, {hvdata.latitude:&gt;8.4f}, {hvdata.elevation:&lt;6.1f}&#34;) for hvdata in hvDataSorted]

    # Get cross section profile
    shapelyPoints = []
    interpData = []
    interpCoords = {&#39;longitude&#39;:[], &#39;latitude&#39;:[], &#39;elevation&#39;:[]}
    for i, hvData in enumerate(hvDataSorted):
        if not hasattr(hvData, &#39;x_elev_m&#39;):
            calc_depth_kwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(sprit_calibration.calculate_depth).parameters.keys())}
            hvData = sprit_calibration.calculate_depth(hvData, **calc_depth_kwargs, verbose=verbose)
        
        # Create shapely Point objects at each profile location
        x = hvData[&#39;longitude&#39;]
        y = hvData[&#39;latitude&#39;]
        z = hvData[&#39;elevation&#39;]

        shapelyPoints.append(shapely.Point(x, y, z))

        # Points arranged for interpolation
        if interpolate_log_values:
            interpData.extend(list(np.log10(hvData.hvsr_curve)))
        else:
            interpData.extend(list(hvData.hvsr_curve))
        for i, pt in enumerate(hvData.hvsr_curve):
            interpCoords[&#39;longitude&#39;].append(x)
            interpCoords[&#39;latitude&#39;].append(y)
            interpCoords[&#39;elevation&#39;].append(hvData[&#39;x_elev_m&#39;][&#39;Z&#39;][i])

        # Since already doing loop, ensure hvData has all depth/elev info it needs
        if not hasattr(hvData, &#39;x_elev_m&#39;):
            calc_depth_kwargs = {k: v for k, v in kwargs.items()
                                      if k in tuple(inspect.signature(sprit_calibration.calculate_depth).parameters.keys())}
            if &#39;calculate_depth_in_feet&#39; not in calc_depth_kwargs:
                calc_depth_kwargs[&#39;calculate_depth_in_feet&#39;] = True
            hvDataSorted[i] = sprit_calibration.calculate_depth(hvData, **calc_depth_kwargs, verbose=verbose)

    xSectionProfile = shapely.LineString(shapelyPoints)
    profileXs, profileYs = xSectionProfile.xy
    
    orderCoordValues = profileXs
    if ordercoord == &#39;latitude&#39;:
        orderCoordValues = profileYs

    minX = min(profileXs)
    minY = min(profileYs)
    maxX = max(profileXs)
    maxY = max(profileYs)

    # Generate grid
    if verbose:
        print(&#34;Generating Grid: &#34;, end=&#39;&#39;)
    xSectionLength = xSectionProfile.length
    if grid_size == &#39;auto&#39;:
        grid_size=(50, 100)

        cellHNumber = grid_size[0]
        cellWNumber = grid_size[1]
    elif isinstance(grid_size, (list, tuple)):
        cellHNumber = grid_size[0]
        cellWNumber = grid_size[1]
    else:
        grid_size=(50, 100)

        cellHNumber = grid_size[0]
        cellWNumber = xSectionLength/grid_size[1]

        if verbose:
            print(f&#39;grid_size value ({grid_size} not recognized, using grid 100 cells wide and 50 cells high: grid_size=(50, 100))&#39;)

    cellWSize = xSectionLength/cellWNumber
    
    max_surf_elev = max([hvd.elevation for hvd in hvDataSorted])
    min_br_elev = min([hvd.Table_Report[&#39;Peak&#39;][0] for hvd in hvDataSorted])
    elev_range = max_surf_elev - min_br_elev

    max_grid_elev = math.ceil(max_surf_elev)

    # Minimum grid elevation is determined by depth_limit and minimum_elevation
    if str(minimum_elevation).lower() == &#39;auto&#39;:
        min_grid_elev = min_br_elev - (elev_range) * 0.1
    elif isinstance(minimum_elevation, numbers.Number):
        min_grid_elev = minimum_elevation
    elif minimum_elevation is None:
        min_grid_elev = max_grid_elev - depth_limit
    
    xSectionDepth = max_grid_elev - min_grid_elev
    cellHSize = xSectionDepth/cellHNumber

    # Get grid coordinates (all coords in z direction (depth/elev))
    gridZcoords = np.linspace(min_grid_elev, max_grid_elev, cellHNumber)

    gridXDists = np.linspace(0, xSectionProfile.length, cellWNumber)
    gridXcoords = [] # All coords in the &#34;x&#34; direction (along profile)
    for xdist in gridXDists:
        x, y = xSectionProfile.interpolate(xdist).xy
        if &#39;east&#39; in profile_direction:
            gridXcoords.append(x[0])
        else:
            gridXcoords.append(y[0])
    gridXcoords = np.array(gridXcoords)
    if verbose:
        print(f&#39;Grid generated ({cellWNumber*cellHNumber} cells)\n\tx-range: {xSectionLength:.5f} ({cellWNumber:d} cells, each {cellWSize:.5f} units in size)\n\tz-range: {xSectionDepth:.2f} ({cellHNumber:d} cells, each {cellHSize:.5f} units in size)&#39;)

    #print(&#39;x&#39;, len(interpCoords[&#39;longitude&#39;]))
    #print(&#39;y&#39;, len(interpCoords[&#39;latitude&#39;]))
    #print(&#39;z&#39;, len(interpCoords[&#39;elevation&#39;]))
    #print(&#39;interp&#39;, np.array(interpData).shape)
    if verbose:
        print(f&#39;Beginning interpolation ({interpolation_type})... &#39;, end=&#39;&#39;)
    
    ctList = [&#39;cloughtocher2dinterpolator&#39;, &#39;cloughtocher&#39;, &#39;ct&#39;, &#39;clough-tocher&#39;, &#39;clough tocher&#39;, &#39;cubic&#39;, &#39;c&#39;]
    nearList = [&#39;nearestnd&#39;, &#39;nearest&#39;, &#39;near&#39;, &#39;n&#39;]
    linList = [&#39;linearnd&#39;, &#39;linear&#39;, &#39;lin&#39;, &#39;l&#39;]
    rbfList = [&#39;radial basis function&#39;, &#39;rbf&#39;, &#39;rbfinterpolator&#39;]
    
    if str(interpolation_type).lower() in ctList:
        interp = interpolate.CloughTocher2DInterpolator(list(zip(interpCoords[ordercoord], interpCoords[&#39;elevation&#39;])), interpData)
    elif str(interpolation_type).lower() in rbfList:
        interp = interpolate.RBFInterpolator(list(zip(interpCoords[ordercoord], interpCoords[&#39;elevation&#39;])), interpData)        
    elif str(interpolation_type).lower() in linList:
        interp = interpolate.LinearNDInterpolator(list(zip(interpCoords[ordercoord], interpCoords[&#39;elevation&#39;])), interpData)
    else: # elif str(interpolation_type).lower() in nearList:
        interp = interpolate.NearestNDInterpolator(list(zip(interpCoords[ordercoord], interpCoords[&#39;elevation&#39;])), interpData)
        
    xx, zz = np.meshgrid(gridXcoords, gridZcoords)
    interpData = interp(xx, zz)
    interpDataflat = interpData[:-1, :-1]
    if verbose:
        print(&#39;Data interpolated&#39;)
        print(&#39;Plotting colormesh&#39;)
    
    # kwargs-defined pcolormesh kwargs
    pcolormeshKwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(plt.pcolormesh).parameters.keys())}
    
    # Set defaults for cmap and shading (if not overriden in kwargs)
    if &#39;cmap&#39; not in pcolormeshKwargs:
        pcolormeshKwargs[&#39;cmap&#39;] = &#39;nipy_spectral&#39;
    if &#39;shading&#39; not in pcolormeshKwargs:
        pcolormeshKwargs[&#39;shading&#39;] = &#39;flat&#39;
                
    ax.pcolormesh(xx, zz, interpDataflat, zorder=0, **pcolormeshKwargs)
    
    if show_curves:
        if verbose:
            print(&#39;Plotting curves&#39;)
        norm_div = 1
        normal_factor = np.diff(orderCoordValues)
        normal_factor = np.nanmedian(normal_factor[normal_factor != 0]) / norm_div
        
        zAttr = &#39;x_depth_m&#39;
        if use_elevation:
            zAttr = &#39;x_elev_m&#39;

        for hvData in hvDataSorted:
            hvData[&#39;Normalized_HVCurve&#39;] = (hvData[&#39;hvsr_curve&#39;] / np.nanmax(hvData[&#39;hvsr_curve&#39;])) * normal_factor
            locatedCurve = hvData[&#39;Normalized_HVCurve&#39;] + hvData[ordercoord]
            if curve_alignment.lower() == &#39;peak&#39;:
                normal_peak_factor = (hvData[&#34;BestPeak&#34;][&#39;HV&#39;][&#39;A0&#39;] / np.nanmax(hvData[&#39;hvsr_curve&#39;])) * normal_factor
                locatedCurve = locatedCurve  - normal_peak_factor
            elif curve_alignment.lower() == &#39;max&#39;:
                locatedCurve = locatedCurve  - normal_factor
            else:
                pass
            
            if max(locatedCurve) &gt; max(gridXcoords):
                locatedCurve = locatedCurve - (max(locatedCurve) - max(gridXcoords))
            if min(locatedCurve) &lt; min(gridXcoords):
                locatedCurve = locatedCurve + (min(gridXcoords) - min(locatedCurve))
                
            ax.plot(locatedCurve, hvData[zAttr][&#39;Z&#39;][:-1], c=&#39;k&#39;, linewidth=0.5, zorder=3)

    if annotate_curves:
        for hvData in hvDataSorted:
            if len(hvData.site) &gt; 10:
                sitename = hvData.site[:8]+ &#39;...&#39;
            else:
                sitename = hvData.site
            ax.text(hvData[ordercoord], y=min_grid_elev, s=sitename, ha=&#39;right&#39;, va=&#39;bottom&#39;, rotation=&#39;vertical&#39;)
    
    if smooth_bedrock_surface:
        show_bedrock_surface = True

    if show_peak_points or show_bedrock_surface:
        brX = []
        brZ = []
        for hvData in hvDataSorted:
            if &#39;BedrockElevation&#39; in hvData[&#39;Table_Report&#39;].columns:
                brX.append(hvData[ordercoord])
                brZ.append(hvData[&#39;Table_Report&#39;].loc[0,&#39;BedrockElevation&#39;][()])
        if show_peak_points:
            ax.scatter(brX, brZ, zorder=5, c=&#39;k&#39;, marker=&#39;v&#39;)

        
        if smooth_bedrock_surface:
            #brSurfZ = scipy.signal.savgol(brZ, window_length=len(brZ))
            if brX[0] &gt; brX[-1]:
                brX = np.flip(brX)
                brZ = np.flip(brZ)
                doFlip=True
            else:
                doFlip=False
                
            newX = np.sort(gridXcoords)
            brSurfZ = np.interp(newX, brX, brZ)
            brSurfX = newX
        else:
            brSurfX = brX
            brSurfZ = brZ
        
        zMinPts = list(np.array(brSurfZ) * 0 + min(gridZcoords))
        
        if show_bedrock_surface:
            ax.fill_between(brSurfX, brSurfZ, zMinPts,facecolor=&#39;w&#39;, alpha=0.5, zorder=1)
            ax.plot(brSurfX, brSurfZ, c=&#39;k&#39;, zorder=2)

    # Plot surfaces
    if verbose:
        print(&#39;Plotting surfaces&#39;)
    
    if surface_elevations is None:
        surfPts_shapely = []
        surfPtsX = []
        surfPtsZ = []
        
        surface_elevations = shapely.LineString([shapely.Point(hvData[&#39;longitude&#39;], 
                                                               hvData[&#34;latitude&#34;], 
                                                               hvData[&#34;elevation&#34;]) 
                                                 for hvData in hvDataSorted])
    
    xPts = []
    zPts = []
    for surf_pt in surface_elevations.coords:
        surfPtDict = {&#39;longitude&#39;:surf_pt[0], 
                      &#39;latitude&#39;: surf_pt[1],
                      &#39;elevation&#39;: surf_pt[2]}
        xPts.append(surfPtDict[ordercoord])
        zPts.append(surfPtDict[&#39;elevation&#39;])
    
    zMaxPts = list(np.array(zPts) * 0 + max_grid_elev)

    # Fill in above surface so interpolation is cleaner and surface topo shape is clear
    ax.fill_between(xPts, zPts, zMaxPts, facecolor=&#39;w&#39;, zorder=1000)

    # Plot surface topography
    ax.plot(xPts, zPts, c=&#39;g&#39;, linewidth=1.5, zorder=1001)

    # Plot configuration
    if verbose:
        print(&#39;Configuring plot&#39;)
    ax.set_xlim([min(gridXcoords), max(gridXcoords)])
    ax.set_ylim([min_grid_elev, max_grid_elev])
    
    ax.tick_params(top=True, labeltop=True, bottom=False, labelbottom=False)
    ax.set_xlabel(str(ordercoord).title())
    ax.xaxis.set_label_position(&#39;top&#39;)
    ax.set_ylabel(&#39;Elevation [Meters]&#39;)
    if title is None:
        title = &#39;HVSR Cross Section Profile&#39;
    ax.set_title(title)
    
    # Display orientation of cross section profile
    # Calculate angle
    profile_angle = math.degrees(math.atan2(shapelyPoints[-1].y - shapelyPoints[0].y, shapelyPoints[-1].x - shapelyPoints[0].x))
    
    # Convert angle to geographic coordinates
    profile_angle = (profile_angle * -1) + 90
    if profile_angle &lt; 0:
        profile_angle += 360

    if verbose:
        print(f&#34;Calculated profile angle to be {profile_angle:.3f} degrees.&#34;)
    # Calculate angle name of cross section profile
    if profile_angle &lt; -11.25 + 22.5 * 1:
        profileStart = &#39;S&#39;
        profileEnd = &#39;N&#39;
    elif profile_angle &lt; -11.25 + 22.5 * 2:
        profileEnd = &#39;NNE&#39;
        profileStart = &#39;SSW&#39;        
    elif profile_angle &lt; -11.25 + 22.5 * 3:
        profileEnd = &#39;NE&#39;
        profileStart = &#39;SW&#39;
    elif profile_angle &lt; -11.25 + 22.5 * 4:
        profileEnd = &#39;ENE&#39;
        profileStart = &#39;WSW&#39;        
    elif profile_angle &lt; -11.25 + 22.5 * 5:
        profileEnd = &#39;E&#39;
        profileStart = &#39;W&#39;        
    elif profile_angle &lt; -11.25 + 22.5 * 6:
        profileEnd = &#39;ESE&#39;
        profileStart = &#39;WNW&#39;
    elif profile_angle &lt; -11.25 + 22.5 * 7:
        profileEnd = &#39;SE&#39;
        profileStart = &#39;NW&#39;
    elif profile_angle &lt; -11.25 + 22.5 * 8:
        profileEnd = &#39;SSE&#39;
        profileStart = &#39;NNW&#39;
    elif profile_angle &lt; -11.25 + 22.5 * 9:
        profileEnd = &#39;S&#39;
        profileStart = &#39;N&#39;
    elif profile_angle &lt; -11.25 + 22.5 * 10:
        profileEnd = &#39;SSW&#39;
        profileStart = &#39;NNE&#39;        
    elif profile_angle &lt; -11.25 + 22.5 * 11:
        profileEnd = &#39;SW&#39;
        profileStart = &#39;NE&#39;
    elif profile_angle &lt; -11.25 + 22.5 * 12:
        profileEnd = &#39;WSW&#39;
        profileStart = &#39;ENE&#39;
    elif profile_angle &lt; -11.25 + 22.5 * 13:
        profileEnd = &#39;W&#39;
        profileStart = &#39;E&#39;
    elif profile_angle &lt; -11.25 + 22.5 * 14:
        profileEnd = &#39;WNW&#39;
        profileStart = &#39;ESE&#39;
    elif profile_angle &lt; -11.25 + 22.5 * 15:
        profileEnd = &#39;NW&#39;
        profileStart = &#39;SE&#39;
    elif profile_angle &lt; -11.25 + 22.5 * 16:
        profileEnd = &#39;NNW&#39;
        profileStart = &#39;SSE&#39;
    elif profile_angle &lt;= 360:
        profileEnd = &#39;N&#39;
        profileStart = &#39;S&#39;

    # Always orient north and east to the right
    if &#39;north&#39; in profile_direction[:5] or &#39;east&#39; in profile_direction[:5]:
        ax.invert_xaxis()

    plt.sca(ax)
    plt.figtext(0.1,0.95, s=profileStart)
    plt.figtext(0.9,0.95, s=profileEnd)

    if show_cross_section:
        if verbose:
            print(&#39;Displaying plot&#39;)
        plt.sca(ax)
        plt.show()
        
    if return_data_batch:
        hvBatch = sprit_hvsr.HVSRBatch(hvDataSorted)
        hvBatch[&#39;Cross_Section_Plot&#39;] = fig
        return hvBatch
            
    return fig</code></pre>
</details>
<div class="desc"><p>Function to plot a cross section given an HVSRBatch or similar object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code><a title="sprit.HVSRBatch" href="#sprit.HVSRBatch">HVSRBatch</a>, list,</code> or <code>similar</code></dt>
<dd>HVSRBatch (intended usage) object with HVSRData objects to show in profile/cross section view</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Title to use for plot, by default None</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.Figure</code>, optional</dt>
<dd>Figure to use for plot, by default None</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.Axis</code>, optional</dt>
<dd>Axis to use for plot, by default None</dd>
<dt><strong><code>use_elevation</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to use elevation (if True) or depth (if False), by default True</dd>
<dt><strong><code>show_feet</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to show feet (if True) or meters (if False), by default False</dd>
<dt><strong><code>primary_unit</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Primary unit to use ('m' or 'ft'), by default 'm'</dd>
<dt><strong><code>show_curves</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to also show curves on plot, by default True</dd>
<dt><strong><code>annotate_curves</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to annotate curves by plotting site names next to them, by default False</dd>
<dt><strong><code>curve_alignment</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>How to horizontally align the curve.
If "peak" the curve will be aligned so that the peak is at the correct latitude or longitude.
If "max" will align the maximum point of the curve to the correct location.
If any other value, will align at the surface (i.e., highest frequency). By default 'peak'.</dd>
<dt><strong><code>grid_size</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Two item list with height and width of grid for interpolation.
If "auto" this will be calculated based on the data, by default 'auto'.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The orientation of the cross section.
Should be either "WE", "EW", "NS", or "SN", by default 'WE'.</dd>
<dt><strong><code>interpolation_type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Interpolation type to use. Uses scipy.interpolation.
Options include: 'cloughtocher', 'nearest neighbor', 'linear',
or 'radial basis function', by default 'cloughtocher'.</dd>
<dt><strong><code>interpolate_log_values</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to use log values of the H/V curve for interpolation (can be useful for better normalizing data)</dd>
<dt><strong><code>surface_elevations</code></strong> :&ensp;<code>shapely.LineString</code>, optional</dt>
<dd>A shapely.LineString object containing surface elevation coordinates along cross section path.
If None, uses elevation data in HVSRBatch specified by hvsr_data, by default None.</dd>
<dt><strong><code>show_peak_points</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to plot small triangles where peaks were picked, by default True</dd>
<dt><strong><code>smooth_bedrock_surface</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to smooth the bedrock surface when plotting, by default False</dd>
<dt><strong><code>depth_limit</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Depth limit for the plot, by default 150</dd>
<dt><strong><code>minimum_elevation</code></strong> :&ensp;<code>_type_</code>, optional</dt>
<dd>Minimum elevation of the plot, by default None</dd>
<dt><strong><code>show_bedrock_surface</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to show the bedrock surface, by default True</dd>
<dt><strong><code>return_data_batch</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to return the HVSRBatch object, by default True</dd>
<dt><strong><code>show_cross_section</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to show the cross section plot, by default True</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print information about the process to terminal, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>figure</code></dt>
<dd>Currently only matplotlib figure supported</dd>
</dl></div>
</dd>
<dt id="sprit.plot_depth_curve"><code class="name flex">
<span>def <span class="ident">plot_depth_curve</span></span>(<span>hvsr_results,<br>use_elevation=True,<br>show_feet=False,<br>normalize_curve=True,<br>depth_limit=250,<br>depth_model=None,<br>annotate=True,<br>depth_plot_export_path=None,<br>fig=None,<br>ax=None,<br>show_depth_curve=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_depth_curve(hvsr_results, use_elevation=True, show_feet=False, normalize_curve=True, 
                     depth_limit=250, depth_model=None,
                     annotate=True, depth_plot_export_path=None, 
                     fig=None, ax=None, show_depth_curve=True):
    &#34;&#34;&#34;Function to plot depth curves, given hvsr_results with depth_model specified.

    Parameters
    ----------
    hvsr_results : sprit.HVSRData or sprit.HVSRBatch
        HVSRData object with depth information (or `depth_model` specified).
    use_elevation : bool, optional
        Whether to use elevation (True) or just depth (False), by default True
    show_feet : bool, optional
        Whether to show elevation/depth in feet on Y axis, by default False
    normalize_curve : bool, optional
        Whether to normalize amplitude of H/V curve (x-axis) using maximum/minimum amplitudes, by default True
    depth_limit : int, optional
        Depth limit at which to cut off plot, by default 250 (meters)
    depth_model : None or tuple, optional
        If depth_model not already specified, this can be used to run sprit.calculate_depth() before generating plot.
    annotate : bool, optional
        Whether to annotate plot, by default True
    depth_plot_export_path : filepath-like object, optional
        If specified, will export depth plot to location specifed, by default None
    fig : matplotlib.figure.Figure, optional
        Maplotlib Figure to use for plotting, by default None (new one will be created)
    ax : matplotlib.axis.Axis, optional
        Maplotlib Axis to use for plotting, by default None (new one will be created)
    show_depth_curve : bool, optional
        Whether to diplay the depth curve chart after generating it, by default True

    Returns
    -------
    HVSRData
        HVSRData object with additional property for Depth_Plot
    &#34;&#34;&#34;


    if fig is None and ax is None:
        fig, ax = plt.subplots(layout=&#39;constrained&#39;)#, figsize=(5, 15))
        fig.suptitle(hvsr_results[&#39;site&#39;])
        ax.set_title(&#39;Calibrated Depth to Interface&#39;, size=&#39;small&#39;)
    ax.tick_params(top=True, labeltop=True, bottom=False, labelbottom=False)
    
    if depth_model is not None:
        hvsr_results = sprit_calibration.calculate_depth(hvsr_results, depth_model=depth_model, show_depth_curve=False)

    surfElev = hvsr_results.Table_Report[&#39;Elevation&#39;][0]
    bedrockElev = hvsr_results.Table_Report[&#39;BedrockElevation&#39;][0]
    bedrockDepth = hvsr_results.Table_Report[&#39;BedrockDepth&#39;][0]
    curveRange = max(hvsr_results.hvsr_curve) - min(hvsr_results.hvsr_curve)

    if normalize_curve:
        curvePlot = (hvsr_results.hvsr_curve - min(hvsr_results.hvsr_curve)) / curveRange
        xBase = 0
        xCap = 1
        xLims = [-0.25, 1.25]
        ax.set_xticks([0, 1])
    else:
        curvePlot = hvsr_results.hvsr_curve
        xBase = min(hvsr_results.hvsr_curve)
        xCap = hvsr_results.BestPeak[&#39;HV&#39;][&#39;A0&#39;]#max(hvsr_results.hvsr_curve)
        xLims = [xBase-(0.15*curveRange), xCap+(0.15*curveRange)]
 
    if use_elevation:
        yLims = [hvsr_results.x_elev_m[&#39;Z&#39;][0] - depth_limit,
              hvsr_results.x_elev_m[&#39;Z&#39;][0]]
        yVals = hvsr_results.x_elev_m[&#39;Z&#39;][:-1]
        ax.set_ylabel(&#39;Elevation [m]&#39;)
        bedrockVal = bedrockElev
        if annotate:
            #Annotate surface elevation
            ax.text(x=xLims[0],
                    y=surfElev,
                    s=str(round(float(surfElev), 2))+&#39;m&#39;,
                    ha=&#39;right&#39;,
                    va=&#39;bottom&#39;,
                    size=&#39;x-small&#39;)

            # Annotate bedrock elevation
            ax.text(x=xBase,
                    y=bedrockElev,
                    s=&#39; &#39; + str(round(float(bedrockElev), 2))+&#39;m\n elevation&#39;,
                    ha=&#39;left&#39;,
                    va=&#39;center&#39;,
                    size=&#39;x-small&#39;)
            
            # Annotate bedrock depth
            ax.text(x=xBase,
                    y=max(yLims),
                    s=str(round(float(bedrockDepth), 2))+&#39;m deep &#39;,
                    ha=&#39;right&#39;,
                    va=&#39;top&#39;,
                    size=&#39;x-small&#39;,
                    rotation=&#39;vertical&#39;)
    else:
        yLims = [depth_limit, hvsr_results.x_depth_m[&#39;Z&#39;][0]]
        yVals = hvsr_results.x_depth_m[&#39;Z&#39;][:-1]
        ax.set_ylabel(&#39;Depth [m]&#39;)
        bedrockVal = bedrockDepth
        if annotate:
            # Annotate surface elevation
            ax.text(x=xLims[0],
                    y=0,
                    s=str(round(float(surfElev), 2))+&#39;m&#39;,
                    ha=&#39;right&#39;,
                    va=&#39;bottom&#39;,
                    size=&#39;x-small&#39;)
            
            # Annotate Bedrock elevation
            ax.text(x=xBase,
                    y=bedrockVal,
                    s=str(round(float(bedrockElev), 2))+&#39;m\nelevation&#39;,
                    ha=&#39;center&#39;,
                    va=&#39;center&#39;,
                    size=&#39;x-small&#39;)

            # Annotate Bedrock depth
            ax.text(x=xBase,
                    y=(min(yLims)+float(bedrockDepth))/2,
                    s=str(round(float(bedrockDepth), 2))+&#39;m deep&#39;,
                    ha=&#39;right&#39;,
                    va=&#39;top&#39;,
                    size=&#39;x-small&#39;,
                    rotation=&#39;vertical&#39;)

    # Plot curve
    ax.fill_betweenx(y=yVals, x1=xBase, x2=curvePlot, alpha=0.2, facecolor=&#39;k&#39;)
    ax.plot(curvePlot, yVals, c=&#39;k&#39;, linewidth=0.5)
    if show_feet:
        ax_ft = ax.twinx()
        ax_ft.plot(curvePlot, yVals*3.281, alpha=0)
        ax_ft.set_ylim(yLims[0]*3.281, yLims[1]*3.281)
        ax_ft.set_ylabel(&#39;Elevation [ft]&#39;)
        if not use_elevation:
            ax_ft.set_ylabel(&#39;Depth [ft]&#39;)
        
    # Plot peak location
    ax.axhline(y=bedrockVal,
               linestyle=&#39;dotted&#39;, c=&#39;k&#39;, linewidth=0.5)
    ax.scatter(xBase, y=bedrockVal, c=&#39;k&#39;, s=0.5)
    ax.scatter(xCap, y=bedrockVal, c=&#39;k&#39;, s=0.5)
    
    # Plot &#34;base&#34; line
    ax.axvline(x=xBase, linestyle=&#39;dotted&#39;, c=&#39;k&#39;, linewidth=0.5)

    ax.set_ylim(yLims)
    ax.set_xlim(xLims)
    
    xlabel = &#34;H/V Ratio&#34;
    if normalize_curve:
        xlabel += &#39;\n(Normalized)&#39;
        ax.set_xticks([])

    ax.set_xlabel(&#39;H/V Ratio&#39;)
    ax.xaxis.set_label_position(&#39;top&#39;)

    ax.set_title(hvsr_results[&#39;site&#39;])

    plt.sca(ax)
    fig.set_size_inches(4, 8)
    if show_depth_curve:
        plt.show()
    else:
        plt.close()
        
    if depth_plot_export_path is not None:
        if isinstance(depth_plot_export_path, os.PathLike):
            fig.savefig(depth_plot_export_path)
        else:
            print(f&#39;Please specify a valid path for depth_plot_export_path, not {depth_plot_export_path}&#39;)
    
    hvsr_results[&#39;Depth_Plot&#39;] = fig
    return hvsr_results</code></pre>
</details>
<div class="desc"><p>Function to plot depth curves, given hvsr_results with depth_model specified.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_results</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code> or <code><a title="sprit.HVSRBatch" href="#sprit.HVSRBatch">HVSRBatch</a></code></dt>
<dd>HVSRData object with depth information (or <code>depth_model</code> specified).</dd>
<dt><strong><code>use_elevation</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to use elevation (True) or just depth (False), by default True</dd>
<dt><strong><code>show_feet</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to show elevation/depth in feet on Y axis, by default False</dd>
<dt><strong><code>normalize_curve</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to normalize amplitude of H/V curve (x-axis) using maximum/minimum amplitudes, by default True</dd>
<dt><strong><code>depth_limit</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Depth limit at which to cut off plot, by default 250 (meters)</dd>
<dt><strong><code>depth_model</code></strong> :&ensp;<code>None</code> or <code>tuple</code>, optional</dt>
<dd>If depth_model not already specified, this can be used to run sprit.calculate_depth() before generating plot.</dd>
<dt><strong><code>annotate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to annotate plot, by default True</dd>
<dt><strong><code>depth_plot_export_path</code></strong> :&ensp;<code>filepath-like object</code>, optional</dt>
<dd>If specified, will export depth plot to location specifed, by default None</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.figure.Figure</code>, optional</dt>
<dd>Maplotlib Figure to use for plotting, by default None (new one will be created)</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axis.Axis</code>, optional</dt>
<dd>Maplotlib Axis to use for plotting, by default None (new one will be created)</dd>
<dt><strong><code>show_depth_curve</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to diplay the depth curve chart after generating it, by default True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code></dt>
<dd>HVSRData object with additional property for Depth_Plot</dd>
</dl></div>
</dd>
<dt id="sprit.plot_hvsr"><code class="name flex">
<span>def <span class="ident">plot_hvsr</span></span>(<span>hvsr_data,<br>plot_type='HVSR p ann COMP+ p ann SPEC p ann',<br>azimuth='HV',<br>use_subplots=True,<br>fig=None,<br>ax=None,<br>return_fig=False,<br>plot_engine='matplotlib',<br>save_dir=None,<br>save_suffix='',<br>show_legend=False,<br>show_plot=True,<br>close_figs=False,<br>clear_fig=True,<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_hvsr(hvsr_data, plot_type=DEFAULT_PLOT_STR, azimuth=&#39;HV&#39;, use_subplots=True, fig=None, ax=None, return_fig=False,  plot_engine=&#39;matplotlib&#39;, save_dir=None, save_suffix=&#39;&#39;, show_legend=False, show_plot=True, close_figs=False, clear_fig=True,**kwargs):
    &#34;&#34;&#34;Function to plot HVSR data

    Parameters
    ----------
    hvsr_data : dict                  
        Dictionary containing output from process_hvsr function
    plot_type : str or list, default = &#39;HVSR ann p C+ ann p SPEC ann p&#39;
        The plot_type of plot(s) to plot. If list, will plot all plots listed
        - &#39;HVSR&#39; - Standard HVSR plot, including standard deviation. Options are included below:
            - &#39;p&#39; shows a vertical dotted line at frequency of the &#34;best&#34; peak
            - &#39;ann&#39; annotates the frequency value of of the &#34;best&#34; peak
            - &#39;all&#39; shows all the peaks identified in check_peaks() (by default, only the max is identified)
            - &#39;t&#39; shows the H/V curve for all time windows
            - &#39;tp&#39; shows all the peaks from the H/V curves of all the time windows
            - &#39;fr&#39; shows the window within which SpRIT will search for peak frequencies, as set by peak_freq_range
            - &#39;test&#39; shows a visualization of the results of the peak validity test(s). Examples:
                - &#39;tests&#39; visualizes the results of all the peak tests (not the curve tests)
                - &#39;test12&#39; shows the results of tests 1 and 2.
                    - Append any number 1-6 after &#39;test&#39; to show a specific test result visualized
        - &#39;COMP&#39; - plot of the PPSD curves for each individual component (&#34;C&#34; also works)
            - &#39;+&#39; (as a suffix in &#39;C+&#39; or &#39;COMP+&#39;) plots C on a plot separate from HVSR (C+ is default, but without + will plot on the same plot as HVSR)
            - &#39;p&#39; shows a vertical dotted line at frequency of the &#34;best&#34; peak
            - &#39;ann&#39; annotates the frequency value of of the &#34;best&#34; peak
            - &#39;all&#39; shows all the peaks identified in check_peaks() (by default, only the max is identified)
            - &#39;t&#39; shows the H/V curve for all time windows
        - &#39;SPEC&#39; - spectrogram style plot of the H/V curve over time
            - &#39;p&#39; shows a horizontal dotted line at the frequency of the &#34;best&#34; peak
            - &#39;ann&#39; annotates the frequency value of the &#34;best&#34; peak
            - &#39;all&#39; shows all the peaks identified in check_peaks()
            - &#39;tp&#39; shows all the peaks of the H/V curve at all time windows
        - &#39;AZ&#39; - circular plot of calculated azimuthal HV curves, similar in style to SPEC plot.
            - &#39;p&#39; shows a point at each calculated (not interpolated) azimuth peak
            - &#39;g&#39; shows grid lines at various angles
            - &#39;i&#39; interpolates so that there is an interpolated azimuth at each degree interval (1 degree step)
                This is the default, so usually &#39;i&#39; is not needed.
            - &#39;-i&#39; prohibits interpolation (only shows the calculated azimuths, as determined by azimuth_angle (default = 30))
    azimuth : str, default = &#39;HV&#39;
        What &#39;azimuth&#39; to plot, default being standard N E components combined
    use_subplots : bool, default = True
        Whether to output the plots as subplots (True) or as separate plots (False)
    fig : matplotlib.Figure, default = None
        If not None, matplotlib figure on which plot is plotted
    ax : matplotlib.Axis, default = None
        If not None, matplotlib axis on which plot is plotted
    return_fig : bool
        Whether to return figure and axis objects
    plot_engine : str, default=&#39;Matplotlib&#39;
        Which engine to use for plotting. Both &#34;matplotlib&#34; and &#34;plotly&#34; are acceptable. For shorthand, &#39;mpl&#39;, &#39;m&#39; also work for matplotlib; &#39;plty&#39; or &#39;p&#39; also work for plotly. Not case sensitive.
    save_dir : str or None
        Directory in which to save figures
    save_suffix : str
        Suffix to add to end of figure filename(s), if save_dir is used
    show_legend : bool, default=False
        Whether to show legend in plot
    show_plot : bool
        Whether to show plot
    close_figs : bool, default=False
        Whether to close figures before plotting
    clear_fig : bool, default=True
        Whether to clear figures before plotting
    **kwargs : keyword arguments
        Keyword arguments for matplotlib.pyplot

    Returns
    -------
    fig, ax : matplotlib figure and axis objects
        Returns figure and axis matplotlib.pyplot objects if return_fig=True, otherwise, simply plots the figures
    &#34;&#34;&#34;
    orig_args = locals().copy() #Get the initial arguments
    if isinstance(hvsr_data, HVSRBatch):
        #If running batch, we&#39;ll loop through each site
        for site_name in hvsr_data.keys():
            args = orig_args.copy() #Make a copy so we don&#39;t accidentally overwrite
            individual_params = hvsr_data[site_name] #Get what would normally be the &#34;params&#34; variable for each site
            args[&#39;hvsr_results&#39;] = individual_params #reset the params parameter we originally read in to an individual site params
            if hvsr_data[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;]:
                try:
                    __hvsr_plot_batch(**args) #Call another function, that lets us run this function again
                except:
                    print(f&#34;{site_name} not able to be plotted.&#34;)

        return

    mplList = [&#39;matplotlib&#39;, &#39;mpl&#39;, &#39;m&#39;]
    plotlyList = [&#39;plotly&#39;, &#39;plty&#39;, &#39;p&#39;]

    if plot_engine.lower() in plotlyList:
        plotlyFigure = sprit_plot.plot_results_plotly(hvsr_data, plot_string=plot_type, azimuth=azimuth,
                                            results_fig=fig, return_fig=return_fig, use_figure_widget=False,
                                            show_results_plot=show_plot)
        if return_fig:
            return plotlyFigure
    else: #plot_engine.lower() in mplList or any other value not in plotly list
        if clear_fig and fig is not None and ax is not None: #Intended use for tkinter
            #Clear everything
            for key in ax:
                ax[key].clear()
            for t in fig.texts:
                del t
            fig.clear()
        if close_figs:
            plt.close(&#39;all&#39;)

        # The possible identifiers in plot_type for the different kind of plots
        hvsrList = [&#39;hvsr&#39;, &#39;hv&#39;, &#39;h&#39;]
        compList = [&#39;c&#39;, &#39;comp&#39;, &#39;component&#39;, &#39;components&#39;]
        specgramList = [&#39;spec&#39;, &#39;specgram&#39;, &#39;spectrogram&#39;]
        azList = [&#39;azimuth&#39;, &#39;az&#39;, &#39;a&#39;, &#39;radial&#39;, &#39;r&#39;]

        hvsrInd = np.nan
        compInd = np.nan
        specInd = np.nan
        azInd = np.nan

        plot_type = plot_type.replace(&#39;,&#39;, &#39;&#39;)
        kList = plot_type.split(&#39; &#39;)
        for i, k in enumerate(kList):
            kList[i] = k.lower()

        # Get the plots in the right order, no matter how they were input (and ensure the right options go with the right plot)
        # HVSR index
        if len(set(hvsrList).intersection(kList)):
            for i, hv in enumerate(hvsrList):
                if hv in kList:
                    hvsrInd = kList.index(hv)
                    break
        # Component index
        #if len(set(compList).intersection(kList)):
        for i, c in enumerate(kList):
            if &#39;+&#39; in c and c[:-1] in compList:
                compInd = kList.index(c)
                break
            
        # Specgram index
        if len(set(specgramList).intersection(kList)):
            for i, sp in enumerate(specgramList):
                if sp in kList:
                    specInd = kList.index(sp)
                    break        

        # Azimuth index
        if len(set(azList).intersection(kList)):
            for i, sp in enumerate(azList):
                if sp in kList:
                    azInd = kList.index(sp)
                    break        

        
        # Get indices for all plot type indicators
        indList = [hvsrInd, compInd, specInd, azInd]
        indListCopy = indList.copy()
        plotTypeList = [&#39;hvsr&#39;, &#39;comp&#39;, &#39;spec&#39;, &#39;az&#39;]

        plotTypeOrder = []
        plotIndOrder = []

        # Get lists with first and last indices of the specifiers for each plot
        lastVal = 0
        while lastVal != 99:
            firstInd = np.nanargmin(indListCopy)
            plotTypeOrder.append(plotTypeList[firstInd])
            plotIndOrder.append(indList[firstInd])
            lastVal = indListCopy[firstInd]
            indListCopy[firstInd] = 99  #just a high number

        plotTypeOrder.pop()
        plotIndOrder[-1] = len(kList)
        
        # set up subplots
        figLayout = &#39;constrained&#39;
        figWidth = 6
        figHeight = 4
        figdpi = 220

        for i, p in enumerate(plotTypeOrder):
            pStartInd = plotIndOrder[i]
            pEndInd = plotIndOrder[i+1]
            plotComponents = kList[pStartInd:pEndInd]

            if use_subplots and i == 0 and fig is None and ax is None:
                mosaicPlots = []
                for pto in plotTypeOrder:
                    if pto == &#39;az&#39;:
                        for i, subp in enumerate(mosaicPlots):
                            if (subp[0].lower() == &#39;hvsr&#39; or subp[0].lower() == &#39;comp&#39;) and len([item for item in plotTypeOrder if item != &#34;hvsr&#34;]) &gt; 0:
                                mosaicPlots[i].append(subp[0])
                                mosaicPlots[i].append(subp[0])
                            else:
                                mosaicPlots[i].append(subp[0])
                                mosaicPlots[i].append(pto)
                    else:
                        mosaicPlots.append([pto])
                perSubPDict = {}
                if &#39;az&#39; in plotTypeOrder:
                    perSubPDict[&#39;az&#39;] = {&#39;projection&#39;:&#39;polar&#39;}
                fig, ax = plt.subplot_mosaic(mosaicPlots, per_subplot_kw=perSubPDict, 
                                             layout=figLayout, figsize=(figWidth, figHeight), dpi=figdpi)
                axis = ax[p]
            elif use_subplots:
                with warnings.catch_warnings():
                    warnings.simplefilter(&#34;ignore&#34;) #Often warns about xlim when it is not an issue
                    if hasattr(ax, &#39;__len__&#39;):#print(dir(ax), ax, len(ax))
                        ax[p].clear()
                        axis = ax[p]
            else:
                fig, axis = plt.subplots(figsize=(figWidth, figHeight), dpi=figdpi)

            if p == &#39;hvsr&#39;:
                kwargs[&#39;subplot&#39;] = p
                fig, ax[p] = _plot_hvsr(hvsr_data, fig=fig, ax=axis, plot_type=plotComponents, azimuth=azimuth, xtype=&#39;x_freqs&#39;, show_legend=show_legend, axes=ax, **kwargs)
            elif p == &#39;comp&#39;:
                plotComponents[0] = plotComponents[0][:-1]
                kwargs[&#39;subplot&#39;] = p
                minY = 99999 # Start high
                maxY = -99999 # Start low
                
                for key in hvsr_data.psd_raw.keys():
                    if min(hvsr_data.ppsd_std_vals_m[key]) &lt; minY:
                        minY = min(hvsr_data.ppsd_std_vals_m[key])
                    if max(hvsr_data.ppsd_std_vals_m[key]) &gt; maxY:
                        maxY = max(hvsr_data.ppsd_std_vals_m[key])
                yRange = maxY - minY
                compYlim = [float(minY - (yRange*0.05)), float(maxY + (yRange * 0.05))]
                compYlim.reverse()
                compKwargs = {&#39;ylim&#39;:compYlim}
                compKwargs.update(kwargs)
                fig, ax[p] = _plot_hvsr(hvsr_data, fig=fig, ax=axis, plot_type=plotComponents, azimuth=azimuth, xtype=&#39;x_freqs&#39;, show_legend=show_legend, axes=ax, **kwargs)
            elif p == &#39;spec&#39;:
                plottypeKwargs = {}
                for c in plotComponents:
                    plottypeKwargs[c] = True
                kwargs.update(plottypeKwargs)
                _plot_specgram_hvsr(hvsr_data, fig=fig, ax=axis, azimuth=azimuth, colorbar=False, **kwargs)
            elif p == &#39;az&#39;:
                kwargs[&#39;plot_type&#39;] = plotComponents
                hvsr_data[&#39;Azimuth_fig&#39;] = plot_azimuth(hvsr_data, fig=fig, ax=axis, **kwargs)
            else:
                warnings.warn(&#39;Plot type {p} not recognized&#39;, UserWarning)   

        windowsUsedStr = f&#34;{hvsr_data[&#39;hvsr_windows_df&#39;][&#39;Use&#39;].astype(bool).sum()}/{hvsr_data[&#39;hvsr_windows_df&#39;].shape[0]} windows used&#34;
        winText = fig.text(x=1, y=0.0, s=windowsUsedStr, ha=&#39;right&#39;, va=&#39;bottom&#39;, fontsize=&#39;xx-small&#39;,
                bbox=dict(facecolor=&#39;w&#39;, edgecolor=None, linewidth=0, alpha=1, pad=-1))
        winText.set_in_layout(False)
        
        if len(plotTypeOrder)&gt;1:
            matplotlib.rcParams[&#34;figure.constrained_layout.h_pad&#34;] = 0.075
        #if use_subplots:
        #    fig.subplots_adjust()#.set(h_pad=0.075, hspace=-5)
        if show_plot:
            fig.canvas.draw()
            
        if return_fig:
            return fig

    return</code></pre>
</details>
<div class="desc"><p>Function to plot HVSR data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>dict
</code></dt>
<dd>Dictionary containing output from process_hvsr function</dd>
<dt><strong><code>plot_type</code></strong> :&ensp;<code>str</code> or <code>list</code>, default <code>= 'HVSR ann p C+ ann p SPEC ann p'</code></dt>
<dd>The plot_type of plot(s) to plot. If list, will plot all plots listed
- 'HVSR' - Standard HVSR plot, including standard deviation. Options are included below:
- 'p' shows a vertical dotted line at frequency of the "best" peak
- 'ann' annotates the frequency value of of the "best" peak
- 'all' shows all the peaks identified in check_peaks() (by default, only the max is identified)
- 't' shows the H/V curve for all time windows
- 'tp' shows all the peaks from the H/V curves of all the time windows
- 'fr' shows the window within which SpRIT will search for peak frequencies, as set by peak_freq_range
- 'test' shows a visualization of the results of the peak validity test(s). Examples:
- 'tests' visualizes the results of all the peak tests (not the curve tests)
- 'test12' shows the results of tests 1 and 2.
- Append any number 1-6 after 'test' to show a specific test result visualized
- 'COMP' - plot of the PPSD curves for each individual component ("C" also works)
- '+' (as a suffix in 'C+' or 'COMP+') plots C on a plot separate from HVSR (C+ is default, but without + will plot on the same plot as HVSR)
- 'p' shows a vertical dotted line at frequency of the "best" peak
- 'ann' annotates the frequency value of of the "best" peak
- 'all' shows all the peaks identified in check_peaks() (by default, only the max is identified)
- 't' shows the H/V curve for all time windows
- 'SPEC' - spectrogram style plot of the H/V curve over time
- 'p' shows a horizontal dotted line at the frequency of the "best" peak
- 'ann' annotates the frequency value of the "best" peak
- 'all' shows all the peaks identified in check_peaks()
- 'tp' shows all the peaks of the H/V curve at all time windows
- 'AZ' - circular plot of calculated azimuthal HV curves, similar in style to SPEC plot.
- 'p' shows a point at each calculated (not interpolated) azimuth peak
- 'g' shows grid lines at various angles
- 'i' interpolates so that there is an interpolated azimuth at each degree interval (1 degree step)
This is the default, so usually 'i' is not needed.
- '-i' prohibits interpolation (only shows the calculated azimuths, as determined by azimuth_angle (default = 30))</dd>
<dt><strong><code>azimuth</code></strong> :&ensp;<code>str</code>, default <code>= 'HV'</code></dt>
<dd>What 'azimuth' to plot, default being standard N E components combined</dd>
<dt><strong><code>use_subplots</code></strong> :&ensp;<code>bool</code>, default <code>= True</code></dt>
<dd>Whether to output the plots as subplots (True) or as separate plots (False)</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.Figure</code>, default <code>= None</code></dt>
<dd>If not None, matplotlib figure on which plot is plotted</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.Axis</code>, default <code>= None</code></dt>
<dd>If not None, matplotlib axis on which plot is plotted</dd>
<dt><strong><code>return_fig</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return figure and axis objects</dd>
<dt><strong><code>plot_engine</code></strong> :&ensp;<code>str</code>, default=<code>'Matplotlib'</code></dt>
<dd>Which engine to use for plotting. Both "matplotlib" and "plotly" are acceptable. For shorthand, 'mpl', 'm' also work for matplotlib; 'plty' or 'p' also work for plotly. Not case sensitive.</dd>
<dt><strong><code>save_dir</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>Directory in which to save figures</dd>
<dt><strong><code>save_suffix</code></strong> :&ensp;<code>str</code></dt>
<dd>Suffix to add to end of figure filename(s), if save_dir is used</dd>
<dt><strong><code>show_legend</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to show legend in plot</dd>
<dt><strong><code>show_plot</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show plot</dd>
<dt><strong><code>close_figs</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to close figures before plotting</dd>
<dt><strong><code>clear_fig</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to clear figures before plotting</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>keyword arguments</code></dt>
<dd>Keyword arguments for matplotlib.pyplot</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong>, <strong><code>ax</code></strong> :&ensp;<code>matplotlib figure and axis objects</code></dt>
<dd>Returns figure and axis matplotlib.pyplot objects if return_fig=True, otherwise, simply plots the figures</dd>
</dl></div>
</dd>
<dt id="sprit.plot_input_stream"><code class="name flex">
<span>def <span class="ident">plot_input_stream</span></span>(<span>hv_data,<br>stream=None,<br>input_fig=None,<br>plot_engine='plotly',<br>spectrogram_component='Z',<br>decimate=True,<br>show_plot=True,<br>return_fig=False,<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_input_stream(hv_data, stream=None, input_fig=None, plot_engine=&#39;plotly&#39;,
                        spectrogram_component=&#39;Z&#39;, decimate=True,
                        show_plot=True, return_fig=False, **kwargs):

    &#34;&#34;&#34;Function to plot input stream using plotly.
    
    Parameters
    ----------
    hv_data : HVSRData
    stream : obspy.stream.Stream
        Can explictly specify stream instead of using hv_data object.
    input_fig : plotly.Figure
        Plotly figure to plot input stream on. If None, creates new one. Default is None.
    spectrogram_component : str, default=&#39;Z&#39;
        Which component to use for the spectrogram
    show_plot : bool, default=True
        Whether to show plot or just generate it.
    return_fig : bool, default=False
        Whether to return figure

    Returns
    -------
    plotly figure
        Only returned if return_fig is True
    &#34;&#34;&#34;

    plotlyList = [&#39;plotly&#39;, &#39;pltly&#39;, &#39;plty&#39;, &#39;p&#39;]
    mplList = [&#39;matplotlib&#39;, &#39;pyplot&#39;, &#39;plt&#39;, &#39;mpl&#39;, &#39;m&#39;]

    if str(plot_engine).lower() in plotlyList:
        return _plot_input_stream_plotly(hv_data=hv_data, stream=stream, input_fig=input_fig,
                                         spectrogram_component=spectrogram_component,
                                         show_plot=show_plot, return_fig=return_fig)
    elif str(plot_engine).lower() in mplList:
        return _plot_input_stream_mpl(hv_data, stream, input_fig, decimate=True, spectrogram_component=&#39;Z&#39;, show_plot=True, return_fig=False, **kwargs)
    else:
        try:
            return _plot_simple_stream_mpl(hv_data, stream, fig=None, axes=None, show_plot=False, ylim_std=0.75, return_fig=True)
        except:
            return _plot_simple_stream_obspy()</code></pre>
</details>
<div class="desc"><p>Function to plot input stream using plotly.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hv_data</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>stream</code></strong> :&ensp;<code>obspy.stream.Stream</code></dt>
<dd>Can explictly specify stream instead of using hv_data object.</dd>
<dt><strong><code>input_fig</code></strong> :&ensp;<code>plotly.Figure</code></dt>
<dd>Plotly figure to plot input stream on. If None, creates new one. Default is None.</dd>
<dt><strong><code>spectrogram_component</code></strong> :&ensp;<code>str</code>, default=<code>'Z'</code></dt>
<dd>Which component to use for the spectrogram</dd>
<dt><strong><code>show_plot</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to show plot or just generate it.</dd>
<dt><strong><code>return_fig</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to return figure</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>plotly figure</code></dt>
<dd>Only returned if return_fig is True</dd>
</dl></div>
</dd>
<dt id="sprit.plot_outlier_curves"><code class="name flex">
<span>def <span class="ident">plot_outlier_curves</span></span>(<span>hvsr_data,<br>plot_engine='plotly',<br>plotly_module='go',<br>remove_outliers_during_plot=False,<br>outlier_threshold=0.98,<br>use_percentile=True,<br>use_hv_curves=False,<br>from_roc=False,<br>show_plot=True,<br>verbose=False,<br>discarded_curves=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_outlier_curves(hvsr_data, plot_engine=&#39;plotly&#39;, plotly_module=&#39;go&#39;, remove_outliers_during_plot=False,
                        outlier_threshold=0.98, use_percentile=True, use_hv_curves=False, 
                        from_roc=False, show_plot=True, verbose=False, discarded_curves=None):
    &#34;&#34;&#34;Function to plot outlier curves, including which have been excluded

    Parameters
    ----------
    hvsr_data : HVSRData
        Input data object
    plot_engine : str = {&#39;plotly&#39;, &#39;matplotlib&#39;}
        Which plotting library to use, by default &#39;plotly&#39;
    plotly_module : str = {&#39;go&#39;, &#39;px&#39;}
        Which plotly module to use if applicable, by default &#39;go&#39;
    remove_outliers_during_plot : bool, optional
        Whether curves should also be removed when plotted. During sprit.run(), removal happens separately, so this is False.
    outlier_threshold : float, optional
        RMSE threshold (for removing outliers), by default 0.98
    use_percentile : bool, optional
        Whether to use percentile or raw value, by default True
    use_hv_curves : bool, optional
        Whether to perform analysis on HV curves (if True) or PSD curves (if False), by default False
    from_roc : bool, optional
        Helper parameter to determine if this is being called from sprit.remove_outlier_curves function, by default False
    show_plot : bool, optional
        Whether to show plot, by default True
    verbose : bool, optional
        Whether to print information to terminal, by default False

    Returns
    -------
    plotly figure
        Figure type depends on plotly_module
    &#34;&#34;&#34;
    orig_args = locals().copy()    
    
    hv_data = hvsr_data
    
    plotlyList = [&#39;plotly&#39;, &#39;plty&#39;, &#39;p&#39;]
    mplList = [&#39;matplotlib&#39;, &#39;mpl&#39;, &#39;pyplot&#39;, &#39;mtpltlb&#39;, &#39;m&#39;]
    
    if outlier_threshold &lt; 1:
        outlier_threshold = outlier_threshold * 100
    
    roc_kwargs = {&#39;outlier_threshold&#39;:outlier_threshold,
                    &#39;use_percentile&#39;:True,
                    &#39;use_hv_curves&#39;:use_hv_curves,
                    &#39;show_outlier_plot&#39;:False,
                    &#39;plot_engine&#39;:&#39;None&#39;,
                    &#39;verbose&#39;:verbose
                    }
    
    if str(plot_engine).lower() in plotlyList:
        #outlier_fig = go.FigureWidget()
        pxList = [&#39;px&#39;, &#39;express&#39;, &#39;exp&#39;, &#39;plotly express&#39;, &#39;plotlyexpress&#39;]
        if str(plotly_module).lower() in pxList:
            return __plotly_outlier_curves_px(**orig_args)
        
        outlier_fig = go.Figure()
        
        titleText = &#39;Outlier Curve Plot&#39;
        if use_hv_curves:
            titleText += &#39; (H/V Curves)&#39;
        else:
            titleText += &#39; PSD Curves&#39;
        outlier_fig = go.Figure()
            
        if &#39;generate_psds_status&#39; in hvsr_data.processing_status.keys() and hvsr_data.processing_status[&#39;generate_psds_status&#39;]:
            #log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nremove_outlier_curves():\n&#39;{roc_kwargs}&#34;    
            #hvsr_data = sprit_hvsr.remove_outlier_curves(hvsr_data, **roc_kwargs)
            pass
        else:
            #log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nremove_outlier_curves() attempted, but not completed. hvsr_data.processing_status[&#39;generate_psds_status&#39;]=False\n&#39;{roc_kwargs}&#34;
            return outlier_fig

        if roc_kwargs[&#39;use_hv_curves&#39;]:
            no_subplots = 1
            if hasattr(hvsr_data, &#39;hvsr_windows_df&#39;) and &#39;HV_Curves&#39; in hvsr_data.hvsr_windows_df.columns:
                outlier_fig.data = []
                outlier_fig.update_layout(grid=None)  # Clear the existing grid layout
                outlier_subp = subplots.make_subplots(rows=no_subplots, cols=1, horizontal_spacing=0.01, vertical_spacing=0.1)
                outlier_fig.update_layout(grid={&#39;rows&#39;: 1})
                #outlier_fig = go.FigureWidget(outlier_subp)
                outlier_fig = go.Figure(outlier_subp)

                x_data = hvsr_data[&#39;x_freqs&#39;][&#39;Z&#39;]
                curve_traces = []
                for ind, (i, hv) in enumerate(hvsr_data.hvsr_windows_df.iterrows()):
                    nameLabel = f&#34;Window starting at {i.strftime(&#39;%H:%M:%S&#39;)}&lt;br&gt;Window #{ind}&#34;
                    curve_traces.append(go.Scatter(x=x_data, y=hv[&#39;HV_Curves&#39;], 
                                hovertemplate=nameLabel, line=dict(color=&#39;rgba(0,0,0,0.1)&#39;, width=0.75),
                                showlegend=False))
                outlier_fig.add_traces(curve_traces)
                
                # Calculate a median curve, and reshape so same size as original
                medCurve = np.nanmedian(np.stack(hvsr_data.hvsr_windows_df[&#39;HV_Curves&#39;]), axis=0)
                outlier_fig.add_trace(go.Scatter(x=x_data, y=medCurve, line=dict(color=&#39;rgba(0,0,0,1)&#39;, width=1.5),showlegend=False))
                
                minY = np.nanmin(np.stack(hvsr_data.hvsr_windows_df[&#39;HV_Curves&#39;]))
                maxY = np.nanmax(np.stack(hvsr_data.hvsr_windows_df[&#39;HV_Curves&#39;]))
                totalWindows = hvsr_data.hvsr_windows_df.shape[0]
                #medCurveArr = np.tile(medCurve, (curr_data.shape[0], 1))

        else:
            no_subplots = 3
            outlier_fig.data = []
            outlier_fig.update_layout(grid=None)  # Clear the existing grid layout
            outlier_subp = subplots.make_subplots(rows=no_subplots, cols=1, horizontal_spacing=0.01, vertical_spacing=0.02,
                                                    row_heights=[1, 1, 1])
            outlier_fig.update_layout(grid={&#39;rows&#39;: 3})
            #outlier_fig = go.FigureWidget(outlier_subp)
            outlier_fig = go.Figure(outlier_subp)

            if hasattr(hvsr_data, &#39;hvsr_windows_df&#39;):
                rowDict = {&#39;Z&#39;:1, &#39;E&#39;:2, &#39;N&#39;:3}
                showTLabelsDict={&#39;Z&#39;:False, &#39;E&#39;:False, &#39;N&#39;:True}
                def comp_rgba(comp, a):
                    compstr = &#39;&#39;
                    if comp==&#39;Z&#39;:
                        compstr = f&#39;rgba(0, 0, 0, {a})&#39;
                    if comp==&#39;E&#39;:
                        compstr = f&#39;rgba(50, 50, 250, {a})&#39;
                    if comp==&#39;N&#39;:
                        compstr = f&#39;rgba(250, 50, 50, {a})&#39;
                    return compstr                         
                compNames = [&#39;Z&#39;, &#39;E&#39;, &#39;N&#39;]
                rmse_to_plot=[]
                med_traces=[]

                noRemoved = 0
                indRemoved = []
                for i, comp in enumerate(compNames):
                    if hasattr(hvsr_data, &#39;x_freqs&#39;):
                        x_data = hvsr_data[&#39;x_freqs&#39;][comp]
                    else:
                        x_data = [1/p for p in hvsr_data[&#39;psds&#39;][comp][&#39;period_xedges&#39;][1:]]                    
                    column = &#39;psd_values_&#39;+comp
                    # Retrieve data from dataframe (use all windows, just in case)
                    curr_data = np.stack(hvsr_data[&#39;hvsr_windows_df&#39;][column])
                    
                    # Calculate a median curve, and reshape so same size as original
                    medCurve = np.nanmedian(curr_data, axis=0)
                    medCurveArr = np.tile(medCurve, (curr_data.shape[0], 1))
                    medTrace = go.Scatter(x=x_data, y=medCurve, line=dict(color=comp_rgba(comp, 1), width=1.5), 
                                                    name=f&#39;{comp} Component&#39;, showlegend=True)
                    # Calculate RMSE
                    rmse = np.sqrt(((np.subtract(curr_data, medCurveArr)**2).sum(axis=1))/curr_data.shape[1])

                    rmse_threshold = np.percentile(rmse, roc_kwargs[&#39;outlier_threshold&#39;])
                    
                    # Retrieve index of those RMSE values that lie outside the threshold
                    timeIndex = hvsr_data[&#39;hvsr_windows_df&#39;].index
                    for j, curve in enumerate(curr_data):
                        if rmse[j] &gt; rmse_threshold:
                            badTrace = go.Scatter(x=x_data, y=curve,
                                                line=dict(color=comp_rgba(comp, 1), width=1.5, dash=&#39;dash&#39;),
                                                #marker=dict(color=comp_rgba(comp, 1), size=3),
                                                name=str(hvsr_data.hvsr_windows_df.index[j]), showlegend=False)
                            outlier_fig.add_trace(badTrace, row=rowDict[comp], col=1)
                            if j not in indRemoved:
                                indRemoved.append(j)
                            noRemoved += 1
                        else:
                            goodTrace = go.Scatter(x=x_data, y=curve,
                                                    line=dict(color=comp_rgba(comp, 0.01)), name=str(hvsr_data.hvsr_windows_df.index[j]), showlegend=False)
                            outlier_fig.add_trace(goodTrace, row=rowDict[comp], col=1)

                    #timeIndRemoved = pd.DatetimeIndex([timeIndex[ind] for ind in indRemoved])
                    #hvsr_data[&#39;hvsr_windows_df&#39;].loc[timeIndRemoved, &#39;Use&#39;] = False

                    outlier_fig.add_trace(medTrace, row=rowDict[comp], col=1)
                    
                    outlier_fig.update_xaxes(showticklabels=False, row=1, col=1)
                    outlier_fig.update_yaxes(title={&#39;text&#39;:&#39;Z&#39;}, row=1, col=1)
                    outlier_fig.update_xaxes(showticklabels=False, row=2, col=1)
                    outlier_fig.update_yaxes(title={&#39;text&#39;:&#39;E&#39;}, row=2, col=1)
                    outlier_fig.update_xaxes(showticklabels=True, row=3, col=1)
                    outlier_fig.update_yaxes(title={&#39;text&#39;:&#39;N&#39;}, row=3, col=1)

                    outlier_fig.update_layout(margin={&#34;l&#34;:10, &#34;r&#34;:10, &#34;t&#34;:30, &#39;b&#39;:0}, showlegend=True,
                                    title=f&#34;{hvsr_data[&#39;site&#39;]} Outliers&#34;)
                    if comp == &#39;N&#39;:
                        minY = np.nanmin(curr_data)
                        maxY = np.nanmax(curr_data)
                    totalWindows = curr_data.shape[0]
                
                outlier_fig.add_annotation(
                    text=f&#34;{len(indRemoved)}/{totalWindows} outlier windows removed&#34;,
                    x=np.log10(max(x_data)) - (np.log10(max(x_data))-np.log10(min(x_data))) * 0.01,
                    y=minY+(maxY-minY)*0.01,
                    xanchor=&#34;right&#34;, yanchor=&#34;bottom&#34;,#bgcolor=&#39;rgba(256,256,256,0.7)&#39;,
                    showarrow=False,row=no_subplots, col=1)


        outlier_fig.update_xaxes(type=&#39;log&#39;)
        outlier_fig.update_layout(paper_bgcolor=&#39;white&#39;, plot_bgcolor=&#39;white&#39;,
                                font_color=&#39;black&#39;, 
                                title=dict(font_color=&#39;black&#39;,
                                text=titleText))
        #with outlier_graph_widget:
        #    clear_output(wait=True)
        #    display(outlier_fig)
        if show_plot:
            outlier_fig.show()        
    else: # Matplotlib outlier plot
        #if discarded_curves is not None:
        #    for i, b in enumerate(hvsr_data[&#39;hvsr_windows_df&#39;].index[pd.Series(discarded_curves)]):
        #        print(&#39;DSCURVES&#39;, discarded_curves)
        #        print(b)

        # Determine names of hvsr_windows_df columns to use
        if not use_hv_curves:
            compNames = [&#39;Z&#39;, &#39;E&#39;, &#39;N&#39;]
            for col_name in hvsr_data[&#39;hvsr_windows_df&#39;].columns:
                if &#39;psd_values&#39; in col_name and &#39;RMSE&#39; not in col_name:
                    cName = col_name.split(&#39;_&#39;)[2]
                    if cName not in compNames:
                        compNames.append(cName)
            col_prefix = &#39;psd_values_&#39;
            colNames = [col_prefix+cn for cn in compNames]
        else:
            compNames = []
            for col_name in hvsr_data[&#39;hvsr_windows_df&#39;].columns:
                if col_name.startswith(&#39;HV_Curves&#39;) and &#34;Log10&#34; not in col_name:
                    compNames.append(col_name)
            colNames = compNames
            col_prefix = &#39;HV_Curves&#39;
    
        spMosaic = []
        if use_hv_curves:
            spMosaic.append([&#39;HV Curve&#39;])
            fSize = (8.5, 6)
        else:
            for c in compNames:
                spMosaic.append([c])
            fSize = (8.5, len(compNames) * 2)

            # Intialize to only get unique labels
            rem_label_got = False
            keep_label_got = False

        outlier_fig, ax = plt.subplot_mosaic(spMosaic, sharex=True, figsize=fSize)
            
        # Loop through each component, and determine which curves are outliers
        bad_rmse = []
        for i, column in enumerate(colNames):
            if column in compNames:
                if use_hv_curves == False:
                    column = col_prefix + column
                else:
                    column = column

            # Retrieve data from dataframe (use all windows, just in case)
            curr_data = np.stack(hvsr_data[&#39;hvsr_windows_df&#39;][column])
            
            # Calculate a median curve, and reshape so same size as original
            medCurve = np.nanmedian(curr_data, axis=0)
            medCurveArr = np.tile(medCurve, (curr_data.shape[0], 1))

            # Calculate RMSE
            rmse = np.sqrt(((np.subtract(curr_data, medCurveArr)**2).sum(axis=1))/curr_data.shape[1])
            hvsr_data[&#39;hvsr_windows_df&#39;][&#39;RMSE_&#39;+column] = rmse
            if use_percentile is True:
                rmse_threshold = np.percentile(rmse[~np.isnan(rmse)], outlier_threshold)
                if verbose:
                    print(f&#39;\tRMSE at {outlier_threshold}th percentile for {column} calculated at: {rmse_threshold:.2f}&#39;)
            else:
                rmse_threshold = outlier_threshold

            # Retrieve index of those RMSE values that lie outside the threshold
            for j, curve in enumerate(curr_data):
                if rmse[j] &gt; rmse_threshold:
                    bad_rmse.append(j)

            # Iterate through each curve to determine if it&#39;s rmse is outside threshold, for plot
            keep_label_got = False
            rem_label_got = False
            for j, curve in enumerate(curr_data):
                label = None
                if rmse[j] &gt; rmse_threshold:
                    linestyle = &#39;dashed&#39;
                    linecolor=&#39;darkred&#39;
                    alpha = 1
                    linewidth = 1
                    if not rem_label_got:
                        label=&#39;Removed Curve&#39;
                        rem_label_got=True
                else:
                    linestyle=&#39;solid&#39;
                    linecolor = &#39;rosybrown&#39;
                    alpha = 0.25
                    linewidth=0.5
                    if not keep_label_got:
                        keep_label_got=True
                        label=&#39;Retained Curve&#39;

                # Plot each individual curve
                if not use_hv_curves:
                    if &#39;x_freqs&#39; in hvsr_data.keys():
                        ax[compNames[i]].plot(hvsr_data.x_freqs[compNames[i]], curve, linewidth=linewidth, c=linecolor, linestyle=linestyle, alpha=alpha, label=label)
                    else:
                        ax[compNames[i]].plot(1/hvsr_data.psds[compNames[i]][&#39;period_bin_centers&#39;], curve, linewidth=linewidth, c=linecolor, linestyle=linestyle, alpha=alpha, label=label)
                else:
                    if &#39;x_freqs&#39; in hvsr_data.keys():
                        ax[&#34;HV Curve&#34;].plot(hvsr_data.x_freqs[&#39;Z&#39;][:-1], curve, linewidth=linewidth, c=linecolor, linestyle=linestyle, alpha=alpha, label=label)
                    else:
                        ax[&#34;HV Curve&#34;].plot(1/(hvsr_data.psds[&#39;Z&#39;][&#39;period_bin_centers&#39;][:-1]), curve, linewidth=linewidth, c=linecolor, linestyle=linestyle, alpha=alpha, label=label)                    
            
            # Plot the median curve
            if &#39;HV_Curves&#39; in compNames[i]:
                axName = &#39;HV Curve&#39;
                keyName = &#39;Z&#39;
            else:
                axName = keyName = compNames[i]
            
            if not use_hv_curves:
                if &#39;x_freqs&#39; in hvsr_data.keys():
                    ax[compNames[i]].plot(hvsr_data.x_freqs[compNames[i]], medCurve, linewidth=1, color=&#39;k&#39;, label=&#39;Median Curve&#39;)
                else:
                    ax[compNames[i]].plot(1/hvsr_data.psds[compNames[i]][&#39;period_bin_centers&#39;],medCurve, linewidth=1, color=&#39;k&#39;, label=&#39;Median Curve&#39;)
            else:
                if &#39;x_freqs&#39; in hvsr_data.keys():
                    ax[&#39;HV Curve&#39;].plot(hvsr_data.x_freqs[&#39;Z&#39;][:-1], medCurve, linewidth=1, color=&#39;k&#39;, label=&#39;Median Curve&#39;)
                else:
                    ax[&#39;HV Curve&#39;].plot(1/hvsr_data.psds[&#39;Z&#39;][&#39;period_bin_centers&#39;][:-1],medCurve, linewidth=1, color=&#39;k&#39;, label=&#39;Median Curve&#39;)


            # Format axis
            ax[axName].set_ylabel(f&#34;{compNames[i]}&#34;)
            ax[axName].legend(fontsize=10, labelspacing=0.1)
            ax[axName].semilogx()

        outlier_fig.suptitle(f&#34;{hvsr_data[&#39;site&#39;]}\n Curves Removed from Analysis&#34;)
        outlier_fig.set_layout_engine(&#39;constrained&#39;)
                
        hvsr_data[&#39;Outlier_Plot&#39;] = outlier_fig 
    
        if show_plot:
            plt.show()
        else:
            plt.close()
    
    if remove_outliers_during_plot:
        bad_rmse = np.unique(bad_rmse)
        if len(bad_rmse) &gt; 0:
            hvsr_data[&#39;hvsr_windows_df&#39;][&#39;Use&#39;] = hvsr_data[&#39;hvsr_windows_df&#39;][&#39;Use&#39;] * (rmse_threshold &gt; hvsr_data[&#39;hvsr_windows_df&#39;][&#39;RMSE_&#39;+column])

    
    hvsr_data[&#39;Outlier_Plot&#39;] = outlier_fig 
    return outlier_fig</code></pre>
</details>
<div class="desc"><p>Function to plot outlier curves, including which have been excluded</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code></dt>
<dd>Input data object</dd>
<dt><strong><code>plot_engine</code></strong> :&ensp;<code>str = {'plotly', 'matplotlib'}</code></dt>
<dd>Which plotting library to use, by default 'plotly'</dd>
<dt><strong><code>plotly_module</code></strong> :&ensp;<code>str = {'go', 'px'}</code></dt>
<dd>Which plotly module to use if applicable, by default 'go'</dd>
<dt><strong><code>remove_outliers_during_plot</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether curves should also be removed when plotted. During sprit.run(), removal happens separately, so this is False.</dd>
<dt><strong><code>outlier_threshold</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>RMSE threshold (for removing outliers), by default 0.98</dd>
<dt><strong><code>use_percentile</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to use percentile or raw value, by default True</dd>
<dt><strong><code>use_hv_curves</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to perform analysis on HV curves (if True) or PSD curves (if False), by default False</dd>
<dt><strong><code>from_roc</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Helper parameter to determine if this is being called from sprit.remove_outlier_curves function, by default False</dd>
<dt><strong><code>show_plot</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to show plot, by default True</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print information to terminal, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>plotly figure</code></dt>
<dd>Figure type depends on plotly_module</dd>
</dl></div>
</dd>
<dt id="sprit.plot_results_plotly"><code class="name flex">
<span>def <span class="ident">plot_results_plotly</span></span>(<span>hv_data,<br>plot_string='HVSR p ann C+ p SPEC ann',<br>azimuth='HV',<br>results_fig=None,<br>results_graph_widget=None,<br>use_figure_widget=False,<br>return_fig=False,<br>show_results_plot=False,<br>html_plot=False,<br>verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_results_plotly(hv_data, plot_string=&#39;HVSR p ann C+ p SPEC ann&#39;, azimuth=&#39;HV&#39;,
                results_fig=None, results_graph_widget=None, use_figure_widget=False,
                return_fig=False, show_results_plot=False, html_plot=False,
                verbose=False,):
    
    &#34;&#34;&#34;Function to plot results using plotly

    Parameters
    ----------
    hv_data : sprit.HVSRData
        Data object to use for plotting
    plot_string : str, optional
        String for designating what to include in plot(s), by default &#39;HVSR p ann C+ p SPEC ann&#39;
    results_fig : pyplot figure, optional
        Which pyplot figure to plot data onto. If None, makes new figure, by default None.
    results_graph_widget : plotly graph object widget, optional
        Which pyplot figure to plot data onto. If None, makes new widget, if applicable, by default None.
    use_figure_widget : bool, optional
        Whether to use figure widget, by default False
    return_fig : bool, optional
        Whether to return figure, by default False
    show_results_plot : bool, optional
        Wheather to show plot, by default False
    html_plot : bool, optional
        Whether to create an HTML version of the plot, by default False
    verbose : bool, optional
        Whether to print information to terminal, by default False

    Returns
    -------
    plotly figure
        Only if return_fig is True.
    &#34;&#34;&#34;

    if results_fig is None:
        results_fig = go.FigureWidget()

    hvsr_data = hv_data

    plotymax = max(hvsr_data.hvsrp2[&#39;HV&#39;]) + (max(hvsr_data.hvsrp2[&#39;HV&#39;]) - max(hvsr_data.hvsr_curve))
    if plotymax &gt; hvsr_data.BestPeak[&#39;HV&#39;][&#39;A0&#39;] * 1.5:
        plotymax = hvsr_data.BestPeak[&#39;HV&#39;][&#39;A0&#39;] * 1.5
    ylim = [0, plotymax]
    if isinstance(hvsr_data, sprit_hvsr.HVSRBatch):
        hvsr_data = hvsr_data[0]

    hvsrDF = hvsr_data.hvsr_windows_df

    plot_list = parse_plot_string(plot_string)

    combinedComp = False
    # By default there 3 subplots
    noSubplots = 3
    # Remove any subplots that are not indicated by plot_type parameter
    noSubplots = noSubplots - plot_list.count([])
    
    # Now, check if comp plot is combined with HV
    if plot_list[1] != [] and &#39;+&#39; not in plot_list[1][0]:
        combinedComp = True
        noSubplots -= 1
    
    # Get all data for each plotted item
    # Get subplot numbers based on plot_list
    spec = []
    if plot_list[0]==[]:
        # if for some reason, HVSR plot was not indicated, add it
        hv_plot_row = 1 # Default first row to hv (may change later)
        noSubplots += 1
        if plot_list[1] == []:
            comp_plot_row = None
            if plot_list[2] == []:
                spec_plot_row = None
                hv_plot_row = 1 #If nothing specified, do basic h/v plot
            else:
                spec_plot_row = 1 # If only spec specified
        else:
            comp_plot_row = 1 # If no HV specified by comp is, comp is subplot 1

            if plot_list[2] == []:
                spec_plot_row = None
            else:
                spec_plot_row = 2 # If only comp and spec specified comp first then spec
    else:
        hv_plot_row = 1 # HV specified explicitly
        if plot_list[1] == []:
            comp_plot_row = None
            if plot_list[2] == []:
                spec_plot_row = None
            else:
                spec_plot_row = 2 # if no comp specified, spec is 2nd subplot
        else:
            if combinedComp:
                comp_plot_row = 1
                if plot_list[2] == []:
                    spec_plot_row = None
                else:
                    spec_plot_row = 2
            else:
                comp_plot_row = 2
                if plot_list[2] == []:
                    spec_plot_row = None
                else:
                    spec_plot_row = 3       

    specList = []
    rHeights = [1]
    if hv_plot_row == 1:
        if comp_plot_row == 1:
            specList.append([{&#39;secondary_y&#39;: True}])
            if spec_plot_row == 2:
                specList.append([{&#39;secondary_y&#39;: False}])
    else:
        specList.append([{&#39;secondary_y&#39;: False}])

        if noSubplots &gt;= 2:
            specList.append([{&#39;secondary_y&#39;: False}])
            rHeights = [1.5,1]
        if noSubplots == 3:
            specList.append([{&#39;secondary_y&#39;: False}])
            rHeights = [2,1.5,1]
    
    # Failsafes
    while len(specList)&lt;noSubplots:
        specList.append([{}])

    while len(rHeights)&lt;noSubplots:
        rHeights.append(1)

    # Re-initialize results_fig
    results_fig.data = []
    results_fig.update_layout(grid=None)  # Clear the existing grid layout, in case applicable

    results_fig = make_subplots(rows=noSubplots, cols=1, horizontal_spacing=0.01, vertical_spacing=0.07,
                                specs=specList,
                                row_heights=rHeights)
    results_fig.update_layout(grid={&#39;rows&#39;: noSubplots})

    if use_figure_widget:
        results_fig = go.FigureWidget(results_fig)

    if plot_list[1] != []:
        results_fig = _parse_comp_plot_list(hvsr_data, results_fig=results_fig, 
                                           comp_plot_list=plot_list[1])
        results_fig.update_xaxes(title_text=&#39;Frequency [Hz]&#39;,
                                 row=comp_plot_row, col=1)

    # HVSR Plot (plot this after COMP so it is on top COMP and to prevent deletion with no C+)
    results_fig = _parse_hv_plot_list(hvsr_data, hvsr_plot_list=plot_list, results_fig=results_fig)

    # Will always plot the HV Curve
    results_fig.add_trace(go.Scatter(x=hvsr_data.x_freqs[&#39;Z&#39;], y=hvsr_data.hvsr_curve,
                        line={&#39;color&#39;:&#39;black&#39;, &#39;width&#39;:1.5}, marker=None, name=&#39;HVSR Curve&#39;),
                        row=1, col=&#39;all&#39;)

    # SPEC plot
    if plot_list[2] != []:
        results_fig = _parse_spec_plot_list(hvsr_data, spec_plot_list=plot_list[2], subplot_num=spec_plot_row, azimuth=azimuth, results_fig=results_fig)

    # Final figure updating
    resultsFigWidth = 650

    components_HV_on_same_plot = (plot_list[1]==[] or &#39;+&#39; not in plot_list[1][0])
    if components_HV_on_same_plot:
        compxside = &#39;bottom&#39;
        secondaryY = True
        showHVTickLabels = True
        showComptickLabels = True
    else:
        compxside = &#39;bottom&#39;
        secondaryY = False
        showHVTickLabels = True
        showComptickLabels = True
    
    # Update H/V Plot
    results_fig.update_xaxes(type=&#39;log&#39;, title_text=&#39;Frequency [Hz]&#39;, title_standoff=0,
                    range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])],
                    side=&#39;bottom&#39;, showticklabels=showHVTickLabels,
                    row=1, col=1)
    results_fig.update_yaxes(title_text=&#39;H/V Ratio&#39;, row=1, col=1, 
                             secondary_y=False, range=ylim)

    # Update Component plot
    results_fig.update_xaxes(type=&#39;log&#39;, overlaying=&#39;x&#39;, showticklabels=showComptickLabels, title_standoff=0,
                             range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])],
                             side=compxside, row=comp_plot_row, col=1)    
    results_fig.update_yaxes(title_text=&#34;PPSD Amp\n[m2/s4/Hz][dB]&#34;, secondary_y=secondaryY, row=comp_plot_row, col=1)

    # Update Spec plot
    results_fig.update_yaxes(title_text=&#39;H/V Over Time&#39;, row=noSubplots, col=1)

    # Update entire figure
    titleString = f&#34;{hvsr_data[&#39;site&#39;]} Results&#34;
    results_fig.update_layout(margin={&#34;l&#34;:40, &#34;r&#34;:10, &#34;t&#34;:35, &#39;b&#39;:0},
                            showlegend=False, autosize=False, width=resultsFigWidth, height=resultsFigWidth*0.7,
                            title=titleString)
    
    # Reset results_graph_widget and display 
    #if results_graph_widget is not None:
    #    with results_graph_widget:
    #        clear_output(wait=True)
    #        display(results_fig)

    if show_results_plot:
        if html_plot:
            results_fig.write_html(titleString.replace(&#39; &#39;, &#39;_&#39;) + &#39;plot.html&#39;, auto_open=True)
        else:
            results_fig.show()
    
    if return_fig:
        return results_fig</code></pre>
</details>
<div class="desc"><p>Function to plot results using plotly</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hv_data</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code></dt>
<dd>Data object to use for plotting</dd>
<dt><strong><code>plot_string</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>String for designating what to include in plot(s), by default 'HVSR p ann C+ p SPEC ann'</dd>
<dt><strong><code>results_fig</code></strong> :&ensp;<code>pyplot figure</code>, optional</dt>
<dd>Which pyplot figure to plot data onto. If None, makes new figure, by default None.</dd>
<dt><strong><code>results_graph_widget</code></strong> :&ensp;<code>plotly graph object widget</code>, optional</dt>
<dd>Which pyplot figure to plot data onto. If None, makes new widget, if applicable, by default None.</dd>
<dt><strong><code>use_figure_widget</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to use figure widget, by default False</dd>
<dt><strong><code>return_fig</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to return figure, by default False</dd>
<dt><strong><code>show_results_plot</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Wheather to show plot, by default False</dd>
<dt><strong><code>html_plot</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to create an HTML version of the plot, by default False</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print information to terminal, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>plotly figure</code></dt>
<dd>Only if return_fig is True.</dd>
</dl></div>
</dd>
<dt id="sprit.process_hvsr"><code class="name flex">
<span>def <span class="ident">process_hvsr</span></span>(<span>hvsr_data,<br>horizontal_method=None,<br>smooth=True,<br>freq_smooth='konno ohmachi',<br>f_smooth_width=40,<br>resample=True,<br>outlier_curve_percentile_threshold=False,<br>azimuth=None,<br>verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_hvsr(hvsr_data, horizontal_method=None, smooth=True, freq_smooth=&#39;konno ohmachi&#39;, 
                 f_smooth_width=40, resample=True, 
                 outlier_curve_percentile_threshold=False, azimuth=None, verbose=False):
    &#34;&#34;&#34;Process the input data and get HVSR data
    
    This is the main function that uses other (private) functions to do 
    the bulk of processing of the HVSR data and the data quality checks.

    Parameters
    ----------
    hvsr_data  : HVSRData or HVSRBatch
        Data object containing all the parameters input and generated by the user (usually, during sprit.input_params(), sprit.fetch_data(), sprit.generate_psds() and/or sprit.remove_noise()).
    horizontal_method  : int or str, default=3
        Method to use for combining the horizontal components. Default is 3) Geometric Mean
            0) (not used) 
            1) &#39;Diffuse field assumption&#39;   H = √( (eie_E + eie_N) / eie_Z), eie = equal interval energy
            2) &#39;Arithmetic Mean&#39;            H ≡ (HN + HE)/2
            3) &#39;Geometric Mean&#39;             H ≡ √(HN · HE), recommended by the SESAME project (2004)
            4) &#39;Vector Summation&#39;           H ≡ √(HN^2 + HE^2)
            5) &#39;Quadratic Mean&#39;             H ≡ √(HN^2 + HE^2)/2
            6) &#39;Maximum Horizontal Value&#39;   H ≡ max {HN, HE}
            7) &#39;Minimum Horizontal Valey&#39;   H ≡ min {HN, HE}
            8) &#39;Single Azimuth&#39;             H = H2·cos(az) + H1·sin(az)
    smooth  : bool, default=True
        bool or int may be used. 
            If True, default to smooth H/V curve to using savgoy filter with window length of 51 (works well with default resample of 1000 pts)
            If int, the length of the window in the savgoy filter.
    freq_smooth : str {&#39;konno ohmachi&#39;, &#39;constant&#39;, &#39;proportional&#39;}
        Which frequency smoothing method to use. By default, uses the &#39;konno ohmachi&#39; method.
            - The Konno &amp; Ohmachi method uses the obspy.signal.konnoohmachismoothing.konno_ohmachi_smoothing() function: https://docs.obspy.org/packages/autogen/obspy.signal.konnoohmachismoothing.konno_ohmachi_smoothing.html
            - The constant method uses a window of constant length f_smooth_width
            - The proportional method uses a window the percentage length of the frequncy steps/range (f_smooth_width now refers to percentage)
        See here for more information: https://www.geopsy.org/documentation/geopsy/hv-processing.html
    f_smooth_width : int, default = 40
        - For &#39;konno ohmachi&#39;: passed directly to the bandwidth parameter of the konno_ohmachi_smoothing() function, determines the width of the smoothing peak, with lower values resulting in broader peak. Must be &gt; 0.
        - For &#39;constant&#39;: the size of a triangular smoothing window in the number of frequency steps
        - For &#39;proportional&#39;: the size of a triangular smoothing window in percentage of the number of frequency steps (e.g., if 1000 frequency steps/bins and f_smooth_width=40, window would be 400 steps wide)
    resample  : bool, default = True
        bool or int. 
            If True, default to resample H/V data to include 1000 frequency values for the rest of the analysis
            If int, the number of data points to interpolate/resample/smooth the component psd/HV curve data to.
    outlier_curve_percentile_threshold : bool, float, default = False
        If False, outlier curve removal is not carried out here. 
        If True, defaults to 98 (98th percentile). 
        Otherwise, float of percentile used as outlier_threshold of remove_outlier_curve().
    azimuth : float, default = None
        The azimuth angle to use when method is single azimuth.
    verbose : bool, defualt=False
        Whether to print output to terminal

    Returns
    -------
        hvsr_out    : dict
            Dictionary containing all the information about the data, including input parameters

    &#34;&#34;&#34;
    orig_args = locals().copy() #Get the initial arguments
    start_time = datetime.datetime.now()

    # Update with processing parameters specified previously in input_params, if applicable
    if &#39;processing_parameters&#39; in hvsr_data.keys():
        if &#39;process_hvsr&#39; in hvsr_data[&#39;processing_parameters&#39;].keys():
            update_msg = []
            for k, v in hvsr_data[&#39;processing_parameters&#39;][&#39;process_hvsr&#39;].items():
                defaultVDict = dict(zip(inspect.getfullargspec(process_hvsr).args[1:], 
                                        inspect.getfullargspec(process_hvsr).defaults))
                # Manual input to function overrides the imported parameter values
                if (not isinstance(v, (HVSRData, HVSRBatch))) and (k in orig_args.keys()) and (orig_args[k]==defaultVDict[k]):
                    update_msg.append(f&#39;\t\t{k} = {v} (previously {orig_args[k]})&#39;)
                    orig_args[k] = v
                                        
    horizontal_method = orig_args[&#39;horizontal_method&#39;]
    smooth = orig_args[&#39;smooth&#39;]
    freq_smooth = orig_args[&#39;freq_smooth&#39;]
    f_smooth_width = orig_args[&#39;f_smooth_width&#39;]
    resample = orig_args[&#39;resample&#39;]
    outlier_curve_percentile_threshold = orig_args[&#39;outlier_curve_percentile_threshold&#39;]
    verbose = orig_args[&#39;verbose&#39;]

    if (verbose and isinstance(hvsr_data, HVSRBatch)) or (verbose and not hvsr_data[&#39;batch&#39;]):
        if isinstance(hvsr_data, HVSRData) and hvsr_data[&#39;batch&#39;]:
            pass
        else:
            print(&#39;\nCalculating Horizontal/Vertical Ratios at all frequencies/time steps (process_hvsr())&#39;)
            print(&#39;\tUsing the following parameters:&#39;)
            for key, value in orig_args.items():
                if key==&#39;hvsr_data&#39;:
                    pass
                else:
                    print(&#39;\t  {}={}&#39;.format(key, value))
            print()

        if &#39;processing_parameters&#39; in hvsr_data.keys() and &#39;process_hvsr&#39; in hvsr_data[&#39;processing_parameters&#39;].keys():
            if update_msg != []:
                update_msg.insert(0, &#39;\tThe following parameters were updated using the processing_parameters attribute:&#39;)
                for msg_line in update_msg:
                    print(msg_line)
                print()
            
    # PROCESSING STARTS HERE (SEPARATE LOOP FOR BATCH)
    if isinstance(hvsr_data, HVSRBatch):
        #If running batch, we&#39;ll loop through each site
        hvsr_out = {}
        for site_name in hvsr_data.keys():
            args = orig_args.copy() #Make a copy so we don&#39;t accidentally overwrite
            args[&#39;hvsr_data&#39;] = hvsr_data[site_name] #Get what would normally be the &#34;hvsr_data&#34; variable for each site
            if hvsr_data[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;]:
                try:
                    hvsr_out[site_name] = __process_hvsr_batch(**args) #Call another function, that lets us run this function again
                except:
                    hvsr_out = hvsr_data
                    hvsr_out[site_name][&#39;processing_status&#39;][&#39;process_hvsr_status&#39;]=False
                    hvsr_out[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;] = False                    
            else:
                hvsr_out = hvsr_data
                hvsr_out[site_name][&#39;processing_status&#39;][&#39;process_hvsr_status&#39;]=False
                hvsr_out[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;] = False
        hvsr_out = HVSRBatch(hvsr_out, df_as_read=hvsr_data.input_df)
        hvsr_out = sprit_utils._check_processing_status(hvsr_out, start_time=start_time, func_name=inspect.stack()[0][3], verbose=verbose)
        return hvsr_out
    
    psds = hvsr_data[&#39;psds&#39;].copy()#[k][&#39;psd_values&#39;]
    psds = sprit_utils._check_xvalues(psds)

    methodList = [&#39;&lt;placeholder_0&gt;&#39;, # 0
                    &#39;Diffuse Field Assumption&#39;, # 1
                    &#39;Arithmetic Mean&#39;, # 2
                    &#39;Geometric Mean&#39;, # 3
                    &#39;Vector Summation&#39;, # 4
                    &#39;Quadratic Mean&#39;, # 5
                    &#39;Maximum Horizontal Value&#39;, # 6
                    &#39;Minimum Horizontal Value&#39;, # 7
                    &#39;Single Azimuth&#39; ] # 8
    x_freqs = {}
    x_periods = {}

    psdValsTAvg = {}
    stDev = {}
    stDevValsP = {}
    stDevValsM = {}
    psdRaw={}
    currTimesUsed={}
    hvsr_data[&#39;hvsr_windows_df&#39;][&#39;Use&#39;] = hvsr_data[&#39;hvsr_windows_df&#39;][&#39;Use&#39;].astype(bool)
    hvsrDF = hvsr_data[&#39;hvsr_windows_df&#39;]
    def move_avg(y, box_pts):
        #box = np.ones(box_pts)/box_pts
        box = np.hanning(box_pts)
        y_smooth = np.convolve(y, box, mode=&#39;same&#39;) / sum(box)
        return y_smooth

    resampleList = [&#39;period_bin_centers&#39;, &#39;period_bin_left_edges&#39;, &#39;period_bin_right_edges&#39;, &#39;period_xedges&#39;,
                    &#39;psd_frequencies&#39;, &#39;psd_periods&#39;]

    for k in psds.keys():
        #for ppsdk, ppsdv in psds[k].items():
            #print(ppsdk, isinstance(ppsdv, np.ndarray))
        #input_ppsds = psds[k][&#39;psd_values&#39;] #original, not used anymore
        input_ppsds = np.stack(hvsrDF[&#39;psd_values_&#39;+k].values)

        #currPPSDs = hvsrDF[&#39;psd_values_&#39;+k][hvsrDF[&#39;Use&#39;]].values
        #used_ppsds = np.stack(currPPSDs)

        xValMin_per = np.round(1/hvsr_data[&#39;hvsr_band&#39;][1], 4)
        xValMax_per = np.round(1/hvsr_data[&#39;hvsr_band&#39;][0], 4)
        
        # If resampling has been selected...
        if resample is True or type(resample) is int or type(resample) is float:
            if resample is True:
                resample = 1000 #Default smooth value

            # Resample period bin values
            x_periods[k] = np.logspace(np.log10(xValMin_per), np.log10(xValMax_per), num=resample)
                
            if smooth or isinstance(smooth, (int, float)):
                if smooth:
                    smooth = 51 #Default smoothing window
                    padVal = 25
                elif smooth % 2==0:
                    smooth + 1 #Otherwise, needs to be odd
                    padVal = smooth // 2
                    if padVal % 2 == 0:
                        padVal += 1


            # Resample raw ppsd values
            for i, ppsd_t in enumerate(input_ppsds):
                if i==0:
                    psdRaw[k] = np.interp(x_periods[k], psds[k][&#39;period_bin_centers&#39;], ppsd_t)
                    if smooth is not False and smooth is not None:
                        padRawKPad = np.pad(psdRaw[k], [padVal, padVal], mode=&#39;reflect&#39;)
                        #padRawKPadSmooth = scipy.signal.savgol_filter(padRawKPad, smooth, 3)
                        padRawKPadSmooth = move_avg(padRawKPad, smooth)
                        psdRaw[k] = padRawKPadSmooth[padVal:-padVal]

                else:
                    psdRaw[k] = np.vstack((psdRaw[k], np.interp(x_periods[k], psds[k][&#39;period_bin_centers&#39;], ppsd_t)))
                    if smooth is not False:
                        padRawKiPad = np.pad(psdRaw[k][i], [padVal, padVal], mode=&#39;reflect&#39;)
                        #padRawKiPadSmooth = scipy.signal.savgol_filter(padRawKiPad, smooth, 3)
                        padRawKiPadSmooth = move_avg(padRawKiPad, smooth)
                        psdRaw[k][i] = padRawKiPadSmooth[padVal:-padVal]

            # Resample other values
            for keys in resampleList:
                if keys == &#39;period_bin_centers&#39;:
                    baseLength = len(psds[k][keys])
                
                if psds[k][keys].ndim == 1:
                    if psds[k][keys].shape[-1] == baseLength:
                        psds[k][keys] = np.logspace(np.log10(min(psds[k][keys])), np.log10(max(psds[k][keys])), num=resample)
                    else:
                        psds[k][keys] = np.logspace(np.log10(min(psds[k][keys])), np.log10(max(psds[k][keys])), num=resample-1)
                else:
                    arrList = []
                    for arr in psds[k][keys]:
                        arrList.append(np.logspace(np.log10(min(arr)), np.log10(max(arr)), num=resample))
                    
                    psds[k][keys] = np.array(arrList)
        else:
            #If no resampling desired
            x_periods[k] =  np.array(psds[k][&#39;period_bin_centers&#39;])#[:-1]#np.round([1/p for p in hvsr_data[&#39;psds&#39;][k][&#39;period_xedges&#39;][:-1]], 3)

            # Clean up edge freq. values
            x_periods[k][0] = 1/hvsr_data[&#39;hvsr_band&#39;][1]
            x_periods[k][-1] = 1/hvsr_data[&#39;hvsr_band&#39;][0]

            # If simple curve smooothing desired
            if smooth or isinstance(smooth, (int, float)):
                if smooth:
                    smooth = 51 #Default smoothing window
                    padVal = 25
                elif smooth % 2==0:
                    smooth + 1 #Otherwise, needs to be odd
                    padVal = smooth // 2
                    if padVal % 2 == 0:
                        padVal += 1

                for i, ppsd_t in enumerate(input_ppsds):
                    if i == 0:
                        psdRaw[k] = ppsd_t
                        padRawKPad = np.pad(psdRaw[k], [padVal, padVal], mode=&#39;reflect&#39;)
                        #padRawKPadSmooth = scipy.signal.savgol_filter(padRawKPad, smooth, 3)
                        padRawKPadSmooth = move_avg(padRawKPad, smooth)
                        psdRaw[k] = padRawKPadSmooth[padVal:-padVal]
                    else:
                        psdRaw[k] = np.vstack((psdRaw[k], ppsd_t))
                        padRawKiPad = np.pad(psdRaw[k][i], [padVal, padVal], mode=&#39;reflect&#39;)
                        #padRawKiPadSmooth = scipy.signal.savgol_filter(padRawKiPad, smooth, 3)
                        padRawKiPadSmooth = move_avg(padRawKiPad, smooth)
                        psdRaw[k][i] = padRawKiPadSmooth[padVal:-padVal]
            else:
                # If no simple curve smoothing
                psdRaw[k] = np.array(input_ppsds)
        
        hvsrDF[&#39;psd_values_&#39;+k] = list(psdRaw[k])
        use = hvsrDF[&#39;Use&#39;].astype(bool)

        #Get average psd value across time for each channel (used to calc main H/V curve)
        psdValsTAvg[k] = np.nanmedian(np.stack(hvsrDF[use][&#39;psd_values_&#39;+k]), axis=0)
        x_freqs[k] = np.array([1/p for p in x_periods[k]]) #np.divide(np.ones_like(x_periods[k]), x_periods[k]) 
        stDev[k] = np.nanstd(np.stack(hvsrDF[use][&#39;psd_values_&#39;+k]), axis=0)

        stDevValsM[k] = np.array(psdValsTAvg[k] - stDev[k])
        stDevValsP[k] = np.array(psdValsTAvg[k] + stDev[k])

        currTimesUsed[k] = np.stack(hvsrDF[use][&#39;TimesProcessed_Obspy&#39;])
        #currTimesUsed[k] = psds[k][&#39;current_times_used&#39;] #original one
    
    #print(&#39;XFREQS&#39;, x_freqs[k].shape)
    #print(&#39;XPERs&#39;, x_periods[k].shape)
    #print(&#39;PSDRAW&#39;, psdRaw[k].shape)

    # Get string of horizontal_method type
    # First, define default
    if horizontal_method is None:
        horizontal_method = 3 # Geometric mean is used as default if nothing is specified

    # If an azimuth has been calculated and it&#39;s only one, automatically use the single azimuth method
    if len(hvsr_data.stream.merge().select(component=&#39;R&#39;)) == 1:
        horizontal_method = 8 # Single azimuth

    # horizontal_method needs to be str or int
    # First check if input is a string
    if type(horizontal_method) is str:
        if horizontal_method.isdigit():
            horizontal_method = int(horizontal_method)
        elif str(horizontal_method).title() in methodList:
            horizontal_method = methodList.index(horizontal_method.title())
        else:
            print(f&#34;\tHorizontal method {f} not recognized, reverting to default (geometric mean).\n\tMust be one of {methodList}&#34;)
            horizontal_method = 3

    # Now, horizontal_method is int no matter how it was entered
    methodInt = horizontal_method
    horizontal_method = methodList[horizontal_method]
    
    hvsr_data[&#39;horizontal_method&#39;] = horizontal_method

    #This gets the main hvsr curve averaged from all time steps
    anyK = list(x_freqs.keys())[0]
    hvsr_curve, hvsr_az, hvsr_tSteps = __get_hvsr_curve(x=x_freqs[anyK], psd=psdValsTAvg, horizontal_method=methodInt, hvsr_data=hvsr_data, azimuth=azimuth, verbose=verbose)
    origPPSD = hvsr_data[&#39;ppsds_obspy&#39;].copy()

    #print(&#39;hvcurv&#39;, np.array(hvsr_curve).shape)
    #print(&#39;hvaz&#39;, np.array(hvsr_az).shape)

    #Add some other variables to our output dictionary
    hvsr_dataUpdate = {&#39;input_params&#39;:hvsr_data,
                &#39;x_freqs&#39;:x_freqs,
                &#39;hvsr_curve&#39;:hvsr_curve,
                &#39;hvsr_az&#39;:hvsr_az,
                &#39;x_period&#39;:x_periods,
                &#39;psd_raw&#39;:psdRaw,
                &#39;current_times_used&#39;: currTimesUsed,
                &#39;psd_values_tavg&#39;:psdValsTAvg,
                &#39;ppsd_std&#39;:stDev,
                &#39;ppsd_std_vals_m&#39;:stDevValsM,
                &#39;ppsd_std_vals_p&#39;:stDevValsP,
                &#39;horizontal_method&#39;:horizontal_method,
                &#39;psds&#39;:psds,
                &#39;ppsds_obspy&#39;:origPPSD,
                &#39;tsteps_used&#39;: hvsr_data[&#39;tsteps_used&#39;].copy(),
                &#39;hvsr_windows_df&#39;:hvsr_data[&#39;hvsr_windows_df&#39;]
                }
    
    hvsr_out = HVSRData(hvsr_dataUpdate)

    #This is if manual editing was used (should probably be updated at some point to just use masks)
    if &#39;x_windows_out&#39; in hvsr_data.keys():
        hvsr_out[&#39;x_windows_out&#39;] = hvsr_data[&#39;x_windows_out&#39;]
    else:
        hvsr_out[&#39;x_windows_out&#39;] = []

    freq_smooth_ko = [&#39;konno ohmachi&#39;, &#39;konno-ohmachi&#39;, &#39;konnoohmachi&#39;, &#39;konnohmachi&#39;, &#39;ko&#39;, &#39;k&#39;]
    freq_smooth_constant = [&#39;constant&#39;, &#39;const&#39;, &#39;c&#39;]
    freq_smooth_proport = [&#39;proportional&#39;, &#39;proportion&#39;, &#39;prop&#39;, &#39;p&#39;]

    #Frequency Smoothing
    if not freq_smooth:
        if verbose:
            warnings.warn(&#39;No frequency smoothing is being applied. This is not recommended for noisy datasets.&#39;)
    elif freq_smooth is True or (freq_smooth.lower() in freq_smooth_ko and (not not f_smooth_width and not not freq_smooth)):
        from obspy.signal import konnoohmachismoothing
        for k in hvsr_out[&#39;psd_raw&#39;]:
            colName = f&#39;psd_values_{k}&#39;

            psd_data = np.stack(hvsr_out[&#39;hvsr_windows_df&#39;][colName])
            psd_data = hvsr_out[&#39;psd_raw&#39;][k]


            freqs = hvsr_out[&#39;x_freqs&#39;][k]
            padding_length = int(f_smooth_width)

            padding_value_R = np.nanmean(psd_data[:,-1*padding_length:])
            padding_value_L = np.nanmean(psd_data[:,:padding_length])

            # Pad the data to prevent boundary anamolies
            padded_ppsd_data = np.pad(psd_data, ((0, 0), (padding_length, padding_length)), 
                                        &#39;constant&#39;, constant_values=(padding_value_L, padding_value_R))

            # Pad the frequencies
            ratio = freqs[1] / freqs[0]
            # Generate new elements on either side and combine
            left_padding = [freqs[0] / (ratio ** i) for i in range(padding_length, 0, -1)]
            right_padding = [freqs[-1] * (ratio ** i) for i in range(1, padding_length + 1)]
            padded_freqs = np.concatenate([left_padding, freqs, right_padding])
            
            #Filter out UserWarning for just this method, since it throws up a UserWarning that doesn&#39;t really matter about dtypes often
            with warnings.catch_warnings():
                #warnings.simplefilter(&#39;ignore&#39;, category=UserWarning)
                padded_ppsd_data = padded_ppsd_data.astype(padded_freqs.dtype) # Make them the same datatype
                padded_ppsd_data = np.round(padded_ppsd_data, 12) # Prevent overflows
                padded_freqs = np.round(padded_freqs, 9)

                smoothed_ppsd_data = konnoohmachismoothing.konno_ohmachi_smoothing(padded_ppsd_data, padded_freqs, 
                                                    bandwidth=f_smooth_width, normalize=True)
            
            # Only use the original, non-padded data
            smoothed_ppsd_data = smoothed_ppsd_data[:,padding_length:-1*padding_length]
            hvsr_out[&#39;psd_raw&#39;][k] = smoothed_ppsd_data
            hvsr_out[&#39;hvsr_windows_df&#39;][colName] = pd.Series(list(smoothed_ppsd_data), index=hvsr_out[&#39;hvsr_windows_df&#39;].index)
    elif freq_smooth.lower() in freq_smooth_constant:
        hvsr_out = __freq_smooth_window(hvsr_out, f_smooth_width, kind_freq_smooth=&#39;constant&#39;)
    elif freq_smooth.lower() in freq_smooth_proport:
        hvsr_out = __freq_smooth_window(hvsr_out, f_smooth_width, kind_freq_smooth=&#39;proportional&#39;)
    else:
        if verbose:
            warnings.warn(f&#39;You indicated no frequency smoothing should be applied (freq_smooth = {freq_smooth}). This is not recommended for noisy datasets.&#39;)

    #Get hvsr curve from three components at each time step
    anyK = list(hvsr_out[&#39;psd_raw&#39;].keys())[0]
    if horizontal_method==1 or horizontal_method ==&#39;dfa&#39; or horizontal_method ==&#39;Diffuse Field Assumption&#39;:
        hvsr_tSteps_az = {}
    else:
        hvsr_tSteps = []
        hvsr_tSteps_az = {}
        for tStep in range(len(hvsr_out[&#39;psd_raw&#39;][anyK])):
            tStepDict = {}
            for k in hvsr_out[&#39;psd_raw&#39;]:
                tStepDict[k] = hvsr_out[&#39;psd_raw&#39;][k][tStep]
            hvsr_tstep, hvsr_az_tstep, _ = __get_hvsr_curve(x=hvsr_out[&#39;x_freqs&#39;][anyK], psd=tStepDict, horizontal_method=methodInt, hvsr_data=hvsr_out, verbose=verbose)
            
            hvsr_tSteps.append(np.float64(hvsr_tstep)) #Add hvsr curve for each time step to larger list of arrays with hvsr_curves
            for k, v in hvsr_az_tstep.items():
                if tStep == 0:
                    hvsr_tSteps_az[k] = [np.float32(v)]
                else:
                    hvsr_tSteps_az[k].append(np.float32(v))
    hvsr_out[&#39;hvsr_windows_df&#39;][&#39;HV_Curves&#39;] = hvsr_tSteps
    
    # Add azimuth HV Curves to hvsr_windows_df, if applicable
    for key, values in hvsr_tSteps_az.items():
        hvsr_out[&#39;hvsr_windows_df&#39;][&#39;HV_Curves_&#39;+key] = values
    
    hvsr_out[&#39;ind_hvsr_curves&#39;] = {}
    for col_name in hvsr_out[&#39;hvsr_windows_df&#39;]:
        if &#34;HV_Curves&#34; in col_name:
            if col_name == &#39;HV_Curves&#39;:
                colID = &#39;HV&#39;
            else:
                colID = col_name.split(&#39;_&#39;)[2]
            hvsr_out[&#39;ind_hvsr_curves&#39;][colID] = np.stack(hvsr_out[&#39;hvsr_windows_df&#39;][hvsr_out[&#39;hvsr_windows_df&#39;][&#39;Use&#39;]][col_name])

    #Initialize array based only on the curves we are currently using
    indHVCurvesArr = np.stack(hvsr_out[&#39;hvsr_windows_df&#39;][&#39;HV_Curves&#39;][hvsr_out[&#39;hvsr_windows_df&#39;][&#39;Use&#39;]])

    if outlier_curve_percentile_threshold:
        if outlier_curve_percentile_threshold is True:
            outlier_curve_percentile_threshold = 98
        hvsr_out = remove_outlier_curves(hvsr_out, use_percentile=True, outlier_threshold=outlier_curve_percentile_threshold, use_hv_curves=True, verbose=verbose)

    hvsr_out[&#39;ind_hvsr_stdDev&#39;] = {}
    for col_name in hvsr_out[&#39;hvsr_windows_df&#39;].columns:
        if &#34;HV_Curves&#34; in col_name:
            if col_name == &#39;HV_Curves&#39;:
                keyID = &#39;HV&#39;
            else:
                keyID = col_name.split(&#39;_&#39;)[2]
            curr_indHVCurvesArr = np.stack(hvsr_out[&#39;hvsr_windows_df&#39;][col_name][hvsr_out[&#39;hvsr_windows_df&#39;][&#39;Use&#39;]])
            hvsr_out[&#39;ind_hvsr_stdDev&#39;][keyID] = np.nanstd(curr_indHVCurvesArr, axis=0)

    #Get peaks for each time step
    hvsr_out[&#39;ind_hvsr_peak_indices&#39;] = {}
    tStepPFDict = {}
    #hvsr_out[&#39;hvsr_windows_df&#39;][&#39;CurvesPeakFreqs&#39;] = {}
    for col_name in hvsr_out[&#39;hvsr_windows_df&#39;].columns:
        if col_name.startswith(&#34;HV_Curves&#34;):
            tStepPeaks = []
            if len(col_name.split(&#39;_&#39;)) &gt; 2:
                colSuffix = &#34;_&#34;+&#39;_&#39;.join(col_name.split(&#39;_&#39;)[2:])
            else:
                colSuffix = &#39;_HV&#39;

            for tStepHVSR in hvsr_out[&#39;hvsr_windows_df&#39;][col_name]:
                tStepPeaks.append(__find_peaks(tStepHVSR))                
            hvsr_out[&#39;ind_hvsr_peak_indices&#39;][&#39;CurvesPeakIndices&#39;+colSuffix] = tStepPeaks

            tStepPFList = []
            for tPeaks in tStepPeaks:
                tStepPFs = []
                for pInd in tPeaks:
                    tStepPFs.append(np.float32(hvsr_out[&#39;x_freqs&#39;][anyK][pInd]))
                tStepPFList.append(tStepPFs)
            tStepPFDict[&#39;CurvesPeakFreqs&#39;+colSuffix] = tStepPFList
    
    indHVPeakIndsDF = pd.DataFrame(hvsr_out[&#39;ind_hvsr_peak_indices&#39;], index=hvsr_out[&#39;hvsr_windows_df&#39;].index)
    tStepPFDictDF = pd.DataFrame(tStepPFDict, index=hvsr_out[&#39;hvsr_windows_df&#39;].index)
    for col in indHVPeakIndsDF.columns:
        hvsr_out[&#39;hvsr_windows_df&#39;][col] = indHVPeakIndsDF.loc[:, col]
    for col in tStepPFDictDF.columns:
        hvsr_out[&#39;hvsr_windows_df&#39;][col] = tStepPFDictDF.loc[:, col]

    #Get peaks of main HV curve
    hvsr_out[&#39;hvsr_peak_indices&#39;] = {}
    hvsr_out[&#39;hvsr_peak_indices&#39;][&#39;HV&#39;] = __find_peaks(hvsr_out[&#39;hvsr_curve&#39;])
    for k in hvsr_az.keys():
        hvsr_out[&#39;hvsr_peak_indices&#39;][k] = __find_peaks(hvsr_out[&#39;hvsr_az&#39;][k])
    
    #Get frequency values at HV peaks in main curve
    hvsr_out[&#39;hvsr_peak_freqs&#39;] = {}
    for k in hvsr_out[&#39;hvsr_peak_indices&#39;].keys():
        hvsrPF = []
        for p in hvsr_out[&#39;hvsr_peak_indices&#39;][k]:
            hvsrPF.append(hvsr_out[&#39;x_freqs&#39;][anyK][p])
        hvsr_out[&#39;hvsr_peak_freqs&#39;][k] = np.array(hvsrPF)

    #Get other HVSR parameters (i.e., standard deviations, etc.)
    hvsr_out = __gethvsrparams(hvsr_out)

    #Include the original obspy stream in the output
    hvsr_out[&#39;input_stream&#39;] = hvsr_dataUpdate[&#39;input_params&#39;][&#39;input_stream&#39;] #input_stream
    hvsr_out = sprit_utils._make_it_classy(hvsr_out)
    hvsr_out[&#39;processing_status&#39;][&#39;process_hvsr_status&#39;] = True

    if &#39;processing_parameters&#39; not in hvsr_out.keys():
        hvsr_out[&#39;processing_parameters&#39;] = {}
    hvsr_out[&#39;processing_parameters&#39;][&#39;process_hvsr&#39;] = {}
    exclude_params_list = [&#39;hvsr_data&#39;]
    for key, value in orig_args.items():
        if key not in exclude_params_list:
            hvsr_out[&#39;processing_parameters&#39;][&#39;process_hvsr&#39;][key] = value
    
    if str(horizontal_method) == &#39;8&#39; or horizontal_method.lower() == &#39;single azimuth&#39;:
        if azimuth is None:
            azimuth = 90
        hvsr_out[&#39;single_azimuth&#39;] = azimuth

    hvsr_out = sprit_utils._check_processing_status(hvsr_out, start_time=start_time, func_name=inspect.stack()[0][3], verbose=verbose)

    return hvsr_out</code></pre>
</details>
<div class="desc"><p>Process the input data and get HVSR data</p>
<p>This is the main function that uses other (private) functions to do
the bulk of processing of the HVSR data and the data quality checks.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>hvsr_data
: HVSRData or HVSRBatch</dt>
<dt>Data object containing all the parameters input and generated by the user (usually, during sprit.input_params(), sprit.fetch_data(), sprit.generate_psds() and/or sprit.remove_noise()).</dt>
<dt>horizontal_method
: int or str, default=3</dt>
<dt>Method to use for combining the horizontal components. Default is 3) Geometric Mean</dt>
<dt>0) (not used)</dt>
<dt>1) 'Diffuse field assumption'
H = √( (eie_E + eie_N) / eie_Z), eie = equal interval energy</dt>
<dt>2) 'Arithmetic Mean'
H ≡ (HN + HE)/2</dt>
<dt>3) 'Geometric Mean'
H ≡ √(HN · HE), recommended by the SESAME project (2004)</dt>
<dt>4) 'Vector Summation'
H ≡ √(HN^2 + HE^2)</dt>
<dt>5) 'Quadratic Mean'
H ≡ √(HN^2 + HE^2)/2</dt>
<dt HE HN_="HN,">6) 'Maximum Horizontal Value'
H ≡ max</dt>
<dt HE HN_="HN,">7) 'Minimum Horizontal Valey'
H ≡ min</dt>
<dt>8) 'Single Azimuth'
H = H2·cos(az) + H1·sin(az)</dt>
<dt>smooth
: bool, default=True</dt>
<dt>bool or int may be used.</dt>
<dt>If True, default to smooth H/V curve to using savgoy filter with window length of 51 (works well with default resample of 1000 pts)</dt>
<dt>If int, the length of the window in the savgoy filter.</dt>
<dt><strong><code>freq_smooth</code></strong> :&ensp;<code>str {'konno ohmachi', 'constant', 'proportional'}</code></dt>
<dd>Which frequency smoothing method to use. By default, uses the 'konno ohmachi' method.
- The Konno &amp; Ohmachi method uses the obspy.signal.konnoohmachismoothing.konno_ohmachi_smoothing() function: <a href="https://docs.obspy.org/packages/autogen/obspy.signal.konnoohmachismoothing.konno_ohmachi_smoothing.html">https://docs.obspy.org/packages/autogen/obspy.signal.konnoohmachismoothing.konno_ohmachi_smoothing.html</a>
- The constant method uses a window of constant length f_smooth_width
- The proportional method uses a window the percentage length of the frequncy steps/range (f_smooth_width now refers to percentage)
See here for more information: <a href="https://www.geopsy.org/documentation/geopsy/hv-processing.html">https://www.geopsy.org/documentation/geopsy/hv-processing.html</a></dd>
<dt><strong><code>f_smooth_width</code></strong> :&ensp;<code>int</code>, default <code>= 40</code></dt>
<dd>
<ul>
<li>For 'konno ohmachi': passed directly to the bandwidth parameter of the konno_ohmachi_smoothing() function, determines the width of the smoothing peak, with lower values resulting in broader peak. Must be &gt; 0.</li>
<li>For 'constant': the size of a triangular smoothing window in the number of frequency steps</li>
<li>For 'proportional': the size of a triangular smoothing window in percentage of the number of frequency steps (e.g., if 1000 frequency steps/bins and f_smooth_width=40, window would be 400 steps wide)</li>
</ul>
</dd>
<dt>resample
: bool, default = True</dt>
<dt>bool or int.</dt>
<dt>If True, default to resample H/V data to include 1000 frequency values for the rest of the analysis</dt>
<dt>If int, the number of data points to interpolate/resample/smooth the component psd/HV curve data to.</dt>
<dt><strong><code>outlier_curve_percentile_threshold</code></strong> :&ensp;<code>bool, float</code>, default <code>= False</code></dt>
<dd>If False, outlier curve removal is not carried out here.
If True, defaults to 98 (98th percentile).
Otherwise, float of percentile used as outlier_threshold of remove_outlier_curve().</dd>
<dt><strong><code>azimuth</code></strong> :&ensp;<code>float</code>, default <code>= None</code></dt>
<dd>The azimuth angle to use when method is single azimuth.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool, defualt=False</code></dt>
<dd>Whether to print output to terminal</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>hvsr_out    : dict
    Dictionary containing all the information about the data, including input parameters
</code></pre></div>
</dd>
<dt id="sprit.read_tromino_files"><code class="name flex">
<span>def <span class="ident">read_tromino_files</span></span>(<span>input_data,<br>struct_format='H',<br>tromino_model=None,<br>diagnose=False,<br>sampling_rate=None,<br>set_record_duration=None,<br>start_byte=24576,<br>verbose=False,<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_tromino_files(input_data, struct_format=&#39;H&#39;, tromino_model=None, diagnose=False,
    sampling_rate=None, set_record_duration=None, start_byte=24576, verbose=False, **kwargs):
    
    &#34;&#34;&#34;Function to read data from tromino. Specifically, this has been lightly tested on Tromino 3G+ and Blue machines

    Parameters
    ----------
    input_data : str
        Falseilepath to .trc file
    struct_format : str, optional
        This is the format used in the struct module. 
        Usually should not be changed, by default &#39;H&#39;
    tromino_model : str, optional
        Which tromino model is being read. 
        Currently only &#34;Yellow&#34; and &#34;Blue&#34; are supported.
        If None, assumes &#34;Yellow&#34;, by default None.
    sampling_rate : int, optional
        Sampling rate (samples per second) used during acquisition. 
        This may later be detected automatically.
        If None, 128 used, by default None
    set_record_duration : int, optional
        Duration of record to set manually in minutes, by default None
    start_byte : int, optional
        Used internally, by default 24576
    verbose : bool, optional
        Whether to print information to terminal, by default False

    Returns
    -------
    obspy.stream.Stream
        Obspy Stream object with Tromino data
    &#34;&#34;&#34;

    blueModelList = [&#39;blue&#39;, &#39;blu&#39;, &#39;tromino blu&#39;, &#39;tromino blue&#39;]

    # Check if input_data is HVSRData object and extract filepath if so
    input_filepath = input_data
    if isinstance(input_data, HVSRData):
        input_filepath = input_data[&#39;input_data&#39;]

    # Allow reading of tromino partition folders (and get the .trc file inside), not just .trc file
    if pathlib.Path(input_filepath).is_dir():
        trDirGlob = pathlib.Path(input_filepath).glob(&#39;*trc&#39;)
        for trcFile in trDirGlob:
            input_data = trcFile
        if verbose:
            print(f&#39;\t Input file updated to {pathlib.Path(input_filepath).name} in specified directory.&#39;)

    if str(tromino_model).lower() in blueModelList or &#39;blue&#39; in str(tromino_model).lower():
        tBlueKwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(__read_tromino_data_blue).parameters.keys())}
        if &#39;sampling_rate&#39; not in tBlueKwargs:
            tBlueKwargs[&#39;sampling_rate&#39;] = sampling_rate
            return __read_tromino_data_blue(input_filepath, verbose=False, **tBlueKwargs)
    else:
        return __read_tromino_data_yellow(input_data=input_data, sampling_rate=sampling_rate, 
                                   struct_format=struct_format, tromino_model=&#34;3G+&#34;,diagnose=diagnose,
                                   set_record_duration=set_record_duration, start_byte=start_byte,
                                   return_dict=False, verbose=verbose, **kwargs)</code></pre>
</details>
<div class="desc"><p>Function to read data from tromino. Specifically, this has been lightly tested on Tromino 3G+ and Blue machines</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>input_data</code></strong> :&ensp;<code>str</code></dt>
<dd>Falseilepath to .trc file</dd>
<dt><strong><code>struct_format</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>This is the format used in the struct module.
Usually should not be changed, by default 'H'</dd>
<dt><strong><code>tromino_model</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Which tromino model is being read.
Currently only "Yellow" and "Blue" are supported.
If None, assumes "Yellow", by default None.</dd>
<dt><strong><code>sampling_rate</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Sampling rate (samples per second) used during acquisition.
This may later be detected automatically.
If None, 128 used, by default None</dd>
<dt><strong><code>set_record_duration</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Duration of record to set manually in minutes, by default None</dd>
<dt><strong><code>start_byte</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Used internally, by default 24576</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print information to terminal, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>obspy.stream.Stream</code></dt>
<dd>Obspy Stream object with Tromino data</dd>
</dl></div>
</dd>
<dt id="sprit.remove_noise"><code class="name flex">
<span>def <span class="ident">remove_noise</span></span>(<span>hvsr_data,<br>remove_method=None,<br>processing_window=None,<br>sat_percent=0.995,<br>noise_percent=0.8,<br>sta=2,<br>lta=30,<br>stalta_thresh=[8, 16],<br>std_ratio_thresh=2.0,<br>std_window_size=20.0,<br>min_std_win=5.0,<br>warmup_time=0,<br>cooldown_time=0,<br>min_win_size=1,<br>remove_raw_noise=False,<br>show_stalta_plot=False,<br>verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_noise(hvsr_data, remove_method=None, 
                 processing_window=None, sat_percent=0.995, noise_percent=0.80, 
                 sta=2, lta=30, stalta_thresh=[8, 16], 
                 std_ratio_thresh=2.0, std_window_size=20.0, min_std_win=5.0,
                 warmup_time=0, cooldown_time=0, min_win_size=1,
                 remove_raw_noise=False, show_stalta_plot=False, verbose=False):
    &#34;&#34;&#34;Function to remove noisy windows from data, using various methods.
    
    Methods include 
    - Manual window selection (by clicking on a chart with spectrogram and stream data), 
    - Auto window selection, which does the following two in sequence (these can also be done indepently):
        - A sta/lta &#34;antitrigger&#34; method (using stalta values to automatically remove triggered windows where there appears to be too much noise)
        - A noise threshold method, that cuts off all times where the noise threshold equals more than (by default) 80% of the highest amplitude noise sample for the length specified by lta (in seconds)
        - A saturation threshold method, that cuts off all times where the noise threshold equals more than (by default) 99.5% of the highest amplitude noise sample.

    Parameters
    ----------
    hvsr_data : dict, obspy.Stream, or obspy.Trace
        Dictionary containing all the data and parameters for the HVSR analysis
    remove_method : str, {&#39;auto&#39;, &#39;manual&#39;, &#39;stalta&#39;/&#39;antitrigger&#39;, &#39;saturation threshold&#39;, &#39;noise threshold&#39;, &#39;warmup&#39;/&#39;cooldown&#39;/&#39;buffer&#39;/&#39;warm_cool&#39;}
        The different methods for removing noise from the dataset. A list of strings will also work, in which case, it should be a list of the above strings. See descriptions above for what how each method works. By default &#39;auto.&#39;
        If remove_method=&#39;auto&#39;, this is the equivalent of remove_method=[&#39;noise threshold&#39;, &#39;antitrigger&#39;, &#39;saturation threshold&#39;, &#39;warm_cool&#39;]
    processing_window : list, tuple, or None
        A list/tuple of two items [s, e] or a list/tuple of two-item lists/tuples [[s0, e0], [s1,e1],...[sn, en]] with start and end time(s) for windows to *keep* for processing. 
        Data outside of these times will be excluded from processing. 
        Times should be obspy.UTCDateTime objects to ensure precision, but time strings (&#34;13:05&#34;) will also work in most cases (excpetions may be when the data stream starts/ends on different UTC days)
    sat_percent : float, default=0.995
        Percentage (between 0 and 1), to use as the threshold at which to remove data. This is used in the saturation method. By default 0.995. 
        If a value is passed that is greater than 1, it will be divided by 100 to obtain the percentage.
    noise_percent : float, default = 0.8
        Percentage (between 0 and 1), to use as the threshold at which to remove data, if it persists for longer than time (in seconds (specified by min_win_size)). This is used in the noise threshold method. By default 0.8. 
        If a value is passed that is greater than 1, it will be divided by 100 to obtain the percentage.
    sta : int, optional
        Short term average (STA) window (in seconds), by default 2. For use with sta/lta antitrigger method.
    lta : int, optional
        Long term average (STA) window (in seconds), by default 30. For use with sta/lta antitrigger method.
    stalta_thresh : list, default=[0.5,5]
        Two-item list or tuple with the thresholds for the stalta antitrigger. The first value (index [0]) is the lower threshold, the second value (index [1] is the upper threshold), by default [0.5,5]
    std_ratio_thresh : float, optional
        The ratio to use as a threshold for removal of noise. The ratio represents the standard deviation value for a rolling window (the size of which is determined by the std_window_size parameter) 
        divided by the standard deviation calculated for the entire trace. This rolling window standard deviation method is similar to the default noise removal method used by the Grilla HVSR software.
    std_window_size : float, optional
        The length of the window (in seconds) to use for calculating the rolling/moving standard deviation of a trace for the rolling standard deviation method.
    min_std_win : float, optional
        The minimum size of &#34;window&#34; that will be remove using the rolling standard deviation method.
    warmup_time : int, default=0
        Time in seconds to allow for warmup of the instrument (or while operator is still near instrument). This will renove any data before this time, by default 0.
    cooldown_time : int, default=0
        Time in seconds to allow for cooldown of the instrument (or for when operator is nearing instrument). This will renove any data before this time, by default 0.
    min_win_size : float, default=1
        The minumum size a window must be over specified threshold (in seconds) for it to be removed
    remove_raw_noise : bool, default=False
        If remove_raw_noise=True, will perform operation on raw data (&#39;input_stream&#39;), rather than potentially already-modified data (&#39;stream&#39;).
    verbose : bool, default=False
        Whether to print status of remove_noise

    Returns
    -------
    output : dict
        Dictionary similar to hvsr_data, but containing modified data with &#39;noise&#39; removed
    &#34;&#34;&#34;
    #Get intput paramaters
    orig_args = locals().copy()
    start_time = datetime.datetime.now()
    
    # Update with processing parameters specified previously in input_params, if applicable
    if &#39;processing_parameters&#39; in hvsr_data.keys():
        if &#39;remove_noise&#39; in hvsr_data[&#39;processing_parameters&#39;].keys():
            update_msg = []
            for k, v in hvsr_data[&#39;processing_parameters&#39;][&#39;remove_noise&#39;].items():
                defaultVDict = dict(zip(inspect.getfullargspec(remove_noise).args[1:], 
                                        inspect.getfullargspec(remove_noise).defaults))
                # Manual input to function overrides the imported parameter values
                if (not isinstance(v, (HVSRData, HVSRBatch))) and (k in orig_args.keys()) and (orig_args[k]==defaultVDict[k]):
                    update_msg.append(f&#39;\t\t{k} = {v} (previously {orig_args[k]})&#39;)
                    orig_args[k] = v
                    
    remove_method = orig_args[&#39;remove_method&#39;]
    processing_window = orig_args[&#39;processing_window&#39;]
    sat_percent = orig_args[&#39;sat_percent&#39;]
    noise_percent = orig_args[&#39;noise_percent&#39;]
    sta = orig_args[&#39;sta&#39;]
    lta = orig_args[&#39;lta&#39;]
    stalta_thresh = orig_args[&#39;stalta_thresh&#39;]
    warmup_time = orig_args[&#39;warmup_time&#39;]
    cooldown_time = orig_args[&#39;cooldown_time&#39;]
    min_win_size = orig_args[&#39;min_win_size&#39;]
    remove_raw_noise = orig_args[&#39;remove_raw_noise&#39;]
    verbose = orig_args[&#39;verbose&#39;]

    if (verbose and isinstance(hvsr_data, HVSRBatch)) or (verbose and not hvsr_data[&#39;batch&#39;]):
        if isinstance(hvsr_data, HVSRData) and hvsr_data[&#39;batch&#39;]:
            pass
        else:
            print(&#39;\nRemoving noisy data windows (remove_noise())&#39;)
            print(&#39;\tUsing the following parameters:&#39;)
            for key, value in orig_args.items():
                if key==&#39;hvsr_data&#39;:
                    pass
                else:
                    print(&#39;\t  {}={}&#39;.format(key, value))
            print()

            if &#39;processing_parameters&#39; in hvsr_data.keys() and &#39;remove_noise&#39; in hvsr_data[&#39;processing_parameters&#39;].keys():
                if update_msg != []:
                    update_msg.insert(0, &#39;\tThe following parameters were updated using the processing_parameters attribute:&#39;)
                    for msg_line in update_msg:
                        print(msg_line)
                print()

    # Set up lists
    manualList = [&#39;manual&#39;, &#39;man&#39;, &#39;m&#39;, &#39;window&#39;, &#39;windows&#39;, &#39;w&#39;]
    autoList = [&#39;auto&#39;, &#39;automatic&#39;, &#39;all&#39;, &#39;a&#39;]
    antitrigger = [&#39;stalta&#39;, &#39;anti&#39;, &#39;antitrigger&#39;, &#39;trigger&#39;, &#39;at&#39;]
    movingstdList = [&#39;moving_std&#39;, &#39;std&#39;, &#39;stdev&#39;, &#39;standard deviation&#39;, &#39;stdev&#39;, &#39;moving_stdev&#39;, &#39;movingstd&#39;, &#39;movingstdev&#39;]
    saturationThresh = [&#39;saturation threshold&#39;, &#39;sat_thresh&#39;, &#39;sat thresh&#39;, &#39;saturation&#39;, &#39;sat&#39;, &#39;s&#39;]
    noiseThresh = [&#39;noise threshold&#39;, &#39;noise thresh&#39;, &#39;noise_thresh&#39;, &#39;noise&#39;, &#39;threshold&#39;, &#39;n&#39;]
    warmup_cooldown=[&#39;warmup&#39;, &#39;cooldown&#39;, &#39;warm&#39;, &#39;cool&#39;, &#39;buffer&#39;, &#39;warmup-cooldown&#39;, &#39;warmup_cooldown&#39;, &#39;wc&#39;, &#39;warm_cool&#39;, &#39;warm-cool&#39;]
    procWinList = [&#39;processing_window&#39;, &#39;processing window&#39;, &#39;windows&#39;, &#39;window&#39;, &#39;win&#39;, &#39;pw&#39;]

    # Do batch runs
    if isinstance(hvsr_data, HVSRBatch):
        #If running batch, we&#39;ll loop through each site
        hvsr_out = {}
        for site_name in hvsr_data.keys():
            args = orig_args.copy() #Make a copy so we don&#39;t accidentally overwrite
            args[&#39;hvsr_data&#39;] = hvsr_data[site_name] #Get what would normally be the &#34;hvsr_data&#34; variable for each site
            if hvsr_data[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;]:
                try:
                   hvsr_out[site_name] = __remove_noise_batch(**args) #Call another function, that lets us run this function again
                except Exception as e:
                    hvsr_out[site_name][&#39;processing_status&#39;][&#39;remove_noise_status&#39;]=False
                    hvsr_out[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;]=False
                    if verbose:
                        print(e)
            else:
                hvsr_data[site_name][&#39;processing_status&#39;][&#39;remove_noise_status&#39;]=False
                hvsr_data[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;]=False
                hvsr_out = hvsr_data

        output = HVSRBatch(hvsr_out, df_as_read=hvsr_data.input_df)
        return output
    
    if not isinstance(hvsr_data, (HVSRData, dict, obspy.Stream, obspy.Trace)):
        warnings.warn(f&#34;Input of type type(hvsr_data)={type(hvsr_data)} cannot be used.&#34;)
        return hvsr_data
    
    # Which stream to use (input, or current)
    if isinstance(hvsr_data, (HVSRData, dict)):
        if remove_raw_noise:
            inStream = hvsr_data[&#39;input_stream&#39;].copy()
        else:
            inStream = hvsr_data[&#39;stream&#39;].copy()
        output = hvsr_data#.copy()
    else:
        inStream = hvsr_data.copy()
        output = inStream.copy()

    outStream = inStream

    # Get remove_method into consistent format (list)
    if isinstance(remove_method, str):
        if &#39;,&#39; in remove_method:
            remove_method = remove_method.split(&#39;,&#39;)
        else:
            remove_method = [remove_method]
    elif isinstance(remove_method, (list, tuple)):
        pass
    elif not remove_method:
        remove_method=[None]
    else:
        warnings.warn(f&#34;Input value remove_method={remove_method} must be either string, list of strings, None, or False. No noise removal will be carried out. Please choose one of the following: &#39;manual&#39;, &#39;auto&#39;, &#39;antitrigger&#39;, &#39;noise threshold&#39;, &#39;warmup_cooldown&#39;.&#34;)
        return output
    orig_removeMeth = remove_method
    # Check if any parameter values are different from default (if they are, automatically add that method to remove_method)
    rn_signature = inspect.signature(remove_noise)

    methodDict = {&#39;moving_std&#39;: [&#39;std_ratio_thresh&#39;, &#39;std_window_size&#39;, &#39;min_std_win&#39;],
                  &#39;sat_thresh&#39;: [&#39;sat_percent&#39;],
                  &#39;antitrigger&#39;: [&#39;sta&#39;, &#39;lta&#39;, &#39;stalta_thresh&#39;, &#39;show_stalta_plot&#39;],
                  &#39;noise_thresh&#39;: [&#39;noise_percent&#39;, &#39;min_win_size&#39;],
                  &#39;warmup_cooldown&#39;: [&#39;warmup_time&#39;, &#39;cooldown_time&#39;],
                  &#39;processing_window&#39;: [&#39;processing_window&#39;]}

    defaultValDict = {param.name: param.default for param in rn_signature.parameters.values() if param.default is not inspect.Parameter.empty}

    # If a non-default parameter is specified, add the method it corresponds to to remove_method
    for key, def_val in defaultValDict.items():
        if key in orig_args:
            if def_val != orig_args[key]:
                for methodKey, methParamList in methodDict.items():
                    if key in methParamList:
                        # Add the corresponding method to remove_mehtod if not already
                        if (methodKey not in remove_method) and (&#39;auto&#39; not in remove_method):
                            if remove_method == [None]:
                                remove_method = [methodKey]
                            else:
                                remove_method.append(methodKey)

    # Reorder list so manual is always first, if it is specified
    do_manual = False
    if len(set(remove_method).intersection(manualList)) &gt; 0:
        do_manual = True
        manInd = list(set(remove_method).intersection(manualList))[0]
        remove_method.remove(manInd)
        remove_method.insert(0, manInd)

    # Reorder list so auto is always first (if no manual) or second (if manual)
    # B/c if &#39;auto&#39; is carried out, no other methods need to be carried out (repetitive)
    newAutoInd = 0
    if do_manual:
        newAutoInd = 1
    if len(set(remove_method).intersection(autoList)) &gt; 0:
        autoInd = list(set(remove_method).intersection(autoList))[0]
        remove_method.remove(autoInd)
        remove_method.insert(newAutoInd, autoInd)        
    
    #Go through each type of removal and remove
    if orig_removeMeth != remove_method:
        if verbose:
            print(f&#39;\tThe remove_method parameter has been updated because non-default parameter values were detected.&#39;)
            print(f&#39;\tThe remove_method parameter was entered as {orig_removeMeth}, but has been updated to {remove_method}&#39;)

    # REMOVE DATA FROM ANALYSIS
    for rem_kind in remove_method:
        try:
            if not rem_kind:
                break
            elif rem_kind.lower() in manualList:
                if isinstance(output, (HVSRData, dict)):
                    if &#39;x_windows_out&#39; in output.keys():
                        pass
                    else:
                        output = _select_windows(output)
                    window_list = output[&#39;x_windows_out&#39;]
                if isinstance(outStream, obspy.core.stream.Stream):
                    if window_list is not None:
                        output[&#39;stream&#39;] = __remove_windows(inStream, window_list, warmup_time)
                    else:
                        output = _select_windows(output)
                elif isinstance(output, (HVSRData, dict)):
                    pass
                else:
                    RuntimeError(&#34;Only obspy.core.stream.Stream data type is currently supported for manual noise removal method.&#34;)     
            elif rem_kind.lower() in autoList:
                outStream = __remove_moving_std(stream=outStream, std_ratio_thresh=std_ratio_thresh, std_window_s=std_window_size, min_win_size=min_std_win, verbose=verbose)
                outStream = __remove_noise_saturate(outStream, sat_percent=sat_percent, min_win_size=min_win_size, verbose=verbose)
                # Break for-loop, since all the rest are already done as part of auto
                break
            elif rem_kind.lower() in antitrigger:
                outStream = __remove_anti_stalta(outStream, sta=sta, lta=lta, thresh=stalta_thresh, show_stalta_plot=show_stalta_plot, verbose=verbose)
            elif rem_kind.lower() in movingstdList:
                outStream = __remove_moving_std(stream=outStream, std_ratio_thresh=std_ratio_thresh, std_window_s=std_window_size, min_win_size=min_std_win, verbose=verbose)
            elif rem_kind.lower() in saturationThresh:
                outStream = __remove_noise_saturate(outStream, sat_percent=sat_percent, min_win_size=min_win_size, verbose=verbose)
            elif rem_kind.lower() in noiseThresh:
                outStream = __remove_noise_thresh(outStream, noise_percent=noise_percent, lta=lta, min_win_size=min_win_size, verbose=verbose)
            elif rem_kind.lower() in warmup_cooldown:
                outStream = __remove_warmup_cooldown(stream=outStream, warmup_time=warmup_time, cooldown_time=cooldown_time, verbose=verbose)
            elif rem_kind.lower() in procWinList and str(processing_window).lower() != &#39;none&#39;:
                outStream = _keep_processing_windows(stream=outStream, processing_window=processing_window, verbose=verbose)
            else:
                if len(remove_method)==1:
                    warnings.warn(f&#34;Input value remove_method={remove_method} is not recognized. No noise removal will be carried out. Please choose one of the following: &#39;manual&#39;, &#39;auto&#39;, &#39;antitrigger&#39;, &#39;noise threshold&#39;, &#39;warmup_cooldown&#39;.&#34;)
                    break
                warnings.warn(f&#34;Input value remove_method={remove_method} is not recognized. Continuing with other noise removal methods.&#34;)
        except Exception as e:
            print(f&#39;\t  *Error with {rem_kind} method. Data was not removed using that method.&#39;)
            print(f&#39;\t  *{e}&#39;)
    
    # Add output
    if isinstance(output, (HVSRData, dict)):
        if isinstance(outStream, (obspy.Stream, obspy.Trace)):
            output[&#39;stream_edited&#39;] = outStream
        else:
            output[&#39;stream_edited&#39;] = outStream[&#39;stream&#39;]
        output[&#39;input_stream&#39;] = hvsr_data[&#39;input_stream&#39;]
        
        if &#39;processing_parameters&#39; not in output.keys():
            output[&#39;processing_parameters&#39;] = {}
        output[&#39;processing_parameters&#39;][&#39;remove_noise&#39;] = {}
        for key, value in orig_args.items():
            output[&#39;processing_parameters&#39;][&#39;remove_noise&#39;][key] = value
        
        output[&#39;processing_status&#39;][&#39;remove_noise_status&#39;] = True
        output = sprit_utils._check_processing_status(output, start_time=start_time, func_name=inspect.stack()[0][3], verbose=verbose)

        output = __remove_windows_from_df(output, verbose=verbose)

        #if &#39;hvsr_windows_df&#39; in output.keys() or (&#39;params&#39; in output.keys() and &#39;hvsr_windows_df&#39; in output[&#39;params&#39;].keys())or (&#39;input_params&#39; in output.keys() and &#39;hvsr_windows_df&#39; in output[&#39;input_params&#39;].keys()):
        #    hvsrDF = output[&#39;hvsr_windows_df&#39;]
        #    
        #    outStream = output[&#39;stream_edited&#39;].split()
        #    for i, trace in enumerate(outStream):
        #        if i == 0:
        #            trEndTime = trace.stats.endtime
        #            comp_end = trace.stats.component
        #            continue
        #        trStartTime = trace.stats.starttime
        #        comp_start = trace.stats.component
                
        #        if trEndTime &lt; trStartTime and comp_end == comp_start:
        #            gap = [trEndTime,trStartTime]

        #            output[&#39;hvsr_windows_df&#39;][&#39;Use&#39;] = (hvsrDF[&#39;TimesProcessed_Obspy&#39;].gt(gap[0]) &amp; hvsrDF[&#39;TimesProcessed_Obspy&#39;].gt(gap[1]) )| \
        #                            (hvsrDF[&#39;TimesProcessed_ObspyEnd&#39;].lt(gap[0]) &amp; hvsrDF[&#39;TimesProcessed_ObspyEnd&#39;].lt(gap[1]))# | \
        #            output[&#39;hvsr_windows_df&#39;][&#39;Use&#39;] = output[&#39;hvsr_windows_df&#39;][&#39;Use&#39;].astype(bool)
        #        
        #        trEndTime = trace.stats.endtime
        #    
        #    outStream.merge()
        #    output[&#39;stream_edited&#39;] = outStream
                
    elif isinstance(hvsr_data, obspy.Stream) or isinstance(hvsr_data, obspy.Trace):
        output = outStream
    else:
        warnings.warn(f&#34;Output of type {type(output)} for this function will likely result in errors in other processing steps. Returning hvsr_data data.&#34;)
        return hvsr_data
    output = sprit_utils._make_it_classy(output)
    if &#39;x_windows_out&#39; not in output.keys():
        output[&#39;x_windows_out&#39;] = []

    return output</code></pre>
</details>
<div class="desc"><p>Function to remove noisy windows from data, using various methods.</p>
<p>Methods include
- Manual window selection (by clicking on a chart with spectrogram and stream data),
- Auto window selection, which does the following two in sequence (these can also be done indepently):
- A sta/lta "antitrigger" method (using stalta values to automatically remove triggered windows where there appears to be too much noise)
- A noise threshold method, that cuts off all times where the noise threshold equals more than (by default) 80% of the highest amplitude noise sample for the length specified by lta (in seconds)
- A saturation threshold method, that cuts off all times where the noise threshold equals more than (by default) 99.5% of the highest amplitude noise sample.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>dict, obspy.Stream,</code> or <code>obspy.Trace</code></dt>
<dd>Dictionary containing all the data and parameters for the HVSR analysis</dd>
<dt><strong><code>remove_method</code></strong> :&ensp;<code>str, {'auto', 'manual', 'stalta'/'antitrigger', 'saturation threshold', 'noise threshold', 'warmup'/'cooldown'/'buffer'/'warm_cool'}</code></dt>
<dd>The different methods for removing noise from the dataset. A list of strings will also work, in which case, it should be a list of the above strings. See descriptions above for what how each method works. By default 'auto.'
If remove_method='auto', this is the equivalent of remove_method=['noise threshold', 'antitrigger', 'saturation threshold', 'warm_cool']</dd>
<dt><strong><code>processing_window</code></strong> :&ensp;<code>list, tuple,</code> or <code>None</code></dt>
<dd>A list/tuple of two items [s, e] or a list/tuple of two-item lists/tuples [[s0, e0], [s1,e1],&hellip;[sn, en]] with start and end time(s) for windows to <em>keep</em> for processing.
Data outside of these times will be excluded from processing.
Times should be obspy.UTCDateTime objects to ensure precision, but time strings ("13:05") will also work in most cases (excpetions may be when the data stream starts/ends on different UTC days)</dd>
<dt><strong><code>sat_percent</code></strong> :&ensp;<code>float</code>, default=<code>0.995</code></dt>
<dd>Percentage (between 0 and 1), to use as the threshold at which to remove data. This is used in the saturation method. By default 0.995.
If a value is passed that is greater than 1, it will be divided by 100 to obtain the percentage.</dd>
<dt><strong><code>noise_percent</code></strong> :&ensp;<code>float</code>, default <code>= 0.8</code></dt>
<dd>Percentage (between 0 and 1), to use as the threshold at which to remove data, if it persists for longer than time (in seconds (specified by min_win_size)). This is used in the noise threshold method. By default 0.8.
If a value is passed that is greater than 1, it will be divided by 100 to obtain the percentage.</dd>
<dt><strong><code>sta</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Short term average (STA) window (in seconds), by default 2. For use with sta/lta antitrigger method.</dd>
<dt><strong><code>lta</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Long term average (STA) window (in seconds), by default 30. For use with sta/lta antitrigger method.</dd>
<dt><strong><code>stalta_thresh</code></strong> :&ensp;<code>list</code>, default=<code>[0.5,5]</code></dt>
<dd>Two-item list or tuple with the thresholds for the stalta antitrigger. The first value (index [0]) is the lower threshold, the second value (index [1] is the upper threshold), by default [0.5,5]</dd>
<dt><strong><code>std_ratio_thresh</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The ratio to use as a threshold for removal of noise. The ratio represents the standard deviation value for a rolling window (the size of which is determined by the std_window_size parameter)
divided by the standard deviation calculated for the entire trace. This rolling window standard deviation method is similar to the default noise removal method used by the Grilla HVSR software.</dd>
<dt><strong><code>std_window_size</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The length of the window (in seconds) to use for calculating the rolling/moving standard deviation of a trace for the rolling standard deviation method.</dd>
<dt><strong><code>min_std_win</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The minimum size of "window" that will be remove using the rolling standard deviation method.</dd>
<dt><strong><code>warmup_time</code></strong> :&ensp;<code>int</code>, default=<code>0</code></dt>
<dd>Time in seconds to allow for warmup of the instrument (or while operator is still near instrument). This will renove any data before this time, by default 0.</dd>
<dt><strong><code>cooldown_time</code></strong> :&ensp;<code>int</code>, default=<code>0</code></dt>
<dd>Time in seconds to allow for cooldown of the instrument (or for when operator is nearing instrument). This will renove any data before this time, by default 0.</dd>
<dt><strong><code>min_win_size</code></strong> :&ensp;<code>float</code>, default=<code>1</code></dt>
<dd>The minumum size a window must be over specified threshold (in seconds) for it to be removed</dd>
<dt><strong><code>remove_raw_noise</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>If remove_raw_noise=True, will perform operation on raw data ('input_stream'), rather than potentially already-modified data ('stream').</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to print status of remove_noise</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>output</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary similar to hvsr_data, but containing modified data with 'noise' removed</dd>
</dl></div>
</dd>
<dt id="sprit.remove_outlier_curves"><code class="name flex">
<span>def <span class="ident">remove_outlier_curves</span></span>(<span>hvsr_data,<br>outlier_method='prototype',<br>outlier_threshold=50,<br>use_percentile=True,<br>min_pts=5,<br>use_hv_curves=False,<br>plot_engine='matplotlib',<br>show_outlier_plot=False,<br>generate_outlier_plot=True,<br>verbose=False,<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_outlier_curves(hvsr_data, outlier_method=&#39;prototype&#39;,
                          outlier_threshold=50, use_percentile=True, min_pts=5,
                          use_hv_curves=False,
                          plot_engine=&#39;matplotlib&#39;, show_outlier_plot=False, generate_outlier_plot=True,
                          verbose=False, **kwargs):
    &#34;&#34;&#34;Function used to remove outliers curves using a &#34;prototype&#34; or &#34;dbscan&#34; method. 
    Prototype method calculates a prototype curve (i.e., median) and calculates the distance of the H/V or PSD curve from each window from that prototype curve.
    Currently, Root Mean Square Error is used to calculate the distance for each windowed H/V or PSD curve at each frequency step for all times.
    It calculates the RMSE for the PPSD curves of each component individually. All curves are removed from analysis.

    DBSCAN uses the DBSCAN method, outlier_threshold being by default the percentile value of distances of all curves from all other curves.
    Distance is calculated using scipy.spatial.distance.pdist, by default with &#39;euclidean&#39; distance. 
    The `min_pts` parameter specifies the minimum number of curves whose distance must be within the threshold distance percentile/value to be retained.
    
    Some abberant curves often occur due to the remove_noise() function, so this should be run some time after remove_noise(). 
    In general, the recommended workflow is to run this immediately following the `generate_psds()` function. or if use_hv_curves=True, after `process_hvsr()`.

    Parameters
    ----------
    hvsr_data : dict
        Input dictionary containing all the values and parameters of interest
    outlier_method : str, default=&#39;prototype&#39;
        The method to use for outlier detection. Currently, &#39;dbscan&#39; and &#39;prototype&#39; is supported.
    outlier_threshold : float or int, default=98
        The Root Mean Square Error value to use as a threshold for determining whether a curve is an outlier. 
        This averages over each individual entire curve so that curves with very abberant data (often occurs when using the remove_noise() method), can be identified.
        Otherwise, specify a float or integer to use as the cutoff RMSE value (all curves with RMSE above will be removed)
    use_percentile :  float, default=True
        Whether outlier_threshold should be interepreted as a raw RMSE value or as a percentile of the RMSE values.
    min_pts : int, default=5
        The minimum number of points to use for the outlier detection method.
        This is only used if outlier_method=&#39;dbscan&#39; 
        This is minimum number of points a point needs in its neighborhood to not be considered an outlier.
    use_hv_curves : bool, default=False
        Whether to use the calculated HV Curve or the individual components. This can only be True after process_hvsr() has been run.
    show_plot : bool, default=False
        Whether to show a plot of the removed data
    verbose : bool, default=False
        Whether to print output of function to terminal

    Returns
    -------
    hvsr_data : dict
        Input dictionary with values modified based on work of function.

    SEE ALSO
    --------
    [scipy.spatial.distance.pdist](https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html#scipy.spatial.distance.pdist)
    &#34;&#34;&#34;
    # Setup function
    #Get intput paramaters
    orig_args = locals().copy()
    start_time = datetime.datetime.now()
    
    # Update with processing parameters specified previously in input_params, if applicable
    if &#39;processing_parameters&#39; in hvsr_data.keys():
        if &#39;remove_outlier_curves&#39; in hvsr_data[&#39;processing_parameters&#39;].keys() and &#39;remove_noise&#39; in hvsr_data[&#39;processing_parameters&#39;].keys():
            update_msg = []
            for k, v in hvsr_data[&#39;processing_parameters&#39;][&#39;remove_noise&#39;].items():
                defaultVDict = dict(zip(inspect.getfullargspec(remove_outlier_curves).args[1:], 
                                        inspect.getfullargspec(remove_outlier_curves).defaults))
                # Manual input to function overrides the imported parameter values
                if (not isinstance(v, (HVSRData, HVSRBatch))) and (k in orig_args.keys()) and (orig_args[k]==defaultVDict[k]):
                    update_msg.append(f&#39;\t\t{k} = {v} (previously {orig_args[k]})&#39;)
                    orig_args[k] = v

    # Reset parameters in case of manual override of imported parameters
    outlier_method = orig_args[&#39;outlier_method&#39;]
    outlier_threshold = orig_args[&#39;outlier_threshold&#39;]
    use_percentile = orig_args[&#39;use_percentile&#39;]
    min_pts = orig_args[&#39;min_pts&#39;]
    use_hv_curves = orig_args[&#39;use_hv_curves&#39;]
    plot_engine = orig_args[&#39;plot_engine&#39;]
    show_outlier_plot = orig_args[&#39;show_outlier_plot&#39;]
    generate_outlier_plot = orig_args[&#39;generate_outlier_plot&#39;]
    verbose = orig_args[&#39;verbose&#39;]

    # Allow skipping step if outlier_method specified as None (may help GUIs)
    if str(outlier_method).lower() == &#39;none&#39; or outlier_method is None:
        return hvsr_data

    #Print if verbose, which changes depending on if batch data or not
    if (verbose and isinstance(hvsr_data, HVSRBatch)) or (verbose and not hvsr_data[&#39;batch&#39;]):
        if isinstance(hvsr_data, HVSRData) and hvsr_data[&#39;batch&#39;]:
            pass
        else:
            print(&#39;\nRemoving outlier curves from further analysis (remove_outlier_curves())&#39;)
            print(&#39;\tUsing the following parameters:&#39;)
            for key, value in orig_args.items():
                if key == &#39;hvsr_data&#39;:
                    pass
                else:
                    print(&#39;\t  {}={}&#39;.format(key, value))
            print()
                        
            if &#39;processing_parameters&#39; in hvsr_data.keys() and &#39;remove_outlier_curves&#39; in hvsr_data[&#39;processing_parameters&#39;].keys():
                if update_msg != []:
                    update_msg.insert(0, &#39;\tThe following parameters were updated using the processing_parameters attribute:&#39;)
                    for msg_line in update_msg:
                        print(msg_line)
                print()
    
    #First, divide up for batch or not
    #Site is in the keys anytime it&#39;s not batch
    if isinstance(hvsr_data, HVSRBatch):
        #If running batch, we&#39;ll loop through each site
        hvsr_out = {}
        for site_name in hvsr_data.keys():
            args = orig_args.copy() #Make a copy so we don&#39;t accidentally overwrite
            args[&#39;hvsr_data&#39;] = hvsr_data[site_name] #Get what would normally be the &#34;hvsr_data&#34; variable for each site
            if hvsr_data[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;]:
                try:
                    hvsr_out[site_name] = __remove_outlier_curves(**args) #Call another function, that lets us run this function again
                except:
                    hvsr_out = hvsr_data
                    hvsr_out[site_name][&#39;processing_status&#39;][&#39;remove_outlier_curves_status&#39;] = False
                    hvsr_out[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;] = False                    
            else:
                hvsr_out = hvsr_data
                hvsr_out[site_name][&#39;processing_status&#39;][&#39;remove_outlier_curves_status&#39;] = False
                hvsr_out[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;] = False
        hvsr_out = HVSRBatch(hvsr_out, df_as_read=hvsr_data.input_df)
        hvsr_out = sprit_utils._check_processing_status(hvsr_out, start_time=start_time, func_name=inspect.stack()[0][3], verbose=verbose)
        return hvsr_out

    dbscanList = [&#39;dbscan&#39;, &#39;distance&#39;, &#39;dist&#39;, &#39;dbs&#39;, &#39;db&#39;, &#39;d&#39;]
    prototypeList = [&#39;prototype&#39;, &#39;proto&#39;, &#39;ptype&#39;, &#39;p&#39;,
                     &#39;root mean square&#39;, &#39;root mean square error&#39;, 
                     &#39;rms&#39;, &#39;rmse&#39;, &#39;r&#39;]

    # Determine names of hvsr_windows_df columns to use
    if not use_hv_curves:
        compNames = [&#39;Z&#39;, &#39;E&#39;, &#39;N&#39;]
        for col_name in hvsr_data[&#39;hvsr_windows_df&#39;].columns:
            if &#39;psd_values&#39; in col_name and &#39;RMSE&#39; not in col_name:
                cName = col_name.split(&#39;_&#39;)[2]
                if cName not in compNames:
                    compNames.append(cName)
        col_prefix = &#39;psd_values_&#39;
        colNames = [col_prefix+cn for cn in compNames]
    else:
        compNames = []
        for col_name in hvsr_data[&#39;hvsr_windows_df&#39;].columns:
            if col_name.startswith(&#39;HV_Curves&#39;) and &#34;Log10&#34; not in col_name:
                compNames.append(col_name)
        colNames = compNames
        col_prefix = &#39;HV_Curves&#39;

    # Remove outlier depending on method, prototype as default
    if str(outlier_method).lower() in dbscanList:
        hvsr_out = __dbscan_outlier_detect(hvsr_data=hvsr_data, use_hv_curves=use_hv_curves, 
                                           use_percentile=use_percentile,
                                           neighborhood_size=outlier_threshold,
                                           dist_metric=&#39;euclidean&#39;, 
                                           min_neighborhood_pts=min_pts,
                                           col_names=colNames,
                                           comp_names=compNames,
                                           col_prefix=col_prefix,
                                           verbose=verbose)
        
    elif str(outlier_method).lower() in prototypeList:
        hvsr_out = __prototype_outlier_detect(hvsr_data, use_hv_curves=use_hv_curves, 
                                              use_percentile=use_percentile,
                                              outlier_threshold=outlier_threshold,
                                              col_names=colNames,
                                              comp_names=compNames,
                                              col_prefix=col_prefix,
                                              verbose=verbose)
    else:
        hvsr_out = __prototype_outlier_detect(hvsr_data, use_hv_curves=use_hv_curves, 
                                              use_percentile=use_percentile,
                                              outlier_threshold=outlier_threshold,
                                              col_names=colNames,
                                              comp_names=compNames,
                                              col_prefix=col_prefix,
                                              verbose=verbose)

    # Show plot of removed/retained data
    if plot_engine.lower() == &#39;matplotlib&#39; and (generate_outlier_plot or show_outlier_plot):
        hvsr_data[&#39;Outlier_Plot&#39;] = sprit_plot.plot_outlier_curves(hvsr_data, outlier_threshold=outlier_threshold, use_percentile=use_percentile, use_hv_curves=use_hv_curves, plot_engine=&#39;matplotlib&#39;, show_plot=show_outlier_plot, verbose=verbose)
    elif plot_engine.lower() == &#39;plotly&#39;  and (generate_outlier_plot or show_outlier_plot):
        hvsr_data[&#39;Outlier_Plot&#39;] = sprit_plot.plot_outlier_curves(hvsr_data, outlier_threshold=outlier_threshold, use_percentile=use_percentile, use_hv_curves=use_hv_curves, plot_engine=&#39;plotly&#39;, from_roc=True, show_plot=show_outlier_plot, verbose=verbose)
    else:
        pass

    if &#39;processing_parameters&#39; not in hvsr_out.keys():
        hvsr_out[&#39;processing_parameters&#39;] = {}
    hvsr_out[&#39;processing_parameters&#39;][&#39;remove_outlier_curves&#39;] = {}
    exclude_params_list = [&#39;hvsr_data&#39;]
    for key, value in orig_args.items():
        if key not in exclude_params_list:
            hvsr_out[&#39;processing_parameters&#39;][&#39;remove_outlier_curves&#39;][key] = value

    hvsr_out[&#39;processing_status&#39;][&#39;remove_outlier_curves_status&#39;] = True
    
    hvsr_out = sprit_utils._check_processing_status(hvsr_out, start_time=start_time, func_name=inspect.stack()[0][3], verbose=verbose)
    
    return hvsr_out</code></pre>
</details>
<div class="desc"><p>Function used to remove outliers curves using a "prototype" or "dbscan" method.
Prototype method calculates a prototype curve (i.e., median) and calculates the distance of the H/V or PSD curve from each window from that prototype curve.
Currently, Root Mean Square Error is used to calculate the distance for each windowed H/V or PSD curve at each frequency step for all times.
It calculates the RMSE for the PPSD curves of each component individually. All curves are removed from analysis.</p>
<p>DBSCAN uses the DBSCAN method, outlier_threshold being by default the percentile value of distances of all curves from all other curves.
Distance is calculated using scipy.spatial.distance.pdist, by default with 'euclidean' distance.
The <code>min_pts</code> parameter specifies the minimum number of curves whose distance must be within the threshold distance percentile/value to be retained.</p>
<p>Some abberant curves often occur due to the remove_noise() function, so this should be run some time after remove_noise().
In general, the recommended workflow is to run this immediately following the <code><a title="sprit.generate_psds" href="#sprit.generate_psds">generate_psds()</a></code> function. or if use_hv_curves=True, after <code><a title="sprit.process_hvsr" href="#sprit.process_hvsr">process_hvsr()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Input dictionary containing all the values and parameters of interest</dd>
<dt><strong><code>outlier_method</code></strong> :&ensp;<code>str</code>, default=<code>'prototype'</code></dt>
<dd>The method to use for outlier detection. Currently, 'dbscan' and 'prototype' is supported.</dd>
<dt><strong><code>outlier_threshold</code></strong> :&ensp;<code>float</code> or <code>int</code>, default=<code>98</code></dt>
<dd>The Root Mean Square Error value to use as a threshold for determining whether a curve is an outlier.
This averages over each individual entire curve so that curves with very abberant data (often occurs when using the remove_noise() method), can be identified.
Otherwise, specify a float or integer to use as the cutoff RMSE value (all curves with RMSE above will be removed)</dd>
<dt><strong><code>use_percentile</code></strong> :&ensp;<code> float</code>, default=<code>True</code></dt>
<dd>Whether outlier_threshold should be interepreted as a raw RMSE value or as a percentile of the RMSE values.</dd>
<dt><strong><code>min_pts</code></strong> :&ensp;<code>int</code>, default=<code>5</code></dt>
<dd>The minimum number of points to use for the outlier detection method.
This is only used if outlier_method='dbscan'
This is minimum number of points a point needs in its neighborhood to not be considered an outlier.</dd>
<dt><strong><code>use_hv_curves</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to use the calculated HV Curve or the individual components. This can only be True after process_hvsr() has been run.</dd>
<dt><strong><code>show_plot</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to show a plot of the removed data</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to print output of function to terminal</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Input dictionary with values modified based on work of function.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>[scipy.spatial.distance.pdist](https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html#scipy.spatial.distance.pdist)</code></p></div>
</dd>
<dt id="sprit.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>input_data=None,<br>source='file',<br>azimuth_calculation=False,<br>noise_removal=False,<br>outlier_curves_removal=False,<br>verbose=False,<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(input_data=None, source=&#39;file&#39;, azimuth_calculation=False, noise_removal=False, outlier_curves_removal=False, verbose=False, **kwargs):
    &#34;&#34;&#34;The sprit.run() is the main function that allows you to do all your HVSR processing in one simple step (sprit.run() is how you would call it in your code, but it may also be called using sprit.sprit_hvsr.run())
    
    The input_data parameter of sprit.run() is the only required parameter (if nothing entered, it will run sample data). This can be either a single file, a list of files (one for each component, for example), a directory (in which case, all obspy-readable files will be added to an HVSRBatch instance), a Rasp. Shake raw data directory, or sample data.
    
    Notes
    -----
    The sprit.run() function calls the following functions. This is the recommended order/set of functions to run to process HVSR using SpRIT. See the API documentation for these functions for more information:
    - input_params(): The input_data parameter of input_params() is the only required variable, though others may also need to be called for your data to process correctly.
    - fetch_data(): the source parameter of fetch_data() is the only explicit variable in the sprit.run() function aside from input_data and verbose. Everything else gets delivered to the correct function via the kwargs dictionary
    - remove_noise(): by default, the kind of noise removal is remove_method=&#39;auto&#39;. See the remove_noise() documentation for more information. If remove_method is set to anything other than one of the explicit options in remove_noise, noise removal will not be carried out.
    - calculate_azimuth(): calculate one or several azimuths. Single azimuth can be a way to combine H components too.
    - generate_psds(): generates psds for each component, which will be combined/used later. Any parameter of obspy.signal.spectral_estimation.PPSD() may also be read into this function.
    - remove_outlier_curves(): removes any outlier ppsd curves so that the data quality for when curves are combined will be enhanced. See the remove_outlier_curves() documentation for more information.
    - process_hvsr(): this is the main function processing the hvsr curve and statistics. See process_hvsr() documentation for more details. The hvsr_band parameter sets the frequency spectrum over which these calculations occur.
    - check_peaks(): this is the main function that will find and &#39;score&#39; peaks to get a best peak. The parameter peak_freq_range can be set to limit the frequencies within which peaks are checked and scored.
    - get_report(): this is the main function that will print, plot, and/or save the results of the data. See the get_report() API documentation for more information.
    - export_hvsr(): this function exports the final data output as a pickle file (by default, this pickle object has a .hvsr extension). This can be used to read data back into SpRIT without having to reprocess data.

    Parameters
    ----------
    input_data : str or filepath object that can be read by obspy
        Filepath to data to be processed. This may be a file or directory, depending on what kind of data is being processed (this can be specified with the source parameter). 
        For sample data, The following can be specified as the input_data parameter:
            - Any integer 1-6 (inclusive), or the string (e.g., input_data=&#34;1&#34; or input_data=1 will work)
            - The word &#34;sample&#34; before any integer (e.g., input_data=&#34;sample1&#34;)
            - The word &#34;sample&#34; will default to &#34;sample1&#34; if source=&#39;file&#39;. 
            - If source=&#39;batch&#39;, input_data should be input_data=&#39;sample&#39; or input_data=&#39;batch&#39;. In this case, it will read and process all the sample files using the HVSRBatch class. Set verbose=True to see all the information in the sample batch csv file.
    source : str, optional
        _description_, by default &#39;file&#39;
    azimuth_calculation : bool, optional
        Whether to perform azimuthal analysis, by default False.
    noise_removal : bool, default=False
        Whether to remove noise (before processing PPSDs)
    outlier_curves_removal : bool, default=False
        Whether to remove outlier curves from HVSR time windows
    show_plot : bool, default=True
        Whether to show plots. This does not affect whether the plots are created (and then inserted as an attribute of HVSRData), only whether they are shown.
    verbose : bool, optional
        _description_, by default False
    **kwargs
        Keyword arguments for the functions listed above. The keyword arguments are unique, so they will get parsed out and passed into the appropriate function.

    Returns
    -------
    hvsr_results : sprit.HVSRData or sprit.HVSRBatch object
        If a single file/data point is being processed, a HVSRData object will be returned. Otherwise, it will be a HVSRBatch object. See their documention for more information.

    See Also
    --------
    input_params
    fetch_data
    remove_noise
    calculate_azimuth
    generate_psds
    remove_outlier_curves
    process_hvsr
    check_peaks
    get_report
    export_hvsr
        

    Raises
    ------
    RuntimeError
        If the input parameter may not be read correctly. This is raised if the input_params() function fails. This raises an error since no other data processing or reading steps will be able to carried out correctly.
    RuntimeError
        If the data is not read/fetched correctly using fetch_data(), an error will be raised. This is raised if the fetch_data() function fails. This raises an error since no other data processing steps will be able to carried out correctly.
    RuntimeError
        If the data being processed is a single file, an error will be raised if generate_psds() does not work correctly. No errors are raised for remove_noise() errors (since that is an optional step) and the process_hvsr() step (since that is the last processing step) .
    &#34;&#34;&#34;
    
    if input_data is None or input_data == &#39;&#39;:
        print(&#34;********************* PROCESSING SAMPLE DATA *****************************************&#34;)
        print(&#34;To read in your own data, use sprit.run(input_data=&#39;/path/to/your/seismic/data.mseed&#39;)&#34;)
        print(&#34;See SpRIT Wiki or API documentation for more information:&#34;)
        print(&#34;\t Wiki: https://github.com/RJbalikian/SPRIT-HVSR/wiki&#34;)
        print(&#34;\t API Documentation: https://sprit.readthedocs.io/en/latest/#&#34;)
        print(&#34;**************************************************************************************&#34;)
        print()
        input_data = &#39;sample&#39;
    
    orig_args = locals().copy()  # Get the initial arguments
    global do_run
    do_run = True

    if verbose:
        print(&#39;Using sprit.run() with the following parameters:&#39;)
        print(f&#39;\tinput_data = {input_data}&#39;)
        print(f&#39;\tazimuth_calculation = {azimuth_calculation}&#39;)
        print(f&#39;\tnoise_removal = {noise_removal}&#39;)
        print(f&#39;\toutlier_curves_removal = {outlier_curves_removal}&#39;)
        print(&#34;\tWith the following kwargs: &#34;, end=&#39;&#39;)
        if kwargs is not {}:
            print()
            for k, v in kwargs.items():
                print(f&#34;\t\t{k} = {v}&#34;)
        else:
            print(&#34;{None}&#34;)
        print()
    
    if &#39;hvsr_band&#39; not in kwargs.keys():
        kwargs[&#39;hvsr_band&#39;] = inspect.signature(input_params).parameters[&#39;hvsr_band&#39;].default
    if &#39;peak_freq_range&#39; not in kwargs.keys():
        kwargs[&#39;peak_freq_range&#39;] = inspect.signature(input_params).parameters[&#39;peak_freq_range&#39;].default
    if &#39;processing_parameters&#39; not in kwargs.keys():
        kwargs[&#39;processing_parameters&#39;] = {}
    
    # Separate out input_params and fetch_data processes based on whether batch has been specified
    batchlist = [&#39;batch&#39;, &#39;bach&#39;, &#39;bath&#39;, &#39;b&#39;]
    if str(source).lower() in batchlist and str(&#39;input_data&#39;).lower() not in SAMPLE_LIST:
        try:
            batch_data_read_kwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(batch_data_read).parameters.keys())}
            hvsrDataIN = batch_data_read(batch_data=input_data, verbose=verbose, **batch_data_read_kwargs)
        except Exception as e:
            raise RuntimeError(f&#39;Batch data read in was not successful:\n{e}&#39;)
    else:
        # Get the input parameters
        try:
            input_params_kwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(input_params).parameters.keys())}
            if &#39;acq_date&#39; not in input_params_kwargs:
                input_params_kwargs[&#39;acq_date&#39;] = NOWTIME.date()
            
            if &#39;starttime&#39; not in input_params_kwargs:
                input_params_kwargs[&#39;starttime&#39;] = NOWTIME.time()
            
            params = input_params(input_data=input_data, verbose=verbose, **input_params_kwargs)
        except Exception as e:
            if hasattr(e, &#39;message&#39;):
                errMsg = e.message
            else:
                errMsg = e
            
            print(f&#34;ERROR during input_params(): {errMsg}&#34;)        
            # Even if batch, this is reading in data for all sites so we want to raise error, not just warn
            raise RuntimeError(&#39;Input parameters not read correctly, see sprit.input_params() function and parameters&#39;)
            # If input_params fails, initialize params as an HVSRDATA
            #params = {&#39;processing_status&#39;:{&#39;input_params_status&#39;:False, &#39;overall_status&#39;:False}}
            #params.update(input_params_kwargs)
            #params = sprit_utils._make_it_classy(params)

        # Fetch Data
        try:
            fetch_data_kwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(fetch_data).parameters.keys())}
            fetch_data_kwargs.update({k: v for k, v in kwargs.items() if k in tuple(inspect.signature(read_tromino_files).parameters.keys())})
            if &#39;obspy_ppsds&#39; in kwargs:
                fetch_data_kwargs[&#39;obspy_ppsds&#39;] = kwargs[&#39;obspy_ppsds&#39;]
            else:
                fetch_data_kwargs[&#39;obspy_ppsds&#39;] = False
            hvsrDataIN = fetch_data(params=params, source=source, verbose=verbose, **fetch_data_kwargs)    
        except Exception as e:
            # Even if batch, this is reading in data for all sites so we want to raise error, not just warn
            if hasattr(e, &#39;message&#39;):
                errMsg = e.message
            else:
                errMsg = e
            
            print(f&#34;ERROR during fetch_data(): {errMsg}&#34;)
            raise RuntimeError(&#39;Data not read correctly, see sprit.fetch_data() function and parameters for more details.&#39;)
    
    # BREAK OUT FOR BATCH PROCESSING
    run_kwargs_for_df = []
    if isinstance(hvsrDataIN, HVSRBatch):
        
        # Create dictionary that will be used to create HVSRBatch object
        hvsrBatchDict = {}
        
        # Loop through each site and run sprit.run() for each HVSRData object
        for site_name, site_data in hvsrDataIN.items():
            run_kwargs = {}  #orig_args.copy()  # Make a copy so we don&#39;t accidentally overwrite
            print(f&#39;\n\n**PROCESSING DATA FOR SITE {site_name.upper()}**\n&#39;)
            run_kwargs[&#39;input_data&#39;] = site_data
            
            # Update run kwargs       
            # First, get processing_parameters per site
            for funname, fundict in site_data[&#39;processing_parameters&#39;].items():
                for funk, funv in fundict.items():
                    run_kwargs[funk] = funv
                                                
            # Overwrite per-site processing parameters with params passed  to sprit.run() as kwargs
            for paramname, paramval in kwargs.items():
                if paramname != &#39;source&#39;:  # Don&#39;t update source for batch data
                    run_kwargs[paramname] = paramval

            dont_update_these_args = [&#39;input_data&#39;, &#39;source&#39;, &#39;kwargs&#39;]

            # Overwrite per-site processing parameters with sprit.run()
            run_args = orig_args.copy()
            for k, v in run_args.items():
                if k not in dont_update_these_args:
                    if v != inspect.signature(run).parameters[k].default:
                        run_kwargs[k] = v
                                   
            try:
                hvsrBatchDict[site_name] = run(**run_kwargs)
                run_kwargs_for_df.append(run_kwargs)
            except Exception as e:
                hvsrBatchDict[site_name] = site_data
                hvsrBatchDict[site_name][&#39;Error_Message&#39;] = sprit_utils._get_error_from_exception(e,
                                                                                                  print_error_message=False,
                                                                                                  return_error_message=True)
                if verbose:
                    sprit_utils._get_error_from_exception(e)
                    
                print(f&#34;Error processing site {site_name}. Continuing processing of remaining sites.&#34;)
                
                hvsrBatchDict[site_name][&#39;processing_status&#39;][&#39;generate_psds_status&#39;] = False
                hvsrBatchDict[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;] = False         
        
        # Create batch object
        hvsrBatchData = HVSRBatch(hvsrBatchDict, df_as_read=pd.DataFrame(run_kwargs_for_df))
        
        # Use batch object to get Output Table with all data, including results and inputs
        for s, site in enumerate(hvsrBatchData):
            if hasattr(hvsrBatchData[site], &#39;Table_Report&#39;):
                if s == 0:
                    table_reports = hvsrBatchData[site].Table_Report
                else:
                    table_reports = pd.concat([table_reports, hvsrBatchData[site].Table_Report])
            else:
                if s == 0:
                    table_reports = pd.DataFrame()
                
        hvsrBatchData[&#39;Table_Report&#39;] = pd.merge(left=hvsrBatchData.input_df, right=table_reports,
                                                 how=&#39;outer&#39;,
                                                 left_on=&#39;site&#39;, right_on=&#39;Site Name&#39;)
        return hvsrBatchData

    # Calculate azimuths
    hvsr_az = hvsrDataIN
    azimuth_kwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(calculate_azimuth).parameters.keys())}
    
    azList = [&#39;azimuth&#39;, &#39;single azimuth&#39;, &#39;single&#39;]
    
    azCond1 = &#39;horizontal_method&#39; in kwargs.keys() and str(kwargs[&#39;horizontal_method&#39;]) == &#39;8&#39;
    azCond2 = &#39;horizontal_method&#39; in kwargs.keys() and str(kwargs[&#39;horizontal_method&#39;]).lower() in azList
    azCond3 = azimuth_calculation
    azCond4 = len(azimuth_kwargs.keys()) &gt; 0

    if azCond1 or azCond2 or azCond3 or azCond4:
        azimuth_calculation = True
        azimuth_kwargs[&#39;azimuth_type&#39;] = kwargs[&#39;azimuth_type&#39;] = &#39;single&#39;
        
        if &#39;azimuth_angle&#39; not in kwargs.keys():
            azimuth_kwargs[&#39;azimuth_angle&#39;] = kwargs[&#39;azimuth_angle&#39;] = 45
        
        kwargs[&#39;azimuth&#39;] = &#34;R&#34;  # str(kwargs[&#39;azimuth_angle&#39;]).zfill(3)
        
        if &#39;horizontal_method&#39; not in kwargs.keys():
            kwargs[&#39;horizontal_method&#39;] = &#39;Single Azimuth&#39;

        try:
            hvsr_az = calculate_azimuth(hvsrDataIN, verbose=verbose, **azimuth_kwargs)
        except Exception as e:
            if hasattr(e, &#39;message&#39;):
                errMsg = e.message
            else:
                errMsg = e
            
            print(f&#34;Error during calculate_azimuth() for {hvsr_az.site}: \n{errMsg}&#34;)            

            if isinstance(hvsr_az, HVSRBatch):
                for site_name in hvsr_az.keys():
                    hvsr_az[site_name][&#39;processing_status&#39;][&#39;calculate_azimuths_status&#39;] = False
            else:
                hvsr_az[&#39;processing_status&#39;][&#39;calculate_azimuths_status&#39;] = False
    else:
        azimuth_calculation = False
        
     
    # Remove Noise
    data_noiseRemoved = hvsr_az
    try:
        remove_noise_kwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(remove_noise).parameters.keys())}
        if noise_removal or remove_noise_kwargs != {}:
            remove_noise_kwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(remove_noise).parameters.keys())}
            try:
                data_noiseRemoved = remove_noise(hvsr_data=data_noiseRemoved, verbose=verbose, **remove_noise_kwargs)   
            except Exception as e:
                if hasattr(e, &#39;message&#39;):
                    errMsg = e.message
                else:
                    errMsg = e                    
                
                print(f&#34;Error with remove_noise for site {data_noiseRemoved.site}: {errMsg}&#34;)
                
                # Mark that remove_noise failed
                # Reformat data so HVSRData and HVSRBatch data both work here
                if isinstance(data_noiseRemoved, HVSRData):
                    data_noiseRemoved = {data_noiseRemoved.site: data_noiseRemoved}
                    data_noiseRemoved = {data_noiseRemoved.site: data_noiseRemoved}
                    
                for site_name in data_noiseRemoved.keys():
                    data_noiseRemoved[site_name][&#39;processing_status&#39;][&#39;remove_noise_status&#39;] = False
                    # Since noise removal is not required for data processing, check others first
                    if data_noiseRemoved[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;]:
                        data_noiseRemoved[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;] = True        
                    else:
                        data_noiseRemoved[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;] = False

                    # If it wasn&#39;t originally HVSRBatch, make it HVSRData object again
                    if not data_noiseRemoved[site_name][&#39;batch&#39;]:
                        data_noiseRemoved = data_noiseRemoved[site_name]
        else:
            if isinstance(data_noiseRemoved, HVSRData):
                data_noiseRemoved = {data_noiseRemoved.site: data_noiseRemoved}
                
            for site_name in data_noiseRemoved.keys():  # This should work more or less the same for batch and regular data now
                data_noiseRemoved[site_name][&#39;stream_edited&#39;] = data_noiseRemoved[site_name][&#39;stream&#39;]
                
                data_noiseRemoved[site_name][&#39;processing_status&#39;][&#39;remove_noise_status&#39;] = None
        
                # If it wasn&#39;t originally HVSRBatch, make it HVSRData object again
                #if not data_noiseRemoved[site_name][&#39;batch&#39;]:
                data_noiseRemoved = data_noiseRemoved[site_name]
    except Exception as e:
        if (source == &#39;file&#39; or source == &#39;raw&#39;):
            if hasattr(e, &#39;message&#39;):
                errMsg = e.message
            else:
                errMsg = e
            if not (&#39;batch&#39; in data_noiseRemoved.keys() and data_noiseRemoved[&#39;batch&#39;]):
                raise RuntimeError(f&#34;generate_psds() error: {errMsg}&#34;)
    
    # Generate PPSDs
    psd_data = data_noiseRemoved
    try:
        generate_psds_kwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(generate_psds).parameters.keys())}
        PPSDkwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(PPSD).parameters.keys())}
        generate_psds_kwargs.update(PPSDkwargs)
        generate_psds_kwargs[&#39;azimuthal_psds&#39;] = azimuth_calculation
        psd_data = generate_psds(hvsr_data=psd_data, verbose=verbose, **generate_psds_kwargs)
    except Exception as e:
        
        if hasattr(e, &#39;message&#39;):
            errMsg = e.message
        else:
            errMsg = e
        
        if verbose:
            print(f&#34;Error during generate_psds() for {site_name}: \n{errMsg}&#34;)
        
        if (source == &#39;file&#39; or source == &#39;raw&#39;):
            raise RuntimeError(f&#34;generate_psds() error: \n{errMsg}&#34;)

        # Reformat data so HVSRData and HVSRBatch data both work here
        if isinstance(psd_data, HVSRData):
            psd_data = {psd_data[&#39;site&#39;]: psd_data}
            
        for site_name in psd_data.keys():  # This should work more or less the same for batch and regular data now
            psd_data[site_name][&#39;processing_status&#39;][&#39;generate_psds_status&#39;] = False
            psd_data[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;] = False
    
            #If it wasn&#39;t originally HVSRBatch, make it HVSRData object again
            if not psd_data[site_name][&#39;batch&#39;]:
                psd_data = psd_data[site_name]

    # Remove Outlier PSD Curves
    data_curvesRemoved = psd_data
    try:
        remove_outlier_curve_kwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(remove_outlier_curves).parameters.keys())}
        if &#39;use_hv_curves&#39; not in remove_outlier_curve_kwargs.keys():
            use_hv_curves = False
        else:
            use_hv_curves = remove_outlier_curve_kwargs[&#39;use_hv_curves&#39;]
        # Check whether it is indicated to remove outlier curves
        outlier_curve_keys_used = True
        if remove_outlier_curve_kwargs == {} or list(remove_outlier_curve_kwargs.keys()) == [&#39;show_plot&#39;]:
            outlier_curve_keys_used = False
        if (outlier_curves_removal or outlier_curve_keys_used) and not use_hv_curves:
            remove_outlier_curve_kwargs[&#39;remove_outliers_during_plot&#39;] = False
            data_curvesRemoved = remove_outlier_curves(hvsr_data=data_curvesRemoved, verbose=verbose,**remove_outlier_curve_kwargs)   
    except Exception as e:
        traceback.print_exception(sys.exc_info()[1])
        exc_type, exc_obj, tb = sys.exc_info()
        f = tb.tb_frame
        lineno = tb.tb_lineno
        filename = f.f_code.co_filename
        errLineNo = str(traceback.extract_tb(sys.exc_info()[2])[-1].lineno)
        error_category = type(e).__name__.title().replace(&#39;error&#39;, &#39;Error&#39;)
        error_message = f&#34;{e} ({errLineNo})&#34;
        print(f&#34;{error_category} ({errLineNo}): {error_message}&#34;)
        print(lineno, filename, f)
        
        # Reformat data so HVSRData and HVSRBatch data both work here
        if isinstance(data_curvesRemoved, HVSRData):
            data_curvesRemoved_interim = {data_curvesRemoved[&#39;site&#39;]: data_curvesRemoved}
        else:
            data_curvesRemoved_interim = data_curvesRemoved
        
        for site_name in data_curvesRemoved_interim.keys():  # This should work more or less the same for batch and regular data now
            data_curvesRemoved_interim[site_name][&#39;processing_status&#39;][&#39;remove_outlier_curves_status&#39;] = False
            #data_curvesRemoved_interim[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;] = False
    
            #If it wasn&#39;t originally HVSRBatch, make it HVSRData object again
            if not data_curvesRemoved_interim[site_name][&#39;batch&#39;]:
                data_curvesRemoved_interim = data_curvesRemoved_interim[site_name]
        data_curvesRemoved = data_curvesRemoved_interim
        
    # Process HVSR Curves
    hvsr_results = data_curvesRemoved
    try:
        process_hvsr_kwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(process_hvsr).parameters.keys())}
        
        if azimuth_calculation:
            if azimuth_kwargs[&#39;azimuth_type&#39;] == &#39;single&#39;:
                process_hvsr_kwargs[&#39;azimuth&#39;] = azimuth_kwargs[&#39;azimuth_angle&#39;]
        
        hvsr_results = process_hvsr(hvsr_data=psd_data, verbose=verbose, **process_hvsr_kwargs)
    except Exception as e:
        sprit_utils._get_error_from_exception(e,
                                              print_error_message=True)
        if isinstance(hvsr_results, HVSRData):
            hvsr_results = {hvsr_results[&#39;site&#39;]: hvsr_results}
            
        for site_name in hvsr_results.keys():  # This should work more or less the same for batch and regular data now
        
            hvsr_results[site_name][&#39;processing_status&#39;][&#39;process_hvsr_status&#39;]=False
            hvsr_results[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;] = False
            
            # If it wasn&#39;t originally HVSRBatch, make it HVSRData object again
            if not hvsr_results[site_name][&#39;batch&#39;]:
                hvsr_results = hvsr_results[site_name]            

    # Remove outlier HV Curves
    try:
        remove_outlier_curve_kwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(remove_outlier_curves).parameters.keys())}
        if &#39;use_hv_curves&#39; not in remove_outlier_curve_kwargs.keys():
            use_hv_curves = False
        else:
            use_hv_curves = remove_outlier_curve_kwargs[&#39;use_hv_curves&#39;]
        # Check whether it is indicated to remove outlier curves
        outlier_curve_keys_used = True
        if remove_outlier_curve_kwargs == {} or list(remove_outlier_curve_kwargs.keys()) == [&#39;show_plot&#39;]:
            outlier_curve_keys_used = False
        if (outlier_curves_removal or outlier_curve_keys_used) and use_hv_curves:
            remove_outlier_curve_kwargs[&#39;remove_outliers_during_plot&#39;] = False
            hvsr_results = remove_outlier_curves(hvsr_data=hvsr_results, verbose=verbose,**remove_outlier_curve_kwargs)   
    except Exception as e:
        traceback.print_exception(sys.exc_info()[1])
        exc_type, exc_obj, tb = sys.exc_info()
        f = tb.tb_frame
        lineno = tb.tb_lineno
        filename = f.f_code.co_filename
        errLineNo = str(traceback.extract_tb(sys.exc_info()[2])[-1].lineno)
        error_category = type(e).__name__.title().replace(&#39;error&#39;, &#39;Error&#39;)
        error_message = f&#34;{e} ({errLineNo})&#34;
        print(f&#34;{error_category} ({errLineNo}): {error_message}&#34;)
        print(lineno, filename, f)
        
        # Reformat data so HVSRData and HVSRBatch data both work here
        if isinstance(hvsr_results, HVSRData):
            data_curvesRemoved_interim = {hvsr_results[&#39;site&#39;]: hvsr_results}
        else:
            data_curvesRemoved_interim = hvsr_results
        
        for site_name in data_curvesRemoved_interim.keys():  # This should work more or less the same for batch and regular data now
            data_curvesRemoved_interim[site_name][&#39;processing_status&#39;][&#39;remove_outlier_curves_status&#39;] = False
            #data_curvesRemoved_interim[site_name][&#39;processing_status&#39;][&#39;overall_status&#39;] = False
    
            #If it wasn&#39;t originally HVSRBatch, make it HVSRData object again
            if not data_curvesRemoved_interim[site_name][&#39;batch&#39;]:
                data_curvesRemoved_interim = data_curvesRemoved_interim[site_name]
        hvsr_results = data_curvesRemoved_interim
        

    # Final post-processing/reporting
    # Check peaks
    check_peaks_kwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(check_peaks).parameters.keys())}
    hvsr_results = check_peaks(hvsr_data=hvsr_results, verbose=verbose, **check_peaks_kwargs)

    get_report_kwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(get_report).parameters.keys())}
    # Add &#39;az&#39; as a default plot if the following conditions
    # first check if report_formats is specified, if not, add default value
    if &#39;report_formats&#39; not in get_report_kwargs.keys():
        get_report_kwargs[&#39;report_formats&#39;] = inspect.signature(get_report).parameters[&#39;report_formats&#39;].default
    
    # Now, check if plot is specified, then if plot_type is specified, then add &#39;az&#39; if stream has azimuths
    if &#39;plot&#39; in get_report_kwargs[&#39;report_formats&#39;]:
        plot_hvsr_kwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(plot_hvsr).parameters.keys())}
        get_report_kwargs.update(plot_hvsr_kwargs)
        usingDefault = True
        if &#39;plot_type&#39; not in get_report_kwargs.keys():
            get_report_kwargs[&#39;plot_type&#39;] = inspect.signature(get_report).parameters[&#39;plot_type&#39;].default
        else:
            usingDefault = False

        # Check if az is already specified as plot output
        azList = [&#39;azimuth&#39;, &#39;az&#39;, &#39;a&#39;, &#39;radial&#39;, &#39;r&#39;]
        az_requested = False
        
        get_report_kwargs[&#39;plot_type&#39;] = [item.lower() for item in get_report_kwargs[&#39;plot_type&#39;].split(&#39; &#39;)]
        for azStr in azList:
            if azStr.lower() in get_report_kwargs[&#39;plot_type&#39;]:
                az_requested = True
                break
        get_report_kwargs[&#39;plot_type&#39;] = &#39; &#39;.join(get_report_kwargs[&#39;plot_type&#39;])

        if isinstance(hvsr_results, HVSRData):
            hvsr_results_interim = {hvsr_results[&#39;site&#39;]: hvsr_results}
        else:
            hvsr_results_interim = hvsr_results

        for site_name in hvsr_results_interim.keys():  # This should work more or less the same for batch and regular data now
            # Check if data has azimuth data
            hasAz = False
            if &#39;stream&#39; in hvsr_results_interim[site_name].keys():
                for tr in hvsr_results_interim[site_name][&#39;stream&#39;]:
                    if tr.stats.component == &#39;R&#39;:
                        hasAz = True
                        break
            
            # Assuming all sites in batch have az if one does
            if hasAz:
                break

            # If it wasn&#39;t originally HVSRBatch, make it HVSRData object again
            #if not hvsr_results_interim[site_name][&#39;batch&#39;]:
            #    hvsr_results_interim = hvsr_results_interim[site_name]            
            
        # Add azimuth as a requested plot if azimuthal data exists but not requested in plot
        if not az_requested and hasAz and hvsr_results.horizontal_method != &#39;Single Azimuth&#39;:
            get_report_kwargs[&#39;plot_type&#39;] = get_report_kwargs[&#39;plot_type&#39;] + &#39; az&#39;

    hvsr_results = get_report(hvsr_results=hvsr_results, verbose=verbose, **get_report_kwargs)

    if verbose:
        if &#39;report_formats&#39; in get_report_kwargs.keys():
            if type(get_report_kwargs[&#39;report_formats&#39;]) is str:
                report_formats = get_report_kwargs[&#39;report_formats&#39;].lower()
            elif isinstance(get_report_kwargs[&#39;report_formats&#39;], (tuple, list)):
                for i, rf in enumerate(get_report_kwargs[&#39;report_formats&#39;]):
                    get_report_kwargs[&#39;report_formats&#39;][i] = rf.lower()
                    
            # if report_formats is &#39;print&#39;, we would have already printed it in previous step
            if get_report_kwargs[&#39;report_formats&#39;] == &#39;print&#39; or &#39;print&#39; in get_report_kwargs[&#39;report_formats&#39;] or isinstance(hvsr_results, HVSRBatch):
                # We do not need to print another report if already printed to terminal
                pass
            else:
                # We will just change the report_formats kwarg to print, since we already got the originally intended report format above, 
                #   now need to print for verbose output
                get_report_kwargs[&#39;report_formats&#39;] = &#39;print&#39;
                get_report(hvsr_results=hvsr_results, **get_report_kwargs)
                
            if get_report_kwargs[&#39;report_formats&#39;] == &#39;plot&#39; or &#39;plot&#39; in get_report_kwargs[&#39;report_formats&#39;]:
                # We do not need to plot another report if already plotted
                pass
            else:
                # hvplot_kwargs = {k: v for k, v in kwargs.items() if k in plot_hvsr.__code__.co_varnames}
                # hvsr_results[&#39;Plot_Report&#39;] = plot_hvsr(hvsr_results, return_fig=True, show_plot=False, close_figs=True)
                pass
        else:
            pass
    
    # Export processed data if hvsr_export_path(as pickle currently, default .hvsr extension)
    if &#39;hvsr_export_path&#39; in kwargs.keys():
        if kwargs[&#39;hvsr_export_path&#39;] is None:
            pass
        else:
            if &#39;ext&#39; in kwargs.keys():
                ext = kwargs[&#39;ext&#39;]
            else:
                ext = &#39;hvsr&#39;
            export_hvsr(hvsr_data=hvsr_results, hvsr_export_path=kwargs[&#39;hvsr_export_path&#39;], ext=ext, verbose=verbose)        
    if &#39;show_plot&#39; in kwargs:
        if not kwargs[&#39;show_plot&#39;]:
            plt.close()


    return hvsr_results</code></pre>
</details>
<div class="desc"><p>The sprit.run() is the main function that allows you to do all your HVSR processing in one simple step (sprit.run() is how you would call it in your code, but it may also be called using sprit.sprit_hvsr.run())</p>
<p>The input_data parameter of sprit.run() is the only required parameter (if nothing entered, it will run sample data). This can be either a single file, a list of files (one for each component, for example), a directory (in which case, all obspy-readable files will be added to an HVSRBatch instance), a Rasp. Shake raw data directory, or sample data.</p>
<h2 id="notes">Notes</h2>
<p>The sprit.run() function calls the following functions. This is the recommended order/set of functions to run to process HVSR using SpRIT. See the API documentation for these functions for more information:
- input_params(): The input_data parameter of input_params() is the only required variable, though others may also need to be called for your data to process correctly.
- fetch_data(): the source parameter of fetch_data() is the only explicit variable in the sprit.run() function aside from input_data and verbose. Everything else gets delivered to the correct function via the kwargs dictionary
- remove_noise(): by default, the kind of noise removal is remove_method='auto'. See the remove_noise() documentation for more information. If remove_method is set to anything other than one of the explicit options in remove_noise, noise removal will not be carried out.
- calculate_azimuth(): calculate one or several azimuths. Single azimuth can be a way to combine H components too.
- generate_psds(): generates psds for each component, which will be combined/used later. Any parameter of obspy.signal.spectral_estimation.PPSD() may also be read into this function.
- remove_outlier_curves(): removes any outlier ppsd curves so that the data quality for when curves are combined will be enhanced. See the remove_outlier_curves() documentation for more information.
- process_hvsr(): this is the main function processing the hvsr curve and statistics. See process_hvsr() documentation for more details. The hvsr_band parameter sets the frequency spectrum over which these calculations occur.
- check_peaks(): this is the main function that will find and 'score' peaks to get a best peak. The parameter peak_freq_range can be set to limit the frequencies within which peaks are checked and scored.
- get_report(): this is the main function that will print, plot, and/or save the results of the data. See the get_report() API documentation for more information.
- export_hvsr(): this function exports the final data output as a pickle file (by default, this pickle object has a .hvsr extension). This can be used to read data back into SpRIT without having to reprocess data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>input_data</code></strong> :&ensp;<code>str</code> or <code>filepath object that can be read by obspy</code></dt>
<dd>Filepath to data to be processed. This may be a file or directory, depending on what kind of data is being processed (this can be specified with the source parameter).
For sample data, The following can be specified as the input_data parameter:
- Any integer 1-6 (inclusive), or the string (e.g., input_data="1" or input_data=1 will work)
- The word "sample" before any integer (e.g., input_data="sample1")
- The word "sample" will default to "sample1" if source='file'.
- If source='batch', input_data should be input_data='sample' or input_data='batch'. In this case, it will read and process all the sample files using the HVSRBatch class. Set verbose=True to see all the information in the sample batch csv file.</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd><em>description</em>, by default 'file'</dd>
<dt><strong><code>azimuth_calculation</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to perform azimuthal analysis, by default False.</dd>
<dt><strong><code>noise_removal</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to remove noise (before processing PPSDs)</dd>
<dt><strong><code>outlier_curves_removal</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to remove outlier curves from HVSR time windows</dd>
<dt><strong><code>show_plot</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to show plots. This does not affect whether the plots are created (and then inserted as an attribute of HVSRData), only whether they are shown.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd><em>description</em>, by default False</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments for the functions listed above. The keyword arguments are unique, so they will get parsed out and passed into the appropriate function.</dd>
<dt><strong><code>input_params</code></strong> :&ensp;<code>function name (not an actual parameter) </code></dt>
<dd>Function for designating input parameters for reading in and processing data
See API documentation: <a href="https://sprit.readthedocs.io/en/latest/sprit.html#sprit.input_params">input_params()</a></dd>
<dt><strong><code>input_data</code></strong> :&ensp;<code>any</code>, default <code>= '&lt;no default&gt;'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>site</code></strong> :&ensp;<code>any</code>, default <code>= 'HVSRSite'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>project</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>network</code></strong> :&ensp;<code>any</code>, default <code>= 'AM'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>station</code></strong> :&ensp;<code>any</code>, default <code>= 'NONE'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>location</code></strong> :&ensp;<code>any</code>, default <code>= '00'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>channels</code></strong> :&ensp;<code>any</code>, default <code>= ['EHZ', 'EHN', 'EHE']</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>acq_date</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>starttime</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>endtime</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>tzone</code></strong> :&ensp;<code>any</code>, default <code>= 'UTC'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>xcoord</code></strong> :&ensp;<code>any</code>, default <code>= -88.229</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>ycoord</code></strong> :&ensp;<code>any</code>, default <code>= 40.101</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>elevation</code></strong> :&ensp;<code>any</code>, default <code>= 225</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>input_crs</code></strong> :&ensp;<code>any</code>, default <code>= 'EPSG:4326'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>output_crs</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>elev_unit</code></strong> :&ensp;<code>any</code>, default <code>= 'meters'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>depth</code></strong> :&ensp;<code>any</code>, default <code>= 0</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>instrument</code></strong> :&ensp;<code>any</code>, default <code>= 'Seismometer'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>hvsr_band</code></strong> :&ensp;<code>any</code>, default <code>= [0.5, 40]</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>peak_freq_range</code></strong> :&ensp;<code>any</code>, default <code>= [0.5, 40]</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>processing_parameters</code></strong> :&ensp;<code>any</code>, default <code>= {}</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.input_params" href="#sprit.input_params">input_params()</a>)</code> for specifics.</dd>
<dt><strong><code>fetch_data</code></strong> :&ensp;<code>function name (not an actual parameter) </code></dt>
<dd>Fetch ambient seismic data from a source to read into obspy stream.
See API documentation: <a href="https://sprit.readthedocs.io/en/latest/sprit.html#sprit.fetch_data">fetch_data()</a></dd>
<dt><strong><code>params</code></strong> :&ensp;<code>any</code>, default <code>= '&lt;output</code> of <code>previous function&gt;'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.fetch_data" href="#sprit.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>any</code>, default <code>= 'file'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.fetch_data" href="#sprit.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>data_export_path</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.fetch_data" href="#sprit.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>data_export_format</code></strong> :&ensp;<code>any</code>, default <code>= 'mseed'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.fetch_data" href="#sprit.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>detrend</code></strong> :&ensp;<code>any</code>, default <code>= 'spline'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.fetch_data" href="#sprit.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>detrend_options</code></strong> :&ensp;<code>any</code>, default <code>= 2</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.fetch_data" href="#sprit.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>filter_type</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.fetch_data" href="#sprit.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>filter_options</code></strong> :&ensp;<code>any</code>, default <code>= {}</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.fetch_data" href="#sprit.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>update_metadata</code></strong> :&ensp;<code>any</code>, default <code>= True</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.fetch_data" href="#sprit.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>plot_input_stream</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.fetch_data" href="#sprit.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>plot_engine</code></strong> :&ensp;<code>any</code>, default <code>= 'matplotlib'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.fetch_data" href="#sprit.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>show_plot</code></strong> :&ensp;<code>any</code>, default <code>= True</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.fetch_data" href="#sprit.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.fetch_data" href="#sprit.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>any</code>, default <code>= {}</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.fetch_data" href="#sprit.fetch_data">fetch_data()</a>)</code> for specifics.</dd>
<dt><strong><code>calculate_azimuth</code></strong> :&ensp;<code>function name (not an actual parameter) </code></dt>
<dd>Function to calculate azimuthal horizontal component at specified angle(s).
See API documentation: <a href="https://sprit.readthedocs.io/en/latest/sprit.html#sprit.calculate_azimuth">calculate_azimuth()</a></dd>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>any</code>, default <code>= '&lt;output</code> of <code>previous function&gt;'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.calculate_azimuth" href="#sprit.calculate_azimuth">calculate_azimuth()</a>)</code> for specifics.</dd>
<dt><strong><code>azimuth_angle</code></strong> :&ensp;<code>any</code>, default <code>= 45</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.calculate_azimuth" href="#sprit.calculate_azimuth">calculate_azimuth()</a>)</code> for specifics.</dd>
<dt><strong><code>azimuth_type</code></strong> :&ensp;<code>any</code>, default <code>= 'multiple'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.calculate_azimuth" href="#sprit.calculate_azimuth">calculate_azimuth()</a>)</code> for specifics.</dd>
<dt><strong><code>azimuth_unit</code></strong> :&ensp;<code>any</code>, default <code>= 'degrees'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.calculate_azimuth" href="#sprit.calculate_azimuth">calculate_azimuth()</a>)</code> for specifics.</dd>
<dt><strong><code>show_az_plot</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.calculate_azimuth" href="#sprit.calculate_azimuth">calculate_azimuth()</a>)</code> for specifics.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.calculate_azimuth" href="#sprit.calculate_azimuth">calculate_azimuth()</a>)</code> for specifics.</dd>
<dt><strong><code>plot_azimuth_kwargs</code></strong> :&ensp;<code>any</code>, default <code>= {}</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.calculate_azimuth" href="#sprit.calculate_azimuth">calculate_azimuth()</a>)</code> for specifics.</dd>
<dt><strong><code>remove_noise</code></strong> :&ensp;<code>function name (not an actual parameter) </code></dt>
<dd>Function to remove noisy windows from data, using various methods.
See API documentation: <a href="https://sprit.readthedocs.io/en/latest/sprit.html#sprit.remove_noise">remove_noise()</a></dd>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>any</code>, default <code>= '&lt;output</code> of <code>previous function&gt;'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_noise" href="#sprit.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>remove_method</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_noise" href="#sprit.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>processing_window</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_noise" href="#sprit.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>sat_percent</code></strong> :&ensp;<code>any</code>, default <code>= 0.995</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_noise" href="#sprit.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>noise_percent</code></strong> :&ensp;<code>any</code>, default <code>= 0.8</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_noise" href="#sprit.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>sta</code></strong> :&ensp;<code>any</code>, default <code>= 2</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_noise" href="#sprit.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>lta</code></strong> :&ensp;<code>any</code>, default <code>= 30</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_noise" href="#sprit.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>stalta_thresh</code></strong> :&ensp;<code>any</code>, default <code>= [8, 16]</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_noise" href="#sprit.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>std_ratio_thresh</code></strong> :&ensp;<code>any</code>, default <code>= 2.0</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_noise" href="#sprit.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>std_window_size</code></strong> :&ensp;<code>any</code>, default <code>= 20.0</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_noise" href="#sprit.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>min_std_win</code></strong> :&ensp;<code>any</code>, default <code>= 5.0</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_noise" href="#sprit.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>warmup_time</code></strong> :&ensp;<code>any</code>, default <code>= 0</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_noise" href="#sprit.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>cooldown_time</code></strong> :&ensp;<code>any</code>, default <code>= 0</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_noise" href="#sprit.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>min_win_size</code></strong> :&ensp;<code>any</code>, default <code>= 1</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_noise" href="#sprit.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>remove_raw_noise</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_noise" href="#sprit.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>show_stalta_plot</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_noise" href="#sprit.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_noise" href="#sprit.remove_noise">remove_noise()</a>)</code> for specifics.</dd>
<dt><strong><code>generate_psds</code></strong> :&ensp;<code>function name (not an actual parameter) </code></dt>
<dd>Calculate Power Spectral Density (PSD) curves for each channel.
See API documentation: <a href="https://sprit.readthedocs.io/en/latest/sprit.html#sprit.generate_psds">generate_psds()</a></dd>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>any</code>, default <code>= '&lt;output</code> of <code>previous function&gt;'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.generate_psds" href="#sprit.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>window_length</code></strong> :&ensp;<code>any</code>, default <code>= 30.0</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.generate_psds" href="#sprit.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>overlap_pct</code></strong> :&ensp;<code>any</code>, default <code>= 0.5</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.generate_psds" href="#sprit.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>window_type</code></strong> :&ensp;<code>any</code>, default <code>= 'hann'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.generate_psds" href="#sprit.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>window_length_method</code></strong> :&ensp;<code>any</code>, default <code>= 'length'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.generate_psds" href="#sprit.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>remove_response</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.generate_psds" href="#sprit.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>skip_on_gaps</code></strong> :&ensp;<code>any</code>, default <code>= True</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.generate_psds" href="#sprit.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>num_freq_bins</code></strong> :&ensp;<code>any</code>, default <code>= 512</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.generate_psds" href="#sprit.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>hvsr_band</code></strong> :&ensp;<code>any</code>, default <code>= [0.5, 40]</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.generate_psds" href="#sprit.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>obspy_ppsds</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.generate_psds" href="#sprit.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>azimuthal_psds</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.generate_psds" href="#sprit.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.generate_psds" href="#sprit.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>plot_psds</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.generate_psds" href="#sprit.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>obspy_ppsd_kwargs</code></strong> :&ensp;<code>any</code>, default <code>= {}</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.generate_psds" href="#sprit.generate_psds">generate_psds()</a>)</code> for specifics.</dd>
<dt><strong><code>process_hvsr</code></strong> :&ensp;<code>function name (not an actual parameter) </code></dt>
<dd>Process the input data and get HVSR data
See API documentation: <a href="https://sprit.readthedocs.io/en/latest/sprit.html#sprit.process_hvsr">process_hvsr()</a></dd>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>any</code>, default <code>= '&lt;output</code> of <code>previous function&gt;'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.process_hvsr" href="#sprit.process_hvsr">process_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>horizontal_method</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.process_hvsr" href="#sprit.process_hvsr">process_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>smooth</code></strong> :&ensp;<code>any</code>, default <code>= True</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.process_hvsr" href="#sprit.process_hvsr">process_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>freq_smooth</code></strong> :&ensp;<code>any</code>, default <code>= 'konno ohmachi'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.process_hvsr" href="#sprit.process_hvsr">process_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>f_smooth_width</code></strong> :&ensp;<code>any</code>, default <code>= 40</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.process_hvsr" href="#sprit.process_hvsr">process_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>resample</code></strong> :&ensp;<code>any</code>, default <code>= True</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.process_hvsr" href="#sprit.process_hvsr">process_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>outlier_curve_percentile_threshold</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.process_hvsr" href="#sprit.process_hvsr">process_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>azimuth</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.process_hvsr" href="#sprit.process_hvsr">process_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.process_hvsr" href="#sprit.process_hvsr">process_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>remove_outlier_curves</code></strong> :&ensp;<code>function name (not an actual parameter) </code></dt>
<dd>Function used to remove outliers curves using a "prototype" or "dbscan" method.
See API documentation: <a href="https://sprit.readthedocs.io/en/latest/sprit.html#sprit.remove_outlier_curves">remove_outlier_curves()</a></dd>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>any</code>, default <code>= '&lt;output</code> of <code>previous function&gt;'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_outlier_curves" href="#sprit.remove_outlier_curves">remove_outlier_curves()</a>)</code> for specifics.</dd>
<dt><strong><code>outlier_method</code></strong> :&ensp;<code>any</code>, default <code>= 'prototype'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_outlier_curves" href="#sprit.remove_outlier_curves">remove_outlier_curves()</a>)</code> for specifics.</dd>
<dt><strong><code>outlier_threshold</code></strong> :&ensp;<code>any</code>, default <code>= 50</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_outlier_curves" href="#sprit.remove_outlier_curves">remove_outlier_curves()</a>)</code> for specifics.</dd>
<dt><strong><code>use_percentile</code></strong> :&ensp;<code>any</code>, default <code>= True</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_outlier_curves" href="#sprit.remove_outlier_curves">remove_outlier_curves()</a>)</code> for specifics.</dd>
<dt><strong><code>min_pts</code></strong> :&ensp;<code>any</code>, default <code>= 5</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_outlier_curves" href="#sprit.remove_outlier_curves">remove_outlier_curves()</a>)</code> for specifics.</dd>
<dt><strong><code>use_hv_curves</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_outlier_curves" href="#sprit.remove_outlier_curves">remove_outlier_curves()</a>)</code> for specifics.</dd>
<dt><strong><code>plot_engine</code></strong> :&ensp;<code>any</code>, default <code>= 'matplotlib'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_outlier_curves" href="#sprit.remove_outlier_curves">remove_outlier_curves()</a>)</code> for specifics.</dd>
<dt><strong><code>show_outlier_plot</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_outlier_curves" href="#sprit.remove_outlier_curves">remove_outlier_curves()</a>)</code> for specifics.</dd>
<dt><strong><code>generate_outlier_plot</code></strong> :&ensp;<code>any</code>, default <code>= True</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_outlier_curves" href="#sprit.remove_outlier_curves">remove_outlier_curves()</a>)</code> for specifics.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_outlier_curves" href="#sprit.remove_outlier_curves">remove_outlier_curves()</a>)</code> for specifics.</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>any</code>, default <code>= {}</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.remove_outlier_curves" href="#sprit.remove_outlier_curves">remove_outlier_curves()</a>)</code> for specifics.</dd>
<dt><strong><code>check_peaks</code></strong> :&ensp;<code>function name (not an actual parameter) </code></dt>
<dd>Function to run tests on HVSR peaks to find best one and see if it passes SESAME quality checks
See API documentation: <a href="https://sprit.readthedocs.io/en/latest/sprit.html#sprit.check_peaks">check_peaks()</a></dd>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>any</code>, default <code>= '&lt;output</code> of <code>previous function&gt;'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.check_peaks" href="#sprit.check_peaks">check_peaks()</a>)</code> for specifics.</dd>
<dt><strong><code>hvsr_band</code></strong> :&ensp;<code>any</code>, default <code>= [0.5, 40]</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.check_peaks" href="#sprit.check_peaks">check_peaks()</a>)</code> for specifics.</dd>
<dt><strong><code>peak_selection</code></strong> :&ensp;<code>any</code>, default <code>= 'max'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.check_peaks" href="#sprit.check_peaks">check_peaks()</a>)</code> for specifics.</dd>
<dt><strong><code>peak_freq_range</code></strong> :&ensp;<code>any</code>, default <code>= [0.5, 40]</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.check_peaks" href="#sprit.check_peaks">check_peaks()</a>)</code> for specifics.</dd>
<dt><strong><code>azimuth</code></strong> :&ensp;<code>any</code>, default <code>= 'HV'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.check_peaks" href="#sprit.check_peaks">check_peaks()</a>)</code> for specifics.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.check_peaks" href="#sprit.check_peaks">check_peaks()</a>)</code> for specifics.</dd>
<dt><strong><code>get_report</code></strong> :&ensp;<code>function name (not an actual parameter) </code></dt>
<dd>Generate and/or print and/or export a report of the HVSR analysis in a variety of formats.
See API documentation: <a href="https://sprit.readthedocs.io/en/latest/sprit.html#sprit.get_report">get_report()</a></dd>
<dt><strong><code>hvsr_results</code></strong> :&ensp;<code>any</code>, default <code>= '&lt;output</code> of <code>previous function&gt;'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.get_report" href="#sprit.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>report_formats</code></strong> :&ensp;<code>any</code>, default <code>= ['print', 'table', 'plot', 'html', 'pdf']</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.get_report" href="#sprit.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>azimuth</code></strong> :&ensp;<code>any</code>, default <code>= 'HV'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.get_report" href="#sprit.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>plot_type</code></strong> :&ensp;<code>any</code>, default <code>= 'HVSR p ann COMP+ p ann SPEC p ann'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.get_report" href="#sprit.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>plot_engine</code></strong> :&ensp;<code>any</code>, default <code>= 'matplotlib'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.get_report" href="#sprit.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>show_print_report</code></strong> :&ensp;<code>any</code>, default <code>= True</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.get_report" href="#sprit.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>show_table_report</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.get_report" href="#sprit.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>show_plot_report</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.get_report" href="#sprit.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>show_html_report</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.get_report" href="#sprit.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>show_pdf_report</code></strong> :&ensp;<code>any</code>, default <code>= True</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.get_report" href="#sprit.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>suppress_report_outputs</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.get_report" href="#sprit.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>show_report_outputs</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.get_report" href="#sprit.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>csv_handling</code></strong> :&ensp;<code>any</code>, default <code>= 'append'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.get_report" href="#sprit.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>report_export_format</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.get_report" href="#sprit.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>report_export_path</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.get_report" href="#sprit.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.get_report" href="#sprit.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>any</code>, default <code>= {}</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.get_report" href="#sprit.get_report">get_report()</a>)</code> for specifics.</dd>
<dt><strong><code>export_hvsr</code></strong> :&ensp;<code>function name (not an actual parameter) </code></dt>
<dd>Export data into pickle format that can be read back in using import_data().
See API documentation: <a href="https://sprit.readthedocs.io/en/latest/sprit.html#sprit.export_hvsr">export_hvsr()</a></dd>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>any</code>, default <code>= '&lt;output</code> of <code>previous function&gt;'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.export_hvsr" href="#sprit.export_hvsr">export_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>hvsr_export_path</code></strong> :&ensp;<code>any</code>, default <code>= None</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.export_hvsr" href="#sprit.export_hvsr">export_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>ext</code></strong> :&ensp;<code>any</code>, default <code>= 'hvsr'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.export_hvsr" href="#sprit.export_hvsr">export_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>export_type</code></strong> :&ensp;<code>any</code>, default <code>= 'gzip'</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.export_hvsr" href="#sprit.export_hvsr">export_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>export_plots</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.export_hvsr" href="#sprit.export_hvsr">export_hvsr()</a>)</code> for specifics.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>any</code>, default <code>= False</code></dt>
<dd>See API documentation at link above or at <code>help(<a title="sprit.export_hvsr" href="#sprit.export_hvsr">export_hvsr()</a>)</code> for specifics.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>hvsr_results</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code> or <code><a title="sprit.HVSRBatch" href="#sprit.HVSRBatch">HVSRBatch</a> object</code></dt>
<dd>If a single file/data point is being processed, a HVSRData object will be returned. Otherwise, it will be a HVSRBatch object. See their documention for more information.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="sprit.input_params" href="#sprit.input_params">input_params()</a></code>
<code><a title="sprit.fetch_data" href="#sprit.fetch_data">fetch_data()</a></code>
<code><a title="sprit.remove_noise" href="#sprit.remove_noise">remove_noise()</a></code>
<code><a title="sprit.calculate_azimuth" href="#sprit.calculate_azimuth">calculate_azimuth()</a></code>
<code><a title="sprit.generate_psds" href="#sprit.generate_psds">generate_psds()</a></code>
<code><a title="sprit.remove_outlier_curves" href="#sprit.remove_outlier_curves">remove_outlier_curves()</a></code>
<code><a title="sprit.process_hvsr" href="#sprit.process_hvsr">process_hvsr()</a></code>
<code><a title="sprit.check_peaks" href="#sprit.check_peaks">check_peaks()</a></code>
<code><a title="sprit.get_report" href="#sprit.get_report">get_report()</a></code>
<code><a title="sprit.export_hvsr" href="#sprit.export_hvsr">export_hvsr()</a> </code>Raises</p>
<hr>
<dl>
<dt><code>RuntimeError</code></dt>
<dd>If the input parameter may not be read correctly. This is raised if the input_params() function fails. This raises an error since no other data processing or reading steps will be able to carried out correctly.</dd>
<dt><code>RuntimeError</code></dt>
<dd>If the data is not read/fetched correctly using fetch_data(), an error will be raised. This is raised if the fetch_data() function fails. This raises an error since no other data processing steps will be able to carried out correctly.</dd>
<dt><code>RuntimeError</code></dt>
<dd>If the data being processed is a single file, an error will be raised if generate_psds() does not work correctly. No errors are raised for remove_noise() errors (since that is an optional step) and the process_hvsr() step (since that is the last processing step) .</dd>
</dl></div>
</dd>
<dt id="sprit.update_elevation"><code class="name flex">
<span>def <span class="ident">update_elevation</span></span>(<span>hvsr_data, updated_surface_elevation, updated_elevation_unit)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_elevation(hvsr_data, updated_surface_elevation, updated_elevation_unit):
    &#34;&#34;&#34;Function to quickly update all attributes associated with elevation of an HVSRData object

    Parameters
    ----------
    hvsr_data : HVSRData or HVSRBatch
        HVSRData or HVSRBatch object containing attributes related to elevation.
        If HVSRBatch, updated_surface_elevation should be list or tuple and 
        updated_elevation_unit may either be str or  list/tuple of strings.        
    updated_surface_elevation : numbers.Number
        Number (float or int) with the updated elevation.
        Meters is the preferred unit. If feet are used instead, it will be converted to meters.
    updated_elevation_unit : str
        Unit used for updated_surface_elevation. If &#39;feet&#39;, it will be converted to meters.

    Returns
    -------
    HVSRData
        HVSRData object with all attributes related to elevation updated
    &#34;&#34;&#34;
    
    # Break out for HVSRBatch
    if isinstance(hvsr_data, HVSRBatch):
        if len(updated_surface_elevation) != len(hvsr_data.sites):
            warnings.warn(f&#39;Elevations for HVSRBatch object could not be updated. \
                Length of updated_surface_elevation ({len(updated_surface_elevation)}) must equal\
                the number of sites ({len(hvsr_data.sites)}) in hvsr_data&#39;)
            return hvsr_data
        
        if isinstance(updated_elevation_unit, (list, tuple)):
            if len(updated_elevation_unit) != len(hvsr_data.sites):
                warnings.warn(f&#39;Elevations for HVSRBatch object could not be updated. \
                    Length of updated_elevation_unit ({len(updated_elevation_unit)}) must equal\
                    the number of sites ({len(hvsr_data.sites)}) in hvsr_data&#39;)
            return hvsr_data
        
        elif type(updated_elevation_unit) is str:
            updated_elevation_unit = [updated_elevation_unit] * len(hvsr_data.sites)
        else:
            warnings.warn(f&#34;updated_elevation_unit must be list, tuple, or str, not {type(updated_elevation_unit)}&#34;)
        
        for i, sitename in enumerate( hvsr_data):
            hvsr_data[sitename] = _update_elevation(hvsr_data[sitename], 
                                                   updated_surface_elevation[i],
                                                   updated_elevation_unit[i])
        return hvsr_data
    
    #elevation_attrs = [&#39;elevation&#39;, &#39;x_elev_m&#39;, &#39;x_elev_ft&#39;]
    if hasattr(hvsr_data, &#39;elevation&#39;):
        elev_diff = hvsr_data[&#39;elevation&#39;] - updated_surface_elevation
    else:
        elev_diff = -1 * updated_surface_elevation
        

    mList = [&#39;meters&#39;, &#39;m&#39;, &#39;standard&#39;, &#39;metric&#39;, &#39;si&#39;, &#39;metres&#39;, &#39;metre&#39;, &#39;meter&#39;]
    fList = [&#39;feet&#39;, &#39;ft&#39;, &#39;f&#39;, &#39;foot&#39;, &#39;american&#39;, &#39;imperial&#39;, &#39;imp&#39;]
    
    # Update parameters with elevations in them
    if str(updated_elevation_unit).lower() in fList:
        updated_surface_elevation = updated_surface_elevation * 0.3048
    hvsr_data[&#39;elevation&#39;] = updated_surface_elevation
        
    hvsr_data[&#39;elev_unit&#39;] = &#39;meters&#39;
    
    if hasattr(hvsr_data, &#39;x_elev_m&#39;):
        hvsr_data[&#39;x_elev_m&#39;][&#39;Z&#39;] = hvsr_data[&#39;x_elev_m&#39;][&#39;Z&#39;] - elev_diff
        hvsr_data[&#39;x_elev_m&#39;][&#39;E&#39;] = hvsr_data[&#39;x_elev_m&#39;][&#39;E&#39;] - elev_diff
        hvsr_data[&#39;x_elev_m&#39;][&#39;N&#39;] = hvsr_data[&#39;x_elev_m&#39;][&#39;N&#39;] - elev_diff
        
        hvsr_data[&#39;x_elev_ft&#39;][&#39;Z&#39;] = hvsr_data[&#39;x_elev_m&#39;][&#39;Z&#39;] / 0.3048
        hvsr_data[&#39;x_elev_ft&#39;][&#39;E&#39;] = hvsr_data[&#39;x_elev_m&#39;][&#39;E&#39;] / 0.3048
        hvsr_data[&#39;x_elev_ft&#39;][&#39;N&#39;] = hvsr_data[&#39;x_elev_m&#39;][&#39;N&#39;] / 0.3048
    
    # Update elevations in Table_Report
    table_report_cols = [&#39;Elevation&#39;, &#39;BedrockElevation&#39;]
    if hasattr(hvsr_data, &#39;Table_Report&#39;):
        hvsr_data.Table_Report[&#39;Elevation&#39;] = updated_surface_elevation
        if &#39;BedrockDepth&#39; in hvsr_data.Table_Report.columns:
            hvsr_data.Table_Report[&#39;BedrockElevation&#39;] = updated_surface_elevation - hvsr_data.Table_Report[&#39;BedrockDepth&#39;]

    # Update elevations in Print_Report
    if hasattr(hvsr_data, &#34;Print_Report&#34;):
        hvsr_data[&#39;Print_Report&#39;] = re.sub(r&#34;Elevation:\s*[\d.]+&#34;, 
                                            f&#34;Elevation: {updated_surface_elevation}&#34;, 
                                            hvsr_data[&#39;Print_Report&#39;])

    # Update elevations in HTML_Report
    if hasattr(hvsr_data, &#34;HTML_Report&#34;):
        hvsr_data[&#39;HTML_Report&#39;] = re.sub(r&#34;Elevation:\s*[\d.]+&#34;, 
                                            f&#34;Elevation: {updated_surface_elevation}&#34;, 
                                            hvsr_data[&#39;HTML_Report&#39;])
    
    # Update elevations in PeakReport attributes
    azList = [&#39;HV&#39;]
    azList.extend(list(hvsr_data.hvsr_az.keys()))
    for az in azList:
        for peakReport in hvsr_data.PeakReport[az]:
            if &#39;Table_Report&#39; in peakReport[&#39;Report&#39;]: #This is a dict
                peakReport[&#39;Report&#39;][&#39;Table_Report&#39;][&#39;Elevation&#39;] = updated_surface_elevation
                if &#39;BedrockDepth&#39; in peakReport[&#39;Report&#39;][&#39;Table_Report&#39;].columns:
                    peakReport[&#39;Report&#39;][&#39;Table_Report&#39;][&#39;BedrockElevation&#39;] = updated_surface_elevation - peakReport[&#39;Report&#39;][&#39;Table_Report&#39;][&#39;BedrockDepth&#39;]
            
            if &#39;Print_Report&#39; in peakReport[&#39;Report&#39;]: #This is a dict
                peakReport[&#39;Report&#39;][&#39;Print_Report&#39;] = re.sub(r&#34;Elevation:\s*[\d.]+&#34;, 
                                                              f&#34;Elevation: {updated_surface_elevation}&#34;, 
                                                              peakReport[&#39;Report&#39;][&#39;Print_Report&#39;])
                
    # Update processing_parameters to reflect new elevations
    hvsr_data[&#39;processing_parameters&#39;][&#39;fetch_data&#39;][&#39;params&#39;][&#39;elevation&#39;] = updated_surface_elevation
    hvsr_data[&#39;processing_parameters&#39;][&#39;fetch_data&#39;][&#39;params&#39;][&#39;elev_unit&#39;] = &#39;meters&#39;
    hvsr_data[&#39;processing_parameters&#39;][&#39;fetch_data&#39;][&#39;params&#39;][&#39;params&#39;][&#39;elevation&#39;] = updated_surface_elevation
    hvsr_data[&#39;processing_parameters&#39;][&#39;fetch_data&#39;][&#39;params&#39;][&#39;params&#39;][&#39;elev_unit&#39;] = &#39;meters&#39;
    
    return hvsr_data</code></pre>
</details>
<div class="desc"><p>Function to quickly update all attributes associated with elevation of an HVSRData object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code> or <code><a title="sprit.HVSRBatch" href="#sprit.HVSRBatch">HVSRBatch</a></code></dt>
<dd>HVSRData or HVSRBatch object containing attributes related to elevation.
If HVSRBatch, updated_surface_elevation should be list or tuple and
updated_elevation_unit may either be str or
list/tuple of strings.</dd>
<dt><strong><code>updated_surface_elevation</code></strong> :&ensp;<code>numbers.Number</code></dt>
<dd>Number (float or int) with the updated elevation.
Meters is the preferred unit. If feet are used instead, it will be converted to meters.</dd>
<dt><strong><code>updated_elevation_unit</code></strong> :&ensp;<code>str</code></dt>
<dd>Unit used for updated_surface_elevation. If 'feet', it will be converted to meters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code></dt>
<dd>HVSRData object with all attributes related to elevation updated</dd>
</dl></div>
</dd>
<dt id="sprit.update_resp_file"><code class="name flex">
<span>def <span class="ident">update_resp_file</span></span>(<span>resp_file,<br>new_network,<br>new_station,<br>return_inv=True,<br>new_channels='CHZ',<br>new_location='',<br>starttime_new=None,<br>endtime_new=None,<br>new_resp_file=None,<br>existing_starttime='2015,001,00:00:00.0000',<br>existing_endtime='No Ending Time',<br>existing_network='XX',<br>existing_station='NS124',<br>existing_channel='CHZ',<br>existing_location='??')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_resp_file(resp_file, new_network, new_station, 
                     return_inv=True, new_channels=&#39;CHZ&#39;, new_location=&#34;&#34;,
                     starttime_new=None, endtime_new=None, new_resp_file=None,
                     existing_starttime=&#39;2015,001,00:00:00.0000&#39;, existing_endtime=&#34;No Ending Time&#34;,
                     existing_network=&#39;XX&#39;, existing_station=&#39;NS124&#39;, existing_channel=&#39;CHZ&#39;, existing_location=&#39;??&#39;):
    &#34;&#34;&#34;Function to update headers in .RESP instrument response files for easy copying.
       It is recommended to read this into a variable and set it as the metadata parameter of input_params
       if it is desired to correct for instrument response, for example.

    Parameters
    ----------
    resp_file : str
        Filepath to input response file
    new_network : str
        Name of network to update header to.
    new_station : str
        Name of station to update header to.
    return_inv : bool, optional
        Whether to return an obspy inventory object.
        If False, a .RESP file will be saved in the same directory as resp_file, by default True
    new_channels : str, optional
        Name or list of channels to update the header to.
        If list, multiple inventory objects will be created/saved, by default &#39;CHZ&#39;
    new_location : str, optional
        New instrument location attribute to update header to, by default &#34;&#34;
    starttime : obspy.UTCDateTime, optional
        Input to update starttime. Must be readable by obspy.UTCDateTime(), by default None
    endtime : obspy.UTCDateTime, optional
        Input to update endtime. Must be readable by obspy.UTCDateTime(), by default None
    new_resp_file : str, optional
        Filepath to designate for .RESP file output, if desired (and return_inv=False)
        If None, uses same directory as resp_file, by default None
    existing_network : str, optional
        Name of network as specified in input file, by default &#39;XX&#39;
    existing_station : str, optional
        name of station as specified in input file, by default &#39;NS124&#39;
    existing_channel : str, optional
        Name of channel as specified in input file, by default &#39;CHZ&#39;
    existing_location : str, optional
        Name of location as specified in input file, by default &#39;??&#39;

    Returns
    -------
    obspy.Inventory
        Only returned if return_inv = True
    &#34;&#34;&#34;

    with open(resp_file) as inFile:
        respTextIN = inFile.read()

    respText = respTextIN.replace(existing_network, new_network)
    respText = respText.replace(existing_station, new_station)
    respTextNoChann = respText.replace(existing_location, new_location)
    if not isinstance(new_channels, (list, tuple)):
        new_channels = [new_channels]

    if starttime_new is not None:
        sTime = obspy.UTCDateTime(starttime_new)
        sTimeText = existing_starttime.replace(&#39;2015,&#39;, str(sTime.year)+&#39;,&#39;)
        sTimeText = sTimeText.replace(&#39;001,&#39;, str(sTime.julday)+&#39;,&#39;)
        sTimeText = sTimeText.replace(&#39;00:00:00.0000&#39;, str(sTime.strftime(&#34;%H:%M:%S.%f&#34;)))
        respTextNoChann = respTextNoChann.replace(existing_starttime, sTimeText)

    if endtime_new is not None:
        eTime = obspy.UTCDateTime(endtime_new)
        respTextNoChann = respTextNoChann.replace(existing_endtime, 
                                                  f&#34;{eTime.year},{eTime.julday},{eTime.strftime(&#39;%H:%M:%S.%f&#39;)}&#34;)

    invList = []
    for i, newcha in enumerate(new_channels):
        print(newcha)
        respText = respTextNoChann.replace(existing_channel, newcha)

        if return_inv:
            invList.append(obspy.read_inventory(io.StringIO(respText)))
                        
        else:
            if new_resp_file is None:
                dir = pathlib.Path(resp_file).parent
                new_resp_file = dir.joinpath(f&#34;RESP_{new_network}.{new_station}.{new_station}.{newcha}.resp&#34;)
            else:
                new_resp_file = pathlib.Path(new_resp_file)

            with open(new_resp_file.as_posix(), &#39;w&#39;) as outFile:
                outFile.write(new_resp_file.as_posix())
    
    if return_inv:
        for i, r in enumerate(invList):
            if i == 0:
                inv = r
            else:
                inv = inv + r
        return inv</code></pre>
</details>
<div class="desc"><p>Function to update headers in .RESP instrument response files for easy copying.
It is recommended to read this into a variable and set it as the metadata parameter of input_params
if it is desired to correct for instrument response, for example.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>resp_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Filepath to input response file</dd>
<dt><strong><code>new_network</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of network to update header to.</dd>
<dt><strong><code>new_station</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of station to update header to.</dd>
<dt><strong><code>return_inv</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to return an obspy inventory object.
If False, a .RESP file will be saved in the same directory as resp_file, by default True</dd>
<dt><strong><code>new_channels</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name or list of channels to update the header to.
If list, multiple inventory objects will be created/saved, by default 'CHZ'</dd>
<dt><strong><code>new_location</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>New instrument location attribute to update header to, by default ""</dd>
<dt><strong><code>starttime</code></strong> :&ensp;<code>obspy.UTCDateTime</code>, optional</dt>
<dd>Input to update starttime. Must be readable by obspy.UTCDateTime(), by default None</dd>
<dt><strong><code>endtime</code></strong> :&ensp;<code>obspy.UTCDateTime</code>, optional</dt>
<dd>Input to update endtime. Must be readable by obspy.UTCDateTime(), by default None</dd>
<dt><strong><code>new_resp_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Filepath to designate for .RESP file output, if desired (and return_inv=False)
If None, uses same directory as resp_file, by default None</dd>
<dt><strong><code>existing_network</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of network as specified in input file, by default 'XX'</dd>
<dt><strong><code>existing_station</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>name of station as specified in input file, by default 'NS124'</dd>
<dt><strong><code>existing_channel</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of channel as specified in input file, by default 'CHZ'</dd>
<dt><strong><code>existing_location</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of location as specified in input file, by default '??'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>obspy.Inventory</code></dt>
<dd>Only returned if return_inv = True</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sprit.HVSRBatch"><code class="flex name class">
<span>class <span class="ident">HVSRBatch</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HVSRBatch:
    &#34;&#34;&#34;HVSRBatch is the data container used for batch processing. 
    It contains several HVSRData objects (one for each site). 
    These can be accessed using their site name, 
    either square brackets (HVSRBatchVariable[&#34;SiteName&#34;]) or the dot (HVSRBatchVariable.SiteName) accessor.
    
    The dot accessor may not work if there is a space in the site name.
    
    All of the  functions in the sprit package are designed to perform the bulk of their operations iteratively
    on the individual HVSRData objects contained in the HVSRBatch object, and do little with the HVSRBatch object itself, 
    besides using it determine which sites are contained within it.
    
    &#34;&#34;&#34;
    @check_instance
    def __init__(self, batch_input, batch_ext=None, batch_use=None, df_as_read=None):
        &#34;&#34;&#34;HVSR Batch initializer

        Parameters
        ----------
        batch_input : dict, list, tuple, HVSRData, or filepath(s)
            If:

            * dict, dictionary containing Key value pairs with {sitename: HVSRData object}.
            * list or tuple, assumed to be dicts, HVSRData objects, or filepaths to processed .hvsr files or seismic data to be processed.
            * HVSRData object, will transform into HVSRBatch object with single HVSRData object. The add() or append() methods, or using square brackes can be used to add additional sites.
            * filepaths, if:
                * If directory, will use `batch_ext` as the input to a `glob()` function to get all files in that directory and add them to batch. Defaults to &#39;.hvsr&#39; files if `batch_ext` not specified.
                * Filepath, will make a HVSRBatch object importing that single file, or if readable by pandas.read_csv() will use in conjunction with `batch_use` (see below)
        batch_ext : str or None
            Filepath extension to use in `glob()` function for filetypes to import, if batch_input is a filepath.
        batch_use : {dict, list, tuple, None}
            Intended to be used as dict with keys &#34;site&#34;, &#34;filepath&#34;, and &#34;batch&#34;. 
            In this case, should be {&#39;site&#39;:&#34;name_of_df_col_with_sitenames&#34;, &#39;filepath&#39;:&#34;name_of_df_col_with_filepaths_to_data&#34;, &#39;batch&#39;:values_to_include}.
            values_to_include can be a value (or list of values) in a column called &#34;batch&#34; to specify that that row should be included in the HVSRBatch object or
            a dictionary where they keys are column names and the values are the values to look for in each column name for inclusion in HVSRBatch object.
            If not specified, defaults to None and uses all rows in dataframe.

        df_as_read : {None, pd.DataFrame}
            Used in various sprit functions to allow original DataFrame used to create HVSRBatch object to be carried through.        
        &#34;&#34;&#34;

        # Just return it as-is if it&#39;s already Batch object
        if isinstance(batch_input, HVSRBatch):
            return batch_input
        
        self._batch_input = batch_input
        self.batch_input = self._batch_input
        
        self._batch_dict = self.batch_dict = {}

        self._input_df = df_as_read
        self.input_df = self._input_df
        
        self.batch = True
        
        if isinstance(batch_input, (list, tuple,)):
            # This is for a list/tuple with the following structure:
            # batch_input = [HVSRData, HVSRData, HVSRData]
            # or batch_input = [&#39;/file/path1.hvsr&#39;, &#39;/file/path2.hvsr&#39;]
            # Can also be mixed: [HVSRData, &#39;/file/path3/.hvsr&#39;]
            siteNo = 0
            zfilldigs = len(str(len(batch_input)))
            
            for hvdata in batch_input:
                if isinstance(hvdata, (dict, HVSRData)):
                    if hasattr(hvdata, &#39;site&#39;):
                        sitename = hvdata.site
                    elif hasattr(hvdata, &#39;Table_Report&#39;) and &#39;Site Name&#39; in hvdata.Table_Report.columns:
                        sitename = hvdata.Table_Report[&#39;Site Name&#39;][0]
                    else:
                        sitename = f&#34;HVSRSite{str(siteNo).zfill(zfilldigs)}&#34;
                        siteNo += 1
                    self.batch_dict[sitename] = hvdata
                elif pathlib.Path(hvdata).exists():
                    def _get_sitename(proposed_sitename, batch_dict):
                        # Get unique site name based on stem
                        j = 0
                        if proposed_sitename in batch_dict.keys():
                            # 100 is limit
                            for index in range(100):
                                if len(proposed_sitename.split(&#39;_&#39;)) &lt;= index:
                                    if proposed_sitename.split(&#39;_&#39;)[-1].isdigit():
                                        j = int(proposed_sitename.split(&#39;_&#39;)[-1]) + 1
                                        sitenameList = proposed_sitename.split(&#39;_&#39;)
                                        sitenameList[-1] = str(j)
                                        proposed_sitename = &#39;_&#39;.join(sitenameList)
                                        break
                                    else:
                                        proposed_sitename = proposed_sitename+&#39;_&#39;+str(j)
                                        break
                                    j += 1
                                else:
                                    proposed_sitename = &#39;_&#39;.join(proposed_sitename.split(&#39;_&#39;)[:index+1])
                        return proposed_sitename

                    if &#39;hvsr&#39; in pathlib.Path(hvdata).suffix:
                        sitename = pathlib.path(hvdata).stem
                        sitename = _get_sitename(sitename, batch_dict)

                        self.batch_dict[sitename] = hvdata
                    elif pathlib.Path(hvdata).suffix.upper()[1:] in OBSPY_FORMATS:
                        if verbose:
                            print(f&#34;Site specified for inclusion in HVSRBatch has not been processed. Processing. ({hvdata})&#34;)
                        sitename = pathlib.Path(hvdata).stem
                        sitename = _get_sitename(sitename, batch_dict)
                        self.batch_dict[sitename] = run(pathlib.Path(hvdata).as_posix())
                    else:
                        print(f&#34;Could not parse Batch input. Excluding from HVSRBatch object: {hvdata}&#34;)
        elif isinstance(batch_input, dict):
            # This is for a dictionary with the following structure:
            # batch_input = {&#34;SiteName1&#34;:HVSRData, &#34;Sitename2&#34;:HVSRData}
            self.batch_dict = batch_input
        elif isinstance(batch_input, HVSRData):
            # If iniitializing HVSRBatch with single HVSRData
            self.batch_dict[batch_input[&#39;site&#39;]] = batch_input
        elif pathlib.Path(batch_input).exists():
            # This is intended for filepaths
            if pathlib.Path(batch_input).is_dir():
                if batch_ext is not None:
                    batchfileglob = pathlib.Path(batch_input).glob(&#34;*.&#34;+batch_ext)
                    batchfiledict = {}
                    #if &#39;hvsr&#39; in batch_ext:
                    for hvfile in batchfileglob:
                        currhvfile = import_data(hvfile)
                        batchfiledict[currhvfile[&#39;site&#39;]] = currhvfile
                    self.batch_dict = self._batch_dict = batchfiledict
                else:
                    # Assume it is .hvsr file you wish to import
                    batchfileglob = []
                    batchfiledict = {}

                    batchfileglob = pathlib.Path(batch_input).glob(&#34;*&#34;)
                    for hvfile in batchfileglob:
                        if hvfile.as_posix().lower().endswith(&#39;hvsr&#39;):
                            currhvfile = import_data(hvfile.as_posix())
                            batchfiledict[currhvfile[&#39;site&#39;]] = currhvfile
                    self.batch_dict = self._batch_dict = batchfiledict           
            else:
                if &#39;.hvsr&#39; in pathlib.Path(batch_input).suffix:
                    # In this case, assume this is alreayd a batch file and import/return it
                    return import_data(batch_input)
                else:
                    # For reading in a csv and specifying column map
                    batch_df = pd.read_csv(batch_input)

                    # Convert columns to lowercase
                    batch_df.columns = [c.lower() for c in batch_df.columns]

                    # This is for if dictionary mapping is not specified
                    snList = [&#39;site&#39;, &#39;sitename&#39;, &#39;sites&#39;, &#39;sitenames&#39;, 
                                &#39;identifier&#39;, &#39;batch&#39;, &#39;profile&#39;, &#39;crosssection&#39;, &#39;group&#39;]
                    pathList = [&#39;hvsr_export_path&#39;, &#39;import_filepath&#39;, &#39;batch_input&#39;, &#39;filepath&#39;, &#39;input_data&#39;,
                                &#39;path&#39;, &#39;filepath&#39;, &#39;filename&#39;, &#39;file&#39;, &#39;hvsrdata&#39;, &#39;hvsr&#39;, &#39;data&#39;]

                    siteCol = batch_df.columns[0]
                    for sn in snList:
                        if sn in snList:
                            siteCol = sn
                            break

                    pathCol = batch_df.columns[1]
                    for pa in pathList:
                        if pa in pathList:
                            pathCol = pa
                            break

                    def _read_data_into_batch(batch_df_row, site_col, path_col):
                        if &#39;.hvsr&#39; in str(batch_df_row[path_col]):
                            dataObj = import_data(str(batch_df_row[path_col]))
                        elif pathlib.Path(batch_df_row[path_col]).suffix.upper()[1:] in OBSPY_FORMATS:
                            dataObj = run(pathlib.Path(batch_df_row[path_col]).as_posix())
                        else:
                            warnings.Warn(f&#34;Batch input specified as site {batch_df_row[site_col]} cannot be read, skipping: {batch_df_row[path_col]}&#34;)
                            dataObj = None
                        
                        return dataObj

                    if isinstance(batch_use, dict):
                        # Dictionary of {&#39;site&#39;:&#34;site_col&#34;, &#39;filepath&#39;:&#39;path_col&#39;, &#39;batch&#39;:values_in_batch_col_to_include}
                        if len(list(batch_use.keys())) != 3:
                            warnMsg = f&#34;batch_use dict should have three keys called &#39;site&#39;, &#39;filepath&#39;, and &#39;batch&#39; (not {len(list(batch_use.keys()))}: {list(batch_use.keys())}). \n\t&#39;batch&#39; may be changed to name of column you are using to specify inclusion in HVSRBatch object, or input DataFrame should have column called &#39;batch&#39;&#34;
                            warnings.Warn(warnMsg)

                        # Should be site and filepath, but just in case
                        for k in batch_use.keys():
                            if str(k).lower() in snList:
                                siteCol = batch_use[k]
                                siteKey = k

                            if str(k).lower() in pathList:
                                pathCol = batch_use[k]
                                pathKey = k

                            if str(k).lower() not in snList and str(k).lower() not in pathList:
                                includeMe = batch_use[k]
                                batchKey = k
    
                        # Get subset df with only rows that we want
                        #includeMe = batchCol#batch_use[batchCol]
                        if isinstance(includeMe, (list, tuple)):
                            sites_df = batch_df[batch_df[batchKey].isin(includeMe)]
                        elif isinstance(includeMe, dict):
                            sitesDFList = []
                            for batchCol, includeValue in includeMe.items():
                                sitesDFList.append(batch_df[batch_df[batchCol]==includeValue])
                            sites_df = pd.concat(sitesDFList, ignore_index=True)
                        else:
                            sites_df = batch_df[batch_df[batchKey]==includeMe]

                        # Import, process, or otherwise read data into batch object
                        for i, row in sites_df.iterrows():
                            dataObj = _read_data_into_batch(row, siteCol, pathCol)
                            if dataObj is not None:
                                self.batch_dict[str(row[siteCol])] = dataObj

                    elif isinstance(batch_use, (list, tuple)):
                        # This should be list/tuples of site names
                        sites_df = batch_df[batch_df[siteCol].isin(batch_use)]
                        for i, row in sites_df.iterrows():
                            dataObj = _read_data_into_batch(row, siteCol, pathCol)
                            if dataObj is not None:
                                self.batch_dict[str(row[siteCol])] = dataObj
                    
                    else:
                        # Use all rows (as possible)
                        print(f&#34;**NOTE**: All data specified will be read into batch object, from: {batch_input}&#34;)
                        for i, row in batch_df.iterrows():
                            dataObj = _read_data_into_batch(row, siteCol, pathCol)

                            if dataObj is not None:
                                self.batch_dict[str(row[siteCol])] = dataObj
        else:
            raise TypeError(f&#34;The batch_input parameter of the HVSRBatch class must be a dict of parameters, list or tuple of HVSRData obejcts, or an HVSRData object itself. {type(batch_input)}&#34;)


        self._batch_dict = self.batch_dict
        for sitename, hvsrdata in self.batch_dict.items():
            setattr(self, sitename, hvsrdata)
            self[sitename][&#39;batch&#39;] = True
        self.sites = list(self.batch_dict.keys())


    # METHODS
    def __to_json(self, filepath):
        &#34;&#34;&#34;Not yet implemented, but may allow import/export to json files in the future, rather than just .hvsr pickles

        Parameters
        ----------
        filepath : filepath object
            Location to save HVSRBatch object as json
        &#34;&#34;&#34;
        # open the file with the given filepath
        with open(filepath, &#39;w&#39;) as f:
            # dump the JSON string to the file
            json.dump(self, f, default=lambda o: o.__dict__, sort_keys=True, indent=4)


    def add(self, hvsr_data):
        &#34;&#34;&#34;Function to add HVSRData objects to existing HVSRBatch objects&#34;&#34;&#34;
        if isinstance(hvsr_data, (dict, HVSRData)):
            hvsr_data = [hvsr_data]

        if isinstance(hvsr_data, (list, tuple,)):
            siteNo = 0
            zfilldigs = len(str(len(hvsr_data)))

            for hvdata in hvsr_data:
                sitename = f&#34;HVSRSite{str(siteNo).zfill(zfilldigs)}&#34;

                if hasattr(hvdata, &#39;site&#39;):
                    sitename = hvdata.site
                elif hasattr(hvdata, &#39;Table_Report&#39;) and &#39;Site Name&#39; in hvdata.Table_Report.columns:
                    sitename = hvdata.Table_Report[&#39;Site Name&#39;][0]
                elif isinstance(hvdata, dict):
                    if &#39;site&#39; in hvdata.keys():
                        sitename = hvdata[&#39;site&#39;]

                self[sitename] = hvsr_data
        

    def append(self, hvsr_data):
        &#34;&#34;&#34;Alias of add()&#34;&#34;&#34;
        add(self, hvsr_data)
        

    def export(self, hvsr_export_path=True, ext=&#39;hvsr&#39;):
        &#34;&#34;&#34;Method to export HVSRData objects in HVSRBatch container to indivdual .hvsr pickle files.

        Parameters
        ----------
        hvsr_export_path : filepath, default=True
            Filepath to save file. Can be either directory (which will assign a filename based on the HVSRData attributes). By default True. If True, it will first try to save each file to the same directory as input_data, then if that does not work, to the current working directory, then to the user&#39;s home directory, by default True
        ext : str, optional
            The extension to use for the output, by default &#39;hvsr&#39;. This is still a pickle file that can be read with pickle.load(), but will have .hvsr extension.
        &#34;&#34;&#34;
        export_hvsr(hvsr_data=self, hvsr_export_path=hvsr_export_path, ext=ext)


    def keys(self):
        &#34;&#34;&#34;Method to return the &#34;keys&#34; of the HVSRBatch object. For HVSRBatch objects, these are the site names. Functions similar to dict.keys().

        Returns
        -------
        dict_keys
            A dict_keys object listing the site names of each of the HVSRData objects contained in the HVSRBatch object
        &#34;&#34;&#34;
        return self.batch_dict.keys()


    def items(self):
        &#34;&#34;&#34;Method to return both the site names and the HVSRData object as a set of dict_items tuples. Functions similar to dict.items().

        Returns
        -------
        _type_
            _description_
        &#34;&#34;&#34;
        return self.batch_dict.items()


    def copy(self, type=&#39;shallow&#39;):
        &#34;&#34;&#34;Make a copy of the HVSRBatch object. Uses python copy module.
        
        Parameters
        ----------
        type : str {&#39;shallow&#39;, &#39;deep&#39;}
            Based on input, creates either a shallow or deep copy of the HVSRBatch object. Shallow is equivalent of copy.copy(). Input of &#39;deep&#39; is equivalent of copy.deepcopy() (still experimental). Defaults to shallow.
    
        &#34;&#34;&#34;
        if type.lower()==&#39;deep&#39;:
            return HVSRBatch(copy.deepcopy(self._batch_dict), df_as_read=self._input_df)
        else:
            return HVSRBatch(copy.copy(self._batch_dict), df_as_read=self._input_df)


    #Method wrapper of sprit.plot_hvsr function
    def plot(self, **kwargs):
        &#34;&#34;&#34;Method to plot data, based on the sprit.plot_hvsr() function. 
        
        All the same kwargs and default values apply as plot_hvsr().
        For return_fig, returns it to the &#39;Plot_Report&#39; attribute of each HVSRData object

        Returns
        -------
        _type_
            _description_

        See Also
        --------
        plot_hvsr
        &#34;&#34;&#34;
        for sitename in self:
            if &#39;return_fig&#39; in kwargs.keys() and kwargs[&#39;return_fig&#39;]:
                self[sitename][&#39;Plot_Report&#39;] = plot_hvsr(self[sitename], **kwargs)
            else:
                plot_hvsr(self[sitename], **kwargs)

        return self
    
    def get_report(self, **kwargs):
        &#34;&#34;&#34;Method to get report from processed data, in print, graphical, or tabular format.

        Returns
        -------
        Variable
            May return nothing, pandas.Dataframe, or pyplot Figure, depending on input.

        See Also
        --------
        get_report
        &#34;&#34;&#34;
        if &#39;report_formats&#39; in kwargs.keys():
            if &#39;table&#39; == kwargs[&#39;report_formats&#39;]:
                for sitename in self:
                    rowList = []
                    rowList.append(get_report(self[sitename], **kwargs))
                return pd.concat(rowList, ignore_index=True)
            elif &#39;plot&#39; == kwargs[&#39;report_formats&#39;]:
                plotDict = {}
                for sitename in self:
                    if &#39;return_fig&#39; in kwargs.keys() and kwargs[&#39;return_fig&#39;]:
                        plotDict[sitename] = get_report(self[sitename], **kwargs)
                    else:
                        get_report(self[sitename], **kwargs)
                return plotDict
            
        #Only report_formats left is print, doesn&#39;t return anything, so doesn&#39;t matter if defalut or not
        for sitename in self:
            get_report(self[sitename], **kwargs)
        return

    def report(self, **kwargs):
        &#34;&#34;&#34;Wrapper of get_report()
        
        See Also
        --------
        get_report
        &#34;&#34;&#34;
        return self.get_report(**kwargs)

    def export_settings(self, site_name=None, export_settings_path=&#39;default&#39;, export_settings_type=&#39;all&#39;, include_location=False, verbose=True):
        &#34;&#34;&#34;Method to export settings from HVSRData object in HVSRBatch object. 
        
        Simply calls sprit.export_settings() from specified HVSRData object in the HVSRBatch object. 
        See sprit.export_settings() for more details.

        Parameters
        ----------
        site_name : str, default=None
            The name of the site whose settings should be exported. If None, will default to the first site, by default None.
        export_settings_path : str, optional
            Filepath to output file. If left as &#39;default&#39;, will save as the default value in the resources directory. If that is not possible, will save to home directory, by default &#39;default&#39;
        export_settings_type : str, {&#39;all&#39;, &#39;instrument&#39;, &#39;processing&#39;}, optional
            They type of settings to save, by default &#39;all&#39;
        include_location : bool, optional
            Whether to include the location information in the instrument settings, if that settings type is selected, by default False
        verbose : bool, optional
            Whether to print output (filepath and settings) to terminal, by default True
        
        
        See Also
        --------
        export_settings
        &#34;&#34;&#34;
        #If no site name selected, use first site
        if site_name is None:
            site_name = self.sites[0]
            
        export_settings(hvsr_data=self[site_name], 
                        export_settings_path=export_settings_path, export_settings_type=export_settings_type, include_location=include_location, verbose=verbose)

    def __iter__(self):
        return iter(self._batch_dict.keys())

    def __setitem__(self, key, value):
        setattr(self, key, value)

    def __getitem__(self, key):
        return getattr(self, key)</code></pre>
</details>
<div class="desc"><p>HVSRBatch is the data container used for batch processing.
It contains several HVSRData objects (one for each site).
These can be accessed using their site name,
either square brackets (HVSRBatchVariable["SiteName"]) or the dot (HVSRBatchVariable.SiteName) accessor.</p>
<p>The dot accessor may not work if there is a space in the site name.</p>
<p>All of the
functions in the sprit package are designed to perform the bulk of their operations iteratively
on the individual HVSRData objects contained in the HVSRBatch object, and do little with the HVSRBatch object itself,
besides using it determine which sites are contained within it.</p></div>
<h3>Methods</h3>
<dl>
<dt id="sprit.HVSRBatch.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, hvsr_data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, hvsr_data):
    &#34;&#34;&#34;Function to add HVSRData objects to existing HVSRBatch objects&#34;&#34;&#34;
    if isinstance(hvsr_data, (dict, HVSRData)):
        hvsr_data = [hvsr_data]

    if isinstance(hvsr_data, (list, tuple,)):
        siteNo = 0
        zfilldigs = len(str(len(hvsr_data)))

        for hvdata in hvsr_data:
            sitename = f&#34;HVSRSite{str(siteNo).zfill(zfilldigs)}&#34;

            if hasattr(hvdata, &#39;site&#39;):
                sitename = hvdata.site
            elif hasattr(hvdata, &#39;Table_Report&#39;) and &#39;Site Name&#39; in hvdata.Table_Report.columns:
                sitename = hvdata.Table_Report[&#39;Site Name&#39;][0]
            elif isinstance(hvdata, dict):
                if &#39;site&#39; in hvdata.keys():
                    sitename = hvdata[&#39;site&#39;]

            self[sitename] = hvsr_data</code></pre>
</details>
<div class="desc"><p>Function to add HVSRData objects to existing HVSRBatch objects</p></div>
</dd>
<dt id="sprit.HVSRBatch.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, hvsr_data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, hvsr_data):
    &#34;&#34;&#34;Alias of add()&#34;&#34;&#34;
    add(self, hvsr_data)</code></pre>
</details>
<div class="desc"><p>Alias of add()</p></div>
</dd>
<dt id="sprit.HVSRBatch.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, type='shallow')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, type=&#39;shallow&#39;):
    &#34;&#34;&#34;Make a copy of the HVSRBatch object. Uses python copy module.
    
    Parameters
    ----------
    type : str {&#39;shallow&#39;, &#39;deep&#39;}
        Based on input, creates either a shallow or deep copy of the HVSRBatch object. Shallow is equivalent of copy.copy(). Input of &#39;deep&#39; is equivalent of copy.deepcopy() (still experimental). Defaults to shallow.

    &#34;&#34;&#34;
    if type.lower()==&#39;deep&#39;:
        return HVSRBatch(copy.deepcopy(self._batch_dict), df_as_read=self._input_df)
    else:
        return HVSRBatch(copy.copy(self._batch_dict), df_as_read=self._input_df)</code></pre>
</details>
<div class="desc"><p>Make a copy of the HVSRBatch object. Uses python copy module.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code>str {'shallow', 'deep'}</code></dt>
<dd>Based on input, creates either a shallow or deep copy of the HVSRBatch object. Shallow is equivalent of copy.copy(). Input of 'deep' is equivalent of copy.deepcopy() (still experimental). Defaults to shallow.</dd>
</dl></div>
</dd>
<dt id="sprit.HVSRBatch.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, hvsr_export_path=True, ext='hvsr')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, hvsr_export_path=True, ext=&#39;hvsr&#39;):
    &#34;&#34;&#34;Method to export HVSRData objects in HVSRBatch container to indivdual .hvsr pickle files.

    Parameters
    ----------
    hvsr_export_path : filepath, default=True
        Filepath to save file. Can be either directory (which will assign a filename based on the HVSRData attributes). By default True. If True, it will first try to save each file to the same directory as input_data, then if that does not work, to the current working directory, then to the user&#39;s home directory, by default True
    ext : str, optional
        The extension to use for the output, by default &#39;hvsr&#39;. This is still a pickle file that can be read with pickle.load(), but will have .hvsr extension.
    &#34;&#34;&#34;
    export_hvsr(hvsr_data=self, hvsr_export_path=hvsr_export_path, ext=ext)</code></pre>
</details>
<div class="desc"><p>Method to export HVSRData objects in HVSRBatch container to indivdual .hvsr pickle files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_export_path</code></strong> :&ensp;<code>filepath</code>, default=<code>True</code></dt>
<dd>Filepath to save file. Can be either directory (which will assign a filename based on the HVSRData attributes). By default True. If True, it will first try to save each file to the same directory as input_data, then if that does not work, to the current working directory, then to the user's home directory, by default True</dd>
<dt><strong><code>ext</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The extension to use for the output, by default 'hvsr'. This is still a pickle file that can be read with pickle.load(), but will have .hvsr extension.</dd>
</dl></div>
</dd>
<dt id="sprit.HVSRBatch.export_settings"><code class="name flex">
<span>def <span class="ident">export_settings</span></span>(<span>self,<br>site_name=None,<br>export_settings_path='default',<br>export_settings_type='all',<br>include_location=False,<br>verbose=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_settings(self, site_name=None, export_settings_path=&#39;default&#39;, export_settings_type=&#39;all&#39;, include_location=False, verbose=True):
    &#34;&#34;&#34;Method to export settings from HVSRData object in HVSRBatch object. 
    
    Simply calls sprit.export_settings() from specified HVSRData object in the HVSRBatch object. 
    See sprit.export_settings() for more details.

    Parameters
    ----------
    site_name : str, default=None
        The name of the site whose settings should be exported. If None, will default to the first site, by default None.
    export_settings_path : str, optional
        Filepath to output file. If left as &#39;default&#39;, will save as the default value in the resources directory. If that is not possible, will save to home directory, by default &#39;default&#39;
    export_settings_type : str, {&#39;all&#39;, &#39;instrument&#39;, &#39;processing&#39;}, optional
        They type of settings to save, by default &#39;all&#39;
    include_location : bool, optional
        Whether to include the location information in the instrument settings, if that settings type is selected, by default False
    verbose : bool, optional
        Whether to print output (filepath and settings) to terminal, by default True
    
    
    See Also
    --------
    export_settings
    &#34;&#34;&#34;
    #If no site name selected, use first site
    if site_name is None:
        site_name = self.sites[0]
        
    export_settings(hvsr_data=self[site_name], 
                    export_settings_path=export_settings_path, export_settings_type=export_settings_type, include_location=include_location, verbose=verbose)</code></pre>
</details>
<div class="desc"><p>Method to export settings from HVSRData object in HVSRBatch object. </p>
<p>Simply calls sprit.export_settings() from specified HVSRData object in the HVSRBatch object.
See sprit.export_settings() for more details.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>site_name</code></strong> :&ensp;<code>str</code>, default=<code>None</code></dt>
<dd>The name of the site whose settings should be exported. If None, will default to the first site, by default None.</dd>
<dt><strong><code>export_settings_path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Filepath to output file. If left as 'default', will save as the default value in the resources directory. If that is not possible, will save to home directory, by default 'default'</dd>
<dt><strong><code>export_settings_type</code></strong> :&ensp;<code>str, {'all', 'instrument', 'processing'}</code>, optional</dt>
<dd>They type of settings to save, by default 'all'</dd>
<dt><strong><code>include_location</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to include the location information in the instrument settings, if that settings type is selected, by default False</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print output (filepath and settings) to terminal, by default True</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="sprit.export_settings" href="#sprit.export_settings">export_settings()</a></code></p></div>
</dd>
<dt id="sprit.HVSRBatch.get_report"><code class="name flex">
<span>def <span class="ident">get_report</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_report(self, **kwargs):
    &#34;&#34;&#34;Method to get report from processed data, in print, graphical, or tabular format.

    Returns
    -------
    Variable
        May return nothing, pandas.Dataframe, or pyplot Figure, depending on input.

    See Also
    --------
    get_report
    &#34;&#34;&#34;
    if &#39;report_formats&#39; in kwargs.keys():
        if &#39;table&#39; == kwargs[&#39;report_formats&#39;]:
            for sitename in self:
                rowList = []
                rowList.append(get_report(self[sitename], **kwargs))
            return pd.concat(rowList, ignore_index=True)
        elif &#39;plot&#39; == kwargs[&#39;report_formats&#39;]:
            plotDict = {}
            for sitename in self:
                if &#39;return_fig&#39; in kwargs.keys() and kwargs[&#39;return_fig&#39;]:
                    plotDict[sitename] = get_report(self[sitename], **kwargs)
                else:
                    get_report(self[sitename], **kwargs)
            return plotDict
        
    #Only report_formats left is print, doesn&#39;t return anything, so doesn&#39;t matter if defalut or not
    for sitename in self:
        get_report(self[sitename], **kwargs)
    return</code></pre>
</details>
<div class="desc"><p>Method to get report from processed data, in print, graphical, or tabular format.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Variable</code></dt>
<dd>May return nothing, pandas.Dataframe, or pyplot Figure, depending on input.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="sprit.get_report" href="#sprit.get_report">get_report()</a></code></p></div>
</dd>
<dt id="sprit.HVSRBatch.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self):
    &#34;&#34;&#34;Method to return both the site names and the HVSRData object as a set of dict_items tuples. Functions similar to dict.items().

    Returns
    -------
    _type_
        _description_
    &#34;&#34;&#34;
    return self.batch_dict.items()</code></pre>
</details>
<div class="desc"><p>Method to return both the site names and the HVSRData object as a set of dict_items tuples. Functions similar to dict.items().</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>_type_</code></dt>
<dd><em>description</em></dd>
</dl></div>
</dd>
<dt id="sprit.HVSRBatch.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    &#34;&#34;&#34;Method to return the &#34;keys&#34; of the HVSRBatch object. For HVSRBatch objects, these are the site names. Functions similar to dict.keys().

    Returns
    -------
    dict_keys
        A dict_keys object listing the site names of each of the HVSRData objects contained in the HVSRBatch object
    &#34;&#34;&#34;
    return self.batch_dict.keys()</code></pre>
</details>
<div class="desc"><p>Method to return the "keys" of the HVSRBatch object. For HVSRBatch objects, these are the site names. Functions similar to dict.keys().</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict_keys</code></dt>
<dd>A dict_keys object listing the site names of each of the HVSRData objects contained in the HVSRBatch object</dd>
</dl></div>
</dd>
<dt id="sprit.HVSRBatch.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, **kwargs):
    &#34;&#34;&#34;Method to plot data, based on the sprit.plot_hvsr() function. 
    
    All the same kwargs and default values apply as plot_hvsr().
    For return_fig, returns it to the &#39;Plot_Report&#39; attribute of each HVSRData object

    Returns
    -------
    _type_
        _description_

    See Also
    --------
    plot_hvsr
    &#34;&#34;&#34;
    for sitename in self:
        if &#39;return_fig&#39; in kwargs.keys() and kwargs[&#39;return_fig&#39;]:
            self[sitename][&#39;Plot_Report&#39;] = plot_hvsr(self[sitename], **kwargs)
        else:
            plot_hvsr(self[sitename], **kwargs)

    return self</code></pre>
</details>
<div class="desc"><p>Method to plot data, based on the sprit.plot_hvsr() function. </p>
<p>All the same kwargs and default values apply as plot_hvsr().
For return_fig, returns it to the 'Plot_Report' attribute of each HVSRData object</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>_type_</code></dt>
<dd><em>description</em></dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="sprit.plot_hvsr" href="#sprit.plot_hvsr">plot_hvsr()</a></code></p></div>
</dd>
<dt id="sprit.HVSRBatch.report"><code class="name flex">
<span>def <span class="ident">report</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report(self, **kwargs):
    &#34;&#34;&#34;Wrapper of get_report()
    
    See Also
    --------
    get_report
    &#34;&#34;&#34;
    return self.get_report(**kwargs)</code></pre>
</details>
<div class="desc"><p>Wrapper of get_report()</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="sprit.get_report" href="#sprit.get_report">get_report()</a></code></p></div>
</dd>
</dl>
</dd>
<dt id="sprit.HVSRData"><code class="flex name class">
<span>class <span class="ident">HVSRData</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HVSRData:
    &#34;&#34;&#34;HVSRData is the basic data class of the sprit package. 
    It contains all the processed data, input parameters, and reports.
    
    These attributes and objects can be accessed using square brackets or the dot accessor. For example, to access the site name, HVSRData[&#39;site&#39;] and HVSRData.site will both return the site name.
    
    Some of the methods that work on the HVSRData object (e.g., .plot() and .get_report()) are essentially wrappers for some of the main sprit package functions (sprit.plot_hvsr() and sprit.get_report(), respectively)
    &#34;&#34;&#34;
    @check_instance    
    def __init__(self, params):
        self.params = params
        self.batch = False
        #self.tsteps_used = []

        for key, value in params.items():
            setattr(self, key, value)
            if key == &#39;input_params&#39;:
                for k, v in params[key].items():
                    setattr(self, k, v)

        self.processing_status = {&#39;input_params_status&#39;: None,
                                  &#39;fetch_data_status&#39;: None,
                                  &#39;calculate_azimuths_status&#39;: None,
                                  &#39;remove_noise_status&#39;: None,
                                  &#39;generate_psds_status&#39;: None,
                                  &#39;process_hvsr_status&#39;: None,
                                  &#39;remove_outlier_curves_status&#39;: None,
                                  &#39;overall_status&#39;: False}


    def __setitem__(self, key, value):
        setattr(self, key, value)

    def __getitem__(self, key):
        return getattr(self, key)

    def __str__(self):
        attrsToUse = [&#39;project&#39;, &#39;site&#39;, 
            &#39;instrument&#39;, &#39;network&#39;, &#39;station&#39;, &#39;location&#39;, &#39;channels&#39;,
            &#39;acq_date&#39;, &#39;starttime&#39;, &#39;endtime&#39;,
            &#39;xcoord&#39;, &#39;ycoord&#39;, &#39;input_crs&#39;, &#39;elevation&#39;, &#39;elev_unit&#39;,
            ]

        if not all([atu in self.keys() for atu in attrsToUse]):
            return &#39;String representation cannot be generated. Object not instatianted correctly using sprit.input_params()&#39;

        def __get_ip_default(parameter):
            if parameter in inspect.signature(input_params).parameters:
                return inspect.signature(input_params).parameters[parameter].default
            elif parameter in params:
                return params[parameter]
            else:
                return parameter

        # Get title lines formatted
        if self.project == __get_ip_default(&#39;project&#39;):
            projStr = &#39;No project specified&#39;
        else:
            projStr = self.project

        hvsrIDStr = &#39;&#39;
        if hasattr(self, &#39;hvsr_id&#39;):
            hvsrIDStr = self.hvsr_id
        elif &#39;hvsr_id&#39; in params:
            hvsrIDStr = params[&#39;hvsr_id&#39;]

        titleInfoStr =f&#34;\nSpRIT HVSR DATA INFORMATION\n&#34;
        titleLen = len(titleInfoStr)
        bigLineBreak = &#34;—&#34;*titleLen+ &#39;\n&#39;
        titleInfoStr += bigLineBreak
        titleInfoStr += f&#34;Site Name: {self.site}\nProject: ({projStr})\n&#34;
        titleInfoStr = f&#34;{titleInfoStr}HVSRID (autogenerated): {hvsrIDStr}\n&#34;
        titleInfoStr += bigLineBreak
        
        # Acquisition instrument information
        instInfoStr = &#34;\n\nINSTRUMENT INFO\n&#34;
        instInfoStr += &#39;-&#39;*(len(instInfoStr)-3) + &#39;\n&#39;

        instStr = f&#34;Instrument in use: {self.instrument}&#34;
        if self.instrument == __get_ip_default(&#39;instrument&#39;):
            instStr = &#39;No instrument type specified&#39;

        netStr = self.network
        staStr = self.station
        locStr = self.location
        chaStr = self.channels
        if chaStr == __get_ip_default(&#39;channels&#39;):
            chaStr = f&#39;No channels specified (using {chaStr})&#39;

        acqInstStr = instInfoStr
        acqInstStr += f&#34;{instStr}&#34;
        acqInstStr += f&#34;\n\tInstrument ID: {netStr}.{staStr}.{locStr}&#34;
        acqInstStr += f&#34;\n\t\tChannels: {chaStr}&#34;

        # Acquisition site information
        xcoordINStr = self.xcoord_input
        xcoordStr = self.xcoord
        lonStr = self.longitude
        ycoordINstr = self.ycoord_input
        ycoordStr = self.ycoord
        latStr = self.latitude
        inCRSStr = self.input_crs
        outCRSStr = self.output_crs

        inputLocStr = f&#34;{xcoordINStr}, {ycoordINstr} (as input in {inCRSStr})\n&#34;
        
        transLocStr = &#39;&#39;
        if inCRSStr != outCRSStr:
            transLocStr = f&#34;{xcoordStr}, {ycoordstr} (transformed to output_crs: {outCRSStr})\n&#34;

        wgs84Str = f&#34;{lonStr:.5f}°, {latStr:.5f}° | Lon/Lat in WGS84 (EPSG:4326)&#34;

        siteLocInfoStr = &#34;\n\nSITE INFO\n&#34;
        siteLocInfoStr += &#39;-&#39;*(len(siteLocInfoStr)-3) + &#39;\n&#39;
        siteLocInfoStr += inputLocStr + transLocStr + wgs84Str

        # Acquistion time information
        acqTimeStr = &#34;\n\nACQUISITION TIME\n&#34;
        acqTimeStr += &#39;-&#39;*(len(acqTimeStr)-3) + &#39;\n&#39;

        aDateStr = self.acq_date
        sTimeStr = self.starttime
        eTimeStr = self.endtime
        if hasattr(self, &#39;stream&#39;):
            dataST = self.stream
            utcSTime = dataST[0].stats.starttime
            utcETime = dataST[0].stats.endtime
        else:
            utcSTime = self.starttime
            utcETime = self.endtime
        
        minDur = int(str((utcETime - utcSTime)//60).split(&#39;.&#39;)[0])
        secDur = float(round((((utcETime - utcSTime) / 60) - int(minDur)) * 60, 3))
        if secDur &gt;= 60:
            minDur += int(secDur//60)
            secDur = secDur - (secDur//60)*60

        acqDurStr = f&#39;Record duration: {minDur}:{secDur:06.3f} ({utcETime-utcSTime} seconds)&#39;
        if aDateStr == __get_ip_default(&#39;acq_date&#39;) and sTimeStr == __get_ip_default(&#39;starttime&#39;):
            acqTimeStr += &#39;No acquisition time specified.\n&#39;
        else:
            acqTimeStr += f&#34;Acquisition Date: {aDateStr}\n&#34;
            acqTimeStr += f&#34;\tStarted at: {sTimeStr}\n&#34;
            acqTimeStr += f&#34;\tEnded at  : {eTimeStr}\n&#34;
        acqTimeStr += acqDurStr


        # PEAK INFORMATION (IF CALCULATED)
        peakInfoStr = &#39;&#39;
        azimuth=&#39;HV&#39;
        if &#39;BestPeak&#39; in self.keys():
            curvTestsPassed = (self[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;WinLen&#39;] +
                                self[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;SigCycles&#39;]+
                                self[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;LowCurveStD&#39;])
            curvePass = curvTestsPassed &gt; 2
            
            #Peak Pass?
            peakTestsPassed = ( self[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;ProminenceLow&#39;] +
                        self[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;ProminenceHi&#39;]+
                        self[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;AmpClarity&#39;]+
                        self[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;FreqStability&#39;]+
                        self[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;LowStDev_Freq&#39;]+
                        self[&#39;BestPeak&#39;][azimuth][&#39;PassList&#39;][&#39;LowStDev_Amp&#39;])
            peakPass = peakTestsPassed &gt;= 5

            peakInfoStr = &#34;\nCALCULATED F₀\n&#34;
            peakInfoStr += &#34;-&#34;*(len(peakInfoStr) - 3) + &#39;\n&#39;
            peakInfoStr += &#39;{0:.3f} Hz ± {1:.4f} Hz&#39;.format(self[&#39;BestPeak&#39;][azimuth][&#39;f0&#39;], float(self[&#34;BestPeak&#34;][azimuth][&#39;Sf&#39;]))
            if curvePass and peakPass:
                peakInfoStr += &#39;\n\t  {} Peak at {} Hz passed SESAME quality tests! :D&#39;.format(sprit_utils._check_mark(), round(self[&#39;BestPeak&#39;][azimuth][&#39;f0&#39;],3))
            else:
                peakInfoStr += &#39;\n\t  {} Peak at {} Hz did NOT pass SESAME quality tests :(&#39;.format(sprit_utils._x_mark(), round(self[&#39;BestPeak&#39;][azimuth][&#39;f0&#39;],3))
        else:
            peakInfoStr = &#39;F₀ not Calculated&#39;

        printList = [
                    titleInfoStr,
                    peakInfoStr,
                    acqInstStr,
                    siteLocInfoStr,
                    acqTimeStr
                    ]

        strRep = &#39;&#39;
        for ps in printList:
            strRep += ps
        
        return strRep

        #try:
            # Check if running in IPython environment
        #    from IPython.display import display, HTML
        #    return f&#34;&lt;b&gt;Person Information:&lt;/b&gt;&lt;br&gt;Name: {self.name}&lt;br&gt;Age: {self.age}&#34;
        #except ImportError:
            # Fallback for terminal/console
        #    return f&#34;Person Information:\nName: {self.name}\nAge: {self.age}&#34;

    def __repr__(self):
        return self.__str__()

    # METHODS (many reflect dictionary methods)    
    def to_json(self, json_filepath=None, export_json=True, return_json=False, **kwargs):
        &#34;&#34;&#34;Not yet supported, will export HVSRData object to json&#34;&#34;&#34;

        class_keys_to_convert = (datetime.date, obspy.UTCDateTime, 
                             datetime.time, CRS, obspy.Inventory)

        def iterative_json_parser(input_attrib=self, level=0):
            outValue = input_attrib
            
            if isinstance(input_attrib, dict):  # simplified condition for demo
            # if isinstance(input_attrib, (dict, sprit.HVSRData)):  # use this line instead
                outValue = {}
                level += 1
                for i, (key, value) in enumerate(input_attrib.items()):
                    outKey = key
                    print(level, &#34;&#34;.join([&#39;  &#39;]*level), outKey)
                    if not isinstance(outKey, (str, int, float, bool, type(None))):
                        outKey = str(outKey)
                    
                    # Recursively process the value
                    processed_value = iterative_json_parser(value, level)
                    
                    # Apply string conversion if needed
                    if isinstance(processed_value, class_keys_to_convert):
                        processed_value = str(processed_value)
                    
                    outValue[outKey] = processed_value
                
                return outValue
            
            elif isinstance(input_attrib, list):
                outValue = []
                for item in input_attrib:
                    if isinstance(item, np.ndarray):
                        outValue.append(item.tolist())
                    else:
                        # Recursively process list items
                        outValue.append(iterative_json_parser(item, level))
                return outValue
            
            elif isinstance(input_attrib, np.ndarray):
                outValue = input_attrib.tolist()
                return outValue
            
            elif isinstance(input_attrib, pd.DataFrame):
                # Convert DataFrame to dict, but then recursively process it
                dict_value = input_attrib.to_dict()
                return iterative_json_parser(dict_value, level)
            
            elif isinstance(input_attrib, class_keys_to_convert):
                return str(input_attrib)
            
            else:
                return input_attrib

        sKeys = True
        if &#39;sort_keys&#39; in kwargs:
            sKeys = kwargs[&#39;sort_keys&#39;]
            del kwargs[&#39;sort_keys&#39;]

        indent = 4
        if &#39;indent&#39; in kwargs:
            indent = kwargs[&#39;indent&#39;]
            del kwargs[&#39;indent&#39;]

        if export_json and json_filepath is not None:
            with open(json_filepath, &#39;w&#39;) as f:
                # dump the JSON string to the file
                json.dump(self, fp=f, default=iterative_json_parser, 
                        sort_keys=True, indent=indent, **kwargs)

        if return_json or json_filepath is None:
            return json.dumps(self, default=iterative_json_parser,
                              sort_keys=True, indent=indent, **kwargs)

    def export(self, hvsr_export_path=None, ext=&#39;hvsr&#39;):
        &#34;&#34;&#34;Method to export HVSRData objects to .hvsr pickle files.

        Parameters
        ----------
        hvsr_export_path : filepath, default=True
            Filepath to save file. Can be either directory (which will assign a filename based on the HVSRData attributes). 
            By default True. 
            If True, it will first try to save each file to the same directory as input_data, then if that does not work, to the current working directory, then to the user&#39;s home directory, by default True
        ext : str, optional
            The extension to use for the output, by default &#39;hvsr&#39;. This is still a pickle file that can be read with pickle.load(), but will have .hvsr extension.
        
        See Also
        --------
        export_hvsr
        
        &#34;&#34;&#34;
        export_hvsr(hvsr_data=self, hvsr_export_path=hvsr_export_path, ext=ext)

    def copy(self, copy_type=&#39;shallow&#39;):
        &#34;&#34;&#34;Make a copy of the HVSRData object. Uses python copy module.
        
        Parameters
        ----------
        copy_type : str {&#39;shallow&#39;, &#39;deep&#39;}
            Based on input, creates either a shallow or deep copy of the HVSRData object. 
            Shallow is equivalent of copy.copy(). 
            Input of copy_type=&#39;deep&#39; is equivalent of copy.deepcopy() (still experimental). 
            Defaults to shallow.
    
        &#34;&#34;&#34;
        if copy_type.lower() == &#39;deep&#39;:
            return copy.deepcopy(self)
        else:
            return HVSRData(copy.copy(self.params))

    def export_settings(self, export_settings_path=&#39;default&#39;, export_settings_type=&#39;all&#39;, include_location=False, verbose=True):
        &#34;&#34;&#34;Method to export settings from HVSRData object. Simply calls sprit.export_settings() from the HVSRData object. See sprit.export_settings() for more details.

        Parameters
        ----------
        export_settings_path : str, optional
            Filepath to output file. If left as &#39;default&#39;, will save as the default value in the resources directory. If that is not possible, will save to home directory, by default &#39;default&#39;
        export_settings_type : str, {&#39;all&#39;, &#39;instrument&#39;, &#39;processing&#39;}, optional
            They type of settings to save, by default &#39;all&#39;
        include_location : bool, optional
            Whether to include the location information in the instrument settings, if that settings type is selected, by default False
        verbose : bool, optional
            Whether to print output (filepath and settings) to terminal, by default True
        &#34;&#34;&#34;
        export_settings(hvsr_data=self, 
                        export_settings_path=export_settings_path, export_settings_type=export_settings_type, include_location=include_location, verbose=verbose)

    def get_report(self, **kwargs):
        &#34;&#34;&#34;Method to get report from processed data, in print, graphical, or tabular format.

        Returns
        -------
        Variable
            May return nothing, pandas.Dataframe, or pyplot Figure, depending on input.

        See Also
        --------
        get_report
        &#34;&#34;&#34;
        report_return = get_report(hvsr_results=self, **kwargs)
        return report_return

    def items(self):
        &#34;&#34;&#34;Method to return the &#34;items&#34; of the HVSRData object. For HVSRData objects, this is a dict_items object with the keys and values in tuples. Functions similar to dict.items().

        Returns
        -------
        dict_items
            A dict_items object of the HVSRData objects attributes, parameters, etc.
        &#34;&#34;&#34;                
        return self.params.items()

    def keys(self):
        &#34;&#34;&#34;Method to return the &#34;keys&#34; of the HVSRData object. For HVSRData objects, these are the attributes and parameters of the object. Functions similar to dict.keys().

        Returns
        -------
        dict_keys
            A dict_keys object of the HVSRData objects attributes, parameters, etc.
        &#34;&#34;&#34;        
        keyList = []
        for k in dir(self):
            if not k.startswith(&#39;_&#39;):
                keyList.append(k)
        return keyList   
        
    def plot(self, **kwargs):
        &#34;&#34;&#34;Method to plot data, wrapper of sprit.plot_hvsr()

        Returns
        -------
        matplotlib.Figure, matplotlib.Axis (if return_fig=True)

        See Also
        --------
        plot_hvsr
        plot_azimuth
        &#34;&#34;&#34;
        if &#39;close_figs&#39; not in kwargs.keys():
            kwargs[&#39;close_figs&#39;]=True
        plot_return = plot_hvsr(self, **kwargs)
        plt.show()
        return plot_return

    def report(self, **kwargs):
        &#34;&#34;&#34;Wrapper of get_report()
        
        See Also
        --------
        get_report
        &#34;&#34;&#34;
        report_return = get_report(hvsr_results=self, **kwargs)
        return report_return
    
    def select(self, **kwargs):
        &#34;&#34;&#34;Wrapper for obspy select method on &#39;stream&#39; attribute of HVSRData object&#34;&#34;&#34;

        if hasattr(self, &#39;stream&#39;):
            stream = self[&#39;stream&#39;].select(**kwargs)
            return stream

        else:
            warnings.Warn(&#34;HVSRData.select() method applied, but &#39;stream&#39; attribute (obspy.Stream object) not found&#34;)

    # ATTRIBUTES
    @property
    def params(self):
        &#34;&#34;&#34;Dictionary containing the parameters used to process the data

        Returns
        -------
        dict
            Dictionary containing the process parameters
        &#34;&#34;&#34;
        return self._params

    @params.setter
    def params(self, value):
        if not (isinstance(value, dict)):
            raise ValueError(&#34;params must be a dict type, currently passing {} type.&#34;.format(type(value)))
        self._params = value
    
    # batch
    @property
    def batch(self):
        &#34;&#34;&#34;Whether this HVSRData object is part of an HVSRBatch object. This is used throughout the code to help direct the object into the proper processing pipeline.

        Returns
        -------
        bool
            True if HVSRData object is part of HVSRBatch object, otherwise, False
        &#34;&#34;&#34;
        return self._batch

    @batch.setter
    def batch(self, value):
        if value == 0:
            value = False
        elif value == 1:
            value = True
        else:
            value = None
        if not isinstance(value, bool):
            raise ValueError(&#34;batch must be boolean type&#34;)
        self._batch = value

    #PPSD object from obspy (static)
    @property
    def ppsds_obspy(self):
        &#34;&#34;&#34;The original ppsd information from the obspy.signal.spectral_estimation.PPSD(), so as to keep original if copy is manipulated/changed.&#34;&#34;&#34;        
        return self._ppsds_obspy

    @ppsds_obspy.setter
    def ppsds_obspy(self, value):
        &#34;&#34;&#34;Checks whether the ppsd_obspy is of the proper type before saving as attribute&#34;&#34;&#34;
        if not isinstance(value, obspy.signal.spectral_estimation.PPSD):
            if not isinstance(value, dict):
                raise ValueError(&#34;ppsds_obspy must be obspy.PPSD or dict with osbpy.PPSDs&#34;)
            else:
                for key in value.keys():
                    if not isinstance(value[key], obspy.signal.spectral_estimation.PPSD):
                        raise ValueError(&#34;ppsds_obspy must be obspy.PPSD or dict with osbpy.PPSDs&#34;)
        self._ppsds_obspy=value
                        
    #PPSD dict, copied from obspy ppsds (dynamic)
    @property
    def ppsds(self):
        &#34;&#34;&#34;Dictionary copy of the class object obspy.signal.spectral_estimation.PPSD(). The dictionary copy allows manipulation of the data in PPSD, whereas that data cannot be easily manipulated in the original Obspy object.

        Returns
        -------
        dict
            Dictionary copy of the PPSD information from generate_psds()
        &#34;&#34;&#34;
        return self._ppsds

    @ppsds.setter
    def ppsds(self, value):
        if not isinstance(value, dict):
            raise ValueError(&#34;ppsds dict with infomration from osbpy.PPSD (created by sprit.generate_psds())&#34;)                  
        self._ppsds=value</code></pre>
</details>
<div class="desc"><p>HVSRData is the basic data class of the sprit package.
It contains all the processed data, input parameters, and reports.</p>
<p>These attributes and objects can be accessed using square brackets or the dot accessor. For example, to access the site name, HVSRData['site'] and HVSRData.site will both return the site name.</p>
<p>Some of the methods that work on the HVSRData object (e.g., .plot() and .get_report()) are essentially wrappers for some of the main sprit package functions (sprit.plot_hvsr() and sprit.get_report(), respectively)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="sprit.HVSRData.batch"><code class="name">prop <span class="ident">batch</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def batch(self):
    &#34;&#34;&#34;Whether this HVSRData object is part of an HVSRBatch object. This is used throughout the code to help direct the object into the proper processing pipeline.

    Returns
    -------
    bool
        True if HVSRData object is part of HVSRBatch object, otherwise, False
    &#34;&#34;&#34;
    return self._batch</code></pre>
</details>
<div class="desc"><p>Whether this HVSRData object is part of an HVSRBatch object. This is used throughout the code to help direct the object into the proper processing pipeline.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if HVSRData object is part of HVSRBatch object, otherwise, False</dd>
</dl></div>
</dd>
<dt id="sprit.HVSRData.params"><code class="name">prop <span class="ident">params</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def params(self):
    &#34;&#34;&#34;Dictionary containing the parameters used to process the data

    Returns
    -------
    dict
        Dictionary containing the process parameters
    &#34;&#34;&#34;
    return self._params</code></pre>
</details>
<div class="desc"><p>Dictionary containing the parameters used to process the data</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary containing the process parameters</dd>
</dl></div>
</dd>
<dt id="sprit.HVSRData.ppsds"><code class="name">prop <span class="ident">ppsds</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ppsds(self):
    &#34;&#34;&#34;Dictionary copy of the class object obspy.signal.spectral_estimation.PPSD(). The dictionary copy allows manipulation of the data in PPSD, whereas that data cannot be easily manipulated in the original Obspy object.

    Returns
    -------
    dict
        Dictionary copy of the PPSD information from generate_psds()
    &#34;&#34;&#34;
    return self._ppsds</code></pre>
</details>
<div class="desc"><p>Dictionary copy of the class object obspy.signal.spectral_estimation.PPSD(). The dictionary copy allows manipulation of the data in PPSD, whereas that data cannot be easily manipulated in the original Obspy object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary copy of the PPSD information from generate_psds()</dd>
</dl></div>
</dd>
<dt id="sprit.HVSRData.ppsds_obspy"><code class="name">prop <span class="ident">ppsds_obspy</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ppsds_obspy(self):
    &#34;&#34;&#34;The original ppsd information from the obspy.signal.spectral_estimation.PPSD(), so as to keep original if copy is manipulated/changed.&#34;&#34;&#34;        
    return self._ppsds_obspy</code></pre>
</details>
<div class="desc"><p>The original ppsd information from the obspy.signal.spectral_estimation.PPSD(), so as to keep original if copy is manipulated/changed.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sprit.HVSRData.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, copy_type='shallow')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, copy_type=&#39;shallow&#39;):
    &#34;&#34;&#34;Make a copy of the HVSRData object. Uses python copy module.
    
    Parameters
    ----------
    copy_type : str {&#39;shallow&#39;, &#39;deep&#39;}
        Based on input, creates either a shallow or deep copy of the HVSRData object. 
        Shallow is equivalent of copy.copy(). 
        Input of copy_type=&#39;deep&#39; is equivalent of copy.deepcopy() (still experimental). 
        Defaults to shallow.

    &#34;&#34;&#34;
    if copy_type.lower() == &#39;deep&#39;:
        return copy.deepcopy(self)
    else:
        return HVSRData(copy.copy(self.params))</code></pre>
</details>
<div class="desc"><p>Make a copy of the HVSRData object. Uses python copy module.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>copy_type</code></strong> :&ensp;<code>str {'shallow', 'deep'}</code></dt>
<dd>Based on input, creates either a shallow or deep copy of the HVSRData object.
Shallow is equivalent of copy.copy().
Input of copy_type='deep' is equivalent of copy.deepcopy() (still experimental).
Defaults to shallow.</dd>
</dl></div>
</dd>
<dt id="sprit.HVSRData.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, hvsr_export_path=None, ext='hvsr')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, hvsr_export_path=None, ext=&#39;hvsr&#39;):
    &#34;&#34;&#34;Method to export HVSRData objects to .hvsr pickle files.

    Parameters
    ----------
    hvsr_export_path : filepath, default=True
        Filepath to save file. Can be either directory (which will assign a filename based on the HVSRData attributes). 
        By default True. 
        If True, it will first try to save each file to the same directory as input_data, then if that does not work, to the current working directory, then to the user&#39;s home directory, by default True
    ext : str, optional
        The extension to use for the output, by default &#39;hvsr&#39;. This is still a pickle file that can be read with pickle.load(), but will have .hvsr extension.
    
    See Also
    --------
    export_hvsr
    
    &#34;&#34;&#34;
    export_hvsr(hvsr_data=self, hvsr_export_path=hvsr_export_path, ext=ext)</code></pre>
</details>
<div class="desc"><p>Method to export HVSRData objects to .hvsr pickle files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_export_path</code></strong> :&ensp;<code>filepath</code>, default=<code>True</code></dt>
<dd>Filepath to save file. Can be either directory (which will assign a filename based on the HVSRData attributes).
By default True.
If True, it will first try to save each file to the same directory as input_data, then if that does not work, to the current working directory, then to the user's home directory, by default True</dd>
<dt><strong><code>ext</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The extension to use for the output, by default 'hvsr'. This is still a pickle file that can be read with pickle.load(), but will have .hvsr extension.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="sprit.export_hvsr" href="#sprit.export_hvsr">export_hvsr()</a></code></p></div>
</dd>
<dt id="sprit.HVSRData.export_settings"><code class="name flex">
<span>def <span class="ident">export_settings</span></span>(<span>self,<br>export_settings_path='default',<br>export_settings_type='all',<br>include_location=False,<br>verbose=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_settings(self, export_settings_path=&#39;default&#39;, export_settings_type=&#39;all&#39;, include_location=False, verbose=True):
    &#34;&#34;&#34;Method to export settings from HVSRData object. Simply calls sprit.export_settings() from the HVSRData object. See sprit.export_settings() for more details.

    Parameters
    ----------
    export_settings_path : str, optional
        Filepath to output file. If left as &#39;default&#39;, will save as the default value in the resources directory. If that is not possible, will save to home directory, by default &#39;default&#39;
    export_settings_type : str, {&#39;all&#39;, &#39;instrument&#39;, &#39;processing&#39;}, optional
        They type of settings to save, by default &#39;all&#39;
    include_location : bool, optional
        Whether to include the location information in the instrument settings, if that settings type is selected, by default False
    verbose : bool, optional
        Whether to print output (filepath and settings) to terminal, by default True
    &#34;&#34;&#34;
    export_settings(hvsr_data=self, 
                    export_settings_path=export_settings_path, export_settings_type=export_settings_type, include_location=include_location, verbose=verbose)</code></pre>
</details>
<div class="desc"><p>Method to export settings from HVSRData object. Simply calls sprit.export_settings() from the HVSRData object. See sprit.export_settings() for more details.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>export_settings_path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Filepath to output file. If left as 'default', will save as the default value in the resources directory. If that is not possible, will save to home directory, by default 'default'</dd>
<dt><strong><code>export_settings_type</code></strong> :&ensp;<code>str, {'all', 'instrument', 'processing'}</code>, optional</dt>
<dd>They type of settings to save, by default 'all'</dd>
<dt><strong><code>include_location</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to include the location information in the instrument settings, if that settings type is selected, by default False</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print output (filepath and settings) to terminal, by default True</dd>
</dl></div>
</dd>
<dt id="sprit.HVSRData.get_report"><code class="name flex">
<span>def <span class="ident">get_report</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_report(self, **kwargs):
    &#34;&#34;&#34;Method to get report from processed data, in print, graphical, or tabular format.

    Returns
    -------
    Variable
        May return nothing, pandas.Dataframe, or pyplot Figure, depending on input.

    See Also
    --------
    get_report
    &#34;&#34;&#34;
    report_return = get_report(hvsr_results=self, **kwargs)
    return report_return</code></pre>
</details>
<div class="desc"><p>Method to get report from processed data, in print, graphical, or tabular format.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Variable</code></dt>
<dd>May return nothing, pandas.Dataframe, or pyplot Figure, depending on input.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="sprit.get_report" href="#sprit.get_report">get_report()</a></code></p></div>
</dd>
<dt id="sprit.HVSRData.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self):
    &#34;&#34;&#34;Method to return the &#34;items&#34; of the HVSRData object. For HVSRData objects, this is a dict_items object with the keys and values in tuples. Functions similar to dict.items().

    Returns
    -------
    dict_items
        A dict_items object of the HVSRData objects attributes, parameters, etc.
    &#34;&#34;&#34;                
    return self.params.items()</code></pre>
</details>
<div class="desc"><p>Method to return the "items" of the HVSRData object. For HVSRData objects, this is a dict_items object with the keys and values in tuples. Functions similar to dict.items().</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict_items</code></dt>
<dd>A dict_items object of the HVSRData objects attributes, parameters, etc.</dd>
</dl></div>
</dd>
<dt id="sprit.HVSRData.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    &#34;&#34;&#34;Method to return the &#34;keys&#34; of the HVSRData object. For HVSRData objects, these are the attributes and parameters of the object. Functions similar to dict.keys().

    Returns
    -------
    dict_keys
        A dict_keys object of the HVSRData objects attributes, parameters, etc.
    &#34;&#34;&#34;        
    keyList = []
    for k in dir(self):
        if not k.startswith(&#39;_&#39;):
            keyList.append(k)
    return keyList   </code></pre>
</details>
<div class="desc"><p>Method to return the "keys" of the HVSRData object. For HVSRData objects, these are the attributes and parameters of the object. Functions similar to dict.keys().</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict_keys</code></dt>
<dd>A dict_keys object of the HVSRData objects attributes, parameters, etc.</dd>
</dl></div>
</dd>
<dt id="sprit.HVSRData.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, **kwargs):
    &#34;&#34;&#34;Method to plot data, wrapper of sprit.plot_hvsr()

    Returns
    -------
    matplotlib.Figure, matplotlib.Axis (if return_fig=True)

    See Also
    --------
    plot_hvsr
    plot_azimuth
    &#34;&#34;&#34;
    if &#39;close_figs&#39; not in kwargs.keys():
        kwargs[&#39;close_figs&#39;]=True
    plot_return = plot_hvsr(self, **kwargs)
    plt.show()
    return plot_return</code></pre>
</details>
<div class="desc"><p>Method to plot data, wrapper of sprit.plot_hvsr()</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>matplotlib.Figure, matplotlib.Axis (if return_fig=True)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="sprit.plot_hvsr" href="#sprit.plot_hvsr">plot_hvsr()</a></code>
<code><a title="sprit.plot_azimuth" href="#sprit.plot_azimuth">plot_azimuth()</a></code></p></div>
</dd>
<dt id="sprit.HVSRData.report"><code class="name flex">
<span>def <span class="ident">report</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report(self, **kwargs):
    &#34;&#34;&#34;Wrapper of get_report()
    
    See Also
    --------
    get_report
    &#34;&#34;&#34;
    report_return = get_report(hvsr_results=self, **kwargs)
    return report_return</code></pre>
</details>
<div class="desc"><p>Wrapper of get_report()</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="sprit.get_report" href="#sprit.get_report">get_report()</a></code></p></div>
</dd>
<dt id="sprit.HVSRData.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(self, **kwargs):
    &#34;&#34;&#34;Wrapper for obspy select method on &#39;stream&#39; attribute of HVSRData object&#34;&#34;&#34;

    if hasattr(self, &#39;stream&#39;):
        stream = self[&#39;stream&#39;].select(**kwargs)
        return stream

    else:
        warnings.Warn(&#34;HVSRData.select() method applied, but &#39;stream&#39; attribute (obspy.Stream object) not found&#34;)</code></pre>
</details>
<div class="desc"><p>Wrapper for obspy select method on 'stream' attribute of HVSRData object</p></div>
</dd>
<dt id="sprit.HVSRData.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self, json_filepath=None, export_json=True, return_json=False, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self, json_filepath=None, export_json=True, return_json=False, **kwargs):
    &#34;&#34;&#34;Not yet supported, will export HVSRData object to json&#34;&#34;&#34;

    class_keys_to_convert = (datetime.date, obspy.UTCDateTime, 
                         datetime.time, CRS, obspy.Inventory)

    def iterative_json_parser(input_attrib=self, level=0):
        outValue = input_attrib
        
        if isinstance(input_attrib, dict):  # simplified condition for demo
        # if isinstance(input_attrib, (dict, sprit.HVSRData)):  # use this line instead
            outValue = {}
            level += 1
            for i, (key, value) in enumerate(input_attrib.items()):
                outKey = key
                print(level, &#34;&#34;.join([&#39;  &#39;]*level), outKey)
                if not isinstance(outKey, (str, int, float, bool, type(None))):
                    outKey = str(outKey)
                
                # Recursively process the value
                processed_value = iterative_json_parser(value, level)
                
                # Apply string conversion if needed
                if isinstance(processed_value, class_keys_to_convert):
                    processed_value = str(processed_value)
                
                outValue[outKey] = processed_value
            
            return outValue
        
        elif isinstance(input_attrib, list):
            outValue = []
            for item in input_attrib:
                if isinstance(item, np.ndarray):
                    outValue.append(item.tolist())
                else:
                    # Recursively process list items
                    outValue.append(iterative_json_parser(item, level))
            return outValue
        
        elif isinstance(input_attrib, np.ndarray):
            outValue = input_attrib.tolist()
            return outValue
        
        elif isinstance(input_attrib, pd.DataFrame):
            # Convert DataFrame to dict, but then recursively process it
            dict_value = input_attrib.to_dict()
            return iterative_json_parser(dict_value, level)
        
        elif isinstance(input_attrib, class_keys_to_convert):
            return str(input_attrib)
        
        else:
            return input_attrib

    sKeys = True
    if &#39;sort_keys&#39; in kwargs:
        sKeys = kwargs[&#39;sort_keys&#39;]
        del kwargs[&#39;sort_keys&#39;]

    indent = 4
    if &#39;indent&#39; in kwargs:
        indent = kwargs[&#39;indent&#39;]
        del kwargs[&#39;indent&#39;]

    if export_json and json_filepath is not None:
        with open(json_filepath, &#39;w&#39;) as f:
            # dump the JSON string to the file
            json.dump(self, fp=f, default=iterative_json_parser, 
                    sort_keys=True, indent=indent, **kwargs)

    if return_json or json_filepath is None:
        return json.dumps(self, default=iterative_json_parser,
                          sort_keys=True, indent=indent, **kwargs)</code></pre>
</details>
<div class="desc"><p>Not yet supported, will export HVSRData object to json</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="sprit.sprit_calibration" href="sprit_calibration.html">sprit.sprit_calibration</a></code></li>
<li><code><a title="sprit.sprit_cli" href="sprit_cli.html">sprit.sprit_cli</a></code></li>
<li><code><a title="sprit.sprit_hvsr" href="sprit_hvsr.html">sprit.sprit_hvsr</a></code></li>
<li><code><a title="sprit.sprit_jupyter_UI" href="sprit_jupyter_UI.html">sprit.sprit_jupyter_UI</a></code></li>
<li><code><a title="sprit.sprit_plot" href="sprit_plot.html">sprit.sprit_plot</a></code></li>
<li><code><a title="sprit.sprit_streamlit_ui" href="sprit_streamlit_ui.html">sprit.sprit_streamlit_ui</a></code></li>
<li><code><a title="sprit.sprit_utils" href="sprit_utils.html">sprit.sprit_utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sprit.batch_data_read" href="#sprit.batch_data_read">batch_data_read</a></code></li>
<li><code><a title="sprit.calculate_azimuth" href="#sprit.calculate_azimuth">calculate_azimuth</a></code></li>
<li><code><a title="sprit.calculate_depth" href="#sprit.calculate_depth">calculate_depth</a></code></li>
<li><code><a title="sprit.calibrate" href="#sprit.calibrate">calibrate</a></code></li>
<li><code><a title="sprit.check_peaks" href="#sprit.check_peaks">check_peaks</a></code></li>
<li><code><a title="sprit.create_jupyter_ui" href="#sprit.create_jupyter_ui">create_jupyter_ui</a></code></li>
<li><code><a title="sprit.export_data" href="#sprit.export_data">export_data</a></code></li>
<li><code><a title="sprit.export_hvsr" href="#sprit.export_hvsr">export_hvsr</a></code></li>
<li><code><a title="sprit.export_report" href="#sprit.export_report">export_report</a></code></li>
<li><code><a title="sprit.export_settings" href="#sprit.export_settings">export_settings</a></code></li>
<li><code><a title="sprit.fetch_data" href="#sprit.fetch_data">fetch_data</a></code></li>
<li><code><a title="sprit.generate_psds" href="#sprit.generate_psds">generate_psds</a></code></li>
<li><code><a title="sprit.get_metadata" href="#sprit.get_metadata">get_metadata</a></code></li>
<li><code><a title="sprit.get_report" href="#sprit.get_report">get_report</a></code></li>
<li><code><a title="sprit.gui" href="#sprit.gui">gui</a></code></li>
<li><code><a title="sprit.import_data" href="#sprit.import_data">import_data</a></code></li>
<li><code><a title="sprit.import_settings" href="#sprit.import_settings">import_settings</a></code></li>
<li><code><a title="sprit.input_params" href="#sprit.input_params">input_params</a></code></li>
<li><code><a title="sprit.parse_plot_string" href="#sprit.parse_plot_string">parse_plot_string</a></code></li>
<li><code><a title="sprit.plot_azimuth" href="#sprit.plot_azimuth">plot_azimuth</a></code></li>
<li><code><a title="sprit.plot_cross_section" href="#sprit.plot_cross_section">plot_cross_section</a></code></li>
<li><code><a title="sprit.plot_depth_curve" href="#sprit.plot_depth_curve">plot_depth_curve</a></code></li>
<li><code><a title="sprit.plot_hvsr" href="#sprit.plot_hvsr">plot_hvsr</a></code></li>
<li><code><a title="sprit.plot_input_stream" href="#sprit.plot_input_stream">plot_input_stream</a></code></li>
<li><code><a title="sprit.plot_outlier_curves" href="#sprit.plot_outlier_curves">plot_outlier_curves</a></code></li>
<li><code><a title="sprit.plot_results_plotly" href="#sprit.plot_results_plotly">plot_results_plotly</a></code></li>
<li><code><a title="sprit.process_hvsr" href="#sprit.process_hvsr">process_hvsr</a></code></li>
<li><code><a title="sprit.read_tromino_files" href="#sprit.read_tromino_files">read_tromino_files</a></code></li>
<li><code><a title="sprit.remove_noise" href="#sprit.remove_noise">remove_noise</a></code></li>
<li><code><a title="sprit.remove_outlier_curves" href="#sprit.remove_outlier_curves">remove_outlier_curves</a></code></li>
<li><code><a title="sprit.run" href="#sprit.run">run</a></code></li>
<li><code><a title="sprit.update_elevation" href="#sprit.update_elevation">update_elevation</a></code></li>
<li><code><a title="sprit.update_resp_file" href="#sprit.update_resp_file">update_resp_file</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sprit.HVSRBatch" href="#sprit.HVSRBatch">HVSRBatch</a></code></h4>
<ul class="two-column">
<li><code><a title="sprit.HVSRBatch.add" href="#sprit.HVSRBatch.add">add</a></code></li>
<li><code><a title="sprit.HVSRBatch.append" href="#sprit.HVSRBatch.append">append</a></code></li>
<li><code><a title="sprit.HVSRBatch.copy" href="#sprit.HVSRBatch.copy">copy</a></code></li>
<li><code><a title="sprit.HVSRBatch.export" href="#sprit.HVSRBatch.export">export</a></code></li>
<li><code><a title="sprit.HVSRBatch.export_settings" href="#sprit.HVSRBatch.export_settings">export_settings</a></code></li>
<li><code><a title="sprit.HVSRBatch.get_report" href="#sprit.HVSRBatch.get_report">get_report</a></code></li>
<li><code><a title="sprit.HVSRBatch.items" href="#sprit.HVSRBatch.items">items</a></code></li>
<li><code><a title="sprit.HVSRBatch.keys" href="#sprit.HVSRBatch.keys">keys</a></code></li>
<li><code><a title="sprit.HVSRBatch.plot" href="#sprit.HVSRBatch.plot">plot</a></code></li>
<li><code><a title="sprit.HVSRBatch.report" href="#sprit.HVSRBatch.report">report</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sprit.HVSRData" href="#sprit.HVSRData">HVSRData</a></code></h4>
<ul class="two-column">
<li><code><a title="sprit.HVSRData.batch" href="#sprit.HVSRData.batch">batch</a></code></li>
<li><code><a title="sprit.HVSRData.copy" href="#sprit.HVSRData.copy">copy</a></code></li>
<li><code><a title="sprit.HVSRData.export" href="#sprit.HVSRData.export">export</a></code></li>
<li><code><a title="sprit.HVSRData.export_settings" href="#sprit.HVSRData.export_settings">export_settings</a></code></li>
<li><code><a title="sprit.HVSRData.get_report" href="#sprit.HVSRData.get_report">get_report</a></code></li>
<li><code><a title="sprit.HVSRData.items" href="#sprit.HVSRData.items">items</a></code></li>
<li><code><a title="sprit.HVSRData.keys" href="#sprit.HVSRData.keys">keys</a></code></li>
<li><code><a title="sprit.HVSRData.params" href="#sprit.HVSRData.params">params</a></code></li>
<li><code><a title="sprit.HVSRData.plot" href="#sprit.HVSRData.plot">plot</a></code></li>
<li><code><a title="sprit.HVSRData.ppsds" href="#sprit.HVSRData.ppsds">ppsds</a></code></li>
<li><code><a title="sprit.HVSRData.ppsds_obspy" href="#sprit.HVSRData.ppsds_obspy">ppsds_obspy</a></code></li>
<li><code><a title="sprit.HVSRData.report" href="#sprit.HVSRData.report">report</a></code></li>
<li><code><a title="sprit.HVSRData.select" href="#sprit.HVSRData.select">select</a></code></li>
<li><code><a title="sprit.HVSRData.to_json" href="#sprit.HVSRData.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
