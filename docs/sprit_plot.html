<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>sprit.sprit_plot API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sprit.sprit_plot</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sprit.sprit_plot.parse_plot_string"><code class="name flex">
<span>def <span class="ident">parse_plot_string</span></span>(<span>plot_string)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_plot_string(plot_string):
    &#34;&#34;&#34;Function to parse a plot string into a list readable by plotting functions

    Parameters
    ----------
    plot_string : str
        Plot string used by sprit.plot_hvsr to define results plot

    Returns
    -------
    list
        A list readable by various sprit plotting functions to show what to include in the results plot.
    &#34;&#34;&#34;
    plot_list = plot_string.split()

    hvsrList = [&#39;hvsr&#39;, &#39;hv&#39;, &#39;h&#39;]
    compList = [&#39;component&#39;, &#39;comp&#39;, &#39;c&#39;]
    compPlus = [item + &#39;+&#39; for item in compList]
    specList = [&#39;spectrogram&#39;, &#39;specgram&#39;, &#39;spec&#39;,&#39;sg&#39;, &#39;s&#39;]

    hvInd = np.nan
    compInd = np.nan
    specInd = np.nan

    hvIndFound = False
    compIndFound = False
    specIndFound = False

    for i, item in enumerate(plot_list):
        if item.lower() in hvsrList and not hvIndFound:
            # assign the index
            hvInd = i
            hvIndFound = True
        if (item.lower() in compList or item.lower() in compPlus) and not compIndFound:
            # assign the index
            compInd = i
            compIndFound = True
        if item.lower() in specList and not specIndFound:
            # assign the index
            specInd = i
            specIndFound = True

    # Get individual plot lists (should already be correctly ordered)
    if hvInd is np.nan:
        hvsr_plot_list = [&#39;HVSR&#39;]

    if compInd is np.nan:
        comp_plot_list = []
        if specInd is np.nan:
            if hvInd is not np.nan:
                hvsr_plot_list = plot_list
            spec_plot_list = []
        else:
            if hvInd is not np.nan:
                hvsr_plot_list = plot_list[hvInd:specInd]
            spec_plot_list = plot_list[specInd:]
    else:
        if hvInd is not np.nan:
            hvsr_plot_list = plot_list[hvInd:compInd]
        
        if specInd is np.nan:
            comp_plot_list = plot_list[compInd:]
            spec_plot_list = []
        else:
            comp_plot_list = plot_list[compInd:specInd]
            spec_plot_list = plot_list[specInd:]

    # Figure out how many subplots there will be
    plot_list_list = [hvsr_plot_list, comp_plot_list, spec_plot_list]

    return plot_list_list</code></pre>
</details>
<div class="desc"><p>Function to parse a plot string into a list readable by plotting functions</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>plot_string</code></strong> :&ensp;<code>str</code></dt>
<dd>Plot string used by sprit.plot_hvsr to define results plot</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list readable by various sprit plotting functions to show what to include in the results plot.</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_plot.plot_cross_section"><code class="name flex">
<span>def <span class="ident">plot_cross_section</span></span>(<span>hvsr_data,<br>title=None,<br>fig=None,<br>ax=None,<br>use_elevation=True,<br>show_feet=False,<br>primary_unit='m',<br>show_curves=True,<br>annotate_curves=False,<br>curve_alignment='peak',<br>grid_size='auto',<br>orientation='WE',<br>interpolation_type='cloughtocher',<br>interpolate_log_values=True,<br>surface_elevations=None,<br>show_peak_points=True,<br>smooth_bedrock_surface=False,<br>depth_limit=150,<br>minimum_elevation=None,<br>show_bedrock_surface=True,<br>return_data_batch=True,<br>show_cross_section=True,<br>verbose=False,<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_cross_section(hvsr_data,  title=None, fig=None, ax=None, use_elevation=True, show_feet=False, primary_unit=&#39;m&#39;, 
                       show_curves=True, annotate_curves=False, curve_alignment=&#39;peak&#39;,
                       grid_size=&#39;auto&#39;, orientation=&#39;WE&#39;, 
                       interpolation_type=&#39;cloughtocher&#39;, interpolate_log_values=True,
                       surface_elevations=None, show_peak_points=True, smooth_bedrock_surface=False,
                       depth_limit=150, minimum_elevation=None, show_bedrock_surface=True,
                       return_data_batch=True, show_cross_section=True, verbose=False,
                       **kwargs):
    &#34;&#34;&#34;Function to plot a cross section given an HVSRBatch or similar object

    Parameters
    ----------
    hvsr_data : HVSRBatch, list, or similar
        HVSRBatch (intended usage) object with HVSRData objects to show in profile/cross section view
    title : str, optional
        Title to use for plot, by default None
    fig : matplotlib.Figure, optional
        Figure to use for plot, by default None
    ax : matplotlib.Axis, optional
        Axis to use for plot, by default None
    use_elevation : bool, optional
        Whether to use elevation (if True) or depth (if False), by default True
    show_feet : bool, optional
        Whether to show feet (if True) or meters (if False), by default False
    primary_unit : str, optional
        Primary unit to use (&#39;m&#39; or &#39;ft&#39;), by default &#39;m&#39;
    show_curves : bool, optional
        Whether to also show curves on plot, by default True
    annotate_curves : bool, optional
        Whether to annotate curves by plotting site names next to them, by default False
    curve_alignment : str, optional
        How to horizontally align the curve. 
        If &#34;peak&#34; the curve will be aligned so that the peak is at the correct latitude or longitude.
        If &#34;max&#34; will align the maximum point of the curve to the correct location.
        If any other value, will align at the surface (i.e., highest frequency). By default &#39;peak&#39;.
    grid_size : list, optional
        Two item list with height and width of grid for interpolation.
        If &#34;auto&#34; this will be calculated based on the data, by default &#39;auto&#39;.
    orientation : str, optional
        The orientation of the cross section. 
        Should be either &#34;WE&#34;, &#34;EW&#34;, &#34;NS&#34;, or &#34;SN&#34;, by default &#39;WE&#39;.
    interpolation_type : str, optional
        Interpolation type to use. Uses scipy.interpolation.
        Options include: &#39;cloughtocher&#39;, &#39;nearest neighbor&#39;, &#39;linear&#39;, 
        or &#39;radial basis function&#39;, by default &#39;cloughtocher&#39;.
    interpolate_log_values : bool, optional
        Whether to use log values of the H/V curve for interpolation (can be useful for better normalizing data)
    surface_elevations : shapely.LineString, optional
        A shapely.LineString object containing surface elevation coordinates along cross section path.
        If None, uses elevation data in HVSRBatch specified by hvsr_data, by default None.
    show_peak_points : bool, optional
        Whether to plot small triangles where peaks were picked, by default True
    smooth_bedrock_surface : bool, optional
        Whether to smooth the bedrock surface when plotting, by default False
    depth_limit : int, optional
        Depth limit for the plot, by default 150
    minimum_elevation : _type_, optional
        Minimum elevation of the plot, by default None
    show_bedrock_surface : bool, optional
        Whether to show the bedrock surface, by default True
    return_data_batch : bool, optional
        Whether to return the HVSRBatch object, by default True
    show_cross_section : bool, optional
        Whether to show the cross section plot, by default True
    verbose : bool, optional
        Whether to print information about the process to terminal, by default False

    Returns
    -------
    figure
        Currently only matplotlib figure supported
    &#34;&#34;&#34;
    if verbose:
        print(&#34;Getting cross section plot configuration&#34;)
        
    if fig is None and ax is None:
        fig, ax = plt.subplots()
    elif ax is None and fig is not None:
        fig = fig
        ax = fig.get_axes()[0]
    elif fig is None and ax is not None:
        ax = ax
        fig = plt.figure()
        fig.axes.append(ax)
    else:
        fig = fig
        ax = ax
    plt.sca(ax)
    
    if verbose:
        print(&#34;Getting data batch for cross section plot&#34;)
    batchExt = None
    if isinstance(hvsr_data, (str, os.PathLike, pathlib.Path)):
        if pathlib.Path(hvsr_data).exists() and pathlib.Path(hvsr_data).is_dir():
            batchExt = &#39;hvsr&#39;
    hvDataBatch = sprit_hvsr.HVSRBatch(hvsr_data, batch_ext=batchExt)
    
    if verbose:
        print(&#34;Sorting and Orienting data&#34;)
    # Get orientation/order of data
    nsList = [&#39;ns&#39;, &#34;north-south&#34;, &#39;northsouth&#39;, &#39;south&#39;, &#39;s&#39;]
    snList = [&#39;sn&#39;, &#34;south-north&#34;, &#39;southnorth&#39;, &#39;north&#39;, &#39;n&#39;]
    weList = [&#39;we&#39;, &#34;west-east&#34;, &#39;westeast&#39;, &#39;east&#39;, &#39;e&#39;]
    ewList = [&#39;ew&#39;, &#34;east-west&#34;, &#39;eastwest&#39;, &#39;west&#39;, &#39;w&#39;]

    if str(orientation).lower() in nsList:
        ordercoord = &#39;latitude&#39;
        order = &#39;descending&#39;
        profile_direction = &#39;north-south&#39;
    elif str(orientation).lower() in snList:
        ordercoord = &#39;latitude&#39;
        order = &#39;ascending&#39;
        profile_direction  = &#39;south-north&#39;
    elif str(orientation).lower() in weList:
        ordercoord = &#39;longitude&#39;
        order = &#39;ascending&#39;
        profile_direction = &#39;west-east&#39;
    elif str(orientation).lower() in ewList:
        ordercoord = &#39;longitude&#39;
        order = &#39;descending&#39;
        profile_direction = &#39;east-west&#39;
    else:
        if verbose:
            print(f&#34;Value for orientation={orientation} is not recognized. Using West-East orientation.&#34;)
        order = &#39;ascending&#39;
        ordercoord=&#39;longitude&#39;
        profile_direction = &#39;west-east (default)&#39;

    # Get data in correct order, as specified by orientation parameter
    reverseit = (order == &#39;descending&#39;)
    sorted_sites = sorted(hvDataBatch, key=lambda site: hvDataBatch[site][ordercoord], reverse=reverseit)
    hvDataSorted = [hvDataBatch[h] for h in sorted_sites]

    if verbose:
        print(f&#39;Plotting {len(hvDataBatch.sites)} sites, {profile_direction}.&#39;)
        [print(f&#34;\t{hvdata.site[:12]:&lt;12}: {hvdata.longitude:&gt;8.4f}, {hvdata.latitude:&gt;8.4f}, {hvdata.elevation:&lt;6.1f}&#34;) for hvdata in hvDataSorted]

    # Get cross section profile
    shapelyPoints = []
    interpData = []
    interpCoords = {&#39;longitude&#39;:[], &#39;latitude&#39;:[], &#39;elevation&#39;:[]}
    for i, hvData in enumerate(hvDataSorted):
        if not hasattr(hvData, &#39;x_elev_m&#39;):
            calc_depth_kwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(sprit_calibration.calculate_depth).parameters.keys())}
            hvData = sprit_calibration.calculate_depth(hvData, **calc_depth_kwargs, verbose=verbose)
        
        # Create shapely Point objects at each profile location
        x = hvData[&#39;longitude&#39;]
        y = hvData[&#39;latitude&#39;]
        z = hvData[&#39;elevation&#39;]

        shapelyPoints.append(shapely.Point(x, y, z))

        # Points arranged for interpolation
        if interpolate_log_values:
            interpData.extend(list(np.log10(hvData.hvsr_curve)))
        else:
            interpData.extend(list(hvData.hvsr_curve))
        for i, pt in enumerate(hvData.hvsr_curve):
            interpCoords[&#39;longitude&#39;].append(x)
            interpCoords[&#39;latitude&#39;].append(y)
            interpCoords[&#39;elevation&#39;].append(hvData[&#39;x_elev_m&#39;][&#39;Z&#39;][i])

        # Since already doing loop, ensure hvData has all depth/elev info it needs
        if not hasattr(hvData, &#39;x_elev_m&#39;):
            calc_depth_kwargs = {k: v for k, v in kwargs.items()
                                      if k in tuple(inspect.signature(sprit_calibration.calculate_depth).parameters.keys())}
            if &#39;calculate_depth_in_feet&#39; not in calc_depth_kwargs:
                calc_depth_kwargs[&#39;calculate_depth_in_feet&#39;] = True
            hvDataSorted[i] = sprit_calibration.calculate_depth(hvData, **calc_depth_kwargs, verbose=verbose)

    xSectionProfile = shapely.LineString(shapelyPoints)
    profileXs, profileYs = xSectionProfile.xy
    
    orderCoordValues = profileXs
    if ordercoord == &#39;latitude&#39;:
        orderCoordValues = profileYs

    minX = min(profileXs)
    minY = min(profileYs)
    maxX = max(profileXs)
    maxY = max(profileYs)

    # Generate grid
    if verbose:
        print(&#34;Generating Grid: &#34;, end=&#39;&#39;)
    xSectionLength = xSectionProfile.length
    if grid_size == &#39;auto&#39;:
        grid_size=(50, 100)

        cellHNumber = grid_size[0]
        cellWNumber = grid_size[1]
    elif isinstance(grid_size, (list, tuple)):
        cellHNumber = grid_size[0]
        cellWNumber = grid_size[1]
    else:
        grid_size=(50, 100)

        cellHNumber = grid_size[0]
        cellWNumber = xSectionLength/grid_size[1]

        if verbose:
            print(f&#39;grid_size value ({grid_size} not recognized, using grid 100 cells wide and 50 cells high: grid_size=(50, 100))&#39;)

    cellWSize = xSectionLength/cellWNumber
    
    max_surf_elev = max([hvd.elevation for hvd in hvDataSorted])
    min_br_elev = min([hvd.Table_Report[&#39;Peak&#39;][0] for hvd in hvDataSorted])
    elev_range = max_surf_elev - min_br_elev

    max_grid_elev = math.ceil(max_surf_elev)

    # Minimum grid elevation is determined by depth_limit and minimum_elevation
    if str(minimum_elevation).lower() == &#39;auto&#39;:
        min_grid_elev = min_br_elev - (elev_range) * 0.1
    elif isinstance(minimum_elevation, numbers.Number):
        min_grid_elev = minimum_elevation
    elif minimum_elevation is None:
        min_grid_elev = max_grid_elev - depth_limit
    
    xSectionDepth = max_grid_elev - min_grid_elev
    cellHSize = xSectionDepth/cellHNumber

    # Get grid coordinates (all coords in z direction (depth/elev))
    gridZcoords = np.linspace(min_grid_elev, max_grid_elev, cellHNumber)

    gridXDists = np.linspace(0, xSectionProfile.length, cellWNumber)
    gridXcoords = [] # All coords in the &#34;x&#34; direction (along profile)
    for xdist in gridXDists:
        x, y = xSectionProfile.interpolate(xdist).xy
        if &#39;east&#39; in profile_direction:
            gridXcoords.append(x[0])
        else:
            gridXcoords.append(y[0])
    gridXcoords = np.array(gridXcoords)
    if verbose:
        print(f&#39;Grid generated ({cellWNumber*cellHNumber} cells)\n\tx-range: {xSectionLength:.5f} ({cellWNumber:d} cells, each {cellWSize:.5f} units in size)\n\tz-range: {xSectionDepth:.2f} ({cellHNumber:d} cells, each {cellHSize:.5f} units in size)&#39;)

    #print(&#39;x&#39;, len(interpCoords[&#39;longitude&#39;]))
    #print(&#39;y&#39;, len(interpCoords[&#39;latitude&#39;]))
    #print(&#39;z&#39;, len(interpCoords[&#39;elevation&#39;]))
    #print(&#39;interp&#39;, np.array(interpData).shape)
    if verbose:
        print(f&#39;Beginning interpolation ({interpolation_type})... &#39;, end=&#39;&#39;)
    
    ctList = [&#39;cloughtocher2dinterpolator&#39;, &#39;cloughtocher&#39;, &#39;ct&#39;, &#39;clough-tocher&#39;, &#39;clough tocher&#39;, &#39;cubic&#39;, &#39;c&#39;]
    nearList = [&#39;nearestnd&#39;, &#39;nearest&#39;, &#39;near&#39;, &#39;n&#39;]
    linList = [&#39;linearnd&#39;, &#39;linear&#39;, &#39;lin&#39;, &#39;l&#39;]
    rbfList = [&#39;radial basis function&#39;, &#39;rbf&#39;, &#39;rbfinterpolator&#39;]
    
    if str(interpolation_type).lower() in ctList:
        interp = interpolate.CloughTocher2DInterpolator(list(zip(interpCoords[ordercoord], interpCoords[&#39;elevation&#39;])), interpData)
    elif str(interpolation_type).lower() in rbfList:
        interp = interpolate.RBFInterpolator(list(zip(interpCoords[ordercoord], interpCoords[&#39;elevation&#39;])), interpData)        
    elif str(interpolation_type).lower() in linList:
        interp = interpolate.LinearNDInterpolator(list(zip(interpCoords[ordercoord], interpCoords[&#39;elevation&#39;])), interpData)
    else: # elif str(interpolation_type).lower() in nearList:
        interp = interpolate.NearestNDInterpolator(list(zip(interpCoords[ordercoord], interpCoords[&#39;elevation&#39;])), interpData)
        
    xx, zz = np.meshgrid(gridXcoords, gridZcoords)
    interpData = interp(xx, zz)
    interpDataflat = interpData[:-1, :-1]
    if verbose:
        print(&#39;Data interpolated&#39;)
        print(&#39;Plotting colormesh&#39;)
    
    # kwargs-defined pcolormesh kwargs
    pcolormeshKwargs = {k: v for k, v in kwargs.items() if k in tuple(inspect.signature(plt.pcolormesh).parameters.keys())}
    
    # Set defaults for cmap and shading (if not overriden in kwargs)
    if &#39;cmap&#39; not in pcolormeshKwargs:
        pcolormeshKwargs[&#39;cmap&#39;] = &#39;nipy_spectral&#39;
    if &#39;shading&#39; not in pcolormeshKwargs:
        pcolormeshKwargs[&#39;shading&#39;] = &#39;flat&#39;
                
    ax.pcolormesh(xx, zz, interpDataflat, zorder=0, **pcolormeshKwargs)
    
    if show_curves:
        if verbose:
            print(&#39;Plotting curves&#39;)
        norm_div = 1
        normal_factor = np.diff(orderCoordValues)
        normal_factor = np.nanmedian(normal_factor[normal_factor != 0]) / norm_div
        
        zAttr = &#39;x_depth_m&#39;
        if use_elevation:
            zAttr = &#39;x_elev_m&#39;

        for hvData in hvDataSorted:
            hvData[&#39;Normalized_HVCurve&#39;] = (hvData[&#39;hvsr_curve&#39;] / np.nanmax(hvData[&#39;hvsr_curve&#39;])) * normal_factor
            locatedCurve = hvData[&#39;Normalized_HVCurve&#39;] + hvData[ordercoord]
            if curve_alignment.lower() == &#39;peak&#39;:
                normal_peak_factor = (hvData[&#34;BestPeak&#34;][&#39;HV&#39;][&#39;A0&#39;] / np.nanmax(hvData[&#39;hvsr_curve&#39;])) * normal_factor
                locatedCurve = locatedCurve  - normal_peak_factor
            elif curve_alignment.lower() == &#39;max&#39;:
                locatedCurve = locatedCurve  - normal_factor
            else:
                pass
            
            if max(locatedCurve) &gt; max(gridXcoords):
                locatedCurve = locatedCurve - (max(locatedCurve) - max(gridXcoords))
            if min(locatedCurve) &lt; min(gridXcoords):
                locatedCurve = locatedCurve + (min(gridXcoords) - min(locatedCurve))
                
            ax.plot(locatedCurve, hvData[zAttr][&#39;Z&#39;][:-1], c=&#39;k&#39;, linewidth=0.5, zorder=3)

    if annotate_curves:
        for hvData in hvDataSorted:
            if len(hvData.site) &gt; 10:
                sitename = hvData.site[:8]+ &#39;...&#39;
            else:
                sitename = hvData.site
            ax.text(hvData[ordercoord], y=min_grid_elev, s=sitename, ha=&#39;right&#39;, va=&#39;bottom&#39;, rotation=&#39;vertical&#39;)
    
    if smooth_bedrock_surface:
        show_bedrock_surface = True

    if show_peak_points or show_bedrock_surface:
        brX = []
        brZ = []
        for hvData in hvDataSorted:
            if &#39;BedrockElevation&#39; in hvData[&#39;Table_Report&#39;].columns:
                brX.append(hvData[ordercoord])
                brZ.append(hvData[&#39;Table_Report&#39;].loc[0,&#39;BedrockElevation&#39;][()])
        if show_peak_points:
            ax.scatter(brX, brZ, zorder=5, c=&#39;k&#39;, marker=&#39;v&#39;)

        
        if smooth_bedrock_surface:
            #brSurfZ = scipy.signal.savgol(brZ, window_length=len(brZ))
            if brX[0] &gt; brX[-1]:
                brX = np.flip(brX)
                brZ = np.flip(brZ)
                doFlip=True
            else:
                doFlip=False
                
            newX = np.sort(gridXcoords)
            brSurfZ = np.interp(newX, brX, brZ)
            brSurfX = newX
        else:
            brSurfX = brX
            brSurfZ = brZ
        
        zMinPts = list(np.array(brSurfZ) * 0 + min(gridZcoords))
        
        if show_bedrock_surface:
            ax.fill_between(brSurfX, brSurfZ, zMinPts,facecolor=&#39;w&#39;, alpha=0.5, zorder=1)
            ax.plot(brSurfX, brSurfZ, c=&#39;k&#39;, zorder=2)

    # Plot surfaces
    if verbose:
        print(&#39;Plotting surfaces&#39;)
    
    if surface_elevations is None:
        surfPts_shapely = []
        surfPtsX = []
        surfPtsZ = []
        
        surface_elevations = shapely.LineString([shapely.Point(hvData[&#39;longitude&#39;], 
                                                               hvData[&#34;latitude&#34;], 
                                                               hvData[&#34;elevation&#34;]) 
                                                 for hvData in hvDataSorted])
    
    xPts = []
    zPts = []
    for surf_pt in surface_elevations.coords:
        surfPtDict = {&#39;longitude&#39;:surf_pt[0], 
                      &#39;latitude&#39;: surf_pt[1],
                      &#39;elevation&#39;: surf_pt[2]}
        xPts.append(surfPtDict[ordercoord])
        zPts.append(surfPtDict[&#39;elevation&#39;])
    
    zMaxPts = list(np.array(zPts) * 0 + max_grid_elev)

    # Fill in above surface so interpolation is cleaner and surface topo shape is clear
    ax.fill_between(xPts, zPts, zMaxPts, facecolor=&#39;w&#39;, zorder=1000)

    # Plot surface topography
    ax.plot(xPts, zPts, c=&#39;g&#39;, linewidth=1.5, zorder=1001)

    # Plot configuration
    if verbose:
        print(&#39;Configuring plot&#39;)
    ax.set_xlim([min(gridXcoords), max(gridXcoords)])
    ax.set_ylim([min_grid_elev, max_grid_elev])
    
    ax.tick_params(top=True, labeltop=True, bottom=False, labelbottom=False)
    ax.set_xlabel(str(ordercoord).title())
    ax.xaxis.set_label_position(&#39;top&#39;)
    ax.set_ylabel(&#39;Elevation [Meters]&#39;)
    if title is None:
        title = &#39;HVSR Cross Section Profile&#39;
    ax.set_title(title)
    
    # Display orientation of cross section profile
    # Calculate angle
    profile_angle = math.degrees(math.atan2(shapelyPoints[-1].y - shapelyPoints[0].y, shapelyPoints[-1].x - shapelyPoints[0].x))
    
    # Convert angle to geographic coordinates
    profile_angle = (profile_angle * -1) + 90
    if profile_angle &lt; 0:
        profile_angle += 360

    if verbose:
        print(f&#34;Calculated profile angle to be {profile_angle:.3f} degrees.&#34;)
    # Calculate angle name of cross section profile
    if profile_angle &lt; -11.25 + 22.5 * 1:
        profileStart = &#39;S&#39;
        profileEnd = &#39;N&#39;
    elif profile_angle &lt; -11.25 + 22.5 * 2:
        profileEnd = &#39;NNE&#39;
        profileStart = &#39;SSW&#39;        
    elif profile_angle &lt; -11.25 + 22.5 * 3:
        profileEnd = &#39;NE&#39;
        profileStart = &#39;SW&#39;
    elif profile_angle &lt; -11.25 + 22.5 * 4:
        profileEnd = &#39;ENE&#39;
        profileStart = &#39;WSW&#39;        
    elif profile_angle &lt; -11.25 + 22.5 * 5:
        profileEnd = &#39;E&#39;
        profileStart = &#39;W&#39;        
    elif profile_angle &lt; -11.25 + 22.5 * 6:
        profileEnd = &#39;ESE&#39;
        profileStart = &#39;WNW&#39;
    elif profile_angle &lt; -11.25 + 22.5 * 7:
        profileEnd = &#39;SE&#39;
        profileStart = &#39;NW&#39;
    elif profile_angle &lt; -11.25 + 22.5 * 8:
        profileEnd = &#39;SSE&#39;
        profileStart = &#39;NNW&#39;
    elif profile_angle &lt; -11.25 + 22.5 * 9:
        profileEnd = &#39;S&#39;
        profileStart = &#39;N&#39;
    elif profile_angle &lt; -11.25 + 22.5 * 10:
        profileEnd = &#39;SSW&#39;
        profileStart = &#39;NNE&#39;        
    elif profile_angle &lt; -11.25 + 22.5 * 11:
        profileEnd = &#39;SW&#39;
        profileStart = &#39;NE&#39;
    elif profile_angle &lt; -11.25 + 22.5 * 12:
        profileEnd = &#39;WSW&#39;
        profileStart = &#39;ENE&#39;
    elif profile_angle &lt; -11.25 + 22.5 * 13:
        profileEnd = &#39;W&#39;
        profileStart = &#39;E&#39;
    elif profile_angle &lt; -11.25 + 22.5 * 14:
        profileEnd = &#39;WNW&#39;
        profileStart = &#39;ESE&#39;
    elif profile_angle &lt; -11.25 + 22.5 * 15:
        profileEnd = &#39;NW&#39;
        profileStart = &#39;SE&#39;
    elif profile_angle &lt; -11.25 + 22.5 * 16:
        profileEnd = &#39;NNW&#39;
        profileStart = &#39;SSE&#39;
    elif profile_angle &lt;= 360:
        profileEnd = &#39;N&#39;
        profileStart = &#39;S&#39;

    # Always orient north and east to the right
    if &#39;north&#39; in profile_direction[:5] or &#39;east&#39; in profile_direction[:5]:
        ax.invert_xaxis()

    plt.sca(ax)
    plt.figtext(0.1,0.95, s=profileStart)
    plt.figtext(0.9,0.95, s=profileEnd)

    if show_cross_section:
        if verbose:
            print(&#39;Displaying plot&#39;)
        plt.sca(ax)
        plt.show()
        
    if return_data_batch:
        hvBatch = sprit_hvsr.HVSRBatch(hvDataSorted)
        hvBatch[&#39;Cross_Section_Plot&#39;] = fig
        return hvBatch
            
    return fig</code></pre>
</details>
<div class="desc"><p>Function to plot a cross section given an HVSRBatch or similar object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>HVSRBatch, list,</code> or <code>similar</code></dt>
<dd>HVSRBatch (intended usage) object with HVSRData objects to show in profile/cross section view</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Title to use for plot, by default None</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.Figure</code>, optional</dt>
<dd>Figure to use for plot, by default None</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.Axis</code>, optional</dt>
<dd>Axis to use for plot, by default None</dd>
<dt><strong><code>use_elevation</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to use elevation (if True) or depth (if False), by default True</dd>
<dt><strong><code>show_feet</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to show feet (if True) or meters (if False), by default False</dd>
<dt><strong><code>primary_unit</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Primary unit to use ('m' or 'ft'), by default 'm'</dd>
<dt><strong><code>show_curves</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to also show curves on plot, by default True</dd>
<dt><strong><code>annotate_curves</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to annotate curves by plotting site names next to them, by default False</dd>
<dt><strong><code>curve_alignment</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>How to horizontally align the curve.
If "peak" the curve will be aligned so that the peak is at the correct latitude or longitude.
If "max" will align the maximum point of the curve to the correct location.
If any other value, will align at the surface (i.e., highest frequency). By default 'peak'.</dd>
<dt><strong><code>grid_size</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Two item list with height and width of grid for interpolation.
If "auto" this will be calculated based on the data, by default 'auto'.</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The orientation of the cross section.
Should be either "WE", "EW", "NS", or "SN", by default 'WE'.</dd>
<dt><strong><code>interpolation_type</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Interpolation type to use. Uses scipy.interpolation.
Options include: 'cloughtocher', 'nearest neighbor', 'linear',
or 'radial basis function', by default 'cloughtocher'.</dd>
<dt><strong><code>interpolate_log_values</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to use log values of the H/V curve for interpolation (can be useful for better normalizing data)</dd>
<dt><strong><code>surface_elevations</code></strong> :&ensp;<code>shapely.LineString</code>, optional</dt>
<dd>A shapely.LineString object containing surface elevation coordinates along cross section path.
If None, uses elevation data in HVSRBatch specified by hvsr_data, by default None.</dd>
<dt><strong><code>show_peak_points</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to plot small triangles where peaks were picked, by default True</dd>
<dt><strong><code>smooth_bedrock_surface</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to smooth the bedrock surface when plotting, by default False</dd>
<dt><strong><code>depth_limit</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Depth limit for the plot, by default 150</dd>
<dt><strong><code>minimum_elevation</code></strong> :&ensp;<code>_type_</code>, optional</dt>
<dd>Minimum elevation of the plot, by default None</dd>
<dt><strong><code>show_bedrock_surface</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to show the bedrock surface, by default True</dd>
<dt><strong><code>return_data_batch</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to return the HVSRBatch object, by default True</dd>
<dt><strong><code>show_cross_section</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to show the cross section plot, by default True</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print information about the process to terminal, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>figure</code></dt>
<dd>Currently only matplotlib figure supported</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_plot.plot_depth_curve"><code class="name flex">
<span>def <span class="ident">plot_depth_curve</span></span>(<span>hvsr_results,<br>use_elevation=True,<br>show_feet=False,<br>normalize_curve=True,<br>depth_limit=250,<br>depth_model=None,<br>annotate=True,<br>depth_plot_export_path=None,<br>fig=None,<br>ax=None,<br>show_depth_curve=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_depth_curve(hvsr_results, use_elevation=True, show_feet=False, normalize_curve=True, 
                     depth_limit=250, depth_model=None,
                     annotate=True, depth_plot_export_path=None, 
                     fig=None, ax=None, show_depth_curve=True):
    &#34;&#34;&#34;Function to plot depth curves, given hvsr_results with depth_model specified.

    Parameters
    ----------
    hvsr_results : sprit.HVSRData or sprit.HVSRBatch
        HVSRData object with depth information (or `depth_model` specified).
    use_elevation : bool, optional
        Whether to use elevation (True) or just depth (False), by default True
    show_feet : bool, optional
        Whether to show elevation/depth in feet on Y axis, by default False
    normalize_curve : bool, optional
        Whether to normalize amplitude of H/V curve (x-axis) using maximum/minimum amplitudes, by default True
    depth_limit : int, optional
        Depth limit at which to cut off plot, by default 250 (meters)
    depth_model : None or tuple, optional
        If depth_model not already specified, this can be used to run sprit.calculate_depth() before generating plot.
    annotate : bool, optional
        Whether to annotate plot, by default True
    depth_plot_export_path : filepath-like object, optional
        If specified, will export depth plot to location specifed, by default None
    fig : matplotlib.figure.Figure, optional
        Maplotlib Figure to use for plotting, by default None (new one will be created)
    ax : matplotlib.axis.Axis, optional
        Maplotlib Axis to use for plotting, by default None (new one will be created)
    show_depth_curve : bool, optional
        Whether to diplay the depth curve chart after generating it, by default True

    Returns
    -------
    HVSRData
        HVSRData object with additional property for Depth_Plot
    &#34;&#34;&#34;


    if fig is None and ax is None:
        fig, ax = plt.subplots(layout=&#39;constrained&#39;)#, figsize=(5, 15))
        fig.suptitle(hvsr_results[&#39;site&#39;])
        ax.set_title(&#39;Calibrated Depth to Interface&#39;, size=&#39;small&#39;)
    ax.tick_params(top=True, labeltop=True, bottom=False, labelbottom=False)
    
    if depth_model is not None:
        hvsr_results = sprit_calibration.calculate_depth(hvsr_results, depth_model=depth_model, show_depth_curve=False)

    surfElev = hvsr_results.Table_Report[&#39;Elevation&#39;][0]
    bedrockElev = hvsr_results.Table_Report[&#39;BedrockElevation&#39;][0]
    bedrockDepth = hvsr_results.Table_Report[&#39;BedrockDepth&#39;][0]
    curveRange = max(hvsr_results.hvsr_curve) - min(hvsr_results.hvsr_curve)

    if normalize_curve:
        curvePlot = (hvsr_results.hvsr_curve - min(hvsr_results.hvsr_curve)) / curveRange
        xBase = 0
        xCap = 1
        xLims = [-0.25, 1.25]
        ax.set_xticks([0, 1])
    else:
        curvePlot = hvsr_results.hvsr_curve
        xBase = min(hvsr_results.hvsr_curve)
        xCap = hvsr_results.BestPeak[&#39;HV&#39;][&#39;A0&#39;]#max(hvsr_results.hvsr_curve)
        xLims = [xBase-(0.15*curveRange), xCap+(0.15*curveRange)]
 
    if use_elevation:
        yLims = [hvsr_results.x_elev_m[&#39;Z&#39;][0] - depth_limit,
              hvsr_results.x_elev_m[&#39;Z&#39;][0]]
        yVals = hvsr_results.x_elev_m[&#39;Z&#39;][:-1]
        ax.set_ylabel(&#39;Elevation [m]&#39;)
        bedrockVal = bedrockElev
        if annotate:
            #Annotate surface elevation
            ax.text(x=xLims[0],
                    y=surfElev,
                    s=str(round(float(surfElev), 2))+&#39;m&#39;,
                    ha=&#39;right&#39;,
                    va=&#39;bottom&#39;,
                    size=&#39;x-small&#39;)

            # Annotate bedrock elevation
            ax.text(x=xBase,
                    y=bedrockElev,
                    s=&#39; &#39; + str(round(float(bedrockElev), 2))+&#39;m\n elevation&#39;,
                    ha=&#39;left&#39;,
                    va=&#39;center&#39;,
                    size=&#39;x-small&#39;)
            
            # Annotate bedrock depth
            ax.text(x=xBase,
                    y=max(yLims),
                    s=str(round(float(bedrockDepth), 2))+&#39;m deep &#39;,
                    ha=&#39;right&#39;,
                    va=&#39;top&#39;,
                    size=&#39;x-small&#39;,
                    rotation=&#39;vertical&#39;)
    else:
        yLims = [depth_limit, hvsr_results.x_depth_m[&#39;Z&#39;][0]]
        yVals = hvsr_results.x_depth_m[&#39;Z&#39;][:-1]
        ax.set_ylabel(&#39;Depth [m]&#39;)
        bedrockVal = bedrockDepth
        if annotate:
            # Annotate surface elevation
            ax.text(x=xLims[0],
                    y=0,
                    s=str(round(float(surfElev), 2))+&#39;m&#39;,
                    ha=&#39;right&#39;,
                    va=&#39;bottom&#39;,
                    size=&#39;x-small&#39;)
            
            # Annotate Bedrock elevation
            ax.text(x=xBase,
                    y=bedrockVal,
                    s=str(round(float(bedrockElev), 2))+&#39;m\nelevation&#39;,
                    ha=&#39;center&#39;,
                    va=&#39;center&#39;,
                    size=&#39;x-small&#39;)

            # Annotate Bedrock depth
            ax.text(x=xBase,
                    y=(min(yLims)+float(bedrockDepth))/2,
                    s=str(round(float(bedrockDepth), 2))+&#39;m deep&#39;,
                    ha=&#39;right&#39;,
                    va=&#39;top&#39;,
                    size=&#39;x-small&#39;,
                    rotation=&#39;vertical&#39;)

    # Plot curve
    ax.fill_betweenx(y=yVals, x1=xBase, x2=curvePlot, alpha=0.2, facecolor=&#39;k&#39;)
    ax.plot(curvePlot, yVals, c=&#39;k&#39;, linewidth=0.5)
    if show_feet:
        ax_ft = ax.twinx()
        ax_ft.plot(curvePlot, yVals*3.281, alpha=0)
        ax_ft.set_ylim(yLims[0]*3.281, yLims[1]*3.281)
        ax_ft.set_ylabel(&#39;Elevation [ft]&#39;)
        if not use_elevation:
            ax_ft.set_ylabel(&#39;Depth [ft]&#39;)
        
    # Plot peak location
    ax.axhline(y=bedrockVal,
               linestyle=&#39;dotted&#39;, c=&#39;k&#39;, linewidth=0.5)
    ax.scatter(xBase, y=bedrockVal, c=&#39;k&#39;, s=0.5)
    ax.scatter(xCap, y=bedrockVal, c=&#39;k&#39;, s=0.5)
    
    # Plot &#34;base&#34; line
    ax.axvline(x=xBase, linestyle=&#39;dotted&#39;, c=&#39;k&#39;, linewidth=0.5)

    ax.set_ylim(yLims)
    ax.set_xlim(xLims)
    
    xlabel = &#34;H/V Ratio&#34;
    if normalize_curve:
        xlabel += &#39;\n(Normalized)&#39;
        ax.set_xticks([])

    ax.set_xlabel(&#39;H/V Ratio&#39;)
    ax.xaxis.set_label_position(&#39;top&#39;)

    ax.set_title(hvsr_results[&#39;site&#39;])

    plt.sca(ax)
    fig.set_size_inches(4, 8)
    if show_depth_curve:
        plt.show()
    else:
        plt.close()
        
    if depth_plot_export_path is not None:
        if isinstance(depth_plot_export_path, os.PathLike):
            fig.savefig(depth_plot_export_path)
        else:
            print(f&#39;Please specify a valid path for depth_plot_export_path, not {depth_plot_export_path}&#39;)
    
    hvsr_results[&#39;Depth_Plot&#39;] = fig
    return hvsr_results</code></pre>
</details>
<div class="desc"><p>Function to plot depth curves, given hvsr_results with depth_model specified.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_results</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="index.html#sprit.HVSRData">HVSRData</a></code> or <code><a title="sprit.HVSRBatch" href="index.html#sprit.HVSRBatch">HVSRBatch</a></code></dt>
<dd>HVSRData object with depth information (or <code>depth_model</code> specified).</dd>
<dt><strong><code>use_elevation</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to use elevation (True) or just depth (False), by default True</dd>
<dt><strong><code>show_feet</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to show elevation/depth in feet on Y axis, by default False</dd>
<dt><strong><code>normalize_curve</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to normalize amplitude of H/V curve (x-axis) using maximum/minimum amplitudes, by default True</dd>
<dt><strong><code>depth_limit</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Depth limit at which to cut off plot, by default 250 (meters)</dd>
<dt><strong><code>depth_model</code></strong> :&ensp;<code>None</code> or <code>tuple</code>, optional</dt>
<dd>If depth_model not already specified, this can be used to run sprit.calculate_depth() before generating plot.</dd>
<dt><strong><code>annotate</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to annotate plot, by default True</dd>
<dt><strong><code>depth_plot_export_path</code></strong> :&ensp;<code>filepath-like object</code>, optional</dt>
<dd>If specified, will export depth plot to location specifed, by default None</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.figure.Figure</code>, optional</dt>
<dd>Maplotlib Figure to use for plotting, by default None (new one will be created)</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axis.Axis</code>, optional</dt>
<dd>Maplotlib Axis to use for plotting, by default None (new one will be created)</dd>
<dt><strong><code>show_depth_curve</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to diplay the depth curve chart after generating it, by default True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>HVSRData</code></dt>
<dd>HVSRData object with additional property for Depth_Plot</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_plot.plot_input_stream"><code class="name flex">
<span>def <span class="ident">plot_input_stream</span></span>(<span>hv_data,<br>stream=None,<br>input_fig=None,<br>plot_engine='plotly',<br>spectrogram_component='Z',<br>decimate=True,<br>show_plot=True,<br>return_fig=False,<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_input_stream(hv_data, stream=None, input_fig=None, plot_engine=&#39;plotly&#39;,
                        spectrogram_component=&#39;Z&#39;, decimate=True,
                        show_plot=True, return_fig=False, **kwargs):

    &#34;&#34;&#34;Function to plot input stream using plotly.
    
    Parameters
    ----------
    hv_data : HVSRData
    stream : obspy.stream.Stream
        Can explictly specify stream instead of using hv_data object.
    input_fig : plotly.Figure
        Plotly figure to plot input stream on. If None, creates new one. Default is None.
    spectrogram_component : str, default=&#39;Z&#39;
        Which component to use for the spectrogram
    show_plot : bool, default=True
        Whether to show plot or just generate it.
    return_fig : bool, default=False
        Whether to return figure

    Returns
    -------
    plotly figure
        Only returned if return_fig is True
    &#34;&#34;&#34;

    plotlyList = [&#39;plotly&#39;, &#39;pltly&#39;, &#39;plty&#39;, &#39;p&#39;]
    mplList = [&#39;matplotlib&#39;, &#39;pyplot&#39;, &#39;plt&#39;, &#39;mpl&#39;, &#39;m&#39;]

    if str(plot_engine).lower() in plotlyList:
        return _plot_input_stream_plotly(hv_data=hv_data, stream=stream, input_fig=input_fig,
                                         spectrogram_component=spectrogram_component,
                                         show_plot=show_plot, return_fig=return_fig)
    elif str(plot_engine).lower() in mplList:
        return _plot_input_stream_mpl(hv_data, stream, input_fig, decimate=True, spectrogram_component=&#39;Z&#39;, show_plot=True, return_fig=False, **kwargs)
    else:
        try:
            return _plot_simple_stream_mpl(hv_data, stream, fig=None, axes=None, show_plot=False, ylim_std=0.75, return_fig=True)
        except:
            return _plot_simple_stream_obspy()</code></pre>
</details>
<div class="desc"><p>Function to plot input stream using plotly.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hv_data</code></strong> :&ensp;<code>HVSRData</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>stream</code></strong> :&ensp;<code>obspy.stream.Stream</code></dt>
<dd>Can explictly specify stream instead of using hv_data object.</dd>
<dt><strong><code>input_fig</code></strong> :&ensp;<code>plotly.Figure</code></dt>
<dd>Plotly figure to plot input stream on. If None, creates new one. Default is None.</dd>
<dt><strong><code>spectrogram_component</code></strong> :&ensp;<code>str</code>, default=<code>'Z'</code></dt>
<dd>Which component to use for the spectrogram</dd>
<dt><strong><code>show_plot</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to show plot or just generate it.</dd>
<dt><strong><code>return_fig</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Whether to return figure</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>plotly figure</code></dt>
<dd>Only returned if return_fig is True</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_plot.plot_outlier_curves"><code class="name flex">
<span>def <span class="ident">plot_outlier_curves</span></span>(<span>hvsr_data,<br>plot_engine='plotly',<br>plotly_module='go',<br>remove_outliers_during_plot=False,<br>outlier_threshold=0.98,<br>use_percentile=True,<br>use_hv_curves=False,<br>from_roc=False,<br>show_plot=True,<br>verbose=False,<br>discarded_curves=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_outlier_curves(hvsr_data, plot_engine=&#39;plotly&#39;, plotly_module=&#39;go&#39;, remove_outliers_during_plot=False,
                        outlier_threshold=0.98, use_percentile=True, use_hv_curves=False, 
                        from_roc=False, show_plot=True, verbose=False, discarded_curves=None):
    &#34;&#34;&#34;Function to plot outlier curves, including which have been excluded

    Parameters
    ----------
    hvsr_data : HVSRData
        Input data object
    plot_engine : str = {&#39;plotly&#39;, &#39;matplotlib&#39;}
        Which plotting library to use, by default &#39;plotly&#39;
    plotly_module : str = {&#39;go&#39;, &#39;px&#39;}
        Which plotly module to use if applicable, by default &#39;go&#39;
    remove_outliers_during_plot : bool, optional
        Whether curves should also be removed when plotted. During sprit.run(), removal happens separately, so this is False.
    outlier_threshold : float, optional
        RMSE threshold (for removing outliers), by default 0.98
    use_percentile : bool, optional
        Whether to use percentile or raw value, by default True
    use_hv_curves : bool, optional
        Whether to perform analysis on HV curves (if True) or PSD curves (if False), by default False
    from_roc : bool, optional
        Helper parameter to determine if this is being called from sprit.remove_outlier_curves function, by default False
    show_plot : bool, optional
        Whether to show plot, by default True
    verbose : bool, optional
        Whether to print information to terminal, by default False

    Returns
    -------
    plotly figure
        Figure type depends on plotly_module
    &#34;&#34;&#34;
    orig_args = locals().copy()    
    
    hv_data = hvsr_data
    
    plotlyList = [&#39;plotly&#39;, &#39;plty&#39;, &#39;p&#39;]
    mplList = [&#39;matplotlib&#39;, &#39;mpl&#39;, &#39;pyplot&#39;, &#39;mtpltlb&#39;, &#39;m&#39;]
    
    if outlier_threshold &lt; 1:
        outlier_threshold = outlier_threshold * 100
    
    roc_kwargs = {&#39;outlier_threshold&#39;:outlier_threshold,
                    &#39;use_percentile&#39;:True,
                    &#39;use_hv_curves&#39;:use_hv_curves,
                    &#39;show_outlier_plot&#39;:False,
                    &#39;plot_engine&#39;:&#39;None&#39;,
                    &#39;verbose&#39;:verbose
                    }
    
    if str(plot_engine).lower() in plotlyList:
        #outlier_fig = go.FigureWidget()
        pxList = [&#39;px&#39;, &#39;express&#39;, &#39;exp&#39;, &#39;plotly express&#39;, &#39;plotlyexpress&#39;]
        if str(plotly_module).lower() in pxList:
            return __plotly_outlier_curves_px(**orig_args)
        
        outlier_fig = go.Figure()
        
        titleText = &#39;Outlier Curve Plot&#39;
        if use_hv_curves:
            titleText += &#39; (H/V Curves)&#39;
        else:
            titleText += &#39; PSD Curves&#39;
        outlier_fig = go.Figure()
            
        if &#39;generate_psds_status&#39; in hvsr_data.processing_status.keys() and hvsr_data.processing_status[&#39;generate_psds_status&#39;]:
            #log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nremove_outlier_curves():\n&#39;{roc_kwargs}&#34;    
            #hvsr_data = sprit_hvsr.remove_outlier_curves(hvsr_data, **roc_kwargs)
            pass
        else:
            #log_textArea.value += f&#34;\n\n{datetime.datetime.now()}\nremove_outlier_curves() attempted, but not completed. hvsr_data.processing_status[&#39;generate_psds_status&#39;]=False\n&#39;{roc_kwargs}&#34;
            return outlier_fig

        if roc_kwargs[&#39;use_hv_curves&#39;]:
            no_subplots = 1
            if hasattr(hvsr_data, &#39;hvsr_windows_df&#39;) and &#39;HV_Curves&#39; in hvsr_data.hvsr_windows_df.columns:
                outlier_fig.data = []
                outlier_fig.update_layout(grid=None)  # Clear the existing grid layout
                outlier_subp = subplots.make_subplots(rows=no_subplots, cols=1, horizontal_spacing=0.01, vertical_spacing=0.1)
                outlier_fig.update_layout(grid={&#39;rows&#39;: 1})
                #outlier_fig = go.FigureWidget(outlier_subp)
                outlier_fig = go.Figure(outlier_subp)

                x_data = hvsr_data[&#39;x_freqs&#39;][&#39;Z&#39;]
                curve_traces = []
                for ind, (i, hv) in enumerate(hvsr_data.hvsr_windows_df.iterrows()):
                    nameLabel = f&#34;Window starting at {i.strftime(&#39;%H:%M:%S&#39;)}&lt;br&gt;Window #{ind}&#34;
                    curve_traces.append(go.Scatter(x=x_data, y=hv[&#39;HV_Curves&#39;], 
                                hovertemplate=nameLabel, line=dict(color=&#39;rgba(0,0,0,0.1)&#39;, width=0.75),
                                showlegend=False))
                outlier_fig.add_traces(curve_traces)
                
                # Calculate a median curve, and reshape so same size as original
                medCurve = np.nanmedian(np.stack(hvsr_data.hvsr_windows_df[&#39;HV_Curves&#39;]), axis=0)
                outlier_fig.add_trace(go.Scatter(x=x_data, y=medCurve, line=dict(color=&#39;rgba(0,0,0,1)&#39;, width=1.5),showlegend=False))
                
                minY = np.nanmin(np.stack(hvsr_data.hvsr_windows_df[&#39;HV_Curves&#39;]))
                maxY = np.nanmax(np.stack(hvsr_data.hvsr_windows_df[&#39;HV_Curves&#39;]))
                totalWindows = hvsr_data.hvsr_windows_df.shape[0]
                #medCurveArr = np.tile(medCurve, (curr_data.shape[0], 1))

        else:
            no_subplots = 3
            outlier_fig.data = []
            outlier_fig.update_layout(grid=None)  # Clear the existing grid layout
            outlier_subp = subplots.make_subplots(rows=no_subplots, cols=1, horizontal_spacing=0.01, vertical_spacing=0.02,
                                                    row_heights=[1, 1, 1])
            outlier_fig.update_layout(grid={&#39;rows&#39;: 3})
            #outlier_fig = go.FigureWidget(outlier_subp)
            outlier_fig = go.Figure(outlier_subp)

            if hasattr(hvsr_data, &#39;hvsr_windows_df&#39;):
                rowDict = {&#39;Z&#39;:1, &#39;E&#39;:2, &#39;N&#39;:3}
                showTLabelsDict={&#39;Z&#39;:False, &#39;E&#39;:False, &#39;N&#39;:True}
                def comp_rgba(comp, a):
                    compstr = &#39;&#39;
                    if comp==&#39;Z&#39;:
                        compstr = f&#39;rgba(0, 0, 0, {a})&#39;
                    if comp==&#39;E&#39;:
                        compstr = f&#39;rgba(50, 50, 250, {a})&#39;
                    if comp==&#39;N&#39;:
                        compstr = f&#39;rgba(250, 50, 50, {a})&#39;
                    return compstr                         
                compNames = [&#39;Z&#39;, &#39;E&#39;, &#39;N&#39;]
                rmse_to_plot=[]
                med_traces=[]

                noRemoved = 0
                indRemoved = []
                for i, comp in enumerate(compNames):
                    if hasattr(hvsr_data, &#39;x_freqs&#39;):
                        x_data = hvsr_data[&#39;x_freqs&#39;][comp]
                    else:
                        x_data = [1/p for p in hvsr_data[&#39;psds&#39;][comp][&#39;period_xedges&#39;][1:]]                    
                    column = &#39;psd_values_&#39;+comp
                    # Retrieve data from dataframe (use all windows, just in case)
                    curr_data = np.stack(hvsr_data[&#39;hvsr_windows_df&#39;][column])
                    
                    # Calculate a median curve, and reshape so same size as original
                    medCurve = np.nanmedian(curr_data, axis=0)
                    medCurveArr = np.tile(medCurve, (curr_data.shape[0], 1))
                    medTrace = go.Scatter(x=x_data, y=medCurve, line=dict(color=comp_rgba(comp, 1), width=1.5), 
                                                    name=f&#39;{comp} Component&#39;, showlegend=True)
                    # Calculate RMSE
                    rmse = np.sqrt(((np.subtract(curr_data, medCurveArr)**2).sum(axis=1))/curr_data.shape[1])

                    rmse_threshold = np.percentile(rmse, roc_kwargs[&#39;outlier_threshold&#39;])
                    
                    # Retrieve index of those RMSE values that lie outside the threshold
                    timeIndex = hvsr_data[&#39;hvsr_windows_df&#39;].index
                    for j, curve in enumerate(curr_data):
                        if rmse[j] &gt; rmse_threshold:
                            badTrace = go.Scatter(x=x_data, y=curve,
                                                line=dict(color=comp_rgba(comp, 1), width=1.5, dash=&#39;dash&#39;),
                                                #marker=dict(color=comp_rgba(comp, 1), size=3),
                                                name=str(hvsr_data.hvsr_windows_df.index[j]), showlegend=False)
                            outlier_fig.add_trace(badTrace, row=rowDict[comp], col=1)
                            if j not in indRemoved:
                                indRemoved.append(j)
                            noRemoved += 1
                        else:
                            goodTrace = go.Scatter(x=x_data, y=curve,
                                                    line=dict(color=comp_rgba(comp, 0.01)), name=str(hvsr_data.hvsr_windows_df.index[j]), showlegend=False)
                            outlier_fig.add_trace(goodTrace, row=rowDict[comp], col=1)

                    #timeIndRemoved = pd.DatetimeIndex([timeIndex[ind] for ind in indRemoved])
                    #hvsr_data[&#39;hvsr_windows_df&#39;].loc[timeIndRemoved, &#39;Use&#39;] = False

                    outlier_fig.add_trace(medTrace, row=rowDict[comp], col=1)
                    
                    outlier_fig.update_xaxes(showticklabels=False, row=1, col=1)
                    outlier_fig.update_yaxes(title={&#39;text&#39;:&#39;Z&#39;}, row=1, col=1)
                    outlier_fig.update_xaxes(showticklabels=False, row=2, col=1)
                    outlier_fig.update_yaxes(title={&#39;text&#39;:&#39;E&#39;}, row=2, col=1)
                    outlier_fig.update_xaxes(showticklabels=True, row=3, col=1)
                    outlier_fig.update_yaxes(title={&#39;text&#39;:&#39;N&#39;}, row=3, col=1)

                    outlier_fig.update_layout(margin={&#34;l&#34;:10, &#34;r&#34;:10, &#34;t&#34;:30, &#39;b&#39;:0}, showlegend=True,
                                    title=f&#34;{hvsr_data[&#39;site&#39;]} Outliers&#34;)
                    if comp == &#39;N&#39;:
                        minY = np.nanmin(curr_data)
                        maxY = np.nanmax(curr_data)
                    totalWindows = curr_data.shape[0]
                
                outlier_fig.add_annotation(
                    text=f&#34;{len(indRemoved)}/{totalWindows} outlier windows removed&#34;,
                    x=np.log10(max(x_data)) - (np.log10(max(x_data))-np.log10(min(x_data))) * 0.01,
                    y=minY+(maxY-minY)*0.01,
                    xanchor=&#34;right&#34;, yanchor=&#34;bottom&#34;,#bgcolor=&#39;rgba(256,256,256,0.7)&#39;,
                    showarrow=False,row=no_subplots, col=1)


        outlier_fig.update_xaxes(type=&#39;log&#39;)
        outlier_fig.update_layout(paper_bgcolor=&#39;white&#39;, plot_bgcolor=&#39;white&#39;,
                                font_color=&#39;black&#39;, 
                                title=dict(font_color=&#39;black&#39;,
                                text=titleText))
        #with outlier_graph_widget:
        #    clear_output(wait=True)
        #    display(outlier_fig)
        if show_plot:
            outlier_fig.show()        
    else: # Matplotlib outlier plot
        #if discarded_curves is not None:
        #    for i, b in enumerate(hvsr_data[&#39;hvsr_windows_df&#39;].index[pd.Series(discarded_curves)]):
        #        print(&#39;DSCURVES&#39;, discarded_curves)
        #        print(b)

        # Determine names of hvsr_windows_df columns to use
        if not use_hv_curves:
            compNames = [&#39;Z&#39;, &#39;E&#39;, &#39;N&#39;]
            for col_name in hvsr_data[&#39;hvsr_windows_df&#39;].columns:
                if &#39;psd_values&#39; in col_name and &#39;RMSE&#39; not in col_name:
                    cName = col_name.split(&#39;_&#39;)[2]
                    if cName not in compNames:
                        compNames.append(cName)
            col_prefix = &#39;psd_values_&#39;
            colNames = [col_prefix+cn for cn in compNames]
        else:
            compNames = []
            for col_name in hvsr_data[&#39;hvsr_windows_df&#39;].columns:
                if col_name.startswith(&#39;HV_Curves&#39;) and &#34;Log10&#34; not in col_name:
                    compNames.append(col_name)
            colNames = compNames
            col_prefix = &#39;HV_Curves&#39;
    
        spMosaic = []
        if use_hv_curves:
            spMosaic.append([&#39;HV Curve&#39;])
            fSize = (8.5, 6)
        else:
            for c in compNames:
                spMosaic.append([c])
            fSize = (8.5, len(compNames) * 2)

            # Intialize to only get unique labels
            rem_label_got = False
            keep_label_got = False

        outlier_fig, ax = plt.subplot_mosaic(spMosaic, sharex=True, figsize=fSize)
            
        # Loop through each component, and determine which curves are outliers
        bad_rmse = []
        for i, column in enumerate(colNames):
            if column in compNames:
                if use_hv_curves == False:
                    column = col_prefix + column
                else:
                    column = column

            # Retrieve data from dataframe (use all windows, just in case)
            curr_data = np.stack(hvsr_data[&#39;hvsr_windows_df&#39;][column])
            
            # Calculate a median curve, and reshape so same size as original
            medCurve = np.nanmedian(curr_data, axis=0)
            medCurveArr = np.tile(medCurve, (curr_data.shape[0], 1))

            # Calculate RMSE
            rmse = np.sqrt(((np.subtract(curr_data, medCurveArr)**2).sum(axis=1))/curr_data.shape[1])
            hvsr_data[&#39;hvsr_windows_df&#39;][&#39;RMSE_&#39;+column] = rmse
            if use_percentile is True:
                rmse_threshold = np.percentile(rmse[~np.isnan(rmse)], outlier_threshold)
                if verbose:
                    print(f&#39;\tRMSE at {outlier_threshold}th percentile for {column} calculated at: {rmse_threshold:.2f}&#39;)
            else:
                rmse_threshold = outlier_threshold

            # Retrieve index of those RMSE values that lie outside the threshold
            for j, curve in enumerate(curr_data):
                if rmse[j] &gt; rmse_threshold:
                    bad_rmse.append(j)

            # Iterate through each curve to determine if it&#39;s rmse is outside threshold, for plot
            keep_label_got = False
            rem_label_got = False
            for j, curve in enumerate(curr_data):
                label = None
                if rmse[j] &gt; rmse_threshold:
                    linestyle = &#39;dashed&#39;
                    linecolor=&#39;darkred&#39;
                    alpha = 1
                    linewidth = 1
                    if not rem_label_got:
                        label=&#39;Removed Curve&#39;
                        rem_label_got=True
                else:
                    linestyle=&#39;solid&#39;
                    linecolor = &#39;rosybrown&#39;
                    alpha = 0.25
                    linewidth=0.5
                    if not keep_label_got:
                        keep_label_got=True
                        label=&#39;Retained Curve&#39;

                # Plot each individual curve
                if not use_hv_curves:
                    if &#39;x_freqs&#39; in hvsr_data.keys():
                        ax[compNames[i]].plot(hvsr_data.x_freqs[compNames[i]], curve, linewidth=linewidth, c=linecolor, linestyle=linestyle, alpha=alpha, label=label)
                    else:
                        ax[compNames[i]].plot(1/hvsr_data.psds[compNames[i]][&#39;period_bin_centers&#39;], curve, linewidth=linewidth, c=linecolor, linestyle=linestyle, alpha=alpha, label=label)
                else:
                    if &#39;x_freqs&#39; in hvsr_data.keys():
                        ax[&#34;HV Curve&#34;].plot(hvsr_data.x_freqs[&#39;Z&#39;][:-1], curve, linewidth=linewidth, c=linecolor, linestyle=linestyle, alpha=alpha, label=label)
                    else:
                        ax[&#34;HV Curve&#34;].plot(1/(hvsr_data.psds[&#39;Z&#39;][&#39;period_bin_centers&#39;][:-1]), curve, linewidth=linewidth, c=linecolor, linestyle=linestyle, alpha=alpha, label=label)                    
            
            # Plot the median curve
            if &#39;HV_Curves&#39; in compNames[i]:
                axName = &#39;HV Curve&#39;
                keyName = &#39;Z&#39;
            else:
                axName = keyName = compNames[i]
            
            if not use_hv_curves:
                if &#39;x_freqs&#39; in hvsr_data.keys():
                    ax[compNames[i]].plot(hvsr_data.x_freqs[compNames[i]], medCurve, linewidth=1, color=&#39;k&#39;, label=&#39;Median Curve&#39;)
                else:
                    ax[compNames[i]].plot(1/hvsr_data.psds[compNames[i]][&#39;period_bin_centers&#39;],medCurve, linewidth=1, color=&#39;k&#39;, label=&#39;Median Curve&#39;)
            else:
                if &#39;x_freqs&#39; in hvsr_data.keys():
                    ax[&#39;HV Curve&#39;].plot(hvsr_data.x_freqs[&#39;Z&#39;][:-1], medCurve, linewidth=1, color=&#39;k&#39;, label=&#39;Median Curve&#39;)
                else:
                    ax[&#39;HV Curve&#39;].plot(1/hvsr_data.psds[&#39;Z&#39;][&#39;period_bin_centers&#39;][:-1],medCurve, linewidth=1, color=&#39;k&#39;, label=&#39;Median Curve&#39;)


            # Format axis
            ax[axName].set_ylabel(f&#34;{compNames[i]}&#34;)
            ax[axName].legend(fontsize=10, labelspacing=0.1)
            ax[axName].semilogx()

        outlier_fig.suptitle(f&#34;{hvsr_data[&#39;site&#39;]}\n Curves Removed from Analysis&#34;)
        outlier_fig.set_layout_engine(&#39;constrained&#39;)
                
        hvsr_data[&#39;Outlier_Plot&#39;] = outlier_fig 
    
        if show_plot:
            plt.show()
        else:
            plt.close()
    
    if remove_outliers_during_plot:
        bad_rmse = np.unique(bad_rmse)
        if len(bad_rmse) &gt; 0:
            hvsr_data[&#39;hvsr_windows_df&#39;][&#39;Use&#39;] = hvsr_data[&#39;hvsr_windows_df&#39;][&#39;Use&#39;] * (rmse_threshold &gt; hvsr_data[&#39;hvsr_windows_df&#39;][&#39;RMSE_&#39;+column])

    
    hvsr_data[&#39;Outlier_Plot&#39;] = outlier_fig 
    return outlier_fig</code></pre>
</details>
<div class="desc"><p>Function to plot outlier curves, including which have been excluded</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hvsr_data</code></strong> :&ensp;<code>HVSRData</code></dt>
<dd>Input data object</dd>
<dt><strong><code>plot_engine</code></strong> :&ensp;<code>str = {'plotly', 'matplotlib'}</code></dt>
<dd>Which plotting library to use, by default 'plotly'</dd>
<dt><strong><code>plotly_module</code></strong> :&ensp;<code>str = {'go', 'px'}</code></dt>
<dd>Which plotly module to use if applicable, by default 'go'</dd>
<dt><strong><code>remove_outliers_during_plot</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether curves should also be removed when plotted. During sprit.run(), removal happens separately, so this is False.</dd>
<dt><strong><code>outlier_threshold</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>RMSE threshold (for removing outliers), by default 0.98</dd>
<dt><strong><code>use_percentile</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to use percentile or raw value, by default True</dd>
<dt><strong><code>use_hv_curves</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to perform analysis on HV curves (if True) or PSD curves (if False), by default False</dd>
<dt><strong><code>from_roc</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Helper parameter to determine if this is being called from sprit.remove_outlier_curves function, by default False</dd>
<dt><strong><code>show_plot</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to show plot, by default True</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print information to terminal, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>plotly figure</code></dt>
<dd>Figure type depends on plotly_module</dd>
</dl></div>
</dd>
<dt id="sprit.sprit_plot.plot_results_plotly"><code class="name flex">
<span>def <span class="ident">plot_results_plotly</span></span>(<span>hv_data,<br>plot_string='HVSR p ann C+ p SPEC ann',<br>azimuth='HV',<br>results_fig=None,<br>results_graph_widget=None,<br>use_figure_widget=False,<br>return_fig=False,<br>show_results_plot=False,<br>html_plot=False,<br>verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_results_plotly(hv_data, plot_string=&#39;HVSR p ann C+ p SPEC ann&#39;, azimuth=&#39;HV&#39;,
                results_fig=None, results_graph_widget=None, use_figure_widget=False,
                return_fig=False, show_results_plot=False, html_plot=False,
                verbose=False,):
    
    &#34;&#34;&#34;Function to plot results using plotly

    Parameters
    ----------
    hv_data : sprit.HVSRData
        Data object to use for plotting
    plot_string : str, optional
        String for designating what to include in plot(s), by default &#39;HVSR p ann C+ p SPEC ann&#39;
    results_fig : pyplot figure, optional
        Which pyplot figure to plot data onto. If None, makes new figure, by default None.
    results_graph_widget : plotly graph object widget, optional
        Which pyplot figure to plot data onto. If None, makes new widget, if applicable, by default None.
    use_figure_widget : bool, optional
        Whether to use figure widget, by default False
    return_fig : bool, optional
        Whether to return figure, by default False
    show_results_plot : bool, optional
        Wheather to show plot, by default False
    html_plot : bool, optional
        Whether to create an HTML version of the plot, by default False
    verbose : bool, optional
        Whether to print information to terminal, by default False

    Returns
    -------
    plotly figure
        Only if return_fig is True.
    &#34;&#34;&#34;

    if results_fig is None:
        results_fig = go.FigureWidget()

    hvsr_data = hv_data

    plotymax = max(hvsr_data.hvsrp2[&#39;HV&#39;]) + (max(hvsr_data.hvsrp2[&#39;HV&#39;]) - max(hvsr_data.hvsr_curve))
    if plotymax &gt; hvsr_data.BestPeak[&#39;HV&#39;][&#39;A0&#39;] * 1.5:
        plotymax = hvsr_data.BestPeak[&#39;HV&#39;][&#39;A0&#39;] * 1.5
    ylim = [0, plotymax]
    if isinstance(hvsr_data, sprit_hvsr.HVSRBatch):
        hvsr_data = hvsr_data[0]

    hvsrDF = hvsr_data.hvsr_windows_df

    plot_list = parse_plot_string(plot_string)

    combinedComp = False
    # By default there 3 subplots
    noSubplots = 3
    # Remove any subplots that are not indicated by plot_type parameter
    noSubplots = noSubplots - plot_list.count([])
    
    # Now, check if comp plot is combined with HV
    if plot_list[1] != [] and &#39;+&#39; not in plot_list[1][0]:
        combinedComp = True
        noSubplots -= 1
    
    # Get all data for each plotted item
    # Get subplot numbers based on plot_list
    spec = []
    if plot_list[0]==[]:
        # if for some reason, HVSR plot was not indicated, add it
        hv_plot_row = 1 # Default first row to hv (may change later)
        noSubplots += 1
        if plot_list[1] == []:
            comp_plot_row = None
            if plot_list[2] == []:
                spec_plot_row = None
                hv_plot_row = 1 #If nothing specified, do basic h/v plot
            else:
                spec_plot_row = 1 # If only spec specified
        else:
            comp_plot_row = 1 # If no HV specified by comp is, comp is subplot 1

            if plot_list[2] == []:
                spec_plot_row = None
            else:
                spec_plot_row = 2 # If only comp and spec specified comp first then spec
    else:
        hv_plot_row = 1 # HV specified explicitly
        if plot_list[1] == []:
            comp_plot_row = None
            if plot_list[2] == []:
                spec_plot_row = None
            else:
                spec_plot_row = 2 # if no comp specified, spec is 2nd subplot
        else:
            if combinedComp:
                comp_plot_row = 1
                if plot_list[2] == []:
                    spec_plot_row = None
                else:
                    spec_plot_row = 2
            else:
                comp_plot_row = 2
                if plot_list[2] == []:
                    spec_plot_row = None
                else:
                    spec_plot_row = 3       

    specList = []
    rHeights = [1]
    if hv_plot_row == 1:
        if comp_plot_row == 1:
            specList.append([{&#39;secondary_y&#39;: True}])
            if spec_plot_row == 2:
                specList.append([{&#39;secondary_y&#39;: False}])
    else:
        specList.append([{&#39;secondary_y&#39;: False}])

        if noSubplots &gt;= 2:
            specList.append([{&#39;secondary_y&#39;: False}])
            rHeights = [1.5,1]
        if noSubplots == 3:
            specList.append([{&#39;secondary_y&#39;: False}])
            rHeights = [2,1.5,1]
    
    # Failsafes
    while len(specList)&lt;noSubplots:
        specList.append([{}])

    while len(rHeights)&lt;noSubplots:
        rHeights.append(1)

    # Re-initialize results_fig
    results_fig.data = []
    results_fig.update_layout(grid=None)  # Clear the existing grid layout, in case applicable

    results_fig = make_subplots(rows=noSubplots, cols=1, horizontal_spacing=0.01, vertical_spacing=0.07,
                                specs=specList,
                                row_heights=rHeights)
    results_fig.update_layout(grid={&#39;rows&#39;: noSubplots})

    if use_figure_widget:
        results_fig = go.FigureWidget(results_fig)

    if plot_list[1] != []:
        results_fig = _parse_comp_plot_list(hvsr_data, results_fig=results_fig, 
                                           comp_plot_list=plot_list[1])
        results_fig.update_xaxes(title_text=&#39;Frequency [Hz]&#39;,
                                 row=comp_plot_row, col=1)

    # HVSR Plot (plot this after COMP so it is on top COMP and to prevent deletion with no C+)
    results_fig = _parse_hv_plot_list(hvsr_data, hvsr_plot_list=plot_list, results_fig=results_fig)

    # Will always plot the HV Curve
    results_fig.add_trace(go.Scatter(x=hvsr_data.x_freqs[&#39;Z&#39;], y=hvsr_data.hvsr_curve,
                        line={&#39;color&#39;:&#39;black&#39;, &#39;width&#39;:1.5}, marker=None, name=&#39;HVSR Curve&#39;),
                        row=1, col=&#39;all&#39;)

    # SPEC plot
    if plot_list[2] != []:
        results_fig = _parse_spec_plot_list(hvsr_data, spec_plot_list=plot_list[2], subplot_num=spec_plot_row, azimuth=azimuth, results_fig=results_fig)

    # Final figure updating
    resultsFigWidth = 650

    components_HV_on_same_plot = (plot_list[1]==[] or &#39;+&#39; not in plot_list[1][0])
    if components_HV_on_same_plot:
        compxside = &#39;bottom&#39;
        secondaryY = True
        showHVTickLabels = True
        showComptickLabels = True
    else:
        compxside = &#39;bottom&#39;
        secondaryY = False
        showHVTickLabels = True
        showComptickLabels = True
    
    # Update H/V Plot
    results_fig.update_xaxes(type=&#39;log&#39;, title_text=&#39;Frequency [Hz]&#39;, title_standoff=0,
                    range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])],
                    side=&#39;bottom&#39;, showticklabels=showHVTickLabels,
                    row=1, col=1)
    results_fig.update_yaxes(title_text=&#39;H/V Ratio&#39;, row=1, col=1, 
                             secondary_y=False, range=ylim)

    # Update Component plot
    results_fig.update_xaxes(type=&#39;log&#39;, overlaying=&#39;x&#39;, showticklabels=showComptickLabels, title_standoff=0,
                             range=[np.log10(hvsr_data[&#39;hvsr_band&#39;][0]), np.log10(hvsr_data[&#39;hvsr_band&#39;][1])],
                             side=compxside, row=comp_plot_row, col=1)    
    results_fig.update_yaxes(title_text=&#34;PPSD Amp\n[m2/s4/Hz][dB]&#34;, secondary_y=secondaryY, row=comp_plot_row, col=1)

    # Update Spec plot
    results_fig.update_yaxes(title_text=&#39;H/V Over Time&#39;, row=noSubplots, col=1)

    # Update entire figure
    titleString = f&#34;{hvsr_data[&#39;site&#39;]} Results&#34;
    results_fig.update_layout(margin={&#34;l&#34;:40, &#34;r&#34;:10, &#34;t&#34;:35, &#39;b&#39;:0},
                            showlegend=False, autosize=False, width=resultsFigWidth, height=resultsFigWidth*0.7,
                            title=titleString)
    
    # Reset results_graph_widget and display 
    #if results_graph_widget is not None:
    #    with results_graph_widget:
    #        clear_output(wait=True)
    #        display(results_fig)

    if show_results_plot:
        if html_plot:
            results_fig.write_html(titleString.replace(&#39; &#39;, &#39;_&#39;) + &#39;plot.html&#39;, auto_open=True)
        else:
            results_fig.show()
    
    if return_fig:
        return results_fig</code></pre>
</details>
<div class="desc"><p>Function to plot results using plotly</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hv_data</code></strong> :&ensp;<code><a title="sprit.HVSRData" href="index.html#sprit.HVSRData">HVSRData</a></code></dt>
<dd>Data object to use for plotting</dd>
<dt><strong><code>plot_string</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>String for designating what to include in plot(s), by default 'HVSR p ann C+ p SPEC ann'</dd>
<dt><strong><code>results_fig</code></strong> :&ensp;<code>pyplot figure</code>, optional</dt>
<dd>Which pyplot figure to plot data onto. If None, makes new figure, by default None.</dd>
<dt><strong><code>results_graph_widget</code></strong> :&ensp;<code>plotly graph object widget</code>, optional</dt>
<dd>Which pyplot figure to plot data onto. If None, makes new widget, if applicable, by default None.</dd>
<dt><strong><code>use_figure_widget</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to use figure widget, by default False</dd>
<dt><strong><code>return_fig</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to return figure, by default False</dd>
<dt><strong><code>show_results_plot</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Wheather to show plot, by default False</dd>
<dt><strong><code>html_plot</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to create an HTML version of the plot, by default False</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print information to terminal, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>plotly figure</code></dt>
<dd>Only if return_fig is True.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sprit" href="index.html">sprit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="sprit.sprit_plot.parse_plot_string" href="#sprit.sprit_plot.parse_plot_string">parse_plot_string</a></code></li>
<li><code><a title="sprit.sprit_plot.plot_cross_section" href="#sprit.sprit_plot.plot_cross_section">plot_cross_section</a></code></li>
<li><code><a title="sprit.sprit_plot.plot_depth_curve" href="#sprit.sprit_plot.plot_depth_curve">plot_depth_curve</a></code></li>
<li><code><a title="sprit.sprit_plot.plot_input_stream" href="#sprit.sprit_plot.plot_input_stream">plot_input_stream</a></code></li>
<li><code><a title="sprit.sprit_plot.plot_outlier_curves" href="#sprit.sprit_plot.plot_outlier_curves">plot_outlier_curves</a></code></li>
<li><code><a title="sprit.sprit_plot.plot_results_plotly" href="#sprit.sprit_plot.plot_results_plotly">plot_results_plotly</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
